class BrushStub {
  constructor(_0x5c0279) {
    this.surface = _0x5c0279, this["showPen"] = true, this["drawingTool"] = true, this["options"] = {}, this["contextSlate"] = this["surface"]["slate"]["getContext"]();
  }
  ["brushStart"]() { }
  ["brushStop"]() { }
  ["drawStart"](_0x4110b5, _0x3ed15b, _0x79102) { }
  ["drawStep"](_0x487df1, _0xd56fac, _0x620d7c) { }
  ["drawEnd"](_0x120854, _0x411968, _0x4acf7c) { }
  ["onKeyPress"](_0x4b86ae) { }
  ["onModifierDown"](_0x353608) { }
  ["onModifierUp"](_0x1d1ab2) { }
  ["onBrushParameter"](_0x4b4ff7) { }
  ["colorChange"](_0x2625d0) { }
  ["colorChanged"](_0x180237) { }
  ["blendModeChange"](_0x305075) { }
  ["cursorMove"](_0xa5c555, _0x3fe4e3) { }
  ["optionChange"](_0x15bfc7, _0x236789) { }
  ["optionChanged"](_0x51fa30, _0x39e138) { }
  ["cancel"]() { }
  ["isUsingSlate"]() {
    return false;
  }
  ["getDistance"](_0x5c80a2, _0x181b41, _0x5bb4d9, _0x1aef5b) {
    return Math["sqrt"](Math.pow(_0x5bb4d9 - _0x5c80a2, 2) + Math["pow"](_0x1aef5b - _0x181b41, 2));
  }
  ["calculateLine"](_0x313d92, _0x2237b6, _0x111712, _0x325bb0) {
    _0x313d92 = parseInt(_0x313d92), _0x111712 = parseInt(_0x111712), _0x2237b6 = parseInt(_0x2237b6), _0x325bb0 = parseInt(_0x325bb0);
    var _0x50a359 = new Array(),
      _0xf5e150 = Math["abs"](_0x111712 - _0x313d92),
      _0x47e65d = Math["abs"](_0x325bb0 - _0x2237b6),
      _0x5777f8 = _0x313d92 < _0x111712 ? 1 : -1,
      _0x2ec28c = _0x2237b6 < _0x325bb0 ? 1 : -1,
      _0x3e4b21 = _0xf5e150 - _0x47e65d;
    while (true) {
      _0x50a359.push(new Point(_0x313d92, _0x2237b6));
      if (_0x313d92 === _0x111712 && _0x2237b6 === _0x325bb0) break;
      var _0x2cbd2a = 2 * _0x3e4b21;
      _0x2cbd2a > -_0x47e65d && (_0x3e4b21 -= _0x47e65d, _0x313d92 += _0x5777f8), _0x2cbd2a < _0xf5e150 && (_0x3e4b21 += _0xf5e150, _0x2237b6 += _0x2ec28c);
    }
    return _0x50a359;
  }
  ["getSync"]() {
    return null;
  }
  ["setSync"]() { }
  ["hasOption"](_0x45b0ef) {
    return _0x45b0ef in this["options"];
  }
  ["isOptionReadOnly"](_0x244d67) {
    if (_0x244d67 in this.options) return this["options"][_0x244d67].readOnly;
    return false;
  }
  ["setOptionReadOnly"](_0x5ce088, _0x490da5) {
    if (_0x5ce088 in this["options"]) return this["options"][_0x5ce088].readOnly = _0x490da5, true;
    return false;
  }
  ["getOptionObject"](_0x2b9ffe) {
    if (_0x2b9ffe in this["options"]) return this["options"][_0x2b9ffe];
    return null;
  }
  ["getOption"](_0x5a8089) {
    if (_0x5a8089 in this["options"]) return this["options"][_0x5a8089]["value"];
    return null;
  }
  ["setOption"](_0x42422, _0x499f33) {
    if (_0x42422 in this["options"]) return this.optionChange(_0x42422, _0x499f33), this["options"][_0x42422]["value"] = _0x499f33, this["optionChanged"](_0x42422, _0x499f33), true;
    return false;
  }
  ["getOptions"]() {
    var _0x31fd01 = {};
    return $["each"](this["options"], function (_0xcf30f9, _0x4fdef0) {
      _0x31fd01[_0xcf30f9] = _0x4fdef0["value"];
    }), _0x31fd01;
  }
  ["setOptions"](_0xad2cd0) {
    var _0xbf8ef7 = this;
    $["each"](_0xad2cd0, function (_0x481cd5, _0x396b58) {
      _0xbf8ef7["options"][_0x481cd5].value = _0x396b58;
    });
  }
}
class BrushDrag extends BrushStub {
  constructor(_0x4c409f) {
    super(_0x4c409f), this.showPen = false, this["drawingTool"] = false, this["options"] = {}, this["options"]["size"] = new SizeOption(1, true), this.options["rightclick"] = new RightClickOption("drag");
  }
  ["brushStart"]() {
    this["surface"]["cursor"]["changePointer"]("invisible");
  }
}
class BrushRotate extends BrushStub {
  constructor(_0x1b0370) {
    super(_0x1b0370), this.showPen = false, this["drawingTool"] = false, this.options = {}, this["options"]["size"] = new SizeOption(1, true), this["options"]["rightclick"] = new RightClickOption("rotate");
  }
  ["brushStart"]() {
    this.surface["cursor"]["changePointer"]("invisible");
  }
}
class BrushPicker extends BrushStub {
  constructor(_0xdc303f) {
    super(_0xdc303f), this["drawingTool"] = false, this["options"] = {}, this.options["size"] = new SizeOption(33), this["options"].areaaverage = new AreaAverageOption(), this["options"]["rightclick"] = new RightClickOption("picker"), this["options"]["cursor"] = new CursorOption("crosshair");
  }
  ["brushStart"]() {
    this["surface"]["cursor"]["changePointer"](this["getOption"]("cursor"));
  }
  ["optionChanged"](_0xb2ae1, _0xb76d19) {
    _0xb2ae1 == "cursor" && this.surface["cursor"]["changePointer"](_0xb76d19);
  }
}
class BrushSelection extends BrushStub {
  constructor(_0x4fe584) {
    super(_0x4fe584), this["clickX"] = new Array(), this["clickY"] = new Array(), this["start"], this["end"], this["offset"] = 0, this.tInt = null, this["marchingAnts"] = false, this["lastPosition"], this.moved = false, this["options"] = {}, this["options"].size = new SizeOption(4, true), this["options"]["selectiontype"] = new SelectionTypeOption(), this["options"]["multilayer"] = new MultilayerOption(), this.options["rightclick"] = new RightClickOption("selection"), this["options"]["allowedlayers"] = new AllowedLayersOption([]), this["options"]["cursor"] = new CursorOption("dot");
  }
  ["brushStart"]() {
    this["surface"].cursor["changePointer"](this["getOption"]("cursor")), this["updateZIndex"](this.getOption("multilayer"));
  }
  ["brushStop"]() {
    this["cancel"](), this["updateZIndex"](false), clearInterval(this["tInt"]);
  }
  ["optionChanged"](_0x4e2143, _0x1f9e32) {
    _0x4e2143 == "cursor" && this["surface"]["cursor"]["changePointer"](_0x1f9e32);
  }
  ["drawStart"](_0x3c655f, _0x4075dc, _0x5323d9) {
    this["moved"] = false, this["setupSlate"](), this["clearSlate"](), this["removeClicks"]();
    this["getOption"]("selectiontype") ? (this["addClick"](_0x3c655f, _0x4075dc), this["lastPosition"] = new Point(_0x3c655f, _0x4075dc)) : this.start = new Point(_0x3c655f, _0x4075dc);
    this["contextSlate"]["beginPath"]();
    if (this["marchingAnts"] && this.tInt == null) {
      var _0x3a8cda = this;
      this.tInt = setInterval(function () {
        _0x3a8cda["offset"]++, _0x3a8cda["offset"] > 24 && (_0x3a8cda["offset"] = 0), _0x3a8cda["redraw"]();
      }, 20);
    }
  }
  ["drawStep"](_0x16b4ad, _0x36ae29, _0x52395c) {
    this.moved = true, _0x16b4ad.x = Math["min"](Math["max"](_0x16b4ad.x, 0), room["board"]["canvasWidth"]), _0x16b4ad.y = Math["min"](Math["max"](_0x16b4ad.y, 0), room["board"].canvasHeight), _0x36ae29.x = Math["min"](Math["max"](_0x36ae29.x, 0), room["board"].canvasWidth), _0x36ae29.y = Math["min"](Math["max"](_0x36ae29.y, 0), room["board"]["canvasHeight"]), this["getOption"]("selectiontype") ? (this["addClick"](_0x36ae29.x, _0x36ae29.y), this["surface"]["isMyself"] && UI["userPreferences"].getProperty("strokequality", "high") == "high" ? this.redraw() : this["getDistance"](this["lastPosition"].x, this["lastPosition"].y, _0x36ae29.x, _0x36ae29.y) >= 12 && (this.contextSlate["moveTo"](_0x16b4ad.x, _0x16b4ad.y), this.contextSlate["lineTo"](_0x36ae29.x, _0x36ae29.y), this["contextSlate"]["stroke"](), this["lastPosition"] = new Point(_0x36ae29.x, _0x36ae29.y))) : (!this.start && (this["start"] = _0x16b4ad), this["drawRect"](this["start"], _0x36ae29), this["end"] = _0x36ae29);
  }
  ["drawEnd"](_0x3ceec8, _0x5aea26, _0x37c06e) {
    this.getOption("selectiontype") ? (this["addClick"](_0x3ceec8, _0x5aea26), this.addClick(this.clickX[0], this.clickY[0]), this["redraw"]()) : (_0x3ceec8 = Math.min(Math.max(_0x3ceec8, 0), this["contextSlate"]["canvas"].width), _0x5aea26 = Math["min"](Math.max(_0x5aea26, 0), this.contextSlate["canvas"]["height"]), this["end"] = new Point(_0x3ceec8, _0x5aea26)), !this.moved && this["cancel"]();
  }
  ["clipSave"](_0x164d9d) {
    var _0x5a5c1f = room["board"]["getContext"](_0x164d9d);
    _0x5a5c1f["save"](), _0x5a5c1f["beginPath"]();
    if (this.getOption("selectiontype")) {
      _0x5a5c1f["moveTo"](this.clickX[0], this["clickY"][0]);
      for (var _0x2d8255 = 0; _0x2d8255 < this.clickX["length"]; _0x2d8255++) {
        _0x5a5c1f["lineTo"](this["clickX"][_0x2d8255], this["clickY"][_0x2d8255]);
      }
    } else _0x5a5c1f.moveTo(this["start"].x, this["start"].y), _0x5a5c1f["lineTo"](this["end"].x, this["start"].y), _0x5a5c1f["lineTo"](this.end.x, this.end.y), _0x5a5c1f["lineTo"](this["start"].x, this["end"].y);
    _0x5a5c1f["closePath"](), _0x5a5c1f["clip"]();
  }
  ["clipClear"](_0x142722) {
    room.board.layers[_0x142722]["advCanvas"]["setCanvasProperties"]({
      fillstyle: room.board["backgroundColor"],
      alpha: 1,
      blendmode: "normal",
      blur: 0
    });
    var _0x516e6e = room["board"]["getContext"](_0x142722);
    _0x516e6e["clearRect"](0, 0, _0x516e6e.canvas["width"], _0x516e6e["canvas"]["height"]);
  }
  ["clipFill"](_0x5dff78, _0x43b65a = null) {
    _0x43b65a == null && (_0x43b65a = this["surface"]["drawColor"]);
    room["board"]["layers"][_0x5dff78].advCanvas.setCanvasProperties({
      fillstyle: _0x43b65a,
      alpha: 1,
      blendmode: "normal",
      blur: 0
    });
    var _0x22b19c = room["board"]["getContext"](_0x5dff78);
    _0x22b19c["fillRect"](0, 0, _0x22b19c["canvas"]["width"], _0x22b19c["canvas"]["height"]);
  }
  ["clipRestore"](_0x1a550a) {
    var _0x569aff = room["board"]["getContext"](_0x1a550a);
    _0x569aff["restore"](), room.board["layers"][_0x1a550a]["advCanvas"]["clearCanvasProperties"]();
  }
  ["addClick"](_0x3bed8e, _0x527fd9) {
    this["clickX"].push(_0x3bed8e), this["clickY"]["push"](_0x527fd9);
  }
  ["removeClicks"]() {
    this["clickX"] = new Array(), this.clickY = new Array(), this["end"] = null;
  }
  ["clearSlate"]() {
    this.contextSlate["clearRect"](0, 0, this.contextSlate["canvas"].width, this["contextSlate"]["canvas"]["height"]);
  }
  ["getSync"]() {
    var _0x1e23ab = {};
    return _0x1e23ab["start"] = this["start"], _0x1e23ab["end"] = this["end"], _0x1e23ab.clickX = this["clickX"], _0x1e23ab.clickY = this["clickY"], _0x1e23ab["moved"] = this.moved, _0x1e23ab;
  }
  ["setSync"](_0x2b27d8) {
    this.moved = _0x2b27d8["moved"];
    if (this["getOption"]("selectiontype")) {
      if (this["surface"]["penPressed"]) {
        if (_0x2b27d8["clickX"]["length"] > 0) {
          this["drawStart"](_0x2b27d8["clickX"][0], _0x2b27d8.clickY[0], this["surface"]["drawColor"]);
          for (var _0x57b8b6 = 1; _0x57b8b6 < _0x2b27d8.clickX["length"]; _0x57b8b6++) {
            this["drawStep"](new Point(_0x2b27d8["clickX"][_0x57b8b6 - 1], _0x2b27d8.clickY[_0x57b8b6 - 1]), new Point(_0x2b27d8.clickX[_0x57b8b6], _0x2b27d8["clickY"][_0x57b8b6]), this["surface"]["drawColor"]);
          }
        }
      } else this["setupSlate"](), this["clickX"] = _0x2b27d8["clickX"], this.clickY = _0x2b27d8["clickY"], this["redraw"]();
    } else this["surface"]["penPressed"] ? this["drawStart"](_0x2b27d8.start.x, _0x2b27d8["start"].y, this["surface"]["drawColor"]) : (this["setupSlate"](), this["start"] = _0x2b27d8.start, this.end = _0x2b27d8.end, this["start"] && this.end && this["drawRect"](this["start"], this.end));
  }
  ["cancel"]() {
    this["clearSlate"](), this["removeClicks"]();
  }
  ["redraw"](_0x45056d = true) {
    this["clearSlate"](), this["surface"]["slate"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: _0x45056d ? 2 : 1,
      strokeStyle: "#808080",
      alpha: 1,
      blendmode: "normal",
      blur: 0,
      linedash: _0x45056d ? [5, 7] : [],
      linedashoffset: -this.offset
    }), this["contextSlate"]["beginPath"]();
    if (this["getOption"]("selectiontype")) {
      this["contextSlate"]["moveTo"](this["clickX"][0], this["clickY"][0]);
      for (var _0x529607 = 0; _0x529607 < this.clickX["length"]; _0x529607++) {
        this["contextSlate"]["lineTo"](this["clickX"][_0x529607], this["clickY"][_0x529607]);
      }
    } else this["contextSlate"]["moveTo"](this["start"].x, this["start"].y), this["contextSlate"]["lineTo"](this.end.x, this["start"].y), this["contextSlate"]["lineTo"](this["end"].x, this["end"].y), this.contextSlate["lineTo"](this["start"].x, this["end"].y), this["contextSlate"].lineTo(this["start"].x, this["start"].y);
    _0x45056d && this["contextSlate"]["stroke"]();
  }
  ["setupSlate"]() {
    this["surface"].slate.setCanvasProperties({
      linejoin: "round",
      linecap: "round",
      linewidth: 2,
      strokestyle: "#808080",
      alpha: 0.6,
      blendmode: "normal",
      blur: 0,
      linedash: [5, 7]
    }), this.surface["slate"]["setCSSProperties"]({
      alpha: 0.6,
      blendmode: "normal",
      blur: 0
    });
  }
  ["drawRect"](_0x403668, _0xb0a97b) {
    this["clearSlate"]();
    if (this["keepRatio"]) {
      var _0x3341d5 = this["getMinDistance"](_0xb0a97b.x - _0x403668.x, _0xb0a97b.y - _0x403668.y),
        _0x22be5a = _0xb0a97b.x - _0x403668.x > 0 ? 1 : -1,
        _0x2dcb72 = _0xb0a97b.y - _0x403668.y > 0 ? 1 : -1;
      this["contextSlate"]["strokeRect"](_0x403668.x, _0x403668.y, _0x3341d5 * _0x22be5a, _0x3341d5 * _0x2dcb72);
    } else this["contextSlate"]["strokeRect"](_0x403668.x, _0x403668.y, _0xb0a97b.x - _0x403668.x, _0xb0a97b.y - _0x403668.y);
  }
  ["optionChange"](_0x2ea29d, _0x48fc8c) {
    if (_0x2ea29d == "multilayer") this.updateZIndex(_0x48fc8c); else _0x2ea29d == "selectiontype" && (this.clearSlate(), this["removeClicks"](), this["contextSlate"]["beginPath"]());
  }
  ["updateZIndex"](_0xc9bfa8) {
    _0xc9bfa8 ? this.surface["setSlatePriority"](room.board["getLayerZIndex"](room.board["nLayers"] - 1) + 1) : this.surface["setSlatePriority"](room["board"]["getLayerZIndex"](this.surface["currentLayer"]) + 1);
  }
  ["onBrushParameter"](_0x4c0f6d) {
    var _0xb29536 = _0x4c0f6d["action"],
      _0x1e7e90 = new Array();
    if (this.getOption("multilayer")) {
      let _0x4caa01 = this["getOption"]("allowedlayers");
      for (var _0x181fa1 = 0; _0x181fa1 < _0x4caa01["length"] || 0; _0x181fa1++) {
        _0x1e7e90["push"](_0x4caa01[_0x181fa1]);
      }
    } else _0x1e7e90["push"](this["surface"].currentLayer);
    var _0x18cff3 = this;
    $.each(_0x1e7e90, function (_0x5b701d, _0x50ae6f) {
      if (_0xb29536 == "clear" || _0xb29536 == "move") _0x18cff3["clipSave"](_0x50ae6f), _0x50ae6f == 0 && !room["bottomTransparency"] ? _0x18cff3["clipFill"](_0x50ae6f, room["board"].backgroundColor) : _0x18cff3.clipClear(_0x50ae6f), _0x18cff3["clipRestore"](_0x50ae6f); else _0xb29536 == "fill" && (_0x18cff3["clipSave"](_0x50ae6f), _0x18cff3.clipFill(_0x50ae6f), _0x18cff3["clipRestore"](_0x50ae6f));
      room.board["layerChanged"](_0x50ae6f);
    }), this["cancel"]();
  }
  ["getSelectedImage"](_0x5527b1) {
    var _0xdb1e31 = new Array(),
      _0x29c8da = this;
    return new Promise(function (_0x2d2c50, _0x248883) {
      var _0x3fa371 = _0x29c8da["getBounds"](),
        _0xc62483 = new Image();
      _0xc62483["onload"] = function () {
        _0x29c8da["contextSlate"]["save"](), _0x29c8da["redraw"](false), _0x29c8da["contextSlate"]["closePath"](), _0x29c8da["contextSlate"]["clip"](), _0x29c8da["contextSlate"]["drawImage"](_0xc62483, 0, 0), _0x29c8da["contextSlate"]["restore"](), _0x29c8da["surface"].slate["clearCanvasProperties"]();
        var _0x5ca4fb = new Image();
        _0x5ca4fb.onload = function (_0x53d468) {
          var _0x39e12c = new Image();
          _0x39e12c["onload"] = function (_0x210ac7) {
            var _0x54d12a = {};
            _0x54d12a["position"] = _0x3fa371, _0x54d12a["img"] = this, _0x54d12a["layer"] = _0x5527b1, _0x2d2c50(_0x54d12a);
          }, _0x39e12c.src = cropImage(this, _0x3fa371.x, _0x3fa371.y, _0x3fa371["width"] - _0x3fa371.x, _0x3fa371.height - _0x3fa371.y);
        }, _0x5ca4fb["src"] = _0x29c8da["surface"]["slate"]["getData"]();
      }, _0xc62483["src"] = room["board"].layers[_0x5527b1]["getData"]();
    });
  }
  ["setClicks"](_0x237bcc) {
    this.removeClicks();
    for (var _0x5afd41 = 0; _0x5afd41 < _0x237bcc["length"]; _0x5afd41++) {
      this["clickX"]["push"](_0x237bcc[_0x5afd41].x), this["clickY"]["push"](_0x237bcc[_0x5afd41].y);
    }
  }
  ["getClicks"](_0x3e3010 = null) {
    var _0x7cdd8f = new Array();
    for (var _0x844e5e = 0; _0x844e5e < this["clickX"]["length"]; _0x844e5e++) {
      _0x7cdd8f.push(new Point(this["clickX"][_0x844e5e], this["clickY"][_0x844e5e]));
    }
    return _0x7cdd8f;
  }
  ["getCoords"](_0x38b819 = null) {
    if (this["getOption"]("selectiontype")) return this["getClicks"](); else {
      var _0x3d9829 = new Array();
      return _0x3d9829.push(new Point(this["start"].x, this["start"].y)), _0x3d9829["push"](new Point(this.end.x, this["start"].y)), _0x3d9829["push"](new Point(this["end"].x, this["end"].y)), _0x3d9829["push"](new Point(this.start.x, this["end"].y)), _0x3d9829;
    }
  }
  ["getBounds"]() {
    var _0x6b1a0e, _0x4eff99;
    return this["getOption"]("selectiontype") ? (_0x6b1a0e = getLimits(this.clickX), _0x4eff99 = getLimits(this["clickY"])) : (_0x6b1a0e = getLimits(new Array(this["start"].x, this["end"].x)), _0x4eff99 = getLimits(new Array(this.start.y, this["end"].y))), new Rect(_0x6b1a0e.x, _0x4eff99.x, _0x6b1a0e.y, _0x4eff99.y);
  }
  ["isUsingSlate"]() {
    return this["getOption"]("selectiontype") ? this["clickX"]["length"] > 0 : this["end"];
  }
}
class BrushEraser extends BrushStub {
  constructor(_0x2dca3e) {
    super(_0x2dca3e), this.clickX = new Array(), this.clickY = new Array(), this.options = {}, this.options.size = new SizeOption(), this["options"]["alpha"] = new AlphaOption(), this.options["blur"] = new BlurOption(), this.options["multilayer"] = new MultilayerOption(), this["options"]["pressure"] = new PressureOption([true, 1]), this.options["rightclick"] = new RightClickOption("eraser"), this["options"]["allowedlayers"] = new AllowedLayersOption([]), this["options"]["cursor"] = new CursorOption("circle");
  }
  ["brushStart"]() {
    this["surface"].cursor["changePointer"](this["getOption"]("cursor")), this.updateZIndex(this["getOption"]("multilayer"));
  }
  ["brushStop"]() {
    this["updateZIndex"](false);
  }
  ["optionChanged"](_0x1d83fc, _0x5f1a61) {
    _0x1d83fc == "cursor" && this.surface.cursor["changePointer"](_0x5f1a61);
  }
  ["drawStart"](_0x4dd777, _0x255523, _0x59f64c) {
    this["surface"]["slate"]["setCSSProperties"]({
      alpha: this["getOption"]("alpha"),
      blendmode: "normal",
      blur: this["getOption"]("blur")
    }), this["addClick"](_0x4dd777, _0x255523);
  }
  ["drawStep"](_0x260fac, _0xd5add1, _0x1685f9) {
    let _0x1c18d1 = this["getOption"]("allowedlayers");
    if (this["surface"].currentLayer == 0 && !this["getOption"]("multilayer") || this["getOption"]("multilayer") && _0x1c18d1 == room["board"]["nLayers"]) this["addClick"](_0xd5add1.x, _0xd5add1.y), this.redraw(); else {
      if (this["getOption"]("multilayer")) for (var _0x5a5e29 = 0; _0x5a5e29 < _0x1c18d1["length"]; _0x5a5e29++) {
        this["compositeLine"](_0x260fac, _0xd5add1, _0x1c18d1[_0x5a5e29], _0x1c18d1[_0x5a5e29] == 0 && !room.bottomTransparency ? "opaque" : "transparent");
      } else this["compositeLine"](_0x260fac, _0xd5add1, this["surface"]["currentLayer"], "transparent");
    }
  }
  ["drawEnd"](_0x5adb14, _0x143131, _0x248834) {
    let _0x49a929 = this["getOption"]("allowedlayers");
    if (this["surface"]["currentLayer"] == 0 && !this["getOption"]("multilayer") || this["getOption"]("multilayer") && _0x49a929 == room.board["nLayers"]) this["addClick"](_0x5adb14, _0x143131), this["endStroke"](); else {
      var _0x291356 = new Point(_0x5adb14, _0x143131);
      if (this.getOption("multilayer")) for (var _0x57e123 = 0; _0x57e123 < _0x49a929["length"]; _0x57e123++) {
        this.compositeLine(_0x291356, _0x291356, _0x49a929[_0x57e123], _0x49a929[_0x57e123] == 0 && !room["bottomTransparency"] ? "opaque" : "transparent");
      } else this["compositeLine"](_0x291356, _0x291356, this["surface"]["currentLayer"], "transparent");
    }
    this["clearSlate"](), this["removeClicks"](), this["updatePreviews"]();
  }
  ["endStroke"]() {
    if (this["getOption"]("multilayer")) {
      let _0x3f99aa = this["getOption"]("allowedlayers");
      for (var _0x217097 = 0; _0x217097 < _0x3f99aa["length"]; _0x217097++) {
        this["compositeBuffer"](_0x3f99aa[_0x217097], _0x3f99aa[_0x217097] == 0 && !room.bottomTransparency ? "opaque" : "transparent");
      }
    } else this["compositeBuffer"](this["surface"]["currentLayer"], this["surface"]["currentLayer"] == 0 && !room.bottomTransparency ? "opaque" : "transparent");
  }
  ["updatePreviews"]() {
    if (this["getOption"]("multilayer")) for (var _0x272477 = 0; _0x272477 < this["getOption"]("allowedlayers").length; _0x272477++) {
      this.getOption("allowedlayers")[_0x272477] != this.surface.currentLayer && room.board["layerChanged"](this["getOption"]("allowedlayers")[_0x272477]);
    }
  }
  ["clearSlate"]() {
    this["contextSlate"]["clearRect"](0, 0, this.contextSlate.canvas.width, this.contextSlate.canvas.height);
  }
  ["addClick"](_0x32559f, _0x457d4f) {
    this["clickX"]["push"](_0x32559f), this["clickY"]["push"](_0x457d4f);
  }
  ["removeClicks"]() {
    this["clickX"] = new Array(), this["clickY"] = new Array();
  }
  ["cancel"]() {
    this["clearSlate"](), this["removeClicks"]();
  }
  ["getSync"]() {
    var _0xff3031 = {};
    return _0xff3031["clickX"] = this["clickX"], _0xff3031["clickY"] = this["clickY"], _0xff3031;
  }
  ["setSync"](_0x44970c) {
    if (_0x44970c.clickX.length > 0) {
      this.drawStart(_0x44970c["clickX"][0], _0x44970c["clickY"][0], this.surface.drawColor);
      for (var _0x265477 = 1; _0x265477 < _0x44970c["clickX"].length; _0x265477++) {
        this["drawStep"](new Point(_0x44970c.clickX[_0x265477 - 1], _0x44970c["clickY"][_0x265477 - 1]), new Point(_0x44970c.clickX[_0x265477], _0x44970c["clickY"][_0x265477]), this["surface"]["drawColor"]);
      }
    }
  }
  ["redraw"]() {
    var _0x161a1a = this.getOption("pressure")[0] ? this["getOption"]("pressure")[1] : 1;
    this["surface"].slate.setCanvasProperties({
      linejoin: "round",
      linecap: "round",
      linewidth: Math["max"](this["getOption"]("size") * _0x161a1a, 1),
      strokestyle: room["board"].backgroundColor,
      alpha: 1,
      blendmode: "normal",
      blur: 0,
      linedash: []
    }), this["contextSlate"].clearRect(0, 0, this["contextSlate"]["canvas"]["width"], this["contextSlate"].canvas["height"]), this.contextSlate.beginPath(), this["contextSlate"]["moveTo"](this["clickX"][0], this["clickY"][0]);
    for (var _0x4f8c1d = 0; _0x4f8c1d < this.clickX["length"]; _0x4f8c1d++) {
      this.contextSlate["lineTo"](this.clickX[_0x4f8c1d], this["clickY"][_0x4f8c1d]);
    }
    this["contextSlate"].stroke();
  }
  ["updateZIndex"](_0x29dece) {
    _0x29dece ? this.surface.setSlatePriority(room.board["getLayerZIndex"](room.board.nLayers - 1) + 1) : this["surface"]["setSlatePriority"](room["board"]["getLayerZIndex"](this["surface"]["currentLayer"]) + 1);
  }
  ["optionChange"](_0x319a6b, _0xd6924f) {
    var _0x4e1405 = this["clickX"]["length"];
    _0x4e1405 > 0 && (this.endStroke(), this["clearSlate"](), this["removeClicks"](), this["updatePreviews"]()), _0x319a6b == "multilayer" && this.updateZIndex(_0xd6924f);
  }
  ["compositeLine"](_0x5abf8f, _0x2e94e9, _0x158376, _0x39da14 = "transparent") {
    var _0x21c71f = this["getOption"]("pressure")[0] ? this.getOption("pressure")[1] : 1;
    room["board"]["layers"][_0x158376]["advCanvas"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: Math.max(this["getOption"]("size") * _0x21c71f, 1),
      strokestyle: room["board"].backgroundColor,
      alpha: this["getOption"]("alpha"),
      blendmode: _0x39da14 == "transparent" ? "destination-out" : "normal",
      blur: this["getOption"]("blur"),
      linedash: []
    });
    var _0x412e12 = room["board"]["getContext"](_0x158376);
    _0x412e12["beginPath"](), _0x412e12["moveTo"](_0x5abf8f.x, _0x5abf8f.y), _0x412e12["lineTo"](_0x2e94e9.x, _0x2e94e9.y), _0x412e12["stroke"]();
  }
  ["compositeBuffer"](_0x1c3d75, _0x55e954 = "transparent") {
    var _0x40b57f = this["getOption"]("pressure")[0] ? this.getOption("pressure")[1] : 1;
    room["board"].layers[_0x1c3d75]["advCanvas"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: Math["max"](this["getOption"]("size") * _0x40b57f, 1),
      strokestyle: room["board"]["backgroundColor"],
      alpha: this.getOption("alpha"),
      blendmode: _0x55e954 == "transparent" ? "destination-out" : "normal",
      blur: this["getOption"]("blur"),
      linedash: []
    });
    var _0x39b0e5 = room["board"]["getContext"](_0x1c3d75);
    _0x39b0e5["beginPath"](), _0x39b0e5["moveTo"](this["clickX"][0], this["clickY"][0]);
    for (var _0x2c1b44 = 0; _0x2c1b44 < this.clickX["length"]; _0x2c1b44++) {
      _0x39b0e5["lineTo"](this["clickX"][_0x2c1b44], this.clickY[_0x2c1b44]);
    }
    _0x39b0e5["stroke"]();
  }
}
class BrushDragModded extends BrushStub {
  constructor(_0x4c409f) {
    super(_0x4c409f), this.showPen = false, this["drawingTool"] = false, this["options"] = {}, this["options"]["size"] = new SizeOption(1, true), this.options["rightclick"] = new RightClickOption("drag");
  }
  ["brushStart"]() {
    this["surface"]["cursor"]["changePointer"]("invisible");
  }
}
class BrushRotateModded extends BrushStub {
  constructor(_0x1b0370) {
    super(_0x1b0370), this.showPen = false, this["drawingTool"] = false, this.options = {}, this["options"]["size"] = new SizeOption(1, true), this["options"]["rightclick"] = new RightClickOption("rotate");
  }
  ["brushStart"]() {
    this.surface["cursor"]["changePointer"]("invisible");
  }
}
class BrushPickerModded extends BrushStub {
  constructor(_0xdc303f) {
    super(_0xdc303f), this["drawingTool"] = false, this["options"] = {}, this.options["size"] = new SizeOption(33), this["options"].areaaverage = new AreaAverageOption(), this["options"]["rightclick"] = new RightClickOption("picker"), this["options"]["cursor"] = new CursorOption("crosshair");
  }
  ["brushStart"]() {
    this["surface"]["cursor"]["changePointer"](this["getOption"]("cursor"));
  }
  ["optionChanged"](_0xb2ae1, _0xb76d19) {
    _0xb2ae1 == "cursor" && this.surface["cursor"]["changePointer"](_0xb76d19);
  }
}
class BrushSelectionModded extends BrushStub {
  constructor(_0x4fe584) {
    super(_0x4fe584), this["clickX"] = new Array(), this["clickY"] = new Array(), this["start"], this["end"], this["offset"] = 0, this.tInt = null, this["marchingAnts"] = false, this["lastPosition"], this.moved = false, this["options"] = {}, this["options"].size = new SizeOption(4, true), this["options"]["selectiontype"] = new SelectionTypeOption(), this["options"]["multilayer"] = new MultilayerOption(), this.options["rightclick"] = new RightClickOption("selection"), this["options"]["allowedlayers"] = new AllowedLayersOption([]), this["options"]["cursor"] = new CursorOption("dot"), this["options"]["togglewholepixels"] = new WholePixelOption(true), this["options"]["polygonalselection"] = new PolygonalSelectionOption();
    this.undoStates = {}; // Will store original pixel data before changes
    this.transformActive = false; // Flag for active transformations
    this.pendingUndoActions = []; // Store undo actions until confirmed
    this.currentActionType = null; // Track the current action type
    this.originalSelectionState = null; // Store original canvas state when selection first made
    this.selectionOriginBounds = null; // Store bounds of original selection
  }
  
  ["transformSelection"](transformParams) {
    // Get affected layers
    const affectedLayers = this.getOption("multilayer") ? 
      this.getOption("allowedlayers") : 
      [this.surface.currentLayer];
    
    // Get bounds of selection
    const originalBounds = this.getBounds();
    
    // Calculate destination bounds based on transformation params
    let destinationBounds = this._calculateDestinationBounds(originalBounds, transformParams);
    
    // For move operations, we need to track both source and destination
    if (this.surface.isMyself) {
      this.transformActive = true;
      
      // Store original state for each affected layer
      this.undoStates = {};
      
      for (let layerId of affectedLayers) {
        const ctx = room.board.getContext(layerId);
        
        // Determine the complete region to capture (union of source and destination)
        const minX = Math.min(originalBounds.x, destinationBounds.x);
        const minY = Math.min(originalBounds.y, destinationBounds.y);
        const maxX = Math.max(originalBounds.x + originalBounds.width, 
                              destinationBounds.x + destinationBounds.width);
        const maxY = Math.max(originalBounds.y + originalBounds.height,
                              destinationBounds.y + destinationBounds.height);
        
        // Add padding to ensure we capture everything
        const padding = 10;
        const captureX = Math.max(0, Math.floor(minX) - padding);
        const captureY = Math.max(0, Math.floor(minY) - padding);
        const captureWidth = Math.min(ctx.canvas.width - captureX, 
                                     Math.ceil(maxX - minX) + padding * 2);
        const captureHeight = Math.min(ctx.canvas.height - captureY,
                                      Math.ceil(maxY - minY) + padding * 2);
        
        // Capture the entire affected region
        const originalData = ctx.getImageData(captureX, captureY, captureWidth, captureHeight);
        
        this.undoStates[layerId] = {
          data: originalData,
          bbox: [captureX, captureY, captureWidth, captureHeight]
        };
      }
    }
    
    // Perform the transformation
    this._performTransformation(transformParams, affectedLayers, originalBounds);
    
    // After transformation, create undo actions
    if (this.surface.isMyself && this.transformActive) {
      const groupActions = [];
      
      for (let layerId of affectedLayers) {
        const ctx = room.board.getContext(layerId);
        const layerState = this.undoStates[layerId];
        
        if (!layerState) continue;
        
        // Capture the current state of the same region
        const newData = ctx.getImageData(
          layerState.bbox[0], layerState.bbox[1],
          layerState.bbox[2], layerState.bbox[3]
        );
        
        groupActions.push({
          layer: layerId,
          bbox: layerState.bbox,
          oldData: layerState.data,
          newData: newData,
          transformType: transformParams.type,
          params: transformParams
        });
        
        room.board.layerChanged(layerId);
      }
      
      // Push to undo stack
      if (groupActions.length > 1) {
        room.board.pushGroupUndo(groupActions);
      } else if (groupActions.length === 1) {
        room.board.pushUndo(groupActions[0]);
      }
      
      // Reset state
      this.transformActive = false;
      this.undoStates = {};
    }
  }
  
  // Calculate the destination bounds after a transformation
  ["_calculateDestinationBounds"](originalBounds, params) {
    let destBounds = {
      x: originalBounds.x,
      y: originalBounds.y,
      width: originalBounds.width,
      height: originalBounds.height
    };
    
    if (params.type === "resize") {
      destBounds.width = params.newWidth || originalBounds.width;
      destBounds.height = params.newHeight || originalBounds.height;
    }
    else if (params.type === "move") {
      destBounds.x = originalBounds.x + (params.deltaX || 0);
      destBounds.y = originalBounds.y + (params.deltaY || 0);
    }
    else if (params.type === "rotate") {
      // For rotation, we use a bounding circle that contains the rectangle
      const centerX = originalBounds.x + originalBounds.width/2;
      const centerY = originalBounds.y + originalBounds.height/2;
      const radius = Math.sqrt(originalBounds.width*originalBounds.width + 
                             originalBounds.height*originalBounds.height)/2;
      
      destBounds.x = centerX - radius;
      destBounds.y = centerY - radius;
      destBounds.width = radius * 2;
      destBounds.height = radius * 2;
    }
    
    return destBounds;
  }
  
  // Helper method to extract a sub-region from ImageData
  ["_getSubImageData"](imageData, x, y, width, height, fullWidth) {
    const result = new ImageData(width, height);
    const srcData = imageData.data;
    const dstData = result.data;
    
    for (let j = 0; j < height; j++) {
      for (let i = 0; i < width; i++) {
        const srcIdx = ((y + j) * fullWidth + (x + i)) * 4;
        const dstIdx = (j * width + i) * 4;
        
        dstData[dstIdx] = srcData[srcIdx];         // R
        dstData[dstIdx + 1] = srcData[srcIdx + 1]; // G
        dstData[dstIdx + 2] = srcData[srcIdx + 2]; // B
        dstData[dstIdx + 3] = srcData[srcIdx + 3]; // A
      }
    }
    
    return result;
  }
  
  // Find the minimum bounding rectangle of actual pixel changes
  ["_findChangedRegion"](before, after, width, height) {
    const beforeData = before.data;
    const afterData = after.data;
    
    let minX = width, minY = height, maxX = 0, maxY = 0;
    let hasChanges = false;
    
    // Scan all pixels to find the changed region
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = (y * width + x) * 4;
        
        // Check if this pixel changed
        if (beforeData[idx] !== afterData[idx] ||
            beforeData[idx + 1] !== afterData[idx + 1] ||
            beforeData[idx + 2] !== afterData[idx + 2] ||
            beforeData[idx + 3] !== afterData[idx + 3]) {
          
          // Update bounds of changed region
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
          hasChanges = true;
        }
      }
    }
    
    return hasChanges ? [minX, minY, maxX, maxY] : null;
  }
  
  // Add a helper method to calculate the complete bounding box for transformations
  ["_calculateTransformBoundingBox"](bounds, params) {
    let captureX = Math.floor(bounds.x);
    let captureY = Math.floor(bounds.y);
    let captureWidth = Math.ceil(bounds.width);
    let captureHeight = Math.ceil(bounds.height);
    
    // Calculate the maximum area affected by the transformation
    if (params.type === "resize") {
      // For resize, take the larger of original and new sizes
      captureWidth = Math.max(captureWidth, params.newWidth);
      captureHeight = Math.max(captureHeight, params.newHeight);
      
      // If resizing to smaller than original, still keep the original area
      // This is important for proper undo/redo
      if (params.newWidth < bounds.width || params.newHeight < bounds.height) {
        captureWidth = Math.max(captureWidth, bounds.width);
        captureHeight = Math.max(captureHeight, bounds.height);
      }
    } 
    if (params.type === "move") {
      // Include both original and new positions
      const deltaX = params.deltaX || 0;
      const deltaY = params.deltaY || 0;
  
      const minX = Math.min(captureX, captureX + deltaX);
      const minY = Math.min(captureY, captureY + deltaY);
      const maxX = Math.max(captureX + captureWidth, captureX + captureWidth + deltaX);
      const maxY = Math.max(captureY + captureHeight, captureY + captureHeight + deltaY);
  
      captureX = minX;
      captureY = minY;
      captureWidth = maxX - minX;
      captureHeight = maxY - minY;
    }
    else if (params.type === "rotate") {
      // For rotation, calculate a bounding square that contains the rotated rectangle
      const centerX = captureX + captureWidth/2;
      const centerY = captureY + captureHeight/2;
      
      // Calculate the radius of a circle that contains the entire rectangle
      // This ensures we capture all pixels even at maximum rotation
      const radius = Math.ceil(Math.sqrt(captureWidth*captureWidth + captureHeight*captureHeight))/2;
      
      captureX = Math.max(0, Math.floor(centerX - radius));
      captureY = Math.max(0, Math.floor(centerY - radius));
      captureWidth = Math.min(room.board.canvasWidth - captureX, Math.ceil(radius * 2));
      captureHeight = Math.min(room.board.canvasHeight - captureY, Math.ceil(radius * 2));
    }
    
    // Add extra padding to ensure we capture everything including antialiasing effects
    // This is critical for clean undo operations
    const padding = 20;
    captureX = Math.max(0, captureX - padding);
    captureY = Math.max(0, captureY - padding);
    captureWidth = Math.min(room.board.canvasWidth - captureX, captureWidth + padding * 2);
    captureHeight = Math.min(room.board.canvasHeight - captureY, captureHeight + padding * 2);
    return [captureX, captureY, captureWidth, captureHeight];
  }
  
  // Helper method to actually perform the transformation
  // This is a placeholder - the actual implementation would depend on how
  // transformations are handled in the application
  ["_performTransformation"](params, affectedLayers, bounds) {
    const type = params.type;
    
    switch (type) {
      case "resize":
        this._applyResize(params, affectedLayers, bounds);
        break;
      case "rotate":
        this._applyRotation(params, affectedLayers, bounds);
        break;
      // Add other transformation types as needed
    }
  }
  
  // Method to apply resize transformation
  ["_applyResize"](params, affectedLayers, bounds) {
    const { newWidth, newHeight } = params;
    
    for (let layerId of affectedLayers) {
      const ctx = room.board.getContext(layerId);
      
      // Create a temporary canvas for the transformation
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = bounds.width;
      tempCanvas.height = bounds.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      // Draw the selection to the temp canvas
      this.clipSave(layerId);
      tempCtx.drawImage(
        ctx.canvas,
        bounds.x, bounds.y, bounds.width, bounds.height,
        0, 0, bounds.width, bounds.height
      );
      
      // Clear the original area
      ctx.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);
      
      // Draw the resized image back
      ctx.drawImage(
        tempCanvas,
        0, 0, bounds.width, bounds.height,
        bounds.x, bounds.y, newWidth, newHeight
      );
      
      this.clipRestore(layerId);
    }
    
    // Update selection bounds to reflect new size
    if (!this.getOption("selectiontype") && this.start && this.end) {
      this.end.x = this.start.x + newWidth;
      this.end.y = this.start.y + newHeight;
      this.redraw();
    }
  }
  
  // Method to apply rotation transformation
  ["_applyRotation"](params, affectedLayers, bounds) {
    const { angle } = params;
    const centerX = bounds.x + bounds.width / 2;
    const centerY = bounds.y + bounds.height / 2;
    
    for (let layerId of affectedLayers) {
      const ctx = room.board.getContext(layerId);
      
      // Create a temporary canvas
      const tempCanvas = document.createElement('canvas');
      const maxDimension = Math.ceil(Math.sqrt(bounds.width * bounds.width + bounds.height * bounds.height));
      tempCanvas.width = maxDimension;
      tempCanvas.height = maxDimension;
      const tempCtx = tempCanvas.getContext('2d');
      
      // Get the content
      tempCtx.drawImage(
        ctx.canvas,
        bounds.x, bounds.y, bounds.width, bounds.height,
        (maxDimension - bounds.width) / 2, (maxDimension - bounds.height) / 2, 
        bounds.width, bounds.height
      );
      
      // Clear the original area
      ctx.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);
      
      // Apply rotation
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(angle * Math.PI / 180);
      ctx.translate(-centerX, -centerY);
      
      // Draw the rotated image
      ctx.drawImage(
        tempCanvas,
        0, 0, maxDimension, maxDimension,
        centerX - maxDimension / 2, centerY - maxDimension / 2,
        maxDimension, maxDimension
      );
      
      ctx.restore();
    }
    
    // For polygon selections, we would need to rotate all points
    // For rectangular selections, we might need to switch to polygon mode
    // after rotation if the angle isn't a multiple of 90 degrees
  }
  ["brushStart"]() {
    this["surface"].cursor["changePointer"](this["getOption"]("cursor")), this["updateZIndex"](this.getOption("multilayer"));
  }
  ["brushStop"]() {
    this["cancel"](), this["updateZIndex"](false), clearInterval(this["tInt"]);
  }
  ["optionChanged"](_0x4e2143, _0x1f9e32) {
    _0x4e2143 == "cursor" && this["surface"]["cursor"]["changePointer"](_0x1f9e32);
  }
  ["drawStart"](_0x3c655f, _0x4075dc, _0x5323d9) {
    this["moved"] = false, this["setupSlate"](), this["clearSlate"](), this["removeClicks"]();
    this["getOption"]("selectiontype") ? (this["addClick"](_0x3c655f, _0x4075dc), this["lastPosition"] = new Point(_0x3c655f, _0x4075dc)) : this.start = new Point(_0x3c655f, _0x4075dc);
    this["contextSlate"]["beginPath"]();
    if (this["marchingAnts"] && this.tInt == null) {
      var _0x3a8cda = this;
      this.tInt = setInterval(function () {
        _0x3a8cda["offset"]++, _0x3a8cda["offset"] > 24 && (_0x3a8cda["offset"] = 0), _0x3a8cda["redraw"]();
      }, 20);
    }
  }
  ["drawStep"](_0x16b4ad, _0x36ae29, _0x52395c) {
    this.moved = true, _0x16b4ad.x = Math["min"](Math["max"](_0x16b4ad.x, 0), room["board"]["canvasWidth"]), _0x16b4ad.y = Math["min"](Math["max"](_0x16b4ad.y, 0), room["board"].canvasHeight), _0x36ae29.x = Math["min"](Math["max"](_0x36ae29.x, 0), room["board"].canvasWidth), _0x36ae29.y = Math["min"](Math["max"](_0x36ae29.y, 0), room["board"]["canvasHeight"]), this["getOption"]("selectiontype") ? (this["addClick"](_0x36ae29.x, _0x36ae29.y), this["surface"]["isMyself"] && UI["userPreferences"].getProperty("strokequality", "high") == "high" ? this.redraw() : this["getDistance"](this["lastPosition"].x, this["lastPosition"].y, _0x36ae29.x, _0x36ae29.y) >= 12 && (this.contextSlate["moveTo"](_0x16b4ad.x, _0x16b4ad.y), this.contextSlate["lineTo"](_0x36ae29.x, _0x36ae29.y), this["contextSlate"]["stroke"](), this["lastPosition"] = new Point(_0x36ae29.x, _0x36ae29.y))) : (!this.start && (this["start"] = _0x16b4ad), this["drawRect"](this["start"], _0x36ae29), this["end"] = _0x36ae29);
  }
  ["drawEnd"](_0x3ceec8, _0x5aea26, _0x37c06e) {
    this.getOption("selectiontype") ? (this["addClick"](_0x3ceec8, _0x5aea26), this.addClick(this.clickX[0], this.clickY[0]), this["redraw"]()) : (_0x3ceec8 = Math.min(Math.max(_0x3ceec8, 0), this["contextSlate"]["canvas"].width), _0x5aea26 = Math["min"](Math.max(_0x5aea26, 0), this.contextSlate["canvas"]["height"]), this["end"] = new Point(_0x3ceec8, _0x5aea26));
    
    // If this is a successful selection (not cancelled), capture original state
    if (this.moved) {
      this.captureOriginalSelectionState();
    } else {
      this["cancel"]();
    }
  }
  
  ["captureOriginalSelectionState"]() {
    if (!this.surface.isMyself) return;
    
    // Get bounds of the selection
    const bounds = this.getBounds();
    this.selectionOriginBounds = {...bounds};
    
    // Determine which layers will be affected
    const affectedLayers = this.getOption("multilayer") ? 
      this.getOption("allowedlayers") : 
      [this.surface.currentLayer];
      
    // Store original state for each layer
    this.originalSelectionState = {};
    
    for (let layerId of affectedLayers) {
      const ctx = room.board.getContext(layerId);
      
      // Get the exact bounds without padding
      const captureX = Math.max(0, Math.floor(bounds.x));
      const captureY = Math.max(0, Math.floor(bounds.y));
      const captureWidth = Math.min(ctx.canvas.width - captureX, Math.ceil(bounds.width));
      const captureHeight = Math.min(ctx.canvas.height - captureY, Math.ceil(bounds.height));
      
      // Capture the original pixels
      const originalData = ctx.getImageData(captureX, captureY, captureWidth, captureHeight);
      
      this.originalSelectionState[layerId] = {
        data: originalData,
        bbox: [captureX, captureY, captureWidth, captureHeight]
      };
    }
  }
  ["clipSave"](_0x164d9d) {
    var _0x5a5c1f = room["board"]["getContext"](_0x164d9d);
    _0x5a5c1f["save"](), _0x5a5c1f["beginPath"]();
    if (this.getOption("selectiontype")) {
      _0x5a5c1f["moveTo"](this.clickX[0], this["clickY"][0]);
      for (var _0x2d8255 = 0; _0x2d8255 < this.clickX["length"]; _0x2d8255++) {
        _0x5a5c1f["lineTo"](this["clickX"][_0x2d8255], this["clickY"][_0x2d8255]);
      }
    } else _0x5a5c1f.moveTo(this["start"].x, this["start"].y), _0x5a5c1f["lineTo"](this["end"].x, this["start"].y), _0x5a5c1f["lineTo"](this.end.x, this.end.y), _0x5a5c1f["lineTo"](this["start"].x, this["end"].y);
    _0x5a5c1f["closePath"](), _0x5a5c1f["clip"]();
  }
  ["clipClear"](_0x142722) {
    room.board.layers[_0x142722]["advCanvas"]["setCanvasProperties"]({
      fillstyle: room.board["backgroundColor"],
      alpha: 1,
      blendmode: "normal",
      blur: 0
    });
    var _0x516e6e = room["board"]["getContext"](_0x142722);
    _0x516e6e["clearRect"](0, 0, _0x516e6e.canvas["width"], _0x516e6e["canvas"]["height"]);
  }
  ["clipFill"](_0x5dff78, _0x43b65a = null) {
    _0x43b65a == null && (_0x43b65a = this["surface"]["drawColor"]);
    room["board"]["layers"][_0x5dff78].advCanvas.setCanvasProperties({
      fillstyle: _0x43b65a,
      alpha: 1,
      blendmode: "normal",
      blur: 0
    });
    var _0x22b19c = room["board"]["getContext"](_0x5dff78);
    _0x22b19c["fillRect"](0, 0, _0x22b19c["canvas"]["width"], _0x22b19c["canvas"]["height"]);
  }
  ["clipRestore"](_0x1a550a) {
    var _0x569aff = room["board"]["getContext"](_0x1a550a);
    _0x569aff["restore"](), room.board["layers"][_0x1a550a]["advCanvas"]["clearCanvasProperties"]();
  }
  ["addClick"](_0x3bed8e, _0x527fd9) {
    this["clickX"].push(_0x3bed8e), this["clickY"]["push"](_0x527fd9);
  }
  ["removeClicks"]() {
    this["clickX"] = new Array(), this.clickY = new Array(), this["end"] = null;
  }
  ["clearSlate"]() {
    this.contextSlate["clearRect"](0, 0, this.contextSlate["canvas"].width, this["contextSlate"]["canvas"]["height"]);
  }
  ["getSync"]() {
    var _0x1e23ab = {};
    return _0x1e23ab["start"] = this["start"], _0x1e23ab["end"] = this["end"], _0x1e23ab.clickX = this["clickX"], _0x1e23ab.clickY = this["clickY"], _0x1e23ab["moved"] = this.moved, _0x1e23ab;
  }
  ["setSync"](_0x2b27d8) {
    this.moved = _0x2b27d8["moved"];
    if (this["getOption"]("selectiontype")) {
      if (this["surface"]["penPressed"]) {
        if (_0x2b27d8["clickX"]["length"] > 0) {
          this["drawStart"](_0x2b27d8["clickX"][0], _0x2b27d8.clickY[0], this["surface"]["drawColor"]);
          for (var _0x57b8b6 = 1; _0x57b8b6 < _0x2b27d8.clickX["length"]; _0x57b8b6++) {
            this["drawStep"](new Point(_0x2b27d8["clickX"][_0x57b8b6 - 1], _0x2b27d8.clickY[_0x57b8b6 - 1]), new Point(_0x2b27d8.clickX[_0x57b8b6], _0x2b27d8["clickY"][_0x57b8b6]), this["surface"]["drawColor"]);
          }
        }
      } else this["setupSlate"](), this["clickX"] = _0x2b27d8["clickX"], this.clickY = _0x2b27d8["clickY"], this["redraw"]();
    } else this["surface"]["penPressed"] ? this["drawStart"](_0x2b27d8.start.x, _0x2b27d8["start"].y, this["surface"]["drawColor"]) : (this["setupSlate"](), this["start"] = _0x2b27d8.start, this.end = _0x2b27d8.end, this["start"] && this.end && this["drawRect"](this["start"], this.end));
  }
  ["cancel"]() {
    this["clearSlate"](), this["removeClicks"]();
  }
  ["redraw"](_0x45056d = true) {
    this["clearSlate"](), this["surface"]["slate"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: _0x45056d ? 2 : 1,
      strokeStyle: "#808080",
      alpha: 1,
      blendmode: "normal",
      blur: 0,
      linedash: _0x45056d ? [5, 7] : [],
      linedashoffset: -this.offset
    }), this["contextSlate"]["beginPath"]();
    if (this["getOption"]("selectiontype")) {
      this["contextSlate"]["moveTo"](this["clickX"][0], this["clickY"][0]);
      for (var _0x529607 = 0; _0x529607 < this.clickX["length"]; _0x529607++) {
        this["contextSlate"]["lineTo"](this["clickX"][_0x529607], this["clickY"][_0x529607]);
      }
    } else this["contextSlate"]["moveTo"](this["start"].x, this["start"].y), this["contextSlate"]["lineTo"](this.end.x, this["start"].y), this["contextSlate"]["lineTo"](this["end"].x, this["end"].y), this.contextSlate["lineTo"](this["start"].x, this["end"].y), this["contextSlate"].lineTo(this["start"].x, this["start"].y);
    _0x45056d && this["contextSlate"]["stroke"]();
  }
  ["setupSlate"]() {
    this["surface"].slate.setCanvasProperties({
      linejoin: "round",
      linecap: "round",
      linewidth: 2,
      strokestyle: "#808080",
      alpha: 0.6,
      blendmode: "normal",
      blur: 0,
      linedash: [5, 7]
    }), this.surface["slate"]["setCSSProperties"]({
      alpha: 0.6,
      blendmode: "normal",
      blur: 0
    });
  }
  ["drawRect"](_0x403668, _0xb0a97b) {
    this["clearSlate"]();
    if (this["keepRatio"]) {
      var _0x3341d5 = this["getMinDistance"](_0xb0a97b.x - _0x403668.x, _0xb0a97b.y - _0x403668.y),
        _0x22be5a = _0xb0a97b.x - _0x403668.x > 0 ? 1 : -1,
        _0x2dcb72 = _0xb0a97b.y - _0x403668.y > 0 ? 1 : -1;
      this["contextSlate"]["strokeRect"](_0x403668.x, _0x403668.y, _0x3341d5 * _0x22be5a, _0x3341d5 * _0x2dcb72);
    } else this["contextSlate"]["strokeRect"](_0x403668.x, _0x403668.y, _0xb0a97b.x - _0x403668.x, _0xb0a97b.y - _0x403668.y);
  }
  ["optionChange"](_0x2ea29d, _0x48fc8c) {
    if (_0x2ea29d == "multilayer") this.updateZIndex(_0x48fc8c); else _0x2ea29d == "selectiontype" && (this.clearSlate(), this["removeClicks"](), this["contextSlate"]["beginPath"]());
  }
  ["updateZIndex"](_0xc9bfa8) {
    _0xc9bfa8 ? this.surface["setSlatePriority"](room.board["getLayerZIndex"](room.board["nLayers"] - 1) + 1) : this.surface["setSlatePriority"](room["board"]["getLayerZIndex"](this.surface["currentLayer"]) + 1);
  }
  ["_calculateDestinationBounds"](originalBounds, params) {
    let destBounds = {
      x: originalBounds.x,
      y: originalBounds.y,
      width: originalBounds.width,
      height: originalBounds.height
    };
    
    if (params.type === "resize") {
      destBounds.width = params.newWidth || originalBounds.width;
      destBounds.height = params.newHeight || originalBounds.height;
    }
    else if (params.type === "move") {
      destBounds.x = originalBounds.x + (params.deltaX || 0);
      destBounds.y = originalBounds.y + (params.deltaY || 0);
    }
    else if (params.type === "rotate") {
      // For rotation, we use a bounding circle that contains the rectangle
      const centerX = originalBounds.x + originalBounds.width/2;
      const centerY = originalBounds.y + originalBounds.height/2;
      const radius = Math.sqrt(originalBounds.width*originalBounds.width + 
                             originalBounds.height*originalBounds.height)/2;
      
      destBounds.x = centerX - radius;
      destBounds.y = centerY - radius;
      destBounds.width = radius * 2;
      destBounds.height = radius * 2;
    }
    
    return destBounds;
  }

  ["onBrushParameter"](_0x4c0f6d) {
    var _0xb29536 = _0x4c0f6d["action"];
    this.currentActionType = _0xb29536; // Store current action type
  
    // For move operations, ensure we have original state
    if ((_0xb29536 == "move") && !this.originalSelectionState) {
      this.captureOriginalSelectionState();
    }
    
    var _0x1e7e90 = new Array();
    
    // Determine which layers will be affected
    if (this.getOption("multilayer")) {
      let _0x4caa01 = this["getOption"]("allowedlayers");
      for (var _0x181fa1 = 0; _0x181fa1 < _0x4caa01["length"] || 0; _0x181fa1++) {
        _0x1e7e90["push"](_0x4caa01[_0x181fa1]);
      }
    } else _0x1e7e90["push"](this["surface"].currentLayer);
    
    // Get the original bounds of the selection
    const originalBounds = this.getBounds();
    
    // For operations like move, we need to calculate destination bounds
    let captureRegion = null;
    if ((_0xb29536 == "move" || _0xb29536 == "clone") && _0x4c0f6d.params) {
      // For move/clone, calculate both original and new positions
      const deltaX = _0x4c0f6d.params.deltaX || 0;
      const deltaY = _0x4c0f6d.params.deltaY || 0;
      
      // For move, we need both source and destination
      // For clone, we only need the destination area
      const minX = _0xb29536 == "move" ? 
        Math.min(originalBounds.x, originalBounds.x + deltaX) : 
        originalBounds.x + deltaX;
      
      const minY = _0xb29536 == "move" ? 
        Math.min(originalBounds.y, originalBounds.y + deltaY) : 
        originalBounds.y + deltaY;
      
      const maxX = _0xb29536 == "move" ? 
        Math.max(originalBounds.x + originalBounds.width, originalBounds.x + originalBounds.width + deltaX) : 
        originalBounds.x + originalBounds.width + deltaX;
      
      const maxY = _0xb29536 == "move" ? 
        Math.max(originalBounds.y + originalBounds.height, originalBounds.y + originalBounds.height + deltaY) : 
        originalBounds.y + originalBounds.height + deltaY;
      
      // Add padding
      const padding = 10;
      captureRegion = {
        x: Math.max(0, Math.floor(minX) - padding),
        y: Math.max(0, Math.floor(minY) - padding),
        width: Math.min(room.board.canvasWidth - Math.floor(minX) - padding, Math.ceil(maxX - minX) + padding * 2),
        height: Math.min(room.board.canvasHeight - Math.floor(minY) - padding, Math.ceil(maxY - minY) + padding * 2)
      };
    }
    
    // For operations like clear, fill, etc., we need to capture state before changes
    const groupActions = [];
    
    if (this.surface.isMyself && (_0xb29536 == "clear" || _0xb29536 == "move" || _0xb29536 == "clone" || _0xb29536 == "fill" || _0xb29536 == "transform")) {
      this.undoStates = {};
      
      // Capture appropriate region for each layer
      for (let layerId of _0x1e7e90) {
        const ctx = room.board.getContext(layerId);
        
        if (captureRegion) {
          // Capture the specific region for move/clone operations
          const regionData = ctx.getImageData(
            captureRegion.x, captureRegion.y,
            captureRegion.width, captureRegion.height
          );
          
          this.undoStates[layerId] = {
            data: regionData,
            bbox: [captureRegion.x, captureRegion.y, captureRegion.width, captureRegion.height]
          };
        } else {
          // For other operations, capture full canvas or the selection area
          const fullCanvasData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
          this.undoStates[layerId] = {
            data: fullCanvasData,
            bbox: [0, 0, ctx.canvas.width, ctx.canvas.height]
          };
        }
      }
    }
    
    // Perform the actions on each layer
    var _0x18cff3 = this;
    $.each(_0x1e7e90, function (_0x5b701d, _0x50ae6f) {
      if (_0xb29536 == "clear" || _0xb29536 == "move") {
        _0x18cff3["clipSave"](_0x50ae6f);
        _0x50ae6f == 0 && !room["bottomTransparency"] ? 
          _0x18cff3["clipFill"](_0x50ae6f, room["board"].backgroundColor) : 
          _0x18cff3.clipClear(_0x50ae6f);
        _0x18cff3["clipRestore"](_0x50ae6f);
      } else if (_0xb29536 == "fill") {
        _0x18cff3["clipSave"](_0x50ae6f);
        _0x18cff3.clipFill(_0x50ae6f);
        _0x18cff3["clipRestore"](_0x50ae6f);
      }
      
      room.board["layerChanged"](_0x50ae6f);
    });
    
    // Create undo actions
    if (this.surface.isMyself && (_0xb29536 == "clear" || _0xb29536 == "move" || _0xb29536 == "clone" || _0xb29536 == "fill" || _0xb29536 == "transform")) {
      for (let layerId of _0x1e7e90) {
        const ctx = room.board.getContext(layerId);
        const layerState = this.undoStates[layerId];
        
        if (!layerState) continue;
        
        // Get the current state after the operation
        const newData = ctx.getImageData(
          layerState.bbox[0], layerState.bbox[1],
          layerState.bbox[2], layerState.bbox[3]
        );
        
        // Create the undo action with the appropriate action type
        let undoAction = {
          layer: layerId,
          bbox: layerState.bbox,
          oldData: layerState.data,
          newData: newData,
          actionType: _0xb29536,
          params: _0x4c0f6d.params
        };
        
        // Mark actions by their specific type
        if (_0xb29536 === "move") {
          undoAction.isMoveAction = true;
        } else if (_0xb29536 === "clone") {
          undoAction.isCloneAction = true;
        }
        
        groupActions.push(undoAction);
      }
      
      // For move and clone actions, store as pending for later confirmation
      // For all other actions, commit immediately
      const needsConfirmation = _0xb29536 === "move" || _0xb29536 === "clone";
      
      if (needsConfirmation) {
        // Store pending actions instead of pushing to Board immediately
        if (groupActions.length > 1) {
          let groupAction = {
            type: 'group',
            actions: groupActions,
            actionType: _0xb29536
          };
          
          // Add specific flags based on action type
          if (_0xb29536 === "move") {
            groupAction.isMoveAction = true;
          } else if (_0xb29536 === "clone") {
            groupAction.isCloneAction = true;
          }
          
          this.pendingUndoActions = [groupAction];
        } else if (groupActions.length === 1) {
          this.pendingUndoActions = groupActions;
        }
        
        // Mark current stroke as needing confirmation in the surface tracking system
        this._markCurrentStrokeForConfirmation();
      } else {
        // Immediately commit to Board's undo stack for other action types
        if (groupActions.length > 1) {
          let groupAction = {
            type: 'group',
            actions: groupActions,
            actionType: _0xb29536
          };
          
          room.board.pushGroupUndo(groupAction);
        } else if (groupActions.length === 1) {
          room.board.pushUndo(groupActions[0]);
        }
        
        // Mark current stroke as already saved in the surface tracking system
        this._markCurrentStrokeAsSaved(_0xb29536);
      }
      
      // Clear undo states
      this.undoStates = {};
    }
    
    this["cancel"]();
  }
// New helper methods to mark strokes in the surface tracking system
["_markCurrentStrokeAsSaved"](actionType) {
  // Find the current stroke in various places
  if (this.surface) {
    // Check current stroke
    if (this.surface.currentStrokeData?.isSelectionStroke) {
      this.surface.currentStrokeData.alreadySaved = true;
      this.surface.currentStrokeData.finalAction = actionType;
    }
    
    // Also check in pending strokes array
    if (this.surface._pendingSelectionStrokes && this.surface._pendingSelectionStrokes.length > 0) {
      const latestStroke = this.surface._pendingSelectionStrokes[this.surface._pendingSelectionStrokes.length - 1];
      if (latestStroke) {
        latestStroke.alreadySaved = true;
        latestStroke.finalAction = actionType;
      }
    }
  }
}

["_markCurrentStrokeForConfirmation"]() {
  // Find the current stroke in various places
  if (this.surface) {
    // Check current stroke
    if (this.surface.currentStrokeData?.isSelectionStroke) {
      this.surface.currentStrokeData.needsConfirmation = true;
    }
    
    // Also check in pending strokes array
    if (this.surface._pendingSelectionStrokes && this.surface._pendingSelectionStrokes.length > 0) {
      const latestStroke = this.surface._pendingSelectionStrokes[this.surface._pendingSelectionStrokes.length - 1];
      if (latestStroke) {
        latestStroke.needsConfirmation = true;
      }
    }
  }
}

// New method to commit or discard pending actions
["commitPendingUndoActions"](commit = true, surfaceStrokeNumber = null) {
  if (!this.pendingUndoActions || !this.pendingUndoActions.length) {
    return;
  }
  
  // Check if undo history is enabled
  const undoHistoryEnabled = localStorage.getItem("undoHistoryEnabled") !== "false";
  
  // Check if we have a move or clone operation (ONLY these need special handling)
  const isMoveOrCloneOperation = this.pendingUndoActions.some(action => 
    (action.actionType === "move" || action.isMoveAction || 
     action.actionType === "clone" || action.isCloneAction) ||
    (action.type === 'group' && (
      action.actionType === "move" || action.actionType === "clone"
    ))
  );
  
  // If cancelling a move/clone operation
  if (!commit && isMoveOrCloneOperation && this.originalSelectionState) {
    // Only restore pixels locally if undo history is enabled
    // Otherwise, let the server handle the restoration
    const undoHistoryEnabled = UI?.undoHistoryEnabled
    if (undoHistoryEnabled) {
      // Restore original state for each affected layer
      for (let layerId in this.originalSelectionState) {
        const layerState = this.originalSelectionState[layerId];
        const ctx = room.board.getContext(layerId);
        
        // Restore the original pixels
        ctx.putImageData(
          layerState.data, 
          layerState.bbox[0], 
          layerState.bbox[1]
        );
        
        // Mark layer as changed
        room.board.layerChanged(layerId);
      }
    }
    
    // Always reset state
    this.originalSelectionState = null;
    this.selectionOriginBounds = null;
    this.pendingUndoActions = [];
    this.currentActionType = null;
    
    return; // Exit early
  }
  
  // Regular handling for commit cases
  if (commit) {
    // Push each pending action to Board's undo stack
    this.pendingUndoActions.forEach(action => {
      if (action.type === 'group') {
        // Store the result from pushGroupUndo to get the assigned strokeId
        const result = room.board.pushGroupUndo(action);
        
        // If surfaceStrokeNumber is provided, register the mapping
        if (surfaceStrokeNumber && result && result.strokeId) {
          room.board.registerStrokeMapping(result.strokeId, surfaceStrokeNumber);
        }
      } else {
        // Store the result from pushUndo to get the assigned strokeId
        const result = room.board.pushUndo(action);
        
        // If surfaceStrokeNumber is provided, register the mapping
        if (surfaceStrokeNumber && result && result.strokeId) {
          room.board.registerStrokeMapping(result.strokeId, surfaceStrokeNumber);
        }
      }
    });
  }
  
  // Reset state
  this.originalSelectionState = null;
  this.selectionOriginBounds = null;
  this.pendingUndoActions = [];
  this.currentActionType = null;
}
  ["getSelectedImage"](_0x5527b1) {
    var _0xdb1e31 = new Array(),
      _0x29c8da = this;
    return new Promise(function (_0x2d2c50, _0x248883) {
      var _0x3fa371 = _0x29c8da["getBounds"](),
        _0xc62483 = new Image();
      _0xc62483["onload"] = function () {
        _0x29c8da["contextSlate"]["save"](), _0x29c8da["redraw"](false), _0x29c8da["contextSlate"]["closePath"](), _0x29c8da["contextSlate"]["clip"](), _0x29c8da["contextSlate"]["drawImage"](_0xc62483, 0, 0), _0x29c8da["contextSlate"]["restore"](), _0x29c8da["surface"].slate["clearCanvasProperties"]();
        var _0x5ca4fb = new Image();
        _0x5ca4fb.onload = function (_0x53d468) {
          var _0x39e12c = new Image();
          _0x39e12c["onload"] = function (_0x210ac7) {
            var _0x54d12a = {};
            _0x54d12a["position"] = _0x3fa371, _0x54d12a["img"] = this, _0x54d12a["layer"] = _0x5527b1, _0x2d2c50(_0x54d12a);
          }, _0x39e12c.src = cropImage(this, _0x3fa371.x, _0x3fa371.y, _0x3fa371["width"] - _0x3fa371.x, _0x3fa371.height - _0x3fa371.y);
        }, _0x5ca4fb["src"] = _0x29c8da["surface"]["slate"]["getData"]();
      }, _0xc62483["src"] = room["board"].layers[_0x5527b1]["getData"]();
    });
  }
  ["setClicks"](_0x237bcc) {
    this.removeClicks();
    for (var _0x5afd41 = 0; _0x5afd41 < _0x237bcc["length"]; _0x5afd41++) {
      this["clickX"]["push"](_0x237bcc[_0x5afd41].x), this["clickY"]["push"](_0x237bcc[_0x5afd41].y);
    }
  }
  ["getClicks"](_0x3e3010 = null) {
    var _0x7cdd8f = new Array();
    for (var _0x844e5e = 0; _0x844e5e < this["clickX"]["length"]; _0x844e5e++) {
      _0x7cdd8f.push(new Point(this["clickX"][_0x844e5e], this["clickY"][_0x844e5e]));
    }
    return _0x7cdd8f;
  }
  ["getCoords"](_0x38b819 = null) {
    if (this["getOption"]("selectiontype")) return this["getClicks"](); else {
      var _0x3d9829 = new Array();
      return _0x3d9829.push(new Point(this["start"].x, this["start"].y)), _0x3d9829["push"](new Point(this.end.x, this["start"].y)), _0x3d9829["push"](new Point(this["end"].x, this["end"].y)), _0x3d9829["push"](new Point(this.start.x, this["end"].y)), _0x3d9829;
    }
  }
  ["getBounds"]() {
    var _0x6b1a0e, _0x4eff99;
    return this["getOption"]("selectiontype") ? (_0x6b1a0e = getLimits(this.clickX), _0x4eff99 = getLimits(this["clickY"])) : (_0x6b1a0e = getLimits(new Array(this["start"].x, this["end"].x)), _0x4eff99 = getLimits(new Array(this.start.y, this["end"].y))), new Rect(_0x6b1a0e.x, _0x4eff99.x, _0x6b1a0e.y, _0x4eff99.y);
  }
  ["isUsingSlate"]() {
    return this["getOption"]("selectiontype") ? this["clickX"]["length"] > 0 : this["end"];
  }
}
class BrushEraserModded extends BrushStub {
  constructor(_0x2dca3e) {
    super(_0x2dca3e), this.clickX = new Array(), this.clickY = new Array(), this.options = {}, this.options.size = new SizeOption(), this["options"]["alpha"] = new AlphaOption(), this.options["blur"] = new BlurOption(), this.options["multilayer"] = new MultilayerOption(), this["options"]["pressure"] = new PressureOption([true, 1]), this.options["rightclick"] = new RightClickOption("eraser"), this["options"]["allowedlayers"] = new AllowedLayersOption([]), this["options"]["cursor"] = new CursorOption("circle");
    
    // Add state variables for undo support
    this.inStroke = false;
    this.strokeLayers = [];
    this.oldData = {};
    
    // Track bounding box of the eraser stroke
    this.eraserBBox = null;
    this.hasOptionChangedDuringStroke = false;
    // Add flag to track if first move happened
    this.hasMadeFirstMove = false;
  }
  
  ["brushStart"]() {
    this["surface"].cursor["changePointer"](this["getOption"]("cursor")), this.updateZIndex(this["getOption"]("multilayer"));
  }
  
  ["brushStop"]() {
    this["updateZIndex"](false);
  }
  
  ["optionChanged"](_0x1d83fc, _0x5f1a61) {
    _0x1d83fc == "cursor" && this.surface.cursor["changePointer"](_0x5f1a61);
  }
  
  ["drawStart"](_0x4dd777, _0x255523, _0x59f64c) {
    // Mark that we're starting a stroke
    this.inStroke = true;
    this.strokeLayers = [];
    this.oldData = {};
    
    // Reset option change tracker and first move flag at stroke start
    this.hasOptionChangedDuringStroke = false;
    this.hasMadeFirstMove = false;
    this._lastOptionChanges = {};
    
    // ADDED: Track initial pressure for later comparison
    this._initialPressure = this.getOption("pressure") ? 
                          (this.getOption("pressure")[0] ? this.getOption("pressure")[1] : 1) : 1;
    
    // Initialize bounding box for eraser stroke
    const brushSize = Math.max(this.getOption("size"), 1);
    this.eraserBBox = {
      minX: _0x4dd777 - brushSize,
      minY: _0x255523 - brushSize,
      maxX: _0x4dd777 + brushSize,
      maxY: _0x255523 + brushSize
    };
    
    // Rest of the method remains the same...
    if (this["getOption"]("multilayer")) {
      this.strokeLayers = this.getOption("allowedlayers");
    } else {
      this.strokeLayers = [this.surface.currentLayer];
    }
    
    if (this.surface.isMyself) {
      for (let layerId of this.strokeLayers) {
        const ctx = room.board.getContext(layerId);
        this.oldData[layerId] = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
      }
    }

    this["surface"]["slate"]["setCSSProperties"]({
      alpha: this["getOption"]("alpha"),
      blendmode: "normal",
      blur: this["getOption"]("blur")
    }), this["addClick"](_0x4dd777, _0x255523);
  }
  
  ["drawStep"](_0x260fac, _0xd5add1, _0x1685f9) {
    // On first pen movement, mark that we've started moving
    if (!this.hasMadeFirstMove) {
      this.hasMadeFirstMove = true;
      // FIXED: Don't reset option changes when we start moving
      // Keep the changes that happened before movement
      // this.hasOptionChangedDuringStroke = false;  // REMOVED
      // this._lastOptionChanges = {};               // REMOVED
    }
    // Update bounding box with brush size for accurate undo region
    const brushSize = Math.max(this.getOption("size"), 1);
    if (this.eraserBBox) {
      this.eraserBBox.minX = Math.min(this.eraserBBox.minX, _0xd5add1.x - brushSize);
      this.eraserBBox.minY = Math.min(this.eraserBBox.minY, _0xd5add1.y - brushSize);
      this.eraserBBox.maxX = Math.max(this.eraserBBox.maxX, _0xd5add1.x + brushSize);
      this.eraserBBox.maxY = Math.max(this.eraserBBox.maxY, _0xd5add1.y + brushSize);
    }
    
    let _0x1c18d1 = this["getOption"]("allowedlayers");
    if (this["surface"].currentLayer == 0 && !this["getOption"]("multilayer") || this["getOption"]("multilayer") && _0x1c18d1 == room["board"]["nLayers"]) this["addClick"](_0xd5add1.x, _0xd5add1.y), this.redraw(); else {
      if (this["getOption"]("multilayer")) for (var _0x5a5e29 = 0; _0x5a5e29 < _0x1c18d1["length"]; _0x5a5e29++) {
        this["compositeLine"](_0x260fac, _0xd5add1, _0x1c18d1[_0x5a5e29], _0x1c18d1[_0x5a5e29] == 0 && !room.bottomTransparency ? "opaque" : "transparent");
      } else this["compositeLine"](_0x260fac, _0xd5add1, this["surface"]["currentLayer"], "transparent");
    }
  }
  
  ["drawEnd"](_0x5adb14, _0x143131, _0x248834) {
    if (!this.inStroke) return; // Safety check
    
    // Update bounding box with final position
    const brushSize = Math.max(this.getOption("size"), 1);
    if (this.eraserBBox) {
      this.eraserBBox.minX = Math.min(this.eraserBBox.minX, _0x5adb14 - brushSize);
      this.eraserBBox.minY = Math.min(this.eraserBBox.minY, _0x143131 - brushSize);
      this.eraserBBox.maxX = Math.max(this.eraserBBox.maxX, _0x5adb14 + brushSize);
      this.eraserBBox.maxY = Math.max(this.eraserBBox.maxY, _0x143131 + brushSize);
    }
    
    // Handle final line or point
    let _0x49a929 = this["getOption"]("allowedlayers");
    if (this["surface"]["currentLayer"] == 0 && !this["getOption"]("multilayer") || this["getOption"]("multilayer") && _0x49a929 == room.board["nLayers"]) {
      this["addClick"](_0x5adb14, _0x143131);
      this["endStroke"]();
    } else {
      var _0x291356 = new Point(_0x5adb14, _0x143131);
      if (this.getOption("multilayer")) {
        for (var _0x57e123 = 0; _0x57e123 < _0x49a929["length"]; _0x57e123++) {
          this.compositeLine(_0x291356, _0x291356, _0x49a929[_0x57e123], _0x49a929[_0x57e123] == 0 && !room["bottomTransparency"] ? "opaque" : "transparent");
        }
      } else {
        this["compositeLine"](_0x291356, _0x291356, this["surface"]["currentLayer"], "transparent");
      }
    }

    // After completing the stroke, collect all layer changes for undo
    // ONLY if this is the local user's drawing
    if (this.surface.isMyself && this.eraserBBox) {
      const groupActions = [];
      
      // Ensure bounding box values are integers and valid
      const bbox = [
        Math.max(0, Math.floor(this.eraserBBox.minX)),
        Math.max(0, Math.floor(this.eraserBBox.minY)),
        Math.min(room.board.canvasWidth, Math.ceil(this.eraserBBox.maxX - this.eraserBBox.minX)),
        Math.min(room.board.canvasHeight, Math.ceil(this.eraserBBox.maxY - this.eraserBBox.minY))
      ];
      
      // Expand bbox slightly to ensure we capture all affected pixels
      bbox[0] = Math.max(0, bbox[0] - 2);
      bbox[1] = Math.max(0, bbox[1] - 2);
      bbox[2] = Math.min(room.board.canvasWidth - bbox[0], bbox[2] + 4);
      bbox[3] = Math.min(room.board.canvasHeight - bbox[1], bbox[3] + 4);
      
      for (let layerId of this.strokeLayers) {
        if (this.oldData[layerId]) {
          const ctx = room.board.getContext(layerId);
          
          // Get the new data only from the affected area
          const newData = ctx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
          
          // Extract the same region from the old data
          const oldCanvas = document.createElement('canvas');
          oldCanvas.width = bbox[2];
          oldCanvas.height = bbox[3];
          const oldCtx = oldCanvas.getContext('2d');
          oldCtx.putImageData(this.oldData[layerId], -bbox[0], -bbox[1]);
          const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
          
          // Add this layer's changes to the group actions
          groupActions.push({
            layer: layerId,
            bbox: bbox,
            oldData: regionOldData,
            newData: newData
          });
        }
      }
      
      // Push all changes as a grouped undo action if we're using multilayer
      if (this.getOption("multilayer") && groupActions.length > 1) {
        room.board.pushGroupUndo({
          type: 'group',
          actions: groupActions
        });
      } else if (groupActions.length === 1) {
        // If only one layer, use regular pushUndo
        room.board.pushUndo(groupActions[0]);
      } else if (this.getOption("multilayer") && groupActions.length === 1) {
        // ADDED: Handle case when multilayer is on but only one layer was affected
        room.board.pushUndo(groupActions[0]);
      }
    }
    
    // Reset stroke tracking
    this.inStroke = false;
    this.strokeLayers = [];
    this.oldData = {};
    this.eraserBBox = null;
    
    this["clearSlate"]();
    this["removeClicks"]();
    this["updatePreviews"]();
  }
  
  // The rest of the methods remain the same
  ["endStroke"]() {
    if (this["getOption"]("multilayer")) {
      let _0x3f99aa = this["getOption"]("allowedlayers");
      for (var _0x217097 = 0; _0x217097 < _0x3f99aa["length"]; _0x217097++) {
        this["compositeBuffer"](_0x3f99aa[_0x217097], _0x3f99aa[_0x217097] == 0 && !room.bottomTransparency ? "opaque" : "transparent");
      }
    } else this["compositeBuffer"](this["surface"]["currentLayer"], this["surface"]["currentLayer"] == 0 && !room.bottomTransparency ? "opaque" : "transparent");
  }
  
  ["updatePreviews"]() {
    if (this["getOption"]("multilayer")) for (var _0x272477 = 0; _0x272477 < this["getOption"]("allowedlayers").length; _0x272477++) {
      this.getOption("allowedlayers")[_0x272477] != this.surface.currentLayer && room.board["layerChanged"](this["getOption"]("allowedlayers")[_0x272477]);
    }
  }
  
  ["clearSlate"]() {
    this["contextSlate"]["clearRect"](0, 0, this.contextSlate.canvas.width, this.contextSlate.canvas.height);
  }
  
  ["addClick"](_0x32559f, _0x457d4f) {
    this["clickX"]["push"](_0x32559f), this["clickY"]["push"](_0x457d4f);
  }
  
  ["removeClicks"]() {
    this["clickX"] = new Array(), this["clickY"] = new Array();
  }
  
  ["cancel"]() {
    // Check if we're in the middle of a stroke
    if (this.inStroke && this.surface.isMyself) {
      const isMultilayer = this.getOption("multilayer");
      const hasPoints = this.clickX && this.clickX.length > 0;
      
      // FIXED: Get current pressure info to compare with initial state
      const initialPressure = this._initialPressure || 0;
      const currentPressure = this.getOption("pressure") ? 
                            (this.getOption("pressure")[0] ? this.getOption("pressure")[1] : 1) : 1;
      const pressureChanged = initialPressure !== currentPressure;
      
      // CORRECTED: True single-click detection - only one point AND no movement
      const isSingleClick = false // hasPoints && this.clickX.length === 1 && !this.hasMadeFirstMove;
      
      // FIXED: Only create undo entries when we have meaningful changes
      // 1. Multilayer erasers (always save)
      // 2. True single clicks (no movement, just one point)
      // 3. Option changes (like alpha, size) that would alter the stroke
      // 4. Pressure changes
      const shouldCreateUndo = isMultilayer || 
                             isSingleClick || 
                             this.hasOptionChangedDuringStroke ||
                             pressureChanged;
      

      
      if (shouldCreateUndo && this.eraserBBox) {
        // Calculate bounding box of the affected area (with padding)
        // For single clicks with no movement, ensure we have a minimum size bbox
        if (isSingleClick) {
          const brushSize = Math.max(this.getOption("size"), 4);
          // Ensure we have a valid bounding box for single-click actions
          if (!this.eraserBBox || 
              this.eraserBBox.minX === this.eraserBBox.maxX ||
              this.eraserBBox.minY === this.eraserBBox.minY) {
            
            // Use stroke data start coordinates if available, otherwise fallback to click array
            let clickX, clickY;
            if (this.surface.currentStrokeData && this.surface.currentStrokeData.start) {
              clickX = this.surface.currentStrokeData.start.x;
              clickY = this.surface.currentStrokeData.start.y;
            } else if (hasPoints) {
              clickX = this.clickX[0];
              clickY = this.clickY[0];
            } else {
              // Default to cursor position if nothing else available
              clickX = this.surface.cursor ? this.surface.cursor.x : 100;
              clickY = this.surface.cursor ? this.surface.cursor.y : 100;
            }
            
            this.eraserBBox = {
              minX: clickX - brushSize,
              minY: clickY - brushSize, 
              maxX: clickX + brushSize,
              maxY: clickY + brushSize
            };
            }
        }
        
        const bbox = [
          Math.max(0, Math.floor(this.eraserBBox.minX - 2)),
          Math.max(0, Math.floor(this.eraserBBox.minY - 2)),
          Math.min(room.board.canvasWidth - Math.floor(this.eraserBBox.minX - 2), 
                 Math.ceil(this.eraserBBox.maxX - this.eraserBBox.minX) + 4),
          Math.min(room.board.canvasHeight - Math.floor(this.eraserBBox.minY - 2), 
                 Math.ceil(this.eraserBBox.maxY - this.eraserBBox.minY) + 4)
        ];
        
        // Ensure minimum size (prevent 0-pixel wide/tall boxes)
        if (bbox[2] < 1) bbox[2] = 1;
        if (bbox[3] < 1) bbox[3] = 1;
        
        // Create undo actions for all affected layers
        const groupActions = [];
        
        for (let layerId of this.strokeLayers) {
          if (this.oldData[layerId]) {
            const ctx = room.board.getContext(layerId);
            
            // Get the current state of the affected area (with partial erasure)
            const newData = ctx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
            
            // Extract the same region from the old data (before any erasure)
            const oldCanvas = document.createElement('canvas');
            oldCanvas.width = bbox[2];
            oldCanvas.height = bbox[3];
            const oldCtx = oldCanvas.getContext('2d');
            oldCtx.putImageData(this.oldData[layerId], -bbox[0], -bbox[1]);
            const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
            
            // Add this layer's changes to the group actions
            groupActions.push({
              layer: layerId,
              bbox: bbox,
              oldData: regionOldData,
              newData: newData,
              partialStroke: true,  // Mark as a partial stroke
              actionType: "eraser"  // Mark as an eraser action
            });
            

          }
        }
        
        // Push all changes as a grouped undo action if using multilayer
        if (groupActions.length > 1) {
          room.board.pushGroupUndo({
            type: 'group',
            actions: groupActions,
            partialStroke: true
          });
        } else if (groupActions.length === 1) {
          // If only one layer, use regular pushUndo
          room.board.pushUndo(groupActions[0]);
        }
      } else {
        }
    }
    
    // Always clear slate and remove clicks
    this.clearSlate();
    this.removeClicks();
    
    // Reset stroke tracking
    if (this.inStroke) {
      this.inStroke = false;
      this.strokeLayers = [];
      this.oldData = {};
      this.eraserBBox = null;
      this.hasOptionChangedDuringStroke = false;
      this.hasMadeFirstMove = false;
      this._lastOptionChanges = null;
      this._initialPressure = null;
    }
  }
  ["getSync"]() {
    var _0xff3031 = {};
    return _0xff3031["clickX"] = this["clickX"], _0xff3031["clickY"] = this["clickY"], _0xff3031;
  }
  ["setSync"](_0x44970c) {
    if (_0x44970c.clickX.length > 0) {
      this.drawStart(_0x44970c["clickX"][0], _0x44970c["clickY"][0], this.surface.drawColor);
      for (var _0x265477 = 1; _0x265477 < _0x44970c["clickX"].length; _0x265477++) {
        this["drawStep"](new Point(_0x44970c.clickX[_0x265477 - 1], _0x44970c["clickY"][_0x265477 - 1]), new Point(_0x44970c.clickX[_0x265477], _0x44970c["clickY"][_0x265477]), this["surface"]["drawColor"]);
      }
    }
  }
  ["redraw"]() {
    var _0x161a1a = this.getOption("pressure")[0] ? this["getOption"]("pressure")[1] : 1;
    this["surface"].slate.setCanvasProperties({
      linejoin: "round",
      linecap: "round",
      linewidth: Math["max"](this["getOption"]("size") * _0x161a1a, 1),
      strokestyle: room["board"].backgroundColor,
      alpha: 1,
      blendmode: "normal",
      blur: 0,
      linedash: []
    }), this["contextSlate"].clearRect(0, 0, this["contextSlate"]["canvas"]["width"], this["contextSlate"].canvas["height"]), this.contextSlate.beginPath(), this["contextSlate"]["moveTo"](this["clickX"][0], this["clickY"][0]);
    for (var _0x4f8c1d = 0; _0x4f8c1d < this.clickX["length"]; _0x4f8c1d++) {
      this.contextSlate["lineTo"](this.clickX[_0x4f8c1d], this["clickY"][_0x4f8c1d]);
    }
    this["contextSlate"].stroke();
  }
  ["updateZIndex"](_0x29dece) {
    _0x29dece ? this.surface.setSlatePriority(room.board["getLayerZIndex"](room.board.nLayers - 1) + 1) : this["surface"]["setSlatePriority"](room["board"]["getLayerZIndex"](this["surface"]["currentLayer"]) + 1);
  }
  ["optionChange"](_0x319a6b, _0xd6924f) {
    // FIXED: Track option changes as soon as we're in a stroke - even before moving
    if (this.inStroke) {
      this.hasOptionChangedDuringStroke = true;
      
      // Track which specific options changed
      if (!this._lastOptionChanges) this._lastOptionChanges = {};
      this._lastOptionChanges[_0x319a6b] = _0xd6924f;
    }
    
    // Original behavior continues
    var _0x4e1405 = this["clickX"]["length"];
    _0x4e1405 > 0 && (this.endStroke(), this["clearSlate"](), this["removeClicks"](), this["updatePreviews"]()), 
    _0x319a6b == "multilayer" && this.updateZIndex(_0xd6924f);
  }
  ["compositeLine"](_0x5abf8f, _0x2e94e9, _0x158376, _0x39da14 = "transparent") {
    var _0x21c71f = this["getOption"]("pressure")[0] ? this.getOption("pressure")[1] : 1;
    room["board"]["layers"][_0x158376]["advCanvas"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: Math.max(this["getOption"]("size") * _0x21c71f, 1),
      strokestyle: room["board"].backgroundColor,
      alpha: this["getOption"]("alpha"),
      blendmode: _0x39da14 == "transparent" ? "destination-out" : "normal",
      blur: this["getOption"]("blur"),
      linedash: []
    });
    var _0x412e12 = room["board"]["getContext"](_0x158376);
    _0x412e12["beginPath"](), _0x412e12["moveTo"](_0x5abf8f.x, _0x5abf8f.y), _0x412e12["lineTo"](_0x2e94e9.x, _0x2e94e9.y), _0x412e12["stroke"]();
  }
  ["compositeBuffer"](_0x1c3d75, _0x55e954 = "transparent") {
    var _0x40b57f = this["getOption"]("pressure")[0] ? this.getOption("pressure")[1] : 1;
    room["board"].layers[_0x1c3d75]["advCanvas"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: Math["max"](this["getOption"]("size") * _0x40b57f, 1),
      strokestyle: room["board"]["backgroundColor"],
      alpha: this.getOption("alpha"),
      blendmode: _0x55e954 == "transparent" ? "destination-out" : "normal",
      blur: this["getOption"]("blur"),
      linedash: []
    });
    var _0x39b0e5 = room["board"]["getContext"](_0x1c3d75);
    _0x39b0e5["beginPath"](), _0x39b0e5["moveTo"](this["clickX"][0], this["clickY"][0]);
    for (var _0x2c1b44 = 0; _0x2c1b44 < this.clickX["length"]; _0x2c1b44++) {
      _0x39b0e5["lineTo"](this["clickX"][_0x2c1b44], this.clickY[_0x2c1b44]);
    }
    _0x39b0e5["stroke"]();
  }
}
class BrushHandler {
  constructor(_0x18cc28) {
    this.surface = _0x18cc28, this["previousBrush"], this["currentBrush"], this["brush"] = null, this.brushes = {};
    
    // Fix: ensure isMyself property exists and is correctly evaluated
    const isMyCanvas = _0x18cc28.isMyself === true;
    
    if (isMyCanvas) {
      // Use Modded brush classes for ourselves
      this["brushes"]["drag"] = new BrushDragModded(_0x18cc28);
      this.brushes["rotate"] = new BrushRotateModded(_0x18cc28);
      this.brushes.picker = new BrushPickerModded(_0x18cc28);
      this["brushes"].selection = new BrushSelectionModded(_0x18cc28);
      this["brushes"]["pen"] = new BrushPenModded(_0x18cc28);
      this["brushes"]["eraser"] = new BrushEraserModded(_0x18cc28);
      this["brushes"]["text"] = new BrushTextModded(_0x18cc28);
      this.brushes["rect"] = new BrushRectModded(_0x18cc28);
      this.brushes.line = new BrushLineModded(_0x18cc28);
      this["brushes"]["ellipse"] = new BrushEllipseModded(_0x18cc28);
      this.brushes.fill = new BrushFillModded(_0x18cc28);
      this["brushes"]["blend"] = new BrushBlendModded(_0x18cc28);
      this["brushes"]["custom"] = new BrushCustomModded(_0x18cc28);
      this.brushes.blur = new BrushBlurModded(_0x18cc28);
      this.brushes["pixel"] = new BrushPixelModded(_0x18cc28);
    } else {
      // Use standard brush classes for others
      this["brushes"]["drag"] = new BrushDrag(_0x18cc28);
      this.brushes["rotate"] = new BrushRotate(_0x18cc28);
      this.brushes.picker = new BrushPicker(_0x18cc28);
      this["brushes"].selection = new BrushSelection(_0x18cc28);
      this["brushes"]["pen"] = new BrushPen(_0x18cc28);
      this["brushes"]["eraser"] = new BrushEraser(_0x18cc28);
      this["brushes"]["text"] = new BrushText(_0x18cc28);
      this.brushes["rect"] = new BrushRect(_0x18cc28);
      this.brushes.line = new BrushLine(_0x18cc28);
      this["brushes"]["ellipse"] = new BrushEllipse(_0x18cc28);
      this.brushes.fill = new BrushFill(_0x18cc28);
      this["brushes"]["blend"] = new BrushBlend(_0x18cc28);
      this["brushes"]["custom"] = new BrushCustom(_0x18cc28);
      this.brushes.blur = new BrushBlur(_0x18cc28);
      this.brushes["pixel"] = new BrushPixel(_0x18cc28);
    }
    
    // Initialize the toolbar (if any)
    if (this.surface.initializeToolbar) {
      this.surface.initializeToolbar();
    }
    
    this.setBrush("pen");
  }
  
  ["setBrush"](_0x2cdb3f) {
    this["brush"] != null && this["brush"]["brushStop"]();
    if (_0x2cdb3f in this.brushes && this["currentBrush"] != _0x2cdb3f) {
      this["previousBrush"] = this["currentBrush"];
      this.currentBrush = _0x2cdb3f;
      this["brush"] = this["brushes"][_0x2cdb3f];
      this["brush"]["brushStart"]();
      
      // Fix: Ensure the toolbar is updated when selection brush is activated
      if (_0x2cdb3f === "selection" && this.surface.showSelectionToolbar) {
        this.surface.showSelectionToolbar();
      }
    }
  }
  ["isOptionReadOnly"](_0x20212) {
    return this["brush"].isOptionReadOnly(_0x20212);
  }
  ["setOptionReadOnly"](_0x2cf6d6, _0x212410) {
    return this["brush"]["setOptionReadOnly"](_0x2cf6d6, _0x212410);
  }
  ["hasOption"](_0x39da4f) {
    return this["brush"]["hasOption"](_0x39da4f);
  }
  ["getOptionObject"](_0x33fb71) {
    return this["brush"]["getOptionObject"](_0x33fb71);
  }
  ["getOption"](_0x2533a7) {
    return this.brush.getOption(_0x2533a7);
  }
  ["setOption"](_0x225b7c, _0x4a392d) {
    this["brush"]["setOption"](_0x225b7c, _0x4a392d);
  }
  ["getOptions"]() {
    return this.brush.getOptions();
  }
  ["getBrushesOptions"]() {
    var _0x3e8871 = {};
    return $["each"](this.brushes, function (_0x507704, _0x31139b) {
      _0x3e8871[_0x507704] = _0x31139b.getOptions();
    }), _0x3e8871;
  }
  ["hasBrushOption"](_0x309b61, _0xe2c0f2) {
    if (_0x309b61 in this["brushes"]) return this["brushes"][_0x309b61]["hasOption"](_0xe2c0f2);
    return null;
  }
  ["getBrushOption"](_0x1ca96c, _0x457a89) {
    if (_0x1ca96c in this["brushes"]) return this["brushes"][_0x1ca96c]["getOption"](_0x457a89);
    return null;
  }
  ["setBrushOption"](_0x4a4633, _0x216012, _0x2c75b7) {
    _0x4a4633 in this["brushes"] && this["brushes"][_0x4a4633]["setOption"](_0x216012, _0x2c75b7);
  }
}
class BrushOption {
  constructor(_0x417158, _0x455370) {
    this.id = _0x417158, this.type = _0x455370, this["readOnly"] = false, this.list = new Array(), this["min"] = 0, this.max = 100, this["enabled"] = true, this.step = 0, this["defaultvalue"] = 1, this["hidden"] = false, this["incompatibleRoomTypes"] = new Array(), this["compatibleLayerCount"] = new Array(), this["callbackFunction"] = null, this["readOnlySubcomponents"] = null, this["value"];
  }
  ["isCompatible"](_0x2a7b94, _0x4a97db) {
    return (this.incompatibleRoomTypes.length == 0 || this["incompatibleRoomTypes"]["indexOf"](_0x2a7b94) == -1) && (this["compatibleLayerCount"]["length"] == 0 || this.compatibleLayerCount["indexOf"](_0x4a97db) > -1);
  }
  ["setList"](_0x31486a, _0x4096a2) {
    this["list"] = _0x31486a, this["defaultvalue"] = _0x4096a2, this.value = _0x4096a2;
  }
  ["setCheck"](_0x220a94, _0x23aeef) {
    this["enabled"] = _0x220a94, this["value"] = _0x23aeef;
  }
  ["setSlider"](_0x19331c, _0x191b2e, _0x46ed73, _0x64f397) {
    this["min"] = _0x19331c, this["max"] = _0x191b2e, this.step = _0x46ed73, this["defaultvalue"] = _0x64f397, this["value"] = _0x64f397;
  }
  ["setSliderCheck"](_0x2404a2, _0x2da08d, _0x17ef30, _0x4f877c, _0x13d55b) {
    this.enabled = _0x2404a2, this.min = _0x2da08d, this.max = _0x17ef30, this["step"] = _0x4f877c, this.defaultvalue = _0x13d55b, this["value"] = _0x13d55b;
  }
  ["setButton"](_0x5332a9) {
    this.callbackFunction = _0x5332a9;
  }
  ["setCustom"](_0x33657e) {
    this["value"] = _0x33657e;
  }
  ["setReadOnly"](_0x57270f) {
    this["readOnly"] = _0x57270f;
  }
}
class BlendModeOption extends BrushOption {
  constructor(_0x250668 = "normal", _0x2ac05a = false) {
    super("blendmode", "list");
    var _0x4e8761 = ["normal", "darken", "lighten", "difference", "exclusion", "hard-light", "soft-light", "multiply", "overlay", "screen", "saturation", "luminosity", "hue", "color", "color-dodge", "color-burn"],
      _0x1bf3df = {};
    $["each"](_0x4e8761, function (_0x5ad6b2, _0x5bafd1) {
      _0x1bf3df[_0x5bafd1] = textManager["getString"]("tooloption.blendmodes." + _0x5bafd1);
    }), this.setList(_0x1bf3df, _0x250668), this["setReadOnly"](_0x2ac05a), this.compatibleLayerCount = [];
  }
}
class AlphaOption extends BrushOption {
  constructor(_0x52899b = 1, _0x58ae1a = false) {
    super("alpha", "slider"), this["setSlider"](0, 1, 0.01, _0x52899b), this["setReadOnly"](_0x58ae1a), this.callbackFunction = zeroToOnePercentage;
  }
}
class SizeOption extends BrushOption {
  constructor(_0xdc0fa7 = 8, _0x3cd8f8 = false) {
    super("size", "slider"), this["setSlider"](1, 140, 1, _0xdc0fa7), this["setReadOnly"](_0x3cd8f8);
  }
}
class BlurOption extends BrushOption {
  constructor(_0x5e6249 = 0, _0x22ea6a = false) {
    super("blur", "slider"), this["setSlider"](0, 10, 0.1, _0x5e6249), this["setReadOnly"](_0x22ea6a), this["callbackFunction"] = blurPercentage;
  }
}
class SmoothOption extends BrushOption {
  constructor(_0x43da84 = 0, _0x794e8f = false) {
    super("smooth", "slider"), this.setSlider(0, 5, 1, _0x43da84), this["setReadOnly"](_0x794e8f);
  }
}
class SpacingOption extends BrushOption {
  constructor(_0x18b9bd = 0, _0x4daedb = false) {
    super("spacing", "slider"), this["setSlider"](0, 50, 1, _0x18b9bd), this["setReadOnly"](_0x4daedb);
  }
}
class MultilayerOption extends BrushOption {
  constructor(_0x33d0fd = false, _0x4903a2 = false) {
    super("multilayer", "check"), this["setCheck"](false, _0x33d0fd), this.setReadOnly(_0x4903a2), this["callbackFunction"] = yesnoFunction;
  }
}
class PolygonalSelectionOption extends BrushOption {
  constructor(_0x33d0fd = false, _0x4903a2 = false) {
    super("polygonalselection", "check"), this["setCheck"](false, _0x33d0fd), this.setReadOnly(_0x4903a2), this["callbackFunction"] = yesnoFunction;
  }
}
class WholePixelOption extends BrushOption {
  constructor(_0x33d0fd = false, _0x4903a2 = false) {
    super("togglewholepixels", "check"), this["setCheck"](false, _0x33d0fd), this.setReadOnly(_0x4903a2), this["callbackFunction"] = yesnoFunction;
  }
}
class PressureOpacityOption extends BrushOption {
  constructor(_0x33d0fd = false, _0x4903a2 = false) {
    super("togglepressureopacity", "check"), this["setCheck"](false, _0x33d0fd), this.setReadOnly(_0x4903a2), this["callbackFunction"] = yesnoFunction;
  }
}
class LockTransparencyOption extends BrushOption {
  constructor(_0x33d0fd = false, _0x4903a2 = false) {
    super("locktransparency", "check"), this["setCheck"](false, _0x33d0fd), this.setReadOnly(_0x4903a2), this["callbackFunction"] = yesnoFunction;
  }
}
class ZoomOption extends BrushOption {
  constructor(_0x33d0fd = false, _0x4903a2 = false) {
    super("togglezoom", "check"), this["setCheck"](false, _0x33d0fd), this.setReadOnly(_0x4903a2), this["callbackFunction"] = yesnoFunction;
  }
}
class SelectionTypeOption extends BrushOption {
  constructor(_0x2faa59 = true, _0x4d479d = false) {
    super("selectiontype", "check"), this["setCheck"](false, _0x2faa59), this["setReadOnly"](_0x4d479d), this["callbackFunction"] = lassoRectFunction;
  }
}
class GalleryOption extends BrushOption {
  constructor(_0x160434 = null, _0x4128e9 = false) {
    super("gallery", "button"), this["setButton"](_0x160434), this["setReadOnly"](_0x4128e9);
  }
}
class CustomizeOption extends BrushOption {
  constructor(_0x4cc800 = null, _0x47581a = false) {
    super("customize", "button"), this.setButton(_0x4cc800), this["setReadOnly"](_0x47581a);
  }
}

var enable1000PressureLevels = localStorage.getItem('enable1000PressureLevels') === 'true';
const PressureOption = (() => {
  if (enable1000PressureLevels) {
    return class extends BrushOption {
      constructor(_0x38dec6 = [true, 1], _0x26e346 = false) {
    super("pressure", "slidercheck"), this["setSliderCheck"](true, 0, 1, 0.001, _0x38dec6), this["setReadOnly"](_0x26e346), this["readOnlySubcomponents"] = [false, true], this["callbackFunction"] = zeroToOnePercentage;
  }
}
}
  else {
    return class extends BrushOption {
      constructor(_0x38dec6 = [true, 1], _0x26e346 = false) {
    super("pressure", "slidercheck"), this["setSliderCheck"](true, 0, 1, 0.1, _0x38dec6), this["setReadOnly"](_0x26e346), this["readOnlySubcomponents"] = [false, true], this["callbackFunction"] = zeroToOnePercentage;
    }
  };
}
})();
  

class AreaAverageOption extends BrushOption {
  constructor(_0x1c8a50 = false, _0x3768eb = false) {
    super("areaaverage", "check"), this["setCheck"](false, _0x1c8a50), this["setReadOnly"](_0x3768eb), this["callbackFunction"] = yesnoFunction;
  }
}
class EraserModeOption extends BrushOption {
  constructor(_0x5d9cbe = false, _0x392050 = false) {
    super("erasermode", "check"), this["setCheck"](false, _0x5d9cbe), this["setReadOnly"](_0x392050), this["callbackFunction"] = yesnoFunction;
  }
}
class AspectRatioOption extends BrushOption {
  constructor(_0x236c2a = false, _0x17b150 = false) {
    super("aspectratio", "check"), this["setCheck"](false, _0x236c2a), this["setReadOnly"](_0x17b150), this["callbackFunction"] = yesnoFunction;
  }
}
class SnapOption extends BrushOption {
  constructor(_0x379496 = false, _0x1c4ca5 = false) {
    super("snap", "check"), this["setCheck"](false, _0x379496), this["setReadOnly"](_0x1c4ca5), this["callbackFunction"] = yesnoFunction;
  }
}
class DrawGridOption extends BrushOption {
  constructor(_0x409aae = false, _0x1f186f = false) {
    super("drawgrid", "check"), this["setCheck"](false, _0x409aae), this["setReadOnly"](_0x1f186f), this["callbackFunction"] = yesnoFunction;
  }
}
class FontOption extends BrushOption {
  constructor(_0x37d3cd = "Rubik", _0x11665d = false) {
    super("font", "list");
    var _0x5c5314 = {};
    _0x5c5314["Rubik"] = "Rubik", _0x5c5314["BeautifulBloom"] = "Beautiful Bloom", _0x5c5314["Quicksand"] = "Quicksand", _0x5c5314["Phenomena"] = "Phenomena", _0x5c5314["LeagueSpartan"] = "League Spartan", _0x5c5314.AbrilFatface = "Abril Fatface", _0x5c5314["Amaranth"] = "Amaranth", _0x5c5314["Bevan"] = "Bevan", _0x5c5314.Stalemate = "Stalemate", _0x5c5314["OstrichSansInline"] = "Ostrich Sans Inline", _0x5c5314["Monicacomic"] = "Monicacomic", _0x5c5314["VeteranTypewriter"] = "Veteran Typewriter", this.setList(_0x5c5314, _0x37d3cd), this["setReadOnly"](_0x11665d);
  }
}
class FillOption extends BrushOption {
  constructor(_0x30741e = false, _0x5999e6 = false) {
    super("fill", "check"), this["setCheck"](false, _0x30741e), this["setReadOnly"](_0x5999e6), this["hidden"] = true, this["callbackFunction"] = yesnoFunction;
  }
}
class AllowedLayersOption extends BrushOption {
  constructor(_0x16b9cf = null, _0x846524 = false) {
    super("allowedlayers", "custom"), this["setCustom"](_0x16b9cf), this["hidden"] = true;
  }
}
class ImageOption extends BrushOption {
  constructor(_0x274ce8 = null, _0x426437 = false) {
    super("image", "custom"), this["setCustom"](_0x274ce8), this["hidden"] = true;
  }
}
class CursorOption extends BrushOption {
  constructor(_0x11ff41 = "circle", _0x1c3234 = false) {
    super("cursor", "list");
    var _0x5989ce = ["circle", "square", "crosshair", "cross", "dot"],
      _0x1e320c = {};
    $["each"](_0x5989ce, function (_0x36e4b0, _0x4354b8) {
      _0x1e320c[_0x4354b8] = textManager["getString"]("tooloption.cursorList." + _0x4354b8);
    }), this["setList"](_0x1e320c, _0x11ff41), this["setReadOnly"](_0x1c3234);
  }
}
class TintOption extends BrushOption {
  constructor(_0x47d6c5 = true, _0x4d708b = false) {
    super("tint", "check"), this.setCheck(false, _0x47d6c5), this["setReadOnly"](_0x4d708b), this["callbackFunction"] = yesnoFunction;
  }
}
class RandomRotationOption extends BrushOption {
  constructor(_0x4b1ef2 = true, _0x97ed4d = false) {
    super("randomrotation", "check"), this["setCheck"](false, _0x4b1ef2), this["setReadOnly"](_0x97ed4d), this["callbackFunction"] = yesnoFunction;
  }
}
class RotationValueOption extends BrushOption {
  constructor(_0x13094d = 0, _0x15fae9 = false) {
    super("rotationvalue", "custom"), this["setCustom"](_0x13094d), this["hidden"] = true;
  }
}
class RightClickOption extends BrushOption {
  constructor(_0x277147 = null, _0x5bf185 = null, _0x398be0 = false) {
    super("rightclick", "list");
    var _0x567cff = ["donothing", "cancelstroke", "toggleselectiontype", "togglemultilayer", "swapcolors", "toggleareaaverage", "rotatereset", "rotate45right", "centerboard", "fittoscreen", "resetzoom", "togglesnap", "toggleaspectratio", "toggleerasermode", "toggledrawgrid", "nextfont", "cleartext", "switchprevtool", "selecteraser", "showmenu", "togglepressureopacity", "togglewholepixels", "polygonalselection", "locktransparency"],
    _0x3f3469 = {};
    $["each"](_0x567cff, function (_0x17a708, _0x872937) {
      _0x3f3469[_0x872937] = textManager.getString("tooloption.rightClickList." + _0x872937);
    });
    var _0x3dbdc0, _0x2a2bc4;
    if (_0x277147 == "pen") _0x3dbdc0 = ["donothing", "showmenu", "cancelstroke", "swapcolors", "selecteraser", "togglepressureopacity", "locktransparency"], _0x2a2bc4 = "cancelstroke"; else {
      if (_0x277147 == "drag") _0x3dbdc0 = ["donothing", "showmenu", "centerboard", "fittoscreen", "resetzoom"], _0x2a2bc4 = "showmenu"; else {
        if (_0x277147 == "rotate") _0x3dbdc0 = ["donothing", "showmenu", "rotatereset", "rotate45right"], _0x2a2bc4 = "rotatereset"; else {
          if (_0x277147 == "picker") _0x3dbdc0 = ["donothing", "showmenu", "toggleareaaverage", "switchprevtool"], _0x2a2bc4 = "toggleareaaverage"; else {
            if (_0x277147 == "selection") _0x3dbdc0 = ["donothing", "showmenu", "toggleselectiontype", "togglemultilayer", "togglewholepixels", "polygonalselection"], _0x2a2bc4 = "toggleselectiontype"; else {
              if (_0x277147 == "eraser") _0x3dbdc0 = ["donothing", "showmenu", "togglemultilayer", "switchprevtool"], _0x2a2bc4 = "togglemultilayer"; else {
                if (_0x277147 == "line") _0x3dbdc0 = ["donothing", "showmenu", "cancelstroke", "togglesnap", "swapcolors"], _0x2a2bc4 = "cancelstroke"; else {
                  if (_0x277147 == "rect") _0x3dbdc0 = ["showmenu", "cancelstroke", "toggleaspectratio", "swapcolors"], _0x2a2bc4 = "cancelstroke"; else {
                    if (_0x277147 == "ellipse") _0x3dbdc0 = ["donothing", "showmenu", "cancelstroke", "toggleaspectratio", "swapcolors"], _0x2a2bc4 = "cancelstroke"; else {
                      if (_0x277147 == "fill") _0x3dbdc0 = ["donothing", "showmenu", "swapcolors", "switchprevtool"], _0x2a2bc4 = "swapcolors"; else {
                        if (_0x277147 == "pixel") _0x3dbdc0 = ["donothing", "showmenu", "toggleerasermode", "toggledrawgrid"], _0x2a2bc4 = "toggleerasermode"; else {
                          if (_0x277147 == "text") _0x3dbdc0 = ["donothing", "showmenu", "nextfont", "cleartext"], _0x2a2bc4 = "nextfont"; else _0x277147 == "custom" && (_0x3dbdc0 = ["donothing", "showmenu", "cancelstroke"], _0x2a2bc4 = "cancelstroke");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    var _0x33e195 = {};
    _0x277147 == null ? (_0x33e195 = _0x3f3469, _0x5bf185 = "cancelstroke") : (_0x5bf185 == null && (_0x5bf185 = _0x2a2bc4), $["each"](_0x3dbdc0, function (_0x3cd8b6, _0x178ac8) {
      _0x33e195[_0x178ac8] = _0x3f3469[_0x178ac8];
    })), this["setList"](_0x33e195, _0x5bf185), this["setReadOnly"](_0x398be0);
  }
}
class BrushPenModded extends BrushStub {
  constructor(_0x2222ae) {
    super(_0x2222ae);
    this.clickX = new Array();
    this.clickY = new Array();
    this.lastPosition;
    this["distance"];
    this["options"] = {};
    
    // Options in specific order
    this["options"]["size"] = new SizeOption();                            // 1. Size
    this["options"]["alpha"] = new AlphaOption();                          // 2. Opacity
    this["options"]["blur"] = new BlurOption();                            // 3. Blur
    this["options"]["blendmode"] = new BlendModeOption();                  // 4. Mode
    this["options"]["pressure"] = new PressureOption([true, 1]);           // 5. Pressure
    this["options"]["togglepressureopacity"] = new PressureOpacityOption(); // 6. Dynamic opacity
    this["options"]["locktransparency"] = new LockTransparencyOption();    // 7. Lock transparency
    
    // Rest of options at the bottom
    this["options"]["smooth"] = new SmoothOption();
    this["options"]["spacing"] = new SpacingOption(0);
    this["options"].rightclick = new RightClickOption("pen");
    this["options"].cursor = new CursorOption("circle");
    
    // Keep these initialization lines
    this.boundingBox = null;
    this.oldData = null;
    this.hasOptionChangesDuringStroke = false;
    this.hasMadeFirstMove = false;
  }
  ["brushStart"]() {
    this.surface["cursor"]["changePointer"](this.getOption("cursor"));
  }
  ["drawStart"](_0x483e39, _0x205d89, _0x1b587b) {
    // Mark that we're starting a stroke
    this.inStroke = true;
    this.strokeStartLayer = this.surface.currentLayer;
    this.hasMadeFirstMove = false; // Track if we've made our first move
    
    // Get brush size to adjust bounding box
    const brushSize = Math.max(this.getOption("size"), 1);
    
    // Initialize bounding box for the stroke with brush size margins
    this.boundingBox = {
      minX: _0x483e39 - brushSize,
      minY: _0x205d89 - brushSize,
      maxX: _0x483e39 + brushSize,
      maxY: _0x205d89 + brushSize
    };
    
    // Get starting image data for the whole canvas BEFORE we start drawing
    const ctx = room.board.getContext(this.surface.currentLayer);
    this.oldData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);

    this.inStroke = true;
    this.hasOptionChangesDuringStroke = false; // Reset option changes tracking
  
    this.setupSlate();
    this.removeClicks();
    this.addClick(_0x483e39, _0x205d89);
    this.contextSlate.beginPath();
    this.lastPosition = null;
    this.distance = 0;
    if (this.getOption("spacing") > 0) {
      this.contextSlate.moveTo(_0x483e39, _0x205d89);
      this.contextSlate.lineTo(_0x483e39, _0x205d89);
      this.contextSlate.stroke();
    }
  }

  ["drawStep"](_0x684ce0, _0x5c5254, _0x1cb21d) {
    // On first pen movement, mark that we've started moving
    if (!this.hasMadeFirstMove) {
      this.hasMadeFirstMove = true;
      // Reset option changes flag - only count changes AFTER first move
      this.hasOptionChangesDuringStroke = false;
      this._lastOptionChanges = {};
    }
    // Get brush size for bounding box
    const brushSize = Math.max(this.getOption("size"), 1);
    
    // Update bounding box with brush size taken into account
    this.boundingBox.minX = Math.min(
      this.boundingBox.minX,
      _0x684ce0.x - brushSize,
      _0x5c5254.x - brushSize
    );
    this.boundingBox.minY = Math.min(
      this.boundingBox.minY,
      _0x684ce0.y - brushSize,
      _0x5c5254.y - brushSize
    );
    this.boundingBox.maxX = Math.max(
      this.boundingBox.maxX,
      _0x684ce0.x + brushSize,
      _0x5c5254.x + brushSize
    );
    this.boundingBox.maxY = Math.max(
      this.boundingBox.maxY,
      _0x684ce0.y + brushSize,
      _0x5c5254.y + brushSize
    );

    var _0x1869b1 = true;
    if (
      this.surface.isMyself &&
      UI.userPreferences.getProperty("strokequality", "high") == "high"
    )
      _0x1869b1 = false;

    if (this.getOption("spacing") > 0) {
      this.distance += this.getDistance(
        _0x684ce0.x,
        _0x684ce0.y,
        _0x5c5254.x,
        _0x5c5254.y
      );
      if (
        this.distance >=
        this.getOption("size") * (this.getOption("spacing") / 15)
      ) {
        this.addClick(_0x5c5254.x, _0x5c5254.y);
        if (_0x1869b1) {
          this.contextSlate.moveTo(_0x5c5254.x, _0x5c5254.y);
          this.contextSlate.lineTo(_0x5c5254.x, _0x5c5254.y);
          this.contextSlate.stroke();
        }
        this.distance = 0;
      }
    } else {
      this.addClick(_0x5c5254.x, _0x5c5254.y);
      var _0x3373e7 = (_0x5c5254.x + _0x684ce0.x) / 2,
        _0x66c8f1 = (_0x5c5254.y + _0x684ce0.y) / 2;
      if (_0x1869b1) {
        this.contextSlate.beginPath();
        if (this.lastPosition)
          this.contextSlate.moveTo(
            this.lastPosition.x,
            this.lastPosition.y
          );
        else this.contextSlate.moveTo(_0x684ce0.x, _0x684ce0.y);
        this.contextSlate.quadraticCurveTo(
          _0x684ce0.x,
          _0x684ce0.y,
          _0x3373e7,
          _0x66c8f1
        );
        this.contextSlate.stroke();
      }
      this.lastPosition = new Point(_0x3373e7, _0x66c8f1);
    }
    if (
      this.surface.isMyself &&
      UI.userPreferences.getProperty("strokequality", "high") == "high"
    )
      this.redraw();
  }

  ["drawEnd"](_0x287f6c, _0x491ceb, _0x1cd8db) {
    if (!this.inStroke) return; // Safety check
    
    // Get brush size for final bounding box adjustment
    const brushSize = Math.max(this.getOption("size"), 1);
    
    // Final update to bounding box
    this.boundingBox.minX = Math.min(this.boundingBox.minX, _0x287f6c - brushSize);
    this.boundingBox.minY = Math.min(this.boundingBox.minY, _0x491ceb - brushSize);
    this.boundingBox.maxX = Math.max(this.boundingBox.maxX, _0x287f6c + brushSize);
    this.boundingBox.maxY = Math.max(this.boundingBox.maxY, _0x491ceb + brushSize);
    
    // Add last point if needed
    if (this.getOption("spacing") == 0) {
      this.addClick(_0x287f6c, _0x491ceb);
    }
    
    // Composite the stroke to the canvas
    this.composite();
  
    // After composite, capture new image data and push undo with bounding box
    if (this.oldData && this.surface.isMyself) {
      // Ensure bounding box values are integers and valid
      const bbox = [
        Math.max(0, Math.floor(this.boundingBox.minX)),
        Math.max(0, Math.floor(this.boundingBox.minY)),
        Math.min(room.board.canvasWidth - Math.floor(this.boundingBox.minX), 
               Math.ceil(this.boundingBox.maxX - this.boundingBox.minX)),
        Math.min(room.board.canvasHeight - Math.floor(this.boundingBox.minY), 
               Math.ceil(this.boundingBox.maxY - this.boundingBox.minY))
      ];
      
      // Add small padding to ensure we capture everything
      bbox[0] = Math.max(0, bbox[0] - 2);
      bbox[1] = Math.max(0, bbox[1] - 2);
      bbox[2] = Math.min(room.board.canvasWidth - bbox[0], bbox[2] + 4);
      bbox[3] = Math.min(room.board.canvasHeight - bbox[1], bbox[3] + 4);
      
      const ctx = room.board.getContext(this.strokeStartLayer);
      
      // Extract the same region from the old data
      const oldCanvas = document.createElement('canvas');
      oldCanvas.width = bbox[2];
      oldCanvas.height = bbox[3];
      const oldCtx = oldCanvas.getContext('2d');
      oldCtx.putImageData(this.oldData, -bbox[0], -bbox[1]);
      const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
      
      // Get the current data from the affected area
      const newData = ctx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
      
      // Push undo with bounded region data
      room.board.pushUndo({
        layer: this.strokeStartLayer,
        bbox: bbox,
        oldData: regionOldData,
        newData: newData
      });
    }
    
    // Reset stroke tracking
    this.inStroke = false;
    this.strokeStartLayer = null;
    this.oldData = null;
    this.boundingBox = null;
  }
  ["optionChange"](_0x5b4d99, _0x52b65e) {
    // If we're in a stroke, flag that we had option changes
    if (this.inStroke) {
      this.hasOptionChangesDuringStroke = true;
      
      // Track which specific options changed
      if (!this._lastOptionChanges) this._lastOptionChanges = {};
      this._lastOptionChanges[_0x5b4d99] = _0x52b65e;
    }
    
    // Rest of existing code...
    var _0x7b21d6 = this["clickX"]["length"];
    if (_0x7b21d6 > 0) {
      var _0xd27fd6 = new Point(this["clickX"][_0x7b21d6 - 1], this["clickY"][_0x7b21d6 - 1]);
      
      // Composite the stroke but DON'T push to undo stack yet
      // This is just visual feedback - undo will be handled in drawEnd
      this["composite"]();
      
      this.getOption("spacing") == 0 && this["addClick"](_0xd27fd6.x, _0xd27fd6.y);
      this.contextSlate["beginPath"]();
      this.contextSlate.moveTo(_0xd27fd6.x, _0xd27fd6.y);
    }
  }
  ["optionChanged"](_0xfe7535, _0x27c2b3) {
    this.setupSlate(), _0xfe7535 == "cursor" && this["surface"]["cursor"]["changePointer"](_0x27c2b3);
  }
  ["colorChange"](_0x5a726f) {
    // If we're in a stroke, flag that we had option changes
    if (this.inStroke) {
      this.hasOptionChangesDuringStroke = true;
    }
    
    // Rest of existing code...
    var _0x36f91b = this["clickX"]["length"];
    if (_0x36f91b > 0) {
      var _0x5df15a = new Point(this["clickX"][_0x36f91b - 1], this.clickY[_0x36f91b - 1]);
      this["composite"](), this.addClick(_0x5df15a.x, _0x5df15a.y);
    }
  }
  ["colorChanged"](_0x3b26d3) {
    this["setupSlate"]();
  }
  ["compositeSpacing"]() {
    var _0x1bf1dc = this["getOption"]("pressure")[0] ? this.getOption("pressure")[1] : 1,
    _0x4e4b96 = Math["max"](this["getOption"]("size") * _0x1bf1dc, 1);
    
    // Get user's chosen blend mode and transparency lock status
    const lockTransparency = this.getOption("locktransparency");
    
    // If pressure is ON and transparency is locked, use source-atop only
    // Otherwise use user's blend mode
    const isPressureEnabled = this["getOption"]("pressure")[0] || this.getOption("togglepressureopacity");
    const userBlendMode = this["getOption"]("blendmode") || "normal";
    const blendMode = (isPressureEnabled && lockTransparency) ? "source-atop" : userBlendMode;
    
    var _0x1e47ec = room["board"].getContext(this["surface"]["currentLayer"]);
    
    if (lockTransparency && !isPressureEnabled) {
      // Two-step process for locked transparency - only when pressure is OFF
      // ... [existing complex transparency lock implementation] ...
      
      // Step 1: Save the current canvas state
      const currentState = _0x1e47ec.getImageData(0, 0, _0x1e47ec.canvas.width, _0x1e47ec.canvas.height);
      
      // Apply the stroke with user's blend mode
      room["board"].layers[this.surface["currentLayer"]].advCanvas["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x4e4b96,
        strokestyle: this.surface.drawColor,
        alpha: this.getOption("alpha"),
        blendmode: userBlendMode,
        blur: this.getOption("blur"),
        linedash: []
      });
      
      // Draw the dots
      _0x1e47ec["beginPath"]();
      for (var _0x4d6eb4 = 0; _0x4d6eb4 < this["clickX"]["length"]; _0x4d6eb4++) {
        _0x1e47ec["moveTo"](this["clickX"][_0x4d6eb4], this["clickY"][_0x4d6eb4]), _0x1e47ec["lineTo"](this["clickX"][_0x4d6eb4], this["clickY"][_0x4d6eb4]);
      }
      _0x1e47ec["stroke"]();
      
      // Step 2: Get the result after drawing
      const newState = _0x1e47ec.getImageData(0, 0, _0x1e47ec.canvas.width, _0x1e47ec.canvas.height);
      
      // Step 3: Preserve original alpha values
      const resultData = newState.data;
      const originalData = currentState.data;
      
      for (let i = 0; i < resultData.length; i += 4) {
        // Preserve original transparency levels
        const originalAlpha = originalData[i + 3];
        const newAlpha = resultData[i + 3];
        
        // If a pixel was originally semitransparent, keep it semitransparent
        if (originalAlpha < 255) {
          resultData[i + 3] = Math.min(newAlpha, originalAlpha);
        }
      }
      
      // Update canvas with masked result
      _0x1e47ec.putImageData(newState, 0, 0);
      
    } else {
      // Standard drawing approach with conditional blend mode
      room["board"].layers[this.surface["currentLayer"]].advCanvas["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x4e4b96,
        strokestyle: this.surface.drawColor,
        alpha: this.getOption("alpha"),
        blendmode: blendMode,
        blur: this.getOption("blur"),
        linedash: []
      });
      
      _0x1e47ec["beginPath"]();
      for (var _0x4d6eb4 = 0; _0x4d6eb4 < this["clickX"]["length"]; _0x4d6eb4++) {
        _0x1e47ec["moveTo"](this["clickX"][_0x4d6eb4], this["clickY"][_0x4d6eb4]), _0x1e47ec["lineTo"](this["clickX"][_0x4d6eb4], this["clickY"][_0x4d6eb4]);
      }
      _0x1e47ec["stroke"]();
    }
  }
  
  ["compositeRegular"]() {
    var _0x1049b5 = this["getOption"]("pressure")[0] ? this["getOption"]("pressure")[1] : 1,
      _0x3945ba = Math["max"](this["getOption"]("size") * _0x1049b5, 1);
    
    // Get user's chosen blend mode and transparency lock status
    const lockTransparency = this.getOption("locktransparency");
    
    // If pressure is ON and transparency is locked, use source-atop only
    // Otherwise use user's blend mode
    const isPressureEnabled = this["getOption"]("pressure")[0] || this.getOption("togglepressureopacity");;
    const userBlendMode = this["getOption"]("blendmode") || "normal";
    const blendMode = (isPressureEnabled && lockTransparency) ? "source-atop" : userBlendMode;
    
    var _0x2061c5 = room["board"].getContext(this.surface["currentLayer"]);
    
    if (lockTransparency && !isPressureEnabled) {
      // Two-step process for locked transparency - only when pressure is OFF
      // ... [existing complex transparency lock implementation] ...
      
      // Step 1: Save the current canvas state
      const currentState = _0x2061c5.getImageData(0, 0, _0x2061c5.canvas.width, _0x2061c5.canvas.height);
      
      // Apply the stroke with normal blending
      room["board"]["layers"][this["surface"].currentLayer]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x3945ba,
        strokestyle: this.surface["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: userBlendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the stroke
      if (this["clickX"]["length"] < 6) {
        var _0x359e38 = new Point(this["clickX"][0], this["clickY"][0]);
        _0x2061c5["beginPath"](), _0x2061c5["moveTo"](this.clickX[0], this["clickY"][0]);
        for (var _0x1689cc = 1; _0x1689cc < this["clickX"]["length"]; _0x1689cc++) {
          _0x2061c5["lineTo"](this.clickX[_0x1689cc], this["clickY"][_0x1689cc]);
        }
      } else {
        _0x2061c5["beginPath"](), _0x2061c5["moveTo"](this.clickX[0], this["clickY"][0]);
        for (var _0x1689cc = 1; _0x1689cc < this.clickX["length"] - 2; _0x1689cc++) {
          var _0x20fd76 = (this["clickX"][_0x1689cc] + this["clickX"][_0x1689cc + 1]) / 2,
            _0xd09e9f = (this["clickY"][_0x1689cc] + this.clickY[_0x1689cc + 1]) / 2;
          _0x2061c5["quadraticCurveTo"](this["clickX"][_0x1689cc], this.clickY[_0x1689cc], _0x20fd76, _0xd09e9f);
        }
        _0x2061c5["quadraticCurveTo"](this["clickX"][_0x1689cc], this.clickY[_0x1689cc], this.clickX[_0x1689cc + 1], this["clickY"][_0x1689cc + 1]);
      }
      _0x2061c5["stroke"]();
      
      // Step 2: Get the result after drawing the stroke
      const newState = _0x2061c5.getImageData(0, 0, _0x2061c5.canvas.width, _0x2061c5.canvas.height);
      
      // Step 3: Preserve original alpha values instead of binary transparent/opaque
      const resultData = newState.data;
      const originalData = currentState.data;
      
      for (let i = 0; i < resultData.length; i += 4) {
        // Preserve the original alpha value - multiply by original alpha percentage
        const originalAlpha = originalData[i + 3];
        const newAlpha = resultData[i + 3];
        
        // If a pixel was originally semitransparent, keep it semitransparent
        // Calculate new alpha based on original alpha percentage
        if (originalAlpha < 255) {
          // Scale the new alpha by the original alpha percentage
          resultData[i + 3] = Math.min(newAlpha, originalAlpha);
        }
      }
      
      // Update canvas with masked result
      _0x2061c5.putImageData(newState, 0, 0);
      
    } else {
      // Standard drawing with conditional blend mode
      room["board"]["layers"][this["surface"].currentLayer]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round", 
        linewidth: _0x3945ba,
        strokestyle: this.surface["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: blendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the stroke
      if (this["clickX"]["length"] < 6) {
        var _0x359e38 = new Point(this["clickX"][0], this["clickY"][0]);
        _0x2061c5["beginPath"](), _0x2061c5["moveTo"](this.clickX[0], this["clickY"][0]);
        for (var _0x1689cc = 1; _0x1689cc < this["clickX"]["length"]; _0x1689cc++) {
          _0x2061c5["lineTo"](this.clickX[_0x1689cc], this["clickY"][_0x1689cc]);
        }
      } else {
        _0x2061c5["beginPath"](), _0x2061c5["moveTo"](this.clickX[0], this["clickY"][0]);
        for (var _0x1689cc = 1; _0x1689cc < this.clickX["length"] - 2; _0x1689cc++) {
          var _0x20fd76 = (this["clickX"][_0x1689cc] + this["clickX"][_0x1689cc + 1]) / 2,
            _0xd09e9f = (this["clickY"][_0x1689cc] + this.clickY[_0x1689cc + 1]) / 2;
          _0x2061c5["quadraticCurveTo"](this["clickX"][_0x1689cc], this.clickY[_0x1689cc], _0x20fd76, _0xd09e9f);
        }
        _0x2061c5["quadraticCurveTo"](this["clickX"][_0x1689cc], this.clickY[_0x1689cc], this.clickX[_0x1689cc + 1], this["clickY"][_0x1689cc + 1]);
      }
      _0x2061c5["stroke"]();
    }
  }
  
  ["compositeSmooth"]() {
    var _0x18f04c = this["getOption"]("pressure")[0] ? this.getOption("pressure")[1] : 1,
      _0x3f50f8 = Math["max"](this["getOption"]("size") * _0x18f04c, 1);
    
    // Get user's chosen blend mode and transparency lock status
    const lockTransparency = this.getOption("locktransparency");
    
    // If pressure is ON and transparency is locked, use source-atop only
    // Otherwise use user's blend mode
    const isPressureEnabled = this["getOption"]("pressure")[0] || this.getOption("togglepressureopacity");;
    const userBlendMode = this["getOption"]("blendmode") || "normal";
    const blendMode = (isPressureEnabled && lockTransparency) ? "source-atop" : userBlendMode;
    
    var _0x5efeb3 = room.board.getContext(this.surface["currentLayer"]);
    
    if (lockTransparency && !isPressureEnabled) {
      // Two-step process for locked transparency - only when pressure is OFF
      // ... [existing complex transparency lock implementation] ...
      
      // Step 1: Save the current canvas state
      const currentState = _0x5efeb3.getImageData(0, 0, _0x5efeb3.canvas.width, _0x5efeb3.canvas.height);
      
      // Apply the stroke with user's blend mode
      room["board"]["layers"][this["surface"]["currentLayer"]]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x3f50f8,
        strokestyle: this["surface"]["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: userBlendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the smooth path
      var _0x54b90d, _0xdb0823, _0x5d5462, _0x532223,
        _0x3dbf9d = parseInt(this["getOption"]("smooth") > this["clickX"].length / 3 ? this["clickX"].length / 3 : this.getOption("smooth") + 1);
      _0x5d5462 = null, _0x532223 = null;
      
      _0x5efeb3.beginPath(), _0x5efeb3.moveTo(this["clickX"][0], this["clickY"][0]);
      var _0x382947 = this.clickX["length"];
      for (var _0x544aed = _0x3dbf9d; _0x544aed < _0x382947; _0x544aed++) {
        _0x544aed % _0x3dbf9d == 0 && (_0x54b90d = new Point(this["clickX"][_0x544aed - _0x3dbf9d], this.clickY[_0x544aed - _0x3dbf9d]), _0xdb0823 = new Point(this["clickX"][_0x544aed], this["clickY"][_0x544aed]), _0x532223 = new Point(_0x54b90d.x + (_0xdb0823.x - _0x54b90d.x) / 2, _0x54b90d.y + (_0xdb0823.y - _0x54b90d.y) / 2), _0x5d5462 ? (_0x5efeb3["moveTo"](_0x5d5462.x, _0x5d5462.y), _0x5efeb3["quadraticCurveTo"](_0x54b90d.x, _0x54b90d.y, _0x532223.x, _0x532223.y)) : _0x5efeb3["lineTo"](_0x532223.x, _0x532223.y), _0x5d5462 = _0x532223), _0x544aed == _0x382947 - 1 && _0x5efeb3["lineTo"](this["clickX"][_0x544aed], this.clickY[_0x544aed]);
      }
      _0x5efeb3["stroke"]();
      
      // Step 2: Get the result after drawing
      const newState = _0x5efeb3.getImageData(0, 0, _0x5efeb3.canvas.width, _0x5efeb3.canvas.height);
      
      // Step 3: Preserve original alpha values
      const resultData = newState.data;
      const originalData = currentState.data;
      
      for (let i = 0; i < resultData.length; i += 4) {
        // Preserve original transparency levels
        const originalAlpha = originalData[i + 3];
        const newAlpha = resultData[i + 3];
        
        // If a pixel was originally semitransparent, keep it semitransparent
        if (originalAlpha < 255) {
          resultData[i + 3] = Math.min(newAlpha, originalAlpha);
        }
      }
      
      // Update canvas with masked result
      _0x5efeb3.putImageData(newState, 0, 0);
    
    } else {
      // Standard drawing with conditional blend mode
      room["board"]["layers"][this["surface"]["currentLayer"]]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x3f50f8,
        strokestyle: this["surface"]["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: blendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the smooth path
      var _0x54b90d, _0xdb0823, _0x5d5462, _0x532223,
        _0x3dbf9d = parseInt(this["getOption"]("smooth") > this["clickX"].length / 3 ? this["clickX"].length / 3 : this.getOption("smooth") + 1);
      _0x5d5462 = null, _0x532223 = null;
      
      _0x5efeb3.beginPath(), _0x5efeb3.moveTo(this["clickX"][0], this["clickY"][0]);
      var _0x382947 = this.clickX["length"];
      for (var _0x544aed = _0x3dbf9d; _0x544aed < _0x382947; _0x544aed++) {
        _0x544aed % _0x3dbf9d == 0 && (_0x54b90d = new Point(this["clickX"][_0x544aed - _0x3dbf9d], this.clickY[_0x544aed - _0x3dbf9d]), _0xdb0823 = new Point(this["clickX"][_0x544aed], this["clickY"][_0x544aed]), _0x532223 = new Point(_0x54b90d.x + (_0xdb0823.x - _0x54b90d.x) / 2, _0x54b90d.y + (_0xdb0823.y - _0x54b90d.y) / 2), _0x5d5462 ? (_0x5efeb3["moveTo"](_0x5d5462.x, _0x5d5462.y), _0x5efeb3["quadraticCurveTo"](_0x54b90d.x, _0x54b90d.y, _0x532223.x, _0x532223.y)) : _0x5efeb3["lineTo"](_0x532223.x, _0x532223.y), _0x5d5462 = _0x532223), _0x544aed == _0x382947 - 1 && _0x5efeb3["lineTo"](this["clickX"][_0x544aed], this.clickY[_0x544aed]);
      }
      _0x5efeb3["stroke"]();
    }
  }
  ["composite"]() {
    if (this["getOption"]("spacing") > 0) this["compositeSpacing"](); else this["getOption"]("smooth") > 0 && this["clickX"]["length"] >= 3 ? this["compositeSmooth"]() : this["compositeRegular"]();
    this["clearSlate"](), this["removeClicks"]();
  }
  ["addClick"](_0x236c0e, _0x94363a) {
    this["clickX"]["push"](_0x236c0e), this["clickY"].push(_0x94363a);
  }
  ["removeClicks"]() {
    this["clickX"] = new Array(), this["clickY"] = new Array();
  }
  ["setupSlate"]() {
    var _0x5d2d36 = this["getOption"]("pressure")[0] ? this.getOption("pressure")[1] : 1,
      _0x1fa2f1 = Math["max"](this["getOption"]("size") * _0x5d2d36, 1);
    
    this.surface["slate"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: _0x1fa2f1,
      strokestyle: this["surface"]["drawColor"],
      alpha: 1,
      blendmode: "normal",
      blur: 0,
      linedash: []
    });
    
    // For the CSS preview, we don't want to change the blend mode - just set alpha
    // This prevents the cursor preview from looking incorrect
    this["surface"]["slate"]["setCSSProperties"]({
      alpha: this["getOption"]("alpha"),
      blendmode: this.getOption("blendmode") || "normal",
      blur: this.getOption("blur")
    });
  }
  ["clearSlate"]() {
    this["contextSlate"]["clearRect"](0, 0, this.contextSlate["canvas"]["width"], this["contextSlate"]["canvas"]["height"]);
  }
// Fixed BrushPen cancel method - only push to undo if options changed AFTER pen movement
["cancel"]() {
  // Check if we're in the middle of a stroke
  if (this.inStroke && this.surface.isMyself) {
    
    // Has the pen actually moved AND were there option changes AFTER movement?
    const hasPenMovement = this.hasMadeFirstMove === true;
    
    // Only create undo if options changed AFTER pen movement began
    const shouldCreateUndo = hasPenMovement && 
                            this.hasOptionChangesDuringStroke === true && 
                            this.oldData && 
                            this.boundingBox;
    
    if (shouldCreateUndo) {
      
      // [undo creation code remains the same]
      const bbox = [
        Math.max(0, Math.floor(this.boundingBox.minX)),
        Math.max(0, Math.floor(this.boundingBox.minY)),
        Math.min(room.board.canvasWidth - Math.floor(this.boundingBox.minX), 
               Math.ceil(this.boundingBox.maxX - this.boundingBox.minX)),
        Math.min(room.board.canvasHeight - Math.floor(this.boundingBox.minY), 
               Math.ceil(this.boundingBox.maxY - this.boundingBox.minY))
      ];
      
      // Add small padding
      bbox[0] = Math.max(0, bbox[0] - 2);
      bbox[1] = Math.max(0, bbox[1] - 2);
      bbox[2] = Math.min(room.board.canvasWidth - bbox[0], bbox[2] + 4);
      bbox[3] = Math.min(room.board.canvasHeight - bbox[1], bbox[3] + 4);
      
      // Extract regions and create undo entry
      const ctx = room.board.getContext(this.strokeStartLayer);
      
      const oldCanvas = document.createElement('canvas');
      oldCanvas.width = bbox[2];
      oldCanvas.height = bbox[3];
      const oldCtx = oldCanvas.getContext('2d');
      oldCtx.putImageData(this.oldData, -bbox[0], -bbox[1]);
      const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
      
      const newData = ctx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
      
      room.board.pushUndo({
        layer: this.strokeStartLayer,
        bbox: bbox,
        oldData: regionOldData,
        newData: newData,
        partialStroke: true
      });
    } else {
    }
    
    // Reset all state tracking
    this.inStroke = false;
    this.strokeStartLayer = null;
    this.oldData = null;
    this.boundingBox = null;
    this.hasOptionChangesDuringStroke = false;
    this._lastOptionChanges = null;
    this.hasMadeFirstMove = false;
  }
  
  // Always clear the slate and remove clicks
  this.clearSlate();
  this.removeClicks();
}
  ["getSync"]() {
    var _0x507502 = {};
    return _0x507502["clickX"] = this["clickX"], _0x507502["clickY"] = this["clickY"], _0x507502;
  }
  ["setSync"](_0x505594) {
    if (_0x505594["clickX"]["length"] > 0) {
      this.drawStart(_0x505594["clickX"][0], _0x505594["clickY"][0], this["surface"]["drawColor"]);
      for (var _0x48fedf = 1; _0x48fedf < _0x505594.clickX.length; _0x48fedf++) {
        this["drawStep"](new Point(_0x505594["clickX"][_0x48fedf - 1], _0x505594["clickY"][_0x48fedf - 1]), new Point(_0x505594["clickX"][_0x48fedf], _0x505594["clickY"][_0x48fedf]), this["surface"]["drawColor"]);
      }
    }
  }
  ["redraw"]() {
    this["clearSlate"](), this["setupSlate"]();
    var _0x25fa00 = this["contextSlate"];
    if (this["getOption"]("spacing") > 0) {
      _0x25fa00.beginPath();
      for (var _0x428151 = 0; _0x428151 < this["clickX"]["length"]; _0x428151++) {
        _0x25fa00["moveTo"](this["clickX"][_0x428151], this["clickY"][_0x428151]), _0x25fa00.lineTo(this["clickX"][_0x428151], this.clickY[_0x428151]);
      }
      _0x25fa00["stroke"]();
    } else {
      if (this["clickX"]["length"] < 6) {
        var _0x18b766 = new Point(this.clickX[0], this["clickY"][0]);
        _0x25fa00["beginPath"](), _0x25fa00["moveTo"](this["clickX"][0], this["clickY"][0]);
        for (var _0x428151 = 1; _0x428151 < this.clickX["length"]; _0x428151++) {
          _0x25fa00["lineTo"](this["clickX"][_0x428151], this["clickY"][_0x428151]);
        }
      } else {
        _0x25fa00["beginPath"](), _0x25fa00["moveTo"](this["clickX"][0], this["clickY"][0]);
        for (var _0x428151 = 1; _0x428151 < this["clickX"]["length"] - 2; _0x428151++) {
          var _0xc4585 = (this["clickX"][_0x428151] + this["clickX"][_0x428151 + 1]) / 2,
            _0x2f86bf = (this["clickY"][_0x428151] + this["clickY"][_0x428151 + 1]) / 2;
          _0x25fa00["quadraticCurveTo"](this.clickX[_0x428151], this["clickY"][_0x428151], _0xc4585, _0x2f86bf);
        }
        _0x25fa00["quadraticCurveTo"](this.clickX[_0x428151], this.clickY[_0x428151], this["clickX"][_0x428151 + 1], this["clickY"][_0x428151 + 1]);
      }
      _0x25fa00.stroke();
    }
  }
}

const mirroredText = localStorage.getItem('mirroredText') === 'true';
class BrushTextModded extends BrushStub {
  constructor(_0x4da651) {
    super(_0x4da651);
    this.textfield;
    this["enabled"] = false;
    this["options"] = {};
    this["options"].size = new SizeOption();
    this["options"]["alpha"] = new AlphaOption();
    this.options["font"] = new FontOption();
    this.options["rightclick"] = new RightClickOption("text");
    this.options["locktransparency"] = new LockTransparencyOption(); // Add lock transparency option
    this["posX"];
    this.posY;
    this["maxLength"] = 200;
    this["minSize"] = 8;
    this["defaultSize"] = 6;
    this["textCursor"] = "<i>|</i>";
    this["disabledCursor"] = "";
    
    // Mirror functionality conditional setup
    if (mirroredText) {
      this.mirroredFeatureEnabled = true;
      this.startFlipXCheck();
    }
  }
  
  startFlipXCheck() {
    if (!mirroredText) return;
    
    this.flipXInterval = setInterval(() => {
      if (typeof UI !== "undefined" && UI.flipX === false) {
        this.mirroredFeatureEnabled = false;
        if (this.mirroredField) this.mirroredField.hide();
      } else {
        this.mirroredFeatureEnabled = true;
        if (this.mirroredField) this.mirroredField.show();
      }
    }, 100);
  }
  
  stopFlipXCheck() {
    if (this.flipXInterval) clearInterval(this.flipXInterval);
  }
  
  ["brushStart"]() {
    this["disabledCursor"] = "<span class=\"disabledCursor\">" + textManager["getString"]("global.lblClickOrEnterToChat", null, false) + "</span>";
    this["surface"]["cursor"]["changePointer"]("invisible");
    this.textfield = $("<div />");
    this["textfield"]["addClass"]("textfield");
    this.textfield["css"]({
      color: this.surface.drawColor,
      opacity: this["getOption"]("alpha"),
      "font-family": '"' + this["getOption"]("font") + '"'
    });

    if (mirroredText) {
      this.mirroredField = $("<div />").addClass("mirroredField");
      this.mirroredField.css({
        color: this.surface.drawColor,
        opacity: this["getOption"]("alpha"),
        "font-family": '"' + this["getOption"]("font") + '"',
        transform: "scaleX(-1)",
        "text-align": "right",
        position: "absolute",
        bottom: "calc(100% + 10px)",
        left: 0,
        width: "100%"
      });
      this.surface.cursor.graphic.append(this.mirroredField);
      
      if (!this.mirroredFeatureEnabled) this.mirroredField.hide();
    }
    
    this.changeSize(this["getOption"]("size"));
    this.disable();
    this["surface"]["cursor"]["graphic"].append(this["textfield"]);
    this["surface"].slate["setCSSProperties"]({
      alpha: this["getOption"]("alpha"),
      blendmode: "normal",
      blur: 0
    });
    this.textfield["hide"]();
    this["positionText"]();
    this["textfield"]["fadeIn"](500);
  }
  
  ["brushStop"]() {
    this.textfield.remove();
    if (mirroredText && this.mirroredField) this.mirroredField.remove();
  }
  
  ["setText"](_0x4d3d04, _0x1016bf = true) {
    if (_0x1016bf) {
      this["textfield"]["html"](_0x4d3d04);
      if (mirroredText && this.mirroredField && this.mirroredFeatureEnabled) 
        this.mirroredField.html(_0x4d3d04);
    } else {
      this["textfield"]["text"](_0x4d3d04);
      if (mirroredText && this.mirroredField && this.mirroredFeatureEnabled) 
        this.mirroredField.text(_0x4d3d04);
    }
  }
  
  ["positionText"]() {
    if (this["textfield"]) {
      var _0x34c1fe = this["surface"]["cursor"]["label"],
        _0x45603d = Number(_0x34c1fe.css("top")["replace"]("px", "")),
        _0x7961ae = Number(_0x34c1fe.css("left").replace("px", "")),
        _0x5496b7 = _0x34c1fe["height"]();
      
      this["textfield"]["css"]({
        top: _0x45603d + _0x5496b7 + "px",
        left: _0x7961ae + "px"
      });
      
      if (mirroredText && this.mirroredField) {
        if (this.mirroredFeatureEnabled) {
          this.mirroredField.css({
            top: _0x45603d - _0x5496b7 - 10 + "px",
            left: _0x7961ae + "px"
          }).show();
        } else {
          this.mirroredField.hide();
        }
      }
    }
  }
  
  destroy() {
    if (mirroredText) this.stopFlipXCheck();
  }

  // All other methods remain the same
  ["drawEnd"](_0x142ad6, _0x4b7c13, _0x37267c) {
    var _0x4f9747 = this["getPlainText"]();
    if (_0x4f9747 != "" && this["enabled"]) {
      var _0x4558f8 = this["surface"]["cursor"]["labelOffset"];
      this["posX"] = _0x142ad6 + _0x4558f8.x, this["posY"] = _0x4b7c13 + _0x4558f8.y + this.surface["cursor"]["label"]["height"]();
      
      // Capture state before rendering text (if we didn't already in drawStart)
      if (this.surface.isMyself && !this.textStarted) {
        this.textStarted = true;
        this.textLayer = this.surface.currentLayer;
        
        // Estimate text dimensions for the bounding box
        const fontSize = this.getOption("size") + this.minSize;
        const ctx = room.board.getContext(this.textLayer);
        ctx.font = fontSize + "px \"" + this.getOption("font") + "\"";
        const metrics = ctx.measureText(_0x4f9747);
        
        // Create bounding box with padding
        const padding = fontSize;
        this.textBBox = {
          minX: Math.max(0, this.posX - padding),
          minY: Math.max(0, this.posY - padding),
          maxX: Math.min(ctx.canvas.width, this.posX + metrics.width + padding),
          maxY: Math.min(ctx.canvas.height, this.posY + fontSize + padding)
        };
        
        // Get the region for undo
        const bbox = [
          Math.floor(this.textBBox.minX),
          Math.floor(this.textBBox.minY),
          Math.ceil(this.textBBox.maxX - this.textBBox.minX),
          Math.ceil(this.textBBox.maxY - this.textBBox.minY)
        ];
        
        this.oldData = ctx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
        this.textBBoxArray = bbox;
      }
      
      // Render the text
      this["composite"]();
      this["setText"](this.textCursor);
      
      // Push to undo stack after rendering
      if (this.surface.isMyself && this.oldData && this.textBBoxArray) {
        const ctx = room.board.getContext(this.textLayer);
        
        // Get the new state after text rendering
        const newData = ctx.getImageData(
          this.textBBoxArray[0], 
          this.textBBoxArray[1], 
          this.textBBoxArray[2], 
          this.textBBoxArray[3]
        );
        
        // Push to undo stack
        room.board.pushUndo({
          layer: this.textLayer,
          bbox: this.textBBoxArray,
          oldData: this.oldData,
          newData: newData
        });
        
        // Reset state variables
        this.textStarted = false;
        this.oldData = null;
        this.textLayer = null;
        this.textBBox = null;
        this.textBBoxArray = null;
      }
    } else this.toggle();
  }
  
  ["colorChange"](_0x4a3609) {
    this.textfield["css"]("color", _0x4a3609);
  }
  
  ["optionChange"](_0x380535, _0x193c93) {
    if (_0x380535 == "size") this["enabled"] && this["changeSize"](_0x193c93), this.positionText(); else {
      if (_0x380535 == "alpha") this.enabled && this["textfield"] && this.textfield["css"]("opacity", _0x193c93); else _0x380535 == "font" && this["textfield"] && this.textfield["css"]("font-family", '"' + _0x193c93 + '"');
    }
  }
  
  ["onModifierDown"](_0x28b0a3) {
    if (_0x28b0a3 == 13) this["enabled"] ? this["isEmpty"]() ? this.disable() : this["setText"](this["textCursor"]) : this["enable"](); else _0x28b0a3 == 32 && this.onKeyPress(32);
  }
  
  ["getCurrentLength"]() {
    return $("<textarea/>").html(this["removeTextCursor"](this["getText"]())).text()["length"];
  }
  
  ["onKeyPress"](_0x261405) {
    if (this.enabled) {
      if (_0x261405 >= 8) {
        var _0x17efa1 = $("<textarea/>").html(this.removeTextCursor(this["getText"]())).text();
        if (_0x261405 == 8) this["setText"](_0x17efa1["substring"](0, _0x17efa1.length - 1), false); else {
          if (_0x261405 >= 32) {
            if (_0x261405 == 32) {
              var _0x59a21d = _0x17efa1[_0x17efa1["length"] - 1];
              _0x59a21d == " " && (_0x261405 = 0);
            }
            _0x17efa1["length"] < this["maxLength"] && _0x261405 > 0 && String.fromCharCode(_0x261405) != "" && this.setText(_0x17efa1 + String["fromCharCode"](_0x261405), false);
          } else this.setText(_0x17efa1, false);
        }
        this.enabled && _0x17efa1.length <= this["maxLength"] && _0x261405 > 0 && this["textfield"].append(this["textCursor"]), this.positionText();
      }
    }
  }
  
  ["getText"]() {
    return this["textfield"]["html"]();
  }
  
  ["getPlainText"]() {
    return this["removeTextCursor"](this.textfield["html"]());
  }
  
  ["isEmpty"]() {
    return this["getPlainText"]() == "";
  }
  
  ["getSync"]() {
    var _0x15a052 = {};
    return _0x15a052.enabled = this.enabled, _0x15a052.enabled && (_0x15a052["text"] = this["getPlainText"]()), _0x15a052;
  }
  
  ["setSync"](_0x153c15) {
    _0x153c15["enabled"] && (this["enable"](), _0x153c15["text"] != "" && (this["setText"](_0x153c15["text"], false), this["textfield"]["append"](this["textCursor"]))), this.positionText();
  }
  
  ["cancel"]() {
    this["enabled"] && this["setText"](this["textCursor"]);
    
    // Reset undo state if canceling
    this.textStarted = false;
    this.oldData = null;
    this.textLayer = null;
    this.textBBox = null;
    this.textBBoxArray = null;
  }
  
  ["removeTextCursor"](_0x1a982c) {
    return _0x1a982c.substring(0, _0x1a982c["length"] - this["textCursor"]["length"]);
  }
  
  ["composite"]() {
    // Get user's chosen transparency lock status
    const lockTransparency = this.getOption("locktransparency");
    const userBlendMode = "normal"; // Text only uses normal blend mode
    
    // Get the canvas context
    var _0x48f9e6 = room["board"].getContext(this.surface["currentLayer"]);
    
    if (lockTransparency) {
      // Two-step process for locked transparency
      
      // Step 1: Save the current canvas state
      const currentState = _0x48f9e6.getImageData(0, 0, _0x48f9e6.canvas.width, _0x48f9e6.canvas.height);
      
      // Apply the text with normal blending
      room["board"]["layers"][this["surface"]["currentLayer"]].advCanvas["setCanvasProperties"]({
        font: this["getOption"]("size") + this["minSize"] + "px \"" + this.getOption("font") + '"',
        strokestyle: this["surface"]["drawColor"],
        fillstyle: this["surface"]["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: userBlendMode,
        blur: 0,
        linedash: [],
        textBaseline: "top"
      });
      
      // Get plain text without HTML tags
      const plainText = $("<textarea/>").html(this.getPlainText()).text();
      
      // Draw text
      _0x48f9e6.fillText(plainText, this["posX"], this["posY"]);
      
      // Step 2: Get the result after drawing the text
      const newState = _0x48f9e6.getImageData(0, 0, _0x48f9e6.canvas.width, _0x48f9e6.canvas.height);
      
      // Step 3: Preserve original alpha values
      const resultData = newState.data;
      const originalData = currentState.data;
      
      for (let i = 0; i < resultData.length; i += 4) {
        // Preserve original transparency levels
        const originalAlpha = originalData[i + 3];
        const newAlpha = resultData[i + 3];
        
        // If a pixel was originally semitransparent, keep it semitransparent
        if (originalAlpha < 255) {
          resultData[i + 3] = Math.min(newAlpha, originalAlpha);
        }
      }
      
      // Update canvas with masked result
      _0x48f9e6.putImageData(newState, 0, 0);
      
    } else {
      // Standard text rendering
      room["board"]["layers"][this["surface"]["currentLayer"]].advCanvas["setCanvasProperties"]({
        font: this["getOption"]("size") + this["minSize"] + "px \"" + this.getOption("font") + '"',
        strokestyle: this["surface"]["drawColor"],
        fillstyle: this["surface"]["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: userBlendMode,
        blur: 0,
        linedash: [],
        textBaseline: "top"
      });
      
      // Get plain text without HTML tags
      const plainText = $("<textarea/>").html(this.getPlainText()).text();
      
      // Draw text
      _0x48f9e6.fillText(plainText, this["posX"], this["posY"]);
    }
  }
  
  ["enable"]() {
    this["enabled"] = true, this["changeSize"](this["getOption"]("size")), this["textfield"]["css"]("opacity", this.getOption("alpha")), this["setText"](this.textCursor);
  }
  
  ["disable"]() {
    this["enabled"] = false, this["changeSize"](this["defaultSize"]), this["textfield"]["css"]("opacity", 1), this["setText"](this["disabledCursor"]);
  }
  
  ["changeSize"](_0xa4a966) {
    this.textfield && this["textfield"]["css"]({
      "font-size": _0xa4a966 + this["minSize"] + "px",
      "line-height": _0xa4a966 + this["minSize"] + "px"
    });
  }
  
  ["toggle"]() {
    this.enabled ? this["disable"]() : this["enable"]();
  }
};

class BrushRectModded extends BrushStub {
  constructor(_0x43dfb9) {
    super(_0x43dfb9);
    this["options"] = {};
    this["options"]["size"] = new SizeOption();
    this["options"]["alpha"] = new AlphaOption();
    this["options"].blur = new BlurOption();
    this["options"]["blendmode"] = new BlendModeOption();
    this["options"]["fill"] = new FillOption();
    this["options"]["aspectratio"] = new AspectRatioOption();
    this["options"]["rightclick"] = new RightClickOption("rect");
    this["options"]["cursor"] = new CursorOption("circle");
    this.options["locktransparency"] = new LockTransparencyOption(); // Add Lock Transparency option
    this["start"];
    this["end"];
    
    // Add tracking variables for undo support
    this.inStroke = false;
    this.oldData = null;
    this.rectBBox = null;
  }
  
  ["brushStart"]() {
    this["surface"]["cursor"].changePointer(this["getOption"]("cursor"));
  }
  
  ["drawStart"](_0x148eaa, _0x756cf7, _0x294274) {
    // Start tracking the stroke for undo support
    this.inStroke = true;
    
    // Always use normal blending for preview so it remains visible
    this["surface"]["slate"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: this["getOption"]("size"),
      strokestyle: _0x294274,
      fillstyle: _0x294274,
      alpha: 1,
      blendmode: "normal", // Always use normal for preview visibility
      blur: 0,
      linedash: []
    });
    
    this.surface["slate"].setCSSProperties({
      alpha: this["getOption"]("alpha"),
      blendmode: this["getOption"]("blendmode") || "normal",
      blur: this["getOption"]("blur")
    });
    
    this.start = new Point(_0x148eaa, _0x756cf7);
    
    // Initialize the bounding box for the rectangle
    const brushSize = Math.max(this.getOption("size"), 1);
    this.rectBBox = {
      minX: _0x148eaa - brushSize,
      minY: _0x756cf7 - brushSize,
      maxX: _0x148eaa + brushSize,
      maxY: _0x756cf7 + brushSize
    };
    
    // If this is the local user, store the canvas state for undo
    if (this.surface.isMyself) {
      const ctx = room.board.getContext(this.surface.currentLayer);
      this.oldData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    }
  }
  
  ["drawStep"](_0x5324ee, _0x193eaa, _0x52fb23) {
    // Update bounding box based on current rectangle shape
    if (this.rectBBox) {
      const brushSize = Math.max(this.getOption("size"), 1);
      
      // Calculate the rectangle dimensions
      let rectX, rectY, rectWidth, rectHeight;
      
      if (this.getOption("aspectratio")) {
        // For square (equal aspect ratio)
        const size = this.getMinDistance(_0x193eaa.x - this.start.x, _0x193eaa.y - this.start.y);
        const dirX = _0x193eaa.x - this.start.x > 0 ? 1 : -1;
        const dirY = _0x193eaa.y - this.start.y > 0 ? 1 : -1;
        
        rectX = this.start.x;
        rectY = this.start.y;
        rectWidth = size * dirX;
        rectHeight = size * dirY;
      } else {
        // For regular rectangle
        rectX = this.start.x;
        rectY = this.start.y;
        rectWidth = _0x193eaa.x - this.start.x;
        rectHeight = _0x193eaa.y - this.start.y;
      }
      
      // Calculate the bounds of the rectangle (accounting for negative dimensions)
      const left = Math.min(rectX, rectX + rectWidth);
      const top = Math.min(rectY, rectY + rectHeight);
      const right = Math.max(rectX, rectX + rectWidth);
      const bottom = Math.max(rectY, rectY + rectHeight);
      
      // Update the bounding box
      this.rectBBox.minX = Math.min(this.rectBBox.minX, left - brushSize);
      this.rectBBox.minY = Math.min(this.rectBBox.minY, top - brushSize);
      this.rectBBox.maxX = Math.max(this.rectBBox.maxX, right + brushSize);
      this.rectBBox.maxY = Math.max(this.rectBBox.maxY, bottom + brushSize);
    }
    
    this["redraw"](this.start, _0x193eaa, _0x52fb23), this["end"] = _0x193eaa;
  }
  
  ["drawEnd"](_0x10378e, _0x4a317b, _0x109fef) {
    if (!this.inStroke) return; // Safety check
    
    // Update final bounding box
    this.drawStep(null, new Point(_0x10378e, _0x4a317b), _0x109fef);
    
    this["end"] = new Point(_0x10378e, _0x4a317b), this.composite();
  }
  
  ["redraw"](_0x1a360f, _0x1bc83b, _0x32381f) {
    this["clearSlate"]();
    if (this.getOption("aspectratio")) {
      var _0x264a01 = this["getMinDistance"](_0x1bc83b.x - _0x1a360f.x, _0x1bc83b.y - _0x1a360f.y),
        _0x21f9a5 = _0x1bc83b.x - _0x1a360f.x > 0 ? 1 : -1,
        _0x3479dc = _0x1bc83b.y - _0x1a360f.y > 0 ? 1 : -1;
      this["getOption"]("fill") ? this["contextSlate"]["fillRect"](_0x1a360f.x, _0x1a360f.y, _0x264a01 * _0x21f9a5, _0x264a01 * _0x3479dc) : this["contextSlate"]["strokeRect"](_0x1a360f.x, _0x1a360f.y, _0x264a01 * _0x21f9a5, _0x264a01 * _0x3479dc);
    } else this["getOption"]("fill") ? this["contextSlate"].fillRect(_0x1a360f.x, _0x1a360f.y, _0x1bc83b.x - _0x1a360f.x, _0x1bc83b.y - _0x1a360f.y) : this["contextSlate"]["strokeRect"](_0x1a360f.x, _0x1a360f.y, _0x1bc83b.x - _0x1a360f.x, _0x1bc83b.y - _0x1a360f.y);
  }
  
  ["getMinDistance"](_0x34b68a, _0x374146) {
    return _0x34b68a = _0x34b68a < 0 ? -_0x34b68a : _0x34b68a, _0x374146 = _0x374146 < 0 ? -_0x374146 : _0x374146, Math.min(_0x34b68a, _0x374146);
  }
  
  ["composite"]() {
    // Get user's blend mode and transparency lock status
    const userBlendMode = this.getOption("blendmode") || "normal";
    const lockTransparency = this.getOption("locktransparency");
    
    var _0x397440 = room["board"].getContext(this["surface"].currentLayer);
    
    if (lockTransparency) {
      // Two-step process for locked transparency
      
      // Step 1: Save the current canvas state
      const currentState = _0x397440.getImageData(0, 0, _0x397440.canvas.width, _0x397440.canvas.height);
      
      // Apply the rectangle with user's blend mode
      room["board"]["layers"][this["surface"]["currentLayer"]]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: this["getOption"]("size"),
        strokestyle: this["surface"].drawColor,
        fillstyle: this["surface"]["drawColor"],
        alpha: this.getOption("alpha"),
        blendmode: userBlendMode,
        blur: this.getOption("blur"),
        linedash: []
      });
      
      // Draw the rectangle
      let rectX, rectY, rectWidth, rectHeight;
      
      if (this.getOption("aspectratio")) {
        var _0x23592a = this.getMinDistance(this["end"].x - this["start"].x, this["end"].y - this["start"].y),
          _0x440046 = this["end"].x - this.start.x > 0 ? 1 : -1,
          _0x21b617 = this["end"].y - this["start"].y > 0 ? 1 : -1;
        
        rectX = this.start.x;
        rectY = this.start.y;
        rectWidth = _0x23592a * _0x440046;
        rectHeight = _0x23592a * _0x21b617;
        
        this["getOption"]("fill") ? 
          _0x397440["fillRect"](rectX, rectY, rectWidth, rectHeight) : 
          _0x397440["strokeRect"](rectX, rectY, rectWidth, rectHeight);
      } else {
        rectX = this.start.x;
        rectY = this.start.y;
        rectWidth = this["end"].x - this["start"].x;
        rectHeight = this["end"].y - this.start.y;
        
        this["getOption"]("fill") ? 
          _0x397440["fillRect"](rectX, rectY, rectWidth, rectHeight) : 
          _0x397440["strokeRect"](rectX, rectY, rectWidth, rectHeight);
      }
      
      // Step 2: Get the result after drawing
      const newState = _0x397440.getImageData(0, 0, _0x397440.canvas.width, _0x397440.canvas.height);
      
      // Step 3: Preserve original alpha values
      const resultData = newState.data;
      const originalData = currentState.data;
      
      for (let i = 0; i < resultData.length; i += 4) {
        // Preserve original transparency levels
        const originalAlpha = originalData[i + 3];
        const newAlpha = resultData[i + 3];
        
        // If a pixel was originally semitransparent, keep it semitransparent
        if (originalAlpha < 255) {
          resultData[i + 3] = Math.min(newAlpha, originalAlpha);
        }
      }
      
      // Update canvas with masked result
      _0x397440.putImageData(newState, 0, 0);
      
    } else {
      // Standard drawing with user's blend mode
      room["board"]["layers"][this["surface"]["currentLayer"]]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: this["getOption"]("size"),
        strokestyle: this["surface"].drawColor,
        fillstyle: this["surface"]["drawColor"],
        alpha: this.getOption("alpha"),
        blendmode: userBlendMode,
        blur: this.getOption("blur"),
        linedash: []
      });
      
      // Draw the rectangle
      if (this.getOption("aspectratio")) {
        var _0x23592a = this.getMinDistance(this["end"].x - this["start"].x, this["end"].y - this["start"].y),
          _0x440046 = this["end"].x - this.start.x > 0 ? 1 : -1,
          _0x21b617 = this["end"].y - this["start"].y > 0 ? 1 : -1;
        
        this["getOption"]("fill") ? 
          _0x397440["fillRect"](this.start.x, this.start.y, _0x23592a * _0x440046, _0x23592a * _0x21b617) : 
          _0x397440["strokeRect"](this.start.x, this.start.y, _0x23592a * _0x440046, _0x23592a * _0x21b617);
      } else {
        this["getOption"]("fill") ? 
          _0x397440["fillRect"](this.start.x, this.start.y, this["end"].x - this["start"].x, this["end"].y - this.start.y) : 
          _0x397440["strokeRect"](this.start.x, this.start.y, this["end"].x - this["start"].x, this["end"].y - this.start.y);
      }
    }
    
    // After drawing, save the action for undo if this is the local user
    if (this.surface.isMyself && this.oldData && this.rectBBox) {
      // Create a valid bounding box from our tracked min/max values
      const bbox = [
        Math.max(0, Math.floor(this.rectBBox.minX)),
        Math.max(0, Math.floor(this.rectBBox.minY)),
        Math.min(room.board.canvasWidth, Math.ceil(this.rectBBox.maxX - this.rectBBox.minX)),
        Math.min(room.board.canvasHeight, Math.ceil(this.rectBBox.maxY - this.rectBBox.minY))
      ];
      
      // Expand slightly to ensure we capture all affected pixels
      bbox[0] = Math.max(0, bbox[0] - 2);
      bbox[1] = Math.max(0, bbox[1] - 2);
      bbox[2] = Math.min(room.board.canvasWidth - bbox[0], bbox[2] + 4);
      bbox[3] = Math.min(room.board.canvasHeight - bbox[1], bbox[3] + 4);
      
      // Get the new state of the affected area
      const newData = _0x397440.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
      
      // Extract the same region from the old data
      const oldCanvas = document.createElement('canvas');
      oldCanvas.width = bbox[2];
      oldCanvas.height = bbox[3];
      const oldCtx = oldCanvas.getContext('2d');
      oldCtx.putImageData(this.oldData, -bbox[0], -bbox[1]);
      const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
      
      // Push the undo action
      room.board.pushUndo({
        layer: this.surface.currentLayer,
        bbox: bbox,
        oldData: regionOldData,
        newData: newData,
        actionType: 'rect'
      });
    }
    
    // Clean up
    this["clearSlate"]();
    this["start"] = null;
    this.end = null;
    this.inStroke = false;
    this.oldData = null;
    this.rectBBox = null;
  }

  ["clearSlate"]() {
    this["contextSlate"]["clearRect"](0, 0, this["contextSlate"]["canvas"]["width"], this["contextSlate"].canvas["height"]);
  }
  
  ["getSync"]() {
    var _0x5ddcc2 = {};
    return _0x5ddcc2["start"] = this.start, _0x5ddcc2;
  }
  
  ["setSync"](_0x5960d3) {
    this["drawStart"](_0x5960d3.start.x, _0x5960d3["start"].y, this["surface"].drawColor);
  }
  
// Modified BrushRect cancel method to NOT add undo entries for canceled shapes
["cancel"]() {
  // If this is a partial cancellation after parameter changes
  if (this.inStroke && this.surface.isMyself && this.start) {
    
    // For canceled rectangles, we should NOT create undo entries
    // This prevents the Board from trying to commit a canceled shape
  }
  
  // Standard cleanup
  this.clearSlate();
  this.start = null;
  this.end = null;
  this.inStroke = false;
  this.oldData = null;
  this.rectBBox = null;
}
  
  ["colorChange"](_0x294baf) {
    this["contextSlate"]["strokeStyle"] = _0x294baf, this["start"] && this["end"] && this["redraw"](this["start"], this.end, _0x294baf);
  }
  
  ["optionChange"](_0x3edca0, _0x1f1c15) {
    if (_0x3edca0 == "size") this["surface"]["slate"]["setCanvasProperties"]({
      linewidth: _0x1f1c15
    }); else {
      if (_0x3edca0 == "alpha") this["surface"]["slate"].setCSSProperties({
        alpha: _0x1f1c15
      }); else {
        if (_0x3edca0 == "blendmode") this.surface.slate["setCSSProperties"]({
          blendmode: _0x1f1c15
        }); else _0x3edca0 == "blur" && this.surface["slate"]["setCSSProperties"]({
          blur: _0x1f1c15
        });
      }
    }
  }
  
  ["optionChanged"](_0x134c9a, _0x13a192) {
    this["start"] && this.end && this["redraw"](this["start"], this["end"], this.surface["drawColor"]), _0x134c9a == "cursor" && this["surface"].cursor.changePointer(_0x13a192);
  }
}
class BrushLineModded extends BrushStub {
  constructor(_0x3ad08f) {
    super(_0x3ad08f);
    this["options"] = {};
    this["options"]["size"] = new SizeOption();
    this["options"].alpha = new AlphaOption();
    this.options["blur"] = new BlurOption();
    this["options"]["blendmode"] = new BlendModeOption();
    this.options["snap"] = new SnapOption();
    this["options"]["rightclick"] = new RightClickOption("line");
    this["options"]["cursor"] = new CursorOption("circle");
    this.options["locktransparency"] = new LockTransparencyOption(); // Add Lock Transparency option
    this["start"];
    this.end;
    
    // Add tracking variables for undo support
    this.inStroke = false;
    this.oldData = null;
    this.lineBBox = null;
  }
  
  ["brushStart"]() {
    this["surface"]["cursor"]["changePointer"](this["getOption"]("cursor"));
  }
  
  ["drawStart"](_0x4e2f91, _0x16e8a0, _0x284300) {
    // Start tracking the stroke for undo support
    this.inStroke = true;
    
    // Always use normal blending for preview so it remains visible
    this.surface["slate"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: this["getOption"]("size"),
      strokestyle: _0x284300,
      alpha: 1,
      blendmode: "normal", // Always use normal for preview
      blur: 0,
      linedash: []
    });
    
    this["surface"].slate["setCSSProperties"]({
      alpha: this["getOption"]("alpha"),
      blendmode: this["getOption"]("blendmode") || "normal",
      blur: this.getOption("blur")
    });
    
    this["start"] = new Point(_0x4e2f91, _0x16e8a0);
    
    // Initialize the bounding box for the line
    const brushSize = Math.max(this.getOption("size"), 1);
    this.lineBBox = {
      minX: _0x4e2f91 - brushSize,
      minY: _0x16e8a0 - brushSize,
      maxX: _0x4e2f91 + brushSize,
      maxY: _0x16e8a0 + brushSize
    };
    
    // If this is the local user, store the initial canvas state for undo
    if (this.surface.isMyself) {
      const ctx = room.board.getContext(this.surface.currentLayer);
      // We'll store the canvas state but only use it when we know the full bounding box
      this.oldData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    }
  }
  
  
  ["drawStep"](_0x1ca757, _0x348692, _0x5f27f2) {
    // Update bounding box with current position and brush size
    const brushSize = Math.max(this.getOption("size"), 1);
    if (this.lineBBox) {
      this.lineBBox.minX = Math.min(this.lineBBox.minX, _0x348692.x - brushSize);
      this.lineBBox.minY = Math.min(this.lineBBox.minY, _0x348692.y - brushSize);
      this.lineBBox.maxX = Math.max(this.lineBBox.maxX, _0x348692.x + brushSize);
      this.lineBBox.maxY = Math.max(this.lineBBox.maxY, _0x348692.y + brushSize);
    }
    
    this.redraw(this["start"], _0x348692, _0x5f27f2), this["end"] = _0x348692;
  }
  
  ["redraw"](_0x27decc, _0x3cc7a0, _0x359e09) {
    this.clearSlate(), this["contextSlate"]["beginPath"](), this["contextSlate"]["moveTo"](_0x27decc.x, _0x27decc.y);
    if (!this.getOption("snap")) this.contextSlate["lineTo"](_0x3cc7a0.x, _0x3cc7a0.y); else {
      var _0x196d77 = this["snapPosition"](_0x27decc, _0x3cc7a0);
      this["contextSlate"]["lineTo"](_0x196d77.x, _0x196d77.y);
    }
    this["contextSlate"]["stroke"]();
  }
  
  ["drawEnd"](_0x5457c2, _0x7fb7fe, _0x337600) {
    if (!this.inStroke) return; // Safety check
    
    // Update final bounding box
    const brushSize = Math.max(this.getOption("size"), 1);
    if (this.lineBBox) {
      this.lineBBox.minX = Math.min(this.lineBBox.minX, _0x5457c2 - brushSize);
      this.lineBBox.minY = Math.min(this.lineBBox.minY, _0x7fb7fe - brushSize);
      this.lineBBox.maxX = Math.max(this.lineBBox.maxX, _0x5457c2 + brushSize);
      this.lineBBox.maxY = Math.max(this.lineBBox.maxY, _0x7fb7fe + brushSize);
    }
    
    this.end = new Point(_0x5457c2, _0x7fb7fe);
    this.composite();
  }
  
  ["composite"]() {
    // Get user's blend mode and transparency lock status
    const userBlendMode = this.getOption("blendmode") || "normal";
    const lockTransparency = this.getOption("locktransparency");
    
    var _0x5cb0bf = room["board"]["getContext"](this["surface"]["currentLayer"]);
    
    if (lockTransparency) {
      // Two-step process for locked transparency
      
      // Step 1: Save the current canvas state
      const currentState = _0x5cb0bf.getImageData(0, 0, _0x5cb0bf.canvas.width, _0x5cb0bf.canvas.height);
      
      // Apply the line with user's blend mode
      room["board"]["layers"][this.surface.currentLayer].advCanvas["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: this.getOption("size"),
        strokestyle: this.surface["drawColor"],
        alpha: this.getOption("alpha"),
        blendmode: userBlendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the line
      _0x5cb0bf["beginPath"]();
      _0x5cb0bf["moveTo"](this["start"].x, this.start.y);
      
      let endpoint = this.end;
      if (this["getOption"]("snap")) {
        endpoint = this["snapPosition"](this.start, this["end"]);
        
        // Update bounding box with snapped endpoint
        const brushSize = Math.max(this.getOption("size"), 1);
        if (this.lineBBox) {
          this.lineBBox.minX = Math.min(this.lineBBox.minX, endpoint.x - brushSize);
          this.lineBBox.minY = Math.min(this.lineBBox.minY, endpoint.y - brushSize);
          this.lineBBox.maxX = Math.max(this.lineBBox.maxX, endpoint.x + brushSize);
          this.lineBBox.maxY = Math.max(this.lineBBox.maxY, endpoint.y + brushSize);
        }
      }
      
      _0x5cb0bf["lineTo"](endpoint.x, endpoint.y);
      _0x5cb0bf["stroke"]();
      
      // Step 2: Get the result after drawing
      const newState = _0x5cb0bf.getImageData(0, 0, _0x5cb0bf.canvas.width, _0x5cb0bf.canvas.height);
      
      // Step 3: Preserve original alpha values
      const resultData = newState.data;
      const originalData = currentState.data;
      
      for (let i = 0; i < resultData.length; i += 4) {
        // Preserve original transparency levels
        const originalAlpha = originalData[i + 3];
        const newAlpha = resultData[i + 3];
        
        // If a pixel was originally semitransparent, keep it semitransparent
        if (originalAlpha < 255) {
          resultData[i + 3] = Math.min(newAlpha, originalAlpha);
        }
      }
      
      // Update canvas with masked result
      _0x5cb0bf.putImageData(newState, 0, 0);
      
    } else {
      // Standard drawing with user's blend mode
      room["board"]["layers"][this.surface.currentLayer].advCanvas["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: this.getOption("size"),
        strokestyle: this.surface["drawColor"],
        alpha: this.getOption("alpha"),
        blendmode: userBlendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the line
      _0x5cb0bf["beginPath"]();
      _0x5cb0bf["moveTo"](this["start"].x, this.start.y);
      
      let endpoint = this.end;
      if (this["getOption"]("snap")) {
        endpoint = this["snapPosition"](this.start, this["end"]);
      }
      
      _0x5cb0bf["lineTo"](endpoint.x, endpoint.y);
      _0x5cb0bf["stroke"]();
    }
    
    // After drawing, save the action for undo if this is the local user
    if (this.surface.isMyself && this.oldData && this.lineBBox) {
      // Create a valid bounding box from our tracked min/max values
      const bbox = [
        Math.max(0, Math.floor(this.lineBBox.minX)),
        Math.max(0, Math.floor(this.lineBBox.minY)),
        Math.min(room.board.canvasWidth, Math.ceil(this.lineBBox.maxX - this.lineBBox.minX)),
        Math.min(room.board.canvasHeight, Math.ceil(this.lineBBox.maxY - this.lineBBox.minY))
      ];
      
      // Expand slightly to ensure we capture all affected pixels
      bbox[0] = Math.max(0, bbox[0] - 2);
      bbox[1] = Math.max(0, bbox[1] - 2);
      bbox[2] = Math.min(room.board.canvasWidth - bbox[0], bbox[2] + 4);
      bbox[3] = Math.min(room.board.canvasHeight - bbox[1], bbox[3] + 4);
      
      // Get the new state of the affected area
      const newData = _0x5cb0bf.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
      
      // Extract the same region from the old data
      const oldCanvas = document.createElement('canvas');
      oldCanvas.width = bbox[2];
      oldCanvas.height = bbox[3];
      const oldCtx = oldCanvas.getContext('2d');
      oldCtx.putImageData(this.oldData, -bbox[0], -bbox[1]);
      const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
      
      // Push the undo action
      room.board.pushUndo({
        layer: this.surface.currentLayer,
        bbox: bbox,
        oldData: regionOldData,
        newData: newData,
        actionType: 'line'
      });
    }
    
    // Clean up
    this.clearSlate();
    this.start = null;
    this["end"] = null;
    this.inStroke = false;
    this.oldData = null;
    this.lineBBox = null;
  }

  ["cancel"]() {
    this.clearSlate();
    this.start = null;
    this.end = null;
    this.inStroke = false;
    this.oldData = null;
    this.lineBBox = null;
  }
  
  // Other methods remain the same
  ["getSync"]() {
    var _0x329027 = {};
    return _0x329027["start"] = this["start"], _0x329027;
  }
  
  ["setSync"](_0x54914c) {
    this["drawStart"](_0x54914c["start"].x, _0x54914c["start"].y, this["surface"]["drawColor"]);
  }
  
  ["snapPosition"](_0x1a5c71, _0x406ad6) {
    var _0x1a4fde = _0x406ad6.x - _0x1a5c71.x,
      _0x262a37 = _0x406ad6.y - _0x1a5c71.y,
      _0x673dfb = Math.sqrt(_0x1a4fde * _0x1a4fde + _0x262a37 * _0x262a37),
      _0x1b789f = Math["atan2"](_0x262a37, _0x1a4fde) / Math.PI * 180;
    _0x1b789f = angleSnap(_0x1b789f);
    var _0x21ecb5 = _0x673dfb * Math["cos"](_0x1b789f * Math.PI / 180),
      _0x19ddce = _0x673dfb * Math["sin"](_0x1b789f * Math.PI / 180);
    return new Point(_0x21ecb5 + _0x1a5c71.x, _0x19ddce + _0x1a5c71.y);
  }
  
  ["clearSlate"]() {
    this["contextSlate"]["clearRect"](0, 0, this["contextSlate"]["canvas"]["width"], this.contextSlate.canvas.height);
  }
  
  ["colorChange"](_0x25d7d5) {
    this.contextSlate["strokeStyle"] = _0x25d7d5, this["start"] && this["end"] && this["redraw"](this["start"], this["end"], _0x25d7d5);
  }
  
  ["optionChange"](_0x231195, _0x2cb6a3) {
    if (_0x231195 == "size") this["surface"]["slate"]["setCanvasProperties"]({
      linewidth: _0x2cb6a3
    }); else {
      if (_0x231195 == "alpha") this["surface"]["slate"]["setCSSProperties"]({
        alpha: _0x2cb6a3
      }); else {
        if (_0x231195 == "blendmode") this["surface"].slate["setCSSProperties"]({
          blendmode: _0x2cb6a3
        }); else _0x231195 == "blur" && this["surface"]["slate"].setCSSProperties({
          blur: _0x2cb6a3
        });
      }
    }
  }
  
  ["optionChanged"](_0x16bce9, _0x5ad32f) {
    this["start"] && this["end"] && this.redraw(this["start"], this.end, this["surface"]["drawColor"]), _0x16bce9 == "cursor" && this["surface"].cursor["changePointer"](_0x5ad32f);
  }
}
class BrushEllipseModded extends BrushStub {
  constructor(_0xa98314) {
    super(_0xa98314);
    this["options"] = {};
    this.options["size"] = new SizeOption();
    this.options["alpha"] = new AlphaOption();
    this["options"]["blur"] = new BlurOption();
    this.options["blendmode"] = new BlendModeOption();
    this["options"]["fill"] = new FillOption();
    this.options["aspectratio"] = new AspectRatioOption();
    this.options["rightclick"] = new RightClickOption("ellipse");
    this["options"].cursor = new CursorOption("circle");
    this.options["locktransparency"] = new LockTransparencyOption(); // Add Lock Transparency option
    this.start;
    this.end;
    
    // Add tracking variables for undo support
    this.inStroke = false;
    this.oldData = null;
    this.ellipseBBox = null;
  }
  
  ["brushStart"]() {
    this.surface.cursor["changePointer"](this["getOption"]("cursor"));
  }
  
  ["drawStart"](_0x3765cd, _0x641bf3, _0x4a2443) {
    // Start tracking the stroke for undo support
    this.inStroke = true;
    
    // Always use normal blending for preview so it remains visible
    this.surface["slate"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: this["getOption"]("size"),
      strokestyle: _0x4a2443,
      fillstyle: _0x4a2443,
      alpha: 1,
      blendmode: "normal", // Always use normal for preview visibility
      blur: 0,
      linedash: []
    });
    
    this.surface["slate"]["setCSSProperties"]({
      alpha: this.getOption("alpha"),
      blendmode: this["getOption"]("blendmode") || "normal",
      blur: this["getOption"]("blur")
    });
    
    this["start"] = new Point(_0x3765cd, _0x641bf3);
    
    // Initialize the bounding box for the ellipse
    const brushSize = Math.max(this.getOption("size"), 1);
    this.ellipseBBox = {
      minX: _0x3765cd - brushSize,
      minY: _0x641bf3 - brushSize,
      maxX: _0x3765cd + brushSize,
      maxY: _0x641bf3 + brushSize
    };
    
    // If this is the local user, store the canvas state for undo
    if (this.surface.isMyself) {
      const ctx = room.board.getContext(this.surface.currentLayer);
      this.oldData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    }
  }
  
  ["drawStep"](_0x2df993, _0x31f7aa, _0x39eb5b) {
    // Update bounding box based on current ellipse shape
    if (this.ellipseBBox) {
      // For ellipse, we need to calculate the bounds differently
      const brushSize = Math.max(this.getOption("size"), 1);
      
      // Calculate center and radii
      let centerX, centerY, radiusX, radiusY;
      
      if (this.getOption("aspectratio")) {
        // For circle (equal aspect ratio)
        const radius = this.getMinDistance(_0x31f7aa.x - this.start.x, _0x31f7aa.y - this.start.y) / 2;
        const dirX = _0x31f7aa.x - this.start.x > 0 ? 1 : -1;
        const dirY = _0x31f7aa.y - this.start.y > 0 ? 1 : -1;
        
        centerX = this.start.x + radius * dirX;
        centerY = this.start.y + radius * dirY;
        radiusX = radiusY = Math.abs(radius);
      } else {
        // For ellipse
        const halfWidth = (_0x31f7aa.x - this.start.x) / 2;
        const halfHeight = (_0x31f7aa.y - this.start.y) / 2;
        
        centerX = this.start.x + halfWidth;
        centerY = this.start.y + halfHeight;
        radiusX = Math.abs(halfWidth);
        radiusY = Math.abs(halfHeight);
      }
      
      // Update bounding box with calculated ellipse bounds
      this.ellipseBBox.minX = Math.min(this.ellipseBBox.minX, centerX - radiusX - brushSize);
      this.ellipseBBox.minY = Math.min(this.ellipseBBox.minY, centerY - radiusY - brushSize);
      this.ellipseBBox.maxX = Math.max(this.ellipseBBox.maxX, centerX + radiusX + brushSize);
      this.ellipseBBox.maxY = Math.max(this.ellipseBBox.maxY, centerY + radiusY + brushSize);
    }
    
    this.redraw(this["start"], _0x31f7aa, _0x39eb5b), this["end"] = _0x31f7aa;
  }
  
  ["drawEnd"](_0x5aa548, _0x4ac7a6, _0x5a46b4) {
    if (!this.inStroke) return; // Safety check
    
    // Update final bounding box
    this.drawStep(null, new Point(_0x5aa548, _0x4ac7a6), _0x5a46b4);
    
    this.end = new Point(_0x5aa548, _0x4ac7a6), this["composite"]();
  }
  
  ["redraw"](_0x2473b8, _0x40f649, _0x36adcc) {
    this["clearSlate"](), this.contextSlate["beginPath"]();
    if (this.getOption("aspectratio")) {
      var _0x11d494 = this["getMinDistance"](_0x40f649.x - _0x2473b8.x, _0x40f649.y - _0x2473b8.y) / 2,
        _0x1adb72 = _0x40f649.x - _0x2473b8.x > 0 ? 1 : -1,
        _0x322f9c = _0x40f649.y - _0x2473b8.y > 0 ? 1 : -1,
        _0x51425a = _0x11d494 < 0 ? -_0x11d494 : _0x11d494;
      this["contextSlate"]["ellipse"](_0x2473b8.x + _0x11d494 * _0x1adb72, _0x2473b8.y + _0x11d494 * _0x322f9c, _0x51425a, _0x51425a, 0, 0, Math.PI * 2), this["getOption"]("fill") && this["contextSlate"]["fill"]();
    } else {
      var _0x484352 = (_0x40f649.x - _0x2473b8.x) / 2,
        _0x2ef185 = (_0x40f649.y - _0x2473b8.y) / 2,
        _0x1942ea = _0x484352 < 0 ? -_0x484352 : _0x484352,
        _0x1b381f = _0x2ef185 < 0 ? -_0x2ef185 : _0x2ef185;
      this["contextSlate"]["ellipse"](_0x2473b8.x + _0x484352, _0x2473b8.y + _0x2ef185, _0x1942ea, _0x1b381f, 0, 0, Math.PI * 2), this["getOption"]("fill") && this["contextSlate"]["fill"]();
    }
    this.contextSlate["stroke"]();
  }
  
  ["composite"]() {
    // Get user's blend mode and transparency lock status
    const userBlendMode = this["getOption"]("blendmode") || "normal";
    const lockTransparency = this.getOption("locktransparency");
    
    var _0x29302f = room["board"]["getContext"](this["surface"]["currentLayer"]);
    
    if (lockTransparency) {
      // Two-step process for locked transparency
      
      // Step 1: Save the current canvas state
      const currentState = _0x29302f.getImageData(0, 0, _0x29302f.canvas.width, _0x29302f.canvas.height);
      
      // Apply the ellipse with user's blend mode
      room["board"].layers[this["surface"]["currentLayer"]].advCanvas.setCanvasProperties({
        linejoin: "round",
        linecap: "round",
        linewidth: this["getOption"]("size"),
        strokestyle: this.surface["drawColor"],
        fillstyle: this["surface"]["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: userBlendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the ellipse
      _0x29302f["beginPath"]();
      
      if (this.getOption("aspectratio")) {
        var _0x2a1e83 = this["getMinDistance"](this.end.x - this["start"].x, this["end"].y - this["start"].y) / 2,
          _0x55f04d = this.end.x - this["start"].x > 0 ? 1 : -1,
          _0xe60a43 = this["end"].y - this["start"].y > 0 ? 1 : -1,
          _0x3fb647 = _0x2a1e83 < 0 ? -_0x2a1e83 : _0x2a1e83;
        _0x29302f.ellipse(this["start"].x + _0x2a1e83 * _0x55f04d, this.start.y + _0x2a1e83 * _0xe60a43, _0x3fb647, _0x3fb647, 0, 0, Math.PI * 2);
        if (this["getOption"]("fill")) _0x29302f["fill"]();
      } else {
        var _0x49e0c5 = (this["end"].x - this["start"].x) / 2,
          _0x2c5b7b = (this["end"].y - this["start"].y) / 2,
          _0x1b22c4 = _0x49e0c5 < 0 ? -_0x49e0c5 : _0x49e0c5,
          _0x41ab15 = _0x2c5b7b < 0 ? -_0x2c5b7b : _0x2c5b7b;
        _0x29302f["ellipse"](this.start.x + _0x49e0c5, this["start"].y + _0x2c5b7b, _0x1b22c4, _0x41ab15, 0, 0, Math.PI * 2);
        if (this.getOption("fill")) _0x29302f["fill"]();
      }
      
      _0x29302f.stroke();
      
      // Step 2: Get the result after drawing
      const newState = _0x29302f.getImageData(0, 0, _0x29302f.canvas.width, _0x29302f.canvas.height);
      
      // Step 3: Preserve original alpha values
      const resultData = newState.data;
      const originalData = currentState.data;
      
      for (let i = 0; i < resultData.length; i += 4) {
        // Preserve original transparency levels
        const originalAlpha = originalData[i + 3];
        const newAlpha = resultData[i + 3];
        
        // If a pixel was originally semitransparent, keep it semitransparent
        if (originalAlpha < 255) {
          resultData[i + 3] = Math.min(newAlpha, originalAlpha);
        }
      }
      
      // Update canvas with masked result
      _0x29302f.putImageData(newState, 0, 0);
      
    } else {
      // Standard drawing with user's blend mode
      room["board"].layers[this["surface"]["currentLayer"]].advCanvas.setCanvasProperties({
        linejoin: "round",
        linecap: "round",
        linewidth: this["getOption"]("size"),
        strokestyle: this.surface["drawColor"],
        fillstyle: this["surface"]["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: userBlendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the ellipse
      _0x29302f["beginPath"]();
      
      if (this.getOption("aspectratio")) {
        var _0x2a1e83 = this["getMinDistance"](this.end.x - this["start"].x, this["end"].y - this["start"].y) / 2,
          _0x55f04d = this.end.x - this["start"].x > 0 ? 1 : -1,
          _0xe60a43 = this["end"].y - this["start"].y > 0 ? 1 : -1,
          _0x3fb647 = _0x2a1e83 < 0 ? -_0x2a1e83 : _0x2a1e83;
        _0x29302f.ellipse(this["start"].x + _0x2a1e83 * _0x55f04d, this.start.y + _0x2a1e83 * _0xe60a43, _0x3fb647, _0x3fb647, 0, 0, Math.PI * 2);
        if (this["getOption"]("fill")) _0x29302f["fill"]();
      } else {
        var _0x49e0c5 = (this["end"].x - this["start"].x) / 2,
          _0x2c5b7b = (this["end"].y - this["start"].y) / 2,
          _0x1b22c4 = _0x49e0c5 < 0 ? -_0x49e0c5 : _0x49e0c5,
          _0x41ab15 = _0x2c5b7b < 0 ? -_0x2c5b7b : _0x2c5b7b;
        _0x29302f["ellipse"](this.start.x + _0x49e0c5, this["start"].y + _0x2c5b7b, _0x1b22c4, _0x41ab15, 0, 0, Math.PI * 2);
        if (this.getOption("fill")) _0x29302f["fill"]();
      }
      
      _0x29302f.stroke();
    }
    
    // After drawing, save the action for undo if this is the local user
    if (this.surface.isMyself && this.oldData && this.ellipseBBox) {
      // Create a valid bounding box from our tracked min/max values
      const bbox = [
        Math.max(0, Math.floor(this.ellipseBBox.minX)),
        Math.max(0, Math.floor(this.ellipseBBox.minY)),
        Math.min(room.board.canvasWidth, Math.ceil(this.ellipseBBox.maxX - this.ellipseBBox.minX)),
        Math.min(room.board.canvasHeight, Math.ceil(this.ellipseBBox.maxY - this.ellipseBBox.minY))
      ];
      
      // Expand slightly to ensure we capture all affected pixels
      bbox[0] = Math.max(0, bbox[0] - 2);
      bbox[1] = Math.max(0, bbox[1] - 2);
      bbox[2] = Math.min(room.board.canvasWidth - bbox[0], bbox[2] + 4);
      bbox[3] = Math.min(room.board.canvasHeight - bbox[1], bbox[3] + 4);
      
      // Get the new state of the affected area
      const newData = _0x29302f.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
      
      // Extract the same region from the old data
      const oldCanvas = document.createElement('canvas');
      oldCanvas.width = bbox[2];
      oldCanvas.height = bbox[3];
      const oldCtx = oldCanvas.getContext('2d');
      oldCtx.putImageData(this.oldData, -bbox[0], -bbox[1]);
      const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
      
      // Push the undo action
      room.board.pushUndo({
        layer: this.surface.currentLayer,
        bbox: bbox,
        oldData: regionOldData,
        newData: newData,
        actionType: 'ellipse'
      });
    }
    
    // Clean up
    this["clearSlate"]();
    this["start"] = null;
    this["end"] = null;
    this.inStroke = false;
    this.oldData = null;
    this.ellipseBBox = null;
  }

  ["getMinDistance"](_0x4ca266, _0x4d1aee) {
    return _0x4ca266 = _0x4ca266 < 0 ? -_0x4ca266 : _0x4ca266, _0x4d1aee = _0x4d1aee < 0 ? -_0x4d1aee : _0x4d1aee, Math["min"](_0x4ca266, _0x4d1aee);
  }
  
  ["clearSlate"]() {
    this["contextSlate"]["clearRect"](0, 0, this["contextSlate"]["canvas"]["width"], this["contextSlate"]["canvas"]["height"]);
  }
  
  ["getSync"]() {
    var _0x22f0e3 = {};
    return _0x22f0e3["start"] = this.start, _0x22f0e3;
  }
  
  ["setSync"](_0x41611b) {
    this["drawStart"](_0x41611b["start"].x, _0x41611b.start.y, this["surface"]["drawColor"]);
  }
  
  ["cancel"]() {
    this["clearSlate"]();
    this.start = null;
    this.end = null;
    this.inStroke = false;
    this.oldData = null;
    this.ellipseBBox = null;
  }
  
  ["colorChange"](_0x1fb82b) {
    this["contextSlate"]["strokeStyle"] = _0x1fb82b, this["start"] && this["end"] && this.redraw(this["start"], this["end"], _0x1fb82b);
  }
  
  ["optionChange"](_0x3ec07b, _0x3bff78) {
    if (_0x3ec07b == "size") this["surface"]["slate"]["setCanvasProperties"]({
      linewidth: _0x3bff78
    }); else {
      if (_0x3ec07b == "alpha") this["surface"]["slate"]["setCSSProperties"]({
        alpha: _0x3bff78
      }); else {
        if (_0x3ec07b == "blendmode") this.surface.slate.setCSSProperties({
          blendmode: _0x3bff78
        }); else _0x3ec07b == "blur" && this["surface"]["slate"]["setCSSProperties"]({
          blur: _0x3bff78
        });
      }
    }
  }
  
  ["optionChanged"](_0x3c3e17, _0x2741b3) {
    this["start"] && this["end"] && this["redraw"](this.start, this["end"], this["surface"]["drawColor"]), _0x3c3e17 == "cursor" && this["surface"]["cursor"].changePointer(_0x2741b3);
  }
}

class BrushFillModded extends BrushStub {
  constructor(_0x18d953) {
    super(_0x18d953);
    this.start;
    this.colorLayer;
    this.filledPixels;
    this.maxPixels = 1e5;
    this.options = {};
    this.options["size"] = new SizeOption(33, true);
    this.options["alpha"] = new AlphaOption();
    this.options["rightclick"] = new RightClickOption("fill");
    this.options["cursor"] = new CursorOption("crosshair");
    
    // Add state variables for undo support
    this.oldData = null;
    this.fillBBox = null;
  }
  
  ["brushStart"]() {
    this.surface.cursor.changePointer(this.getOption("cursor"));
  }
  
  ["optionChanged"](_0x3feabe, _0x3ae26c) {
    _0x3feabe == "cursor" && this.surface.cursor.changePointer(_0x3ae26c);
  }
  
  ["drawEnd"](_0x3b260b, _0x78972f, _0x5dfca9) {
    this.start = new Point(parseInt(_0x3b260b), parseInt(_0x78972f));
    
    // Initialize bounding box with just the starting point
    this.fillBBox = {
      minX: this.start.x,
      minY: this.start.y,
      maxX: this.start.x,
      maxY: this.start.y
    };
    
    // Only save original state if this is the local user's operation
    if (this.surface.isMyself) {
      const ctx = room.board.getContext(this.surface.currentLayer);
      this.oldData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    }
    
    this.draw();
    
    // After fill is complete, push to undo stack if this is the local user
    if (this.surface.isMyself && this.fillBBox && this.oldData) {
      const layer = this.surface.currentLayer;
      const ctx = room.board.getContext(layer);
      
      // Ensure bounding box values are integers and valid
      const bbox = [
        Math.max(0, Math.floor(this.fillBBox.minX)),
        Math.max(0, Math.floor(this.fillBBox.minY)),
        Math.min(room.board.canvasWidth, Math.ceil(this.fillBBox.maxX - this.fillBBox.minX + 1)),
        Math.min(room.board.canvasHeight, Math.ceil(this.fillBBox.maxY - this.fillBBox.minY + 1))
      ];
      
      // Get the new data from the affected area
      const newData = ctx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
      
      // Extract the same region from the old data
      const oldCanvas = document.createElement('canvas');
      oldCanvas.width = bbox[2];
      oldCanvas.height = bbox[3];
      const oldCtx = oldCanvas.getContext('2d');
      oldCtx.putImageData(this.oldData, -bbox[0], -bbox[1]);
      const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
      
      // Push this as an undo action
      room.board.pushUndo({
        layer: layer,
        bbox: bbox,
        oldData: regionOldData,
        newData: newData
      });
    }
    
    // Reset undo tracking
    this.oldData = null;
    this.fillBBox = null;
  }
  
  ["draw"]() {
    this.filledPixels = 0;
    var _0x21bfce = room.board.getContext(this.surface.currentLayer),
      _0x1148a9 = room.board.canvasWidth,
      _0x226544 = room.board.canvasHeight;
    this.colorLayer = _0x21bfce.getImageData(0, 0, _0x1148a9, _0x226544);
    var _0x1af81e = (this.start.y * _0x1148a9 + this.start.x) * 4,
      _0x571e1f = {
        r: this.colorLayer.data[_0x1af81e],
        g: this.colorLayer.data[_0x1af81e + 1],
        b: this.colorLayer.data[_0x1af81e + 2],
        a: this.colorLayer.data[_0x1af81e + 3]
      },
      _0x279a08 = this.surface.drawColor;
    this.surface.drawColor[0] != "#" && (_0x279a08 = rgb2hex(this.surface.drawColor));
    var _0x4a23b8 = hex2rgb(_0x279a08);
    _0x4a23b8.a = this.getOption("alpha") * 255;
    this.surface.currentLayer == 0 && !room.bottomTransparency && (_0x4a23b8 = rgba2rgb(_0x4a23b8.r, _0x4a23b8.g, _0x4a23b8.b, _0x4a23b8.a / 255), _0x4a23b8.a = 255);
    if (!this.sameColor(_0x571e1f, _0x4a23b8)) {
      var _0x2a0056 = [[this.start.x, this.start.y]],
        _0x4cfe5c = 0;
      while (_0x2a0056.length) {
        var _0x1ffaf0, _0x186a56, _0x405241, _0x1af81e, _0x15590f, _0xee1724;
        _0x1ffaf0 = _0x2a0056.pop(), _0x186a56 = _0x1ffaf0[0], _0x405241 = _0x1ffaf0[1], _0x1af81e = (_0x405241 * _0x1148a9 + _0x186a56) * 4;
        while (_0x405241-- >= _0x4cfe5c && this.matchesColor(_0x1af81e, _0x571e1f)) {
          _0x1af81e -= _0x1148a9 * 4;
        }
        _0x1af81e += _0x1148a9 * 4, _0x405241++, _0x15590f = false, _0xee1724 = false;
        while (_0x405241++ < _0x226544 - 1 && this.matchesColor(_0x1af81e, _0x571e1f)) {
          if (!this.fillPixel(_0x1af81e, _0x4a23b8, _0x186a56, _0x405241)) {
            this.surface.isMyself && UI.dialogHandler.showAlert(textManager.getString("alerts.txtAreaTooBig"));
            return;
          }
          if (_0x186a56 > 0) {
            if (this.matchesColor(_0x1af81e - 4, _0x571e1f)) !_0x15590f && (_0x2a0056.push([_0x186a56 - 1, _0x405241]), _0x15590f = true); else _0x15590f && (_0x15590f = false);
          }
          if (_0x186a56 < _0x1148a9 - 1) {
            if (this.matchesColor(_0x1af81e + 4, _0x571e1f)) !_0xee1724 && (_0x2a0056.push([_0x186a56 + 1, _0x405241]), _0xee1724 = true); else _0xee1724 && (_0xee1724 = false);
          }
          _0x1af81e += _0x1148a9 * 4;
        }
      }
      this.filledPixels < this.maxPixels && _0x21bfce.putImageData(this.colorLayer, 0, 0);
    }
  }
  
  ["sameColor"](_0x32a649, _0x3e0904) {
    return _0x32a649.r == _0x3e0904.r && _0x32a649.g == _0x3e0904.g && _0x32a649.b == _0x3e0904.b && _0x32a649.a == _0x3e0904.a;
  }
  
  ["matchesColor"](_0x3c770b, _0xe3d25e) {
    var _0x549bb4 = {
      r: this.colorLayer.data[_0x3c770b],
      g: this.colorLayer.data[_0x3c770b + 1],
      b: this.colorLayer.data[_0x3c770b + 2],
      a: this.colorLayer.data[_0x3c770b + 3]
    };
    return this.sameColor(_0x549bb4, _0xe3d25e);
  }
  
  ["fillPixel"](_0x575ce6, _0x443e92, x, y) {
    // Update bounding box of affected area
    if (this.fillBBox && x !== undefined && y !== undefined) {
      this.fillBBox.minX = Math.min(this.fillBBox.minX, x);
      this.fillBBox.minY = Math.min(this.fillBBox.minY, y);
      this.fillBBox.maxX = Math.max(this.fillBBox.maxX, x);
      this.fillBBox.maxY = Math.max(this.fillBBox.maxY, y);
    }
    
    this.colorLayer.data[_0x575ce6] = _0x443e92.r;
    this.colorLayer.data[_0x575ce6 + 1] = _0x443e92.g;
    this.colorLayer.data[_0x575ce6 + 2] = _0x443e92.b;
    this.colorLayer.data[_0x575ce6 + 3] = _0x443e92.a;
    
    return ++this.filledPixels < this.maxPixels;
  }
  
  ["cancel"]() {
    // Reset undo tracking if canceling fill operation
    this.oldData = null;
    this.fillBBox = null;
  }
}
class BrushBlendModded extends BrushStub {
  constructor(_0x110ba3) {
    super(_0x110ba3);
    this.lastX;
    this["lastY"];
    this.options = {};
    this["options"]["size"] = new SizeOption();
    this["options"]["alpha"] = new AlphaOption();
    this["options"]["blur"] = new BlurOption(); 
    this["options"]["blendmode"] = new BlendModeOption();
    this.options["cursor"] = new CursorOption("circle");
    
    // Add state variables for undo support
    this.inStroke = false;
    this.strokeLayer = null;
    this.oldData = null;
    this.blendBBox = null;
  }

  ["brushStart"]() {
    this["surface"]["cursor"].changePointer(this["getOption"]("cursor"));
  }

  ["optionChanged"](_0x59c86a, _0x1fc3d8) {
    _0x59c86a == "cursor" && this.surface.cursor["changePointer"](_0x1fc3d8);
  }

  ["drawStart"](_0x381a2b, _0xa5a79a, _0x4c5744) {
    // Mark that we're starting a stroke
    this.inStroke = true;
    this.strokeLayer = this.surface.currentLayer;
    
    // Initialize bounding box for blend stroke
    const brushSize = Math.max(this.getOption("size"), 1);
    this.blendBBox = {
      minX: _0x381a2b - brushSize,
      minY: _0xa5a79a - brushSize,
      maxX: _0x381a2b + brushSize,
      maxY: _0xa5a79a + brushSize
    };
    
    // Save the state of the affected layer before starting - ONLY if this is the local user
    if (this.surface.isMyself) {
      const ctx = room.board.getContext(this.strokeLayer);
      this.oldData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    }
    
    this.plotCircle(_0x381a2b, _0xa5a79a);
    this["lastX"] = _0x381a2b;
    this["lastY"] = _0xa5a79a;
  }

  ["drawStep"](_0x36d3b, _0x48ae50, _0xa2b83c) {
    // Update bounding box with brush size for accurate undo region
    const brushSize = Math.max(this.getOption("size"), 1);  
    if (this.blendBBox) {
      this.blendBBox.minX = Math.min(this.blendBBox.minX, _0x36d3b.x - brushSize);
      this.blendBBox.minY = Math.min(this.blendBBox.minY, _0x36d3b.y - brushSize);
      this.blendBBox.maxX = Math.max(this.blendBBox.maxX, _0x36d3b.x + brushSize);
      this.blendBBox.maxY = Math.max(this.blendBBox.maxY, _0x36d3b.y + brushSize);
    }
    
    this["getDistance"](_0x36d3b.x, _0x36d3b.y, this.lastX, this.lastY) >= this["getOption"]("size") / 4 && (this["plotCircle"](_0x36d3b.x, _0x36d3b.y), this.lastX = _0x36d3b.x, this["lastY"] = _0x36d3b.y);
  }

  ["drawEnd"](_0x53ed81, _0xc51016, _0x4c5744) {
    if (!this.inStroke) return; // Safety check
    
    // Update bounding box with final position
    const brushSize = Math.max(this.getOption("size"), 1);
    if (this.blendBBox) {
      this.blendBBox.minX = Math.min(this.blendBBox.minX, _0x53ed81 - brushSize);
      this.blendBBox.minY = Math.min(this.blendBBox.minY, _0xc51016 - brushSize);
      this.blendBBox.maxX = Math.max(this.blendBBox.maxX, _0x53ed81 + brushSize);
      this.blendBBox.maxY = Math.max(this.blendBBox.maxY, _0xc51016 + brushSize);
    }
    
    // After completing the stroke, collect layer changes for undo
    // ONLY if this is the local user's drawing
    if (this.surface.isMyself && this.blendBBox && this.oldData) {
      const ctx = room.board.getContext(this.strokeLayer);
      
      // Ensure bounding box values are integers and valid
      const bbox = [
        Math.max(0, Math.floor(this.blendBBox.minX)),
        Math.max(0, Math.floor(this.blendBBox.minY)),
        Math.min(room.board.canvasWidth, Math.ceil(this.blendBBox.maxX - this.blendBBox.minX)),
        Math.min(room.board.canvasHeight, Math.ceil(this.blendBBox.maxY - this.blendBBox.minY))
      ];
      
      // Expand bbox slightly to ensure we capture all affected pixels
      bbox[0] = Math.max(0, bbox[0] - 2);
      bbox[1] = Math.max(0, bbox[1] - 2);
      bbox[2] = Math.min(room.board.canvasWidth - bbox[0], bbox[2] + 4);
      bbox[3] = Math.min(room.board.canvasHeight - bbox[1], bbox[3] + 4);
      
      // Get the new data only from the affected area
      const newData = ctx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
      
      // Extract the same region from the old data
      const oldCanvas = document.createElement('canvas');
      oldCanvas.width = bbox[2];
      oldCanvas.height = bbox[3];
      const oldCtx = oldCanvas.getContext('2d');
      oldCtx.putImageData(this.oldData, -bbox[0], -bbox[1]);
      const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
      
      // Push to undo stack
      room.board.pushUndo({
        layer: this.strokeLayer,
        bbox: bbox,
        oldData: regionOldData,
        newData: newData
      });
    }
    
    // Reset stroke tracking
    this.inStroke = false;
    this.strokeLayer = null;
    this.oldData = null;
    this.blendBBox = null;
  }

  ["onBrushParameter"](_0x584faf) {
    if (_0x584faf && _0x584faf["type"] == "plot") {
      room["board"]["layers"][this.surface["currentLayer"]]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: this.getOption("size"),
        strokestyle: _0x584faf["color"],
        alpha: this["getOption"]("alpha"),
        blendmode: this["getOption"]("blendmode") || "normal",
        blur: this["getOption"]("blur")
      });
      var _0x3d1a07 = room["board"]["getContext"](this["surface"].currentLayer);
      _0x3d1a07.beginPath();
      _0x3d1a07["moveTo"](_0x584faf.x - 0.5, _0x584faf.y - 0.5);
      _0x3d1a07["lineTo"](_0x584faf.x + 0.5, _0x584faf.y + 0.5);
      _0x3d1a07["stroke"]();
    }
  }

  ["plotCircle"](_0x53ed81, _0xc51016) {
    if (this["surface"]["isMyself"]) {
      var _0x4de9a5 = getRadialAvg(room.board["getImageData"](this["surface"]["currentLayer"]), _0x53ed81, _0xc51016, Math["max"](this["getOption"]("size") / 2, 1), room["board"]["backgroundColor"]);
      if (!isNaN(_0x4de9a5[0])) {
        _0x4de9a5 = rgba2rgb(_0x4de9a5[0], _0x4de9a5[1], _0x4de9a5[2], _0x4de9a5[3] / 255);
        var _0x544d46 = rgb2hex("rgb(" + _0x4de9a5.r + "," + _0x4de9a5.g + "," + _0x4de9a5.b + ")");
        var _0x4d5af6 = {};
        _0x4d5af6["type"] = "plot";
        _0x4d5af6["color"] = _0x544d46;
        _0x4d5af6.x = _0x53ed81;
        _0x4d5af6.y = _0xc51016;
        this["surface"].brushParameter(_0x4d5af6);
      }
    }
  }

  ["cancel"]() {
    // Reset stroke tracking if canceling in the middle of a stroke
    if (this.inStroke) {
      this.inStroke = false;
      this.strokeLayer = null;
      this.oldData = null;
      this.blendBBox = null;
    }
  }
}

var brushCustomPressure = localStorage.getItem('brushCustomPressure') === 'true';
const BrushCustomModded = (() => {
  if (brushCustomPressure) {
    return class extends BrushStub {
  constructor(_0x2085ef) {
    super(_0x2085ef);
    this["clickX"] = new Array();
    this["clickY"] = new Array();
    this["clickSettings"] = new Array(); // Store settings for each click point
    this["options"] = {};
    this["options"]["size"] = new SizeOption();
    this["options"]["alpha"] = new AlphaOption();
    this["options"]["blendmode"] = new BlendModeOption();
    this["options"]["spacing"] = new SpacingOption(15);
    this["options"].tint = new TintOption();
    this["options"]["randomrotation"] = new RandomRotationOption();
    this["options"]["rotationvalue"] = new RotationValueOption();
    this["options"]["gallery"] = new GalleryOption(openBrushGallery);
    this.options["customize"] = new CustomizeOption(openBrushDesigner);
    this["options"]["rightclick"] = new RightClickOption("custom");
    this["options"]["cursor"] = new CursorOption("square");
    this["options"]["image"] = new ImageOption(null);
    this.options["pressure"] = new PressureOption([true, 1]);
    this.options["locktransparency"] = new LockTransparencyOption(); // Add Lock Transparency option
    this.brushImage = null;
    this["brushCache"] = null;
    this.brushCaches = {}; // Store brush caches for different sizes/tints
    this.compositing = false;
    this["distance"];
    this.currentSettings = null; // Current settings object
    this.currentImageId = 0; // Track the current image ID
    this.currentColor = ""; // Track the current color
    
    // Add state variables for undo support
    this.inStroke = false;
    this.strokeBBox = null;
    this.oldData = null;
    this.hadImageAtStart = false; // Track if brush image existed at stroke start
  }

  ["brushStart"]() {
    this.surface["cursor"]["changePointer"](this["getOption"]("cursor"));
    this.currentColor = this.surface["drawColor"];
    this.updateCurrentSettings();
    this["cache"](this["getOption"]("size"), this["getOption"]("tint"), this.surface["drawColor"]);
  }

  // Store current settings in a reusable object
  ["updateCurrentSettings"]() {
    this.currentSettings = {
      size: this["getOption"]("size"),
      pressure: this["getOption"]("pressure"),
      alpha: this["getOption"]("alpha"),
      blendmode: this["getOption"]("blendmode") || "normal",
      blur: this["getOption"]("blur") ?? 0,
      tint: this["getOption"]("tint"),
      rotationvalue: this["getOption"]("rotationvalue"),
      imageId: this.currentImageId,
      color: this.currentColor,
      locktransparency: this["getOption"]("locktransparency"),
      // Calculate effective size based on pressure
      effectiveSize: this.getPressureAdjustedSize()
    };
    return this.currentSettings;
  }

  ["optionChanged"](_0x438916, _0x102ff1) {
    if (_0x438916 == "cursor") {
      this.surface["cursor"]["changePointer"](_0x102ff1);
    } else if (_0x438916 == "image") {
      // For image changes, clear all cached brushes and increment the image ID
      this.brushCaches = {};
      this.currentImageId++;
      
      var _0x57d5bf = this;
      var _0x2f2a23 = new Image();
      _0x2f2a23["onload"] = function () {
        _0x57d5bf.brushImage = this;
        _0x57d5bf.cache(_0x57d5bf["getOption"]("size"), _0x57d5bf["getOption"]("tint"), _0x57d5bf["surface"]["drawColor"]);
        
        // Force redraw if there are points in the current stroke
        if (_0x57d5bf.clickX.length > 0) {
          _0x57d5bf.redraw();
        }
      };
      _0x2f2a23["src"] = _0x102ff1;
    }
    
    // Update current settings after any option change
    this.updateCurrentSettings();
  }

  // Create a cache key for storing/retrieving brush caches
  ["getBrushCacheKey"](_0x2fc01e, _0x27e49e, _0x4c16e1) {
    return this.currentImageId + "-" + _0x2fc01e + "-" + (_0x27e49e ? "tinted" : "untinted") + "-" + _0x4c16e1;
  }

  ["cache"](_0x2fc01e, _0x27e49e, _0x4c16e1) {
    if (this.brushImage) {
      // Check if we already have this brush in cache
      var cacheKey = this.getBrushCacheKey(_0x2fc01e, _0x27e49e, _0x4c16e1);
      if (this.brushCaches[cacheKey]) {
        this.brushCache = this.brushCaches[cacheKey];
        return;
      }
      
      var _0x2fee47;
      _0x4c16e1[0] == "#" ? _0x2fee47 = hex2rgb(_0x4c16e1) : _0x2fee47 = rgb2obj(_0x4c16e1);
      
      if (_0x2fee47) {
        var _0x44c25f = new AdvancedCanvas(_0x2fc01e, _0x2fc01e);
        var _0x22bf8e = _0x44c25f.getContext();
        _0x44c25f["drawImage"](this.brushImage, 0, 0, _0x2fc01e, _0x2fc01e);
        
        if (_0x27e49e) {
          var _0x313647 = _0x22bf8e["getImageData"](0, 0, _0x2fc01e, _0x2fc01e);
          var _0x31fb69 = _0x313647["data"];
          for (var _0x2fa361 = 0; _0x2fa361 < _0x31fb69["length"]; _0x2fa361 += 4) {
            let _0x122e28 = parseInt((_0x31fb69[_0x2fa361] + _0x31fb69[_0x2fa361 + 1] + _0x31fb69[_0x2fa361 + 2]) / 3);
            _0x31fb69[_0x2fa361] = _0x122e28 + _0x2fee47.r;
            _0x31fb69[_0x2fa361 + 1] = _0x122e28 + _0x2fee47.g;
            _0x31fb69[_0x2fa361 + 2] = _0x122e28 + _0x2fee47.b;
          }
          _0x22bf8e["putImageData"](_0x313647, 0, 0);
        }
        
        var _0x388afa = this;
        var _0x58de24 = new Image();
        _0x58de24["onload"] = function () {
          _0x388afa["brushCache"] = _0x58de24;
          // Store in cache for future use
          _0x388afa.brushCaches[cacheKey] = _0x58de24;
          _0x44c25f["remove"]();
        };
        _0x58de24["src"] = _0x44c25f.getData();
      }
    }
  }

  ["getPressureAdjustedSize"]() {
    // Apply pressure to size, just like in BrushPen
    var _0x1bf1dc = this["getOption"]("pressure")[0] ? this.getOption("pressure")[1] : 1;
    return Math["max"](this["getOption"]("size") * _0x1bf1dc, 1);
  }

  ["drawStart"](_0x4f03e0, _0x3a65d2, _0x2456dc) {
    this.hadImageAtStart = !!this["brushCache"]; // Record if brush image exists
    
    if (this["brushCache"]) {
      // Mark that we're starting a stroke
      this.inStroke = true;
      
      // Initialize bounding box for stroke
      const padding = this.getPressureAdjustedSize() * 0.75;
      this.strokeBBox = {
        minX: _0x4f03e0 - padding,
        minY: _0x3a65d2 - padding,
        maxX: _0x4f03e0 + padding,
        maxY: _0x3a65d2 + padding
      };
      
      // Save the state of the current layer before starting - ONLY if this is the local user
      if (this.surface.isMyself) {
        const layerId = this.surface.currentLayer;
        const ctx = room.board.getContext(layerId);
        this.oldData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
      }
      
      this.updateCurrentSettings();
      var _0x58cf3c = this.currentSettings.effectiveSize;
      
      this["surface"]["slate"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x58cf3c,
        strokestyle: this["surface"]["drawColor"],
        alpha: 1,
        blendmode: "normal",
        blur: 0,
        linedash: []
      });

      this["surface"].slate.setCSSProperties({ blur: 0 });
      
      this["surface"].slate["setCSSProperties"]({
        alpha: this.currentSettings.alpha,
        blendmode: this.currentSettings.blendmode,
        blur: this.currentSettings.blur
      });

      this.contextSlate.filter = this.currentSettings.blur ? `blur(${this.currentSettings.blur}px)` : "none";
      
      this["removeClicks"]();
      this["addClick"](_0x4f03e0, _0x3a65d2);
      
      if (this.getOption("randomrotation")) {
        this["surface"]["isMyself"] && this["surface"].setBrushOption("rotationvalue", Math.floor(Math.random() * 361 + 0));
        var _0x96f84c = parseInt(this.currentSettings.rotationvalue) * (Math.PI / 180);
        this["contextSlate"]["translate"](_0x4f03e0, _0x3a65d2);
        this["contextSlate"]["rotate"](_0x96f84c);
        this.contextSlate.drawImage(this["brushCache"], -_0x58cf3c / 2, -_0x58cf3c / 2, _0x58cf3c, _0x58cf3c);
        this["contextSlate"]["rotate"](-_0x96f84c);
        this["contextSlate"]["translate"](-_0x4f03e0, -_0x3a65d2);
      } else {
        this["contextSlate"].drawImage(this.brushCache, _0x4f03e0 - _0x58cf3c / 2, _0x3a65d2 - _0x58cf3c / 2, _0x58cf3c, _0x58cf3c);
      }
      
      this["distance"] = 0;
    }
  }

  ["drawStep"](_0x44f702, _0x32953c, _0x4e78a1) {
    if (this["brushCache"] && !this["compositing"]) {
      // Update settings if they've changed
      this.updateCurrentSettings();
      
      // Update bounding box with brush size for accurate undo region
      if (this.strokeBBox) {
        const padding = this.currentSettings.effectiveSize * 0.75;
        this.strokeBBox.minX = Math.min(this.strokeBBox.minX, _0x32953c.x - padding);
        this.strokeBBox.minY = Math.min(this.strokeBBox.minY, _0x32953c.y - padding);
        this.strokeBBox.maxX = Math.max(this.strokeBBox.maxX, _0x32953c.x + padding);
        this.strokeBBox.maxY = Math.max(this.strokeBBox.maxY, _0x32953c.y + padding);
      }
      
      if (this["getOption"]("randomrotation") && this["surface"].isMyself) {
        this["surface"]["setBrushOption"]("rotationvalue", Math.floor(Math.random() * 361 + 0));
        this.updateCurrentSettings();
      }
      
      var _0x332089 = this.currentSettings.effectiveSize;
      
      var _0x76ca90 = new Point(_0x32953c.x - _0x44f702.x, _0x32953c.y - _0x44f702.y);
      var _0x4e53d8 = Math["sqrt"](_0x76ca90.x * _0x76ca90.x + _0x76ca90.y * _0x76ca90.y);
      var _0x294f05 = this["getOption"]("spacing") * 4;
      
      let _0x576b9c = this["calculateLine"](_0x44f702.x, _0x44f702.y, _0x32953c.x, _0x32953c.y);
      var _0x497fbd = this;
      
      $["each"](_0x576b9c, function (_0x3922af, _0x904d07) {
        if (++_0x497fbd["distance"] >= _0x332089 * _0x294f05 / 100) {
          _0x497fbd.addClick(_0x904d07.x, _0x904d07.y);
          
          // Update bounding box for each stamp
          if (_0x497fbd.strokeBBox) {
            const padding = _0x332089 * 0.75;
            _0x497fbd.strokeBBox.minX = Math.min(_0x497fbd.strokeBBox.minX, _0x904d07.x - padding);
            _0x497fbd.strokeBBox.minY = Math.min(_0x497fbd.strokeBBox.minY, _0x904d07.y - padding);
            _0x497fbd.strokeBBox.maxX = Math.max(_0x497fbd.strokeBBox.maxX, _0x904d07.x + padding);
            _0x497fbd.strokeBBox.maxY = Math.max(_0x497fbd.strokeBBox.maxY, _0x904d07.y + padding);
          }
          
          if (_0x497fbd["getOption"]("randomrotation")) {
            var _0xffe5a7 = parseInt(loopValue(_0x497fbd.currentSettings.rotationvalue + _0x3922af * 25, 360)) * (Math.PI / 180);
            _0x497fbd["contextSlate"]["translate"](_0x904d07.x, _0x904d07.y);
            _0x497fbd.contextSlate["rotate"](_0xffe5a7);
            _0x497fbd["contextSlate"]["drawImage"](_0x497fbd["brushCache"], -_0x332089 / 2, -_0x332089 / 2, _0x332089, _0x332089);
            _0x497fbd["contextSlate"].rotate(-_0xffe5a7);
            _0x497fbd["contextSlate"]["translate"](-_0x904d07.x, -_0x904d07.y);
          } else {
            _0x497fbd["contextSlate"]["drawImage"](_0x497fbd.brushCache, _0x904d07.x - _0x332089 / 2, _0x904d07.y - _0x332089 / 2, _0x332089, _0x332089);
          }
          
          _0x497fbd["distance"] = 0;
        }
      });
    }
  }

  ["drawEnd"](_0x379517, _0x2872a8, _0x5113c1) {
    // Update bounding box with final position
    if (this.strokeBBox) {
      const padding = this.currentSettings.effectiveSize * 0.75;
      this.strokeBBox.minX = Math.min(this.strokeBBox.minX, _0x379517 - padding);
      this.strokeBBox.minY = Math.min(this.strokeBBox.minY, _0x2872a8 - padding);
      this.strokeBBox.maxX = Math.max(this.strokeBBox.maxX, _0x379517 + padding);
      this.strokeBBox.maxY = Math.max(this.strokeBBox.maxY, _0x2872a8 + padding);
    }
    
    this["composite"]();
  }

  ["colorChange"](_0x3bd546) {
    // Update current color
    this.currentColor = _0x3bd546;
    
    // Generate new brush cache for this color
    this.cache(this["getOption"]("size"), this.getOption("tint"), _0x3bd546);
    
    // Update current settings with new color
    this.updateCurrentSettings();
    
    // Redraw with the new color if we have points
    if (this.clickX.length > 0) {
      this.redraw();
    }
  }

  ["optionChange"](_0x4a8f34, _0xa3f451) {
    // Apply the option change
    if (_0x4a8f34 == "blendmode") {
      this["surface"]["slate"]["canvas"]["css"]("mix-blend-mode", _0xa3f451);
    } else if (_0x4a8f34 == "blur") {
      // Normalize and apply blur to preview; clear CSS and ctx filters when 0
      const val = Number(_0xa3f451) || 0;
      this.surface.slate.setCSSProperties({ blur: val });
      this.contextSlate.filter = val ? `blur(${val}px)` : "none";
      // Keep current settings consistent for stamps captured in clickSettings
      this.currentSettings.blur = val;
    } else if (_0x4a8f34 == "size") {
      this["cache"](_0xa3f451, this["getOption"]("tint"), this.currentColor);
    } else if (_0x4a8f34 == "tint") {
      this["cache"](this["getOption"]("size"), _0xa3f451, this.currentColor);
    }
    
    // Update current settings
    this.updateCurrentSettings();
  }

  ["composite"]() {
    if (!this["compositing"]) {
      this["compositing"] = true;
      
      // Get user's blend mode and transparency lock status
      const userBlendMode = this.getOption("blendmode") || "normal";
      const lockTransparency = this.getOption("locktransparency");
      
      // We'll need the context for transparency masking
      const ctx = room["board"]["getContext"](this["surface"]["currentLayer"]);
      
      if (lockTransparency) {
        // Two-step process for locked transparency
        
        // Step 1: Save the current canvas state
        const currentState = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        // Apply the brush with user's blend mode
        room["board"]["layers"][this["surface"]["currentLayer"]].advCanvas["setCanvasProperties"]({
          linejoin: "round",
          linecap: "round",
          alpha: this["getOption"]("alpha"),
          blendmode: userBlendMode,
          blur: 0,
          linedash: []
        });
        
        var _0x4a2ccd = this;
        var _0x35eb62 = new Image();
        _0x35eb62.onload = function () {
          // Draw the image
          ctx["imageSmoothingEnabled"] = false;
          ctx["drawImage"](_0x35eb62, 0, 0);
          
          // Step 2: Get the result after drawing
          const newState = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
          
          // Step 3: Preserve original alpha values
          const resultData = newState.data;
          const originalData = currentState.data;
          
          for (let i = 0; i < resultData.length; i += 4) {
            // Preserve original transparency levels
            const originalAlpha = originalData[i + 3];
            const newAlpha = resultData[i + 3];
            
            // If a pixel was originally transparent/semitransparent, keep it that way
            if (originalAlpha < 255) {
              resultData[i + 3] = Math.min(newAlpha, originalAlpha);
            }
          }
          
          // Update canvas with masked result
          ctx.putImageData(newState, 0, 0);
          
          // Handle undo stack
          _0x4a2ccd.handleUndoStack(ctx);
          
          // Reset stroke tracking
          _0x4a2ccd.inStroke = false;
          _0x4a2ccd.strokeBBox = null;
          _0x4a2ccd.oldData = null;
          
          _0x4a2ccd["clearSlate"]();
          _0x4a2ccd["removeClicks"]();
          _0x4a2ccd["compositing"] = false;
        };
        _0x35eb62["src"] = this.surface["slate"]["getData"]();
      } else {
        // Standard drawing with user's blend mode
        room["board"]["layers"][this["surface"]["currentLayer"]].advCanvas["setCanvasProperties"]({
          linejoin: "round",
          linecap: "round",
          alpha: this["getOption"]("alpha"),
          blendmode: userBlendMode,
          blur: 0,
          linedash: []
        });
        
        var _0x4a2ccd = this;
        var _0x35eb62 = new Image();
        
        _0x35eb62.onload = function () {
          ctx["imageSmoothingEnabled"] = false;
          ctx["drawImage"](_0x35eb62, 0, 0);
          
          // Handle undo stack
          _0x4a2ccd.handleUndoStack(ctx);
          
          // Reset stroke tracking
          _0x4a2ccd.inStroke = false;
          _0x4a2ccd.strokeBBox = null;
          _0x4a2ccd.oldData = null;
          
          _0x4a2ccd["clearSlate"]();
          _0x4a2ccd["removeClicks"]();
          _0x4a2ccd["compositing"] = false;
        };
        
        _0x35eb62["src"] = this.surface["slate"]["getData"]();
      }
    }
  }
  
  // Helper method for handling undo stack actions
  ["handleUndoStack"](ctx) {
    // Only add to undo stack if the brush had an image at the start of the stroke
    if (this.surface.isMyself && this.strokeBBox && this.oldData && this.hadImageAtStart) {
      // Ensure bounding box values are integers and valid
      const bbox = [
        Math.max(0, Math.floor(this.strokeBBox.minX)),
        Math.max(0, Math.floor(this.strokeBBox.minY)),
        Math.min(room.board.canvasWidth, Math.ceil(this.strokeBBox.maxX - this.strokeBBox.minX)),
        Math.min(room.board.canvasHeight, Math.ceil(this.strokeBBox.maxY - this.strokeBBox.minY))
      ];
      
      // Ensure minimum size (prevent 0-pixel wide/tall boxes)
      if (bbox[2] < 1) bbox[2] = 1;
      if (bbox[3] < 1) bbox[3] = 1;
      
      // Expand bbox slightly to ensure we capture all affected pixels
      bbox[0] = Math.max(0, bbox[0] - 2);
      bbox[1] = Math.max(0, bbox[1] - 2);
      bbox[2] = Math.min(room.board.canvasWidth - bbox[0], bbox[2] + 4);
      bbox[3] = Math.min(room.board.canvasHeight - bbox[1], bbox[3] + 4);
      
      const layerId = this.surface.currentLayer;
      
      // Get the new data only from the affected area
      const newData = ctx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
      
      // Extract the same region from the old data
      const oldCanvas = document.createElement('canvas');
      oldCanvas.width = bbox[2];
      oldCanvas.height = bbox[3];
      const oldCtx = oldCanvas.getContext('2d');
      oldCtx.putImageData(this.oldData, -bbox[0], -bbox[1]);
      const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
      
      // Get the stroke ID from the current stroke data
      const currentStrokeData = this.surface.currentStrokeData;
      const strokeNumber = currentStrokeData ? currentStrokeData.strokeNumber : null;
      
      // Create undo action with consistent format for both brush types
      const undoAction = {
        layer: layerId,
        bbox: bbox,
        oldData: regionOldData,
        newData: newData,
        actionType: "customBrush",
        strokeNumber: strokeNumber
      };
      
      // Store the index of this stroke in the strokes array for easier removal during undo
      if (strokeNumber !== null && this.surface.strokes) {
        // Find the index of this stroke in the array
        const strokeIndex = this.surface.strokes.findIndex(
          stroke => stroke.strokeNumber === strokeNumber
        );
        
        if (strokeIndex !== -1) {
          // Store the index and stroke info for removal during undo
          undoAction.strokeIndex = strokeIndex;
          undoAction.strokeInfo = {
            number: strokeNumber,
            brushName: "custom"
          };
        }
      }
      
      // Push the changes to the undo stack
      room.board.pushUndo(undoAction);
      
      // Add undo handler if it doesn't exist yet
      if (!room.board.originalHandleUndo && room.board.handleUndo) {
        // Store the original method
        room.board.originalHandleUndo = room.board.handleUndo;
        
        // Replace with our enhanced version
        room.board.handleUndo = function (undoAction) {
          // Call the original method first
          const result = room.board.originalHandleUndo(undoAction);
          
          // Now handle stroke removal for both pen and custom brushes
          if (undoAction.strokeInfo && room.myself && room.myself.surface && room.myself.surface.strokes) {
            // Find by stroke number first
            const strokeIdx = room.myself.surface.strokes.findIndex(
              s => s.strokeNumber === undoAction.strokeInfo.number
            );
            
            // If found, remove it
            if (strokeIdx >= 0) {
              room.myself.surface.strokes.splice(strokeIdx, 1);
            }
          }
          
          return result;
        };
      }
    }
  }

  ["addClick"](_0x44a68b, _0x32694b) {
    this.clickX["push"](_0x44a68b);
    this["clickY"]["push"](_0x32694b);
    // Store a copy of current settings with this point
    this["clickSettings"].push(JSON.parse(JSON.stringify(this.currentSettings)));
  }

  ["removeClicks"]() {
    this["clickX"] = new Array();
    this["clickY"] = new Array();
    this["clickSettings"] = new Array();
  }

  ["clearSlate"]() {
    this.contextSlate["clearRect"](0, 0, this.contextSlate["canvas"].width, this["contextSlate"]["canvas"]["height"]);
    // Ensure preview blur is cleared after compositing/cancel
    this.surface.slate.setCSSProperties({ blur: 0 });
    this.contextSlate.filter = "none";
  }

  ["cancel"]() {
    this["clearSlate"]();
    this.removeClicks();
    
    // Reset stroke tracking
    if (this.inStroke) {
      this.inStroke = false;
      this.strokeBBox = null;
      this.oldData = null;
      this.hadImageAtStart = false;
    }
  }

  ["getSync"]() {
    var _0x2af73b = {};
    _0x2af73b.clickX = this["clickX"];
    _0x2af73b.clickY = this["clickY"];
    _0x2af73b.clickSettings = this["clickSettings"];
    return _0x2af73b;
  }

  ["setSync"](_0x85510a) {
    this.clickX = _0x85510a["clickX"];
    this["clickY"] = _0x85510a["clickY"];
    // Handle case where settings aren't in the sync data (for backward compatibility)
    this["clickSettings"] = _0x85510a["clickSettings"] || Array(this.clickX.length).fill(this.updateCurrentSettings());
    this["redraw"]();
  }

  ["redraw"]() {
    if (this["brushCache"]) {
      this.clearSlate();
      
      for (var _0x4ab5d0 = 0; _0x4ab5d0 < this.clickX["length"]; _0x4ab5d0++) {
        // Get settings for this specific point
        var pointSettings = this["clickSettings"][_0x4ab5d0] || this.currentSettings;
        var _0x2286f8 = pointSettings.effectiveSize;
        
        // Set per-point properties
        this["surface"]["slate"]["setCSSProperties"]({
          alpha: pointSettings.alpha,
          blendmode: pointSettings.blendmode,
          blur: pointSettings.blur
        });
        
        // Get the appropriate brush for this point
        var brushToUse = this.brushCache;
        
        // Look for the right cached brush for this point's settings
        if (pointSettings.imageId === this.currentImageId) {
          var brushCacheKey = this.getBrushCacheKey(
            pointSettings.size, 
            pointSettings.tint, 
            pointSettings.color || this.currentColor
          );
          brushToUse = this.brushCaches[brushCacheKey] || this.brushCache;
        }
        
        // Draw this point with its specific settings
        this["contextSlate"]["drawImage"](brushToUse, 
          this["clickX"][_0x4ab5d0] - _0x2286f8 / 2, 
          this["clickY"][_0x4ab5d0] - _0x2286f8 / 2, 
          _0x2286f8, _0x2286f8);
      }
    }
  }
}
}
  else {
    return class extends BrushStub {
  constructor(_0x2085ef) {
    super(_0x2085ef);
    this["clickX"] = new Array();
    this["clickY"] = new Array();
    this["options"] = {};
    this["options"]["size"] = new SizeOption();
    this["options"]["alpha"] = new AlphaOption();
    this["options"]["blendmode"] = new BlendModeOption();
    this["options"]["spacing"] = new SpacingOption(15);
    this["options"].tint = new TintOption();
    this["options"]["randomrotation"] = new RandomRotationOption();
    this["options"]["rotationvalue"] = new RotationValueOption();
    this["options"]["gallery"] = new GalleryOption(openBrushGallery);
    this.options["customize"] = new CustomizeOption(openBrushDesigner);
    this["options"]["rightclick"] = new RightClickOption("custom");
    this["options"]["cursor"] = new CursorOption("square");
    this["options"]["image"] = new ImageOption(null);
    this.options["locktransparency"] = new LockTransparencyOption(); // Add Lock Transparency option
    this.brushImage = null;
    this["brushCache"] = null;
    this.compositing = false;
    this["distance"];
    
    // Add state variables for undo support
    this.inStroke = false;
    this.strokeBBox = null;
    this.oldData = null;
    this.hadImageAtStart = false; // Track if brush image existed at stroke start
    
    // Add tracking for option changes and first movement
    this.hasOptionChangedDuringStroke = false;
    this.hasMadeFirstMove = false;
    this._lastOptionChanges = {};
  }

  ["brushStart"]() {
    this.surface["cursor"]["changePointer"](this["getOption"]("cursor"));
    this["cache"](this["getOption"]("size"), this["getOption"]("tint"), this.surface["drawColor"]);
  }

  ["optionChanged"](_0x438916, _0x102ff1) {
    if (_0x438916 == "cursor") this.surface["cursor"]["changePointer"](_0x102ff1); 
    else {
      if (_0x438916 == "image") {
        var _0x57d5bf = this,
          _0x2f2a23 = new Image();
        _0x2f2a23["onload"] = function () {
          _0x57d5bf.brushImage = this, _0x57d5bf.cache(_0x57d5bf["getOption"]("size"), _0x57d5bf["getOption"]("tint"), _0x57d5bf["surface"]["drawColor"]);
        };
        _0x2f2a23["src"] = _0x102ff1;
      }
    }
  }
  ["cache"](_0x2fc01e, _0x27e49e, _0x4c16e1) {
    if (this.brushImage) {
      var _0x2fee47;
      _0x4c16e1[0] == "#" ? _0x2fee47 = hex2rgb(_0x4c16e1) : _0x2fee47 = rgb2obj(_0x4c16e1);
      if (_0x2fee47) {
        var _0x44c25f = new AdvancedCanvas(_0x2fc01e, _0x2fc01e),
          _0x22bf8e = _0x44c25f.getContext();
        _0x44c25f["drawImage"](this.brushImage, 0, 0, _0x2fc01e, _0x2fc01e);
        if (_0x27e49e) {
          var _0x313647 = _0x22bf8e["getImageData"](0, 0, _0x2fc01e, _0x2fc01e),
            _0x31fb69 = _0x313647["data"];
          for (var _0x2fa361 = 0; _0x2fa361 < _0x31fb69["length"]; _0x2fa361 += 4) {
            let _0x122e28 = parseInt((_0x31fb69[_0x2fa361] + _0x31fb69[_0x2fa361 + 1] + _0x31fb69[_0x2fa361 + 2]) / 3);
            _0x31fb69[_0x2fa361] = _0x122e28 + _0x2fee47.r, _0x31fb69[_0x2fa361 + 1] = _0x122e28 + _0x2fee47.g, _0x31fb69[_0x2fa361 + 2] = _0x122e28 + _0x2fee47.b;
          }
          _0x22bf8e["putImageData"](_0x313647, 0, 0);
        }
        var _0x388afa = this,
          _0x58de24 = new Image();
        _0x58de24["onload"] = function () {
          _0x388afa["brushCache"] = _0x58de24, _0x44c25f["remove"]();
        }, _0x58de24["src"] = _0x44c25f.getData();
      }
    }
  }
  ["drawStart"](_0x4f03e0, _0x3a65d2, _0x2456dc) {
    this.hadImageAtStart = !!this["brushCache"]; // Record if brush image exists
    
    if (this["brushCache"]) {
      // Mark that we're starting a stroke
      this.inStroke = true;
      this.hasMadeFirstMove = false; // Reset first move flag
      this.hasOptionChangedDuringStroke = false; // Reset option changes tracking
      this._lastOptionChanges = {};
      
      // Initialize bounding box for stroke
      const brushSize = this.getOption("size");
      const padding = brushSize * 0.75;
      this.strokeBBox = {
        minX: _0x4f03e0 - padding,
        minY: _0x3a65d2 - padding,
        maxX: _0x4f03e0 + padding,
        maxY: _0x3a65d2 + padding
      };
      
      // Save the state of the current layer before starting - ONLY if this is the local user
      if (this.surface.isMyself) {
        const layerId = this.surface.currentLayer;
        const ctx = room.board.getContext(layerId);
        this.oldData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
      }
      
      // Rest of the original method remains unchanged
      var _0x58cf3c = this.getOption("size");
      this["surface"]["slate"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x58cf3c,
        strokestyle: this["surface"]["drawColor"],
        alpha: 1,
        blendmode: "normal",
        blur: 0,
        linedash: []
      }); 
      this["surface"].slate["setCSSProperties"]({
        alpha: this["getOption"]("alpha"),
        blendmode: this["getOption"]("blendmode") || "normal",
        blur: this["getOption"]("blur")
      });
      this["removeClicks"]();
      this["addClick"](_0x4f03e0, _0x3a65d2);
      if (this.getOption("randomrotation")) {
        this["surface"]["isMyself"] && this["surface"].setBrushOption("rotationvalue", Math.floor(Math.random() * 361 + 0));
        var _0x96f84c = parseInt(this["getOption"]("rotationvalue")) * (Math.PI / 180);
        this["contextSlate"]["translate"](_0x4f03e0, _0x3a65d2);
        this["contextSlate"]["rotate"](_0x96f84c);
        this.contextSlate.drawImage(this["brushCache"], -_0x58cf3c / 2, -_0x58cf3c / 2, _0x58cf3c, _0x58cf3c); 
        this["contextSlate"]["rotate"](-_0x96f84c);
        this["contextSlate"]["translate"](-_0x4f03e0, -_0x3a65d2);
      } else 
        this["contextSlate"].drawImage(this.brushCache, _0x4f03e0 - _0x58cf3c / 2, _0x3a65d2 - _0x58cf3c / 2);
      
      this["distance"] = 0;
    }
  }

  ["drawStep"](_0x44f702, _0x32953c, _0x4e78a1) {
    if (this["brushCache"] && !this["compositing"]) {
      // Mark that we've made first move
      if (!this.hasMadeFirstMove) {
        this.hasMadeFirstMove = true;
        // Reset option changes flag - only count changes AFTER first move
        this.hasOptionChangedDuringStroke = false;
        this._lastOptionChanges = {};
      }
      
      // Update bounding box with brush size for accurate undo region
      if (this.strokeBBox) {
        const brushSize = this.getOption("size");
        const padding = brushSize * 0.75;
        this.strokeBBox.minX = Math.min(this.strokeBBox.minX, _0x32953c.x - padding);
        this.strokeBBox.minY = Math.min(this.strokeBBox.minY, _0x32953c.y - padding);
        this.strokeBBox.maxX = Math.max(this.strokeBBox.maxX, _0x32953c.x + padding);
        this.strokeBBox.maxY = Math.max(this.strokeBBox.maxY, _0x32953c.y + padding);
      }
  
      // REMOVE THIS LINE - don't update rotation on every step
      // this["getOption"]("randomrotation") && this["surface"].isMyself && this["surface"]["setBrushOption"]("rotationvalue", Math.floor(Math.random() * 361 + 0));
      
      var _0x76ca90 = new Point(_0x32953c.x - _0x44f702.x, _0x32953c.y - _0x44f702.y),
        _0x4e53d8 = Math["sqrt"](_0x76ca90.x * _0x76ca90.x + _0x76ca90.y * _0x76ca90.y),
        _0x332089 = this["getOption"]("size"),
        _0x294f05 = this["getOption"]("spacing") * 4;
      let _0x576b9c = this["calculateLine"](_0x44f702.x, _0x44f702.y, _0x32953c.x, _0x32953c.y);
      var _0x497fbd = this;
      $["each"](_0x576b9c, function (_0x3922af, _0x904d07) {
        if (++_0x497fbd["distance"] >= _0x332089 * _0x294f05 / 100) {
          _0x497fbd.addClick(_0x904d07.x, _0x904d07.y);
          
          // Update bounding box for each stamp
          if (_0x497fbd.strokeBBox) {
            _0x497fbd.strokeBBox.minX = Math.min(_0x497fbd.strokeBBox.minX, _0x904d07.x - _0x332089/2);
            _0x497fbd.strokeBBox.minY = Math.min(_0x497fbd.strokeBBox.minY, _0x904d07.y - _0x332089/2);
            _0x497fbd.strokeBBox.maxX = Math.max(_0x497fbd.strokeBBox.maxX, _0x904d07.x + _0x332089/2);
            _0x497fbd.strokeBBox.maxY = Math.max(_0x497fbd.strokeBBox.maxY, _0x904d07.y + _0x332089/2);
          }
          
          // MOVE RANDOM ROTATION HERE - only change rotation when actually placing a stamp
          if (_0x497fbd["getOption"]("randomrotation") && _0x497fbd["surface"].isMyself) {
            _0x497fbd["surface"]["setBrushOption"]("rotationvalue", Math.floor(Math.random() * 361));
          }
          
          if (_0x497fbd["getOption"]("randomrotation")) {
            var _0xffe5a7 = parseInt(loopValue(_0x497fbd["getOption"]("rotationvalue") + _0x3922af * 25, 360)) * (Math.PI / 180);
            _0x497fbd["contextSlate"]["translate"](_0x904d07.x, _0x904d07.y);
            _0x497fbd.contextSlate["rotate"](_0xffe5a7);
            _0x497fbd["contextSlate"]["drawImage"](_0x497fbd["brushCache"], -_0x332089 / 2, -_0x332089 / 2, _0x332089, _0x332089);
            _0x497fbd["contextSlate"].rotate(-_0xffe5a7);
            _0x497fbd["contextSlate"]["translate"](-_0x904d07.x, -_0x904d07.y);
          } else 
            _0x497fbd["contextSlate"]["drawImage"](_0x497fbd.brushCache, _0x904d07.x - _0x332089 / 2, _0x904d07.y - _0x332089 / 2);
          
          _0x497fbd["distance"] = 0;
        }
      });
    }
  }

  ["drawEnd"](_0x379517, _0x2872a8, _0x5113c1) {
    // Update bounding box with final position
    const brushSize = this.getOption("size");
    const padding = brushSize * 0.75;
    if (this.strokeBBox) {
      this.strokeBBox.minX = Math.min(this.strokeBBox.minX, _0x379517 - padding);
      this.strokeBBox.minY = Math.min(this.strokeBBox.minY, _0x2872a8 - padding);
      this.strokeBBox.maxX = Math.max(this.strokeBBox.maxX, _0x379517 + padding);
      this.strokeBBox.maxY = Math.max(this.strokeBBox.maxY, _0x2872a8 + padding);
    }
    
    // Call composite to finish the stroke - original functionality
    this["composite"]();
  }
  ["colorChange"](_0x3bd546) {
    this.cache(this["getOption"]("size"), this.getOption("tint"), _0x3bd546);
  }
  ["optionChange"](_0x4a8f34, _0xa3f451) {
    // Track option changes, but only if we've already started moving
    if (this.inStroke && this.hasMadeFirstMove) {
      
      this.hasOptionChangedDuringStroke = true;
      
      // Track which specific options changed
      if (!this._lastOptionChanges) this._lastOptionChanges = {};
      this._lastOptionChanges[_0x4a8f34] = _0xa3f451;
    }
    
    // Original behavior continues
    if (_0x4a8f34 == "blendmode") this["surface"]["slate"]["canvas"]["css"]("mix-blend-mode", _0xa3f451); else {
      if (_0x4a8f34 == "blur") this["contextSlate"]["filter"] = "blur(" + _0xa3f451 + "px)"; else {
        if (_0x4a8f34 == "size") this["cache"](_0xa3f451, this["getOption"]("tint"), this["surface"]["drawColor"]); else _0x4a8f34 == "tint" && this["cache"](this["getOption"]("size"), _0xa3f451, this["surface"]["drawColor"]);
      }
    }
    if (_0x4a8f34 != "rotationvalue") {
      var _0x20643d = this["clickX"]["length"];
      if (_0x20643d > 0) {
        var _0xbf678d = new Point(this["clickX"][_0x20643d - 1], this.clickY[_0x20643d - 1]);
        this["composite"](), this["addClick"](_0xbf678d.x, _0xbf678d.y);
      }
    }
  }

  ["composite"]() {
    if (!this["compositing"]) {
      this["compositing"] = true;
      
      // Get user's blend mode and transparency lock status
      const userBlendMode = this.getOption("blendmode") || "normal";
      const lockTransparency = this.getOption("locktransparency");
      
      // We'll need the context for transparency masking
      const ctx = room["board"]["getContext"](this["surface"]["currentLayer"]);
      
      if (lockTransparency) {
        // Two-step process for locked transparency
        
        // Step 1: Save the current canvas state
        const currentState = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        // Apply the brush with user's blend mode
        room["board"]["layers"][this["surface"]["currentLayer"]].advCanvas["setCanvasProperties"]({
          linejoin: "round",
          linecap: "round",
          alpha: this["getOption"]("alpha"),
          blendmode: userBlendMode,
          blur: 0,
          linedash: []
        });
        
        var _0x4a2ccd = this,
          _0x35eb62 = new Image();
        _0x35eb62.onload = function () {
          // Draw the image
          ctx["imageSmoothingEnabled"] = false;
          ctx["drawImage"](_0x35eb62, 0, 0);
          
          // Step 2: Get the result after drawing
          const newState = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
          
          // Step 3: Preserve original alpha values
          const resultData = newState.data;
          const originalData = currentState.data;
          
          for (let i = 0; i < resultData.length; i += 4) {
            // Preserve original transparency levels
            const originalAlpha = originalData[i + 3];
            const newAlpha = resultData[i + 3];
            
            // If a pixel was originally semitransparent, keep it semitransparent
            if (originalAlpha < 255) {
              resultData[i + 3] = Math.min(newAlpha, originalAlpha);
            }
          }
          
          // Update canvas with masked result
          ctx.putImageData(newState, 0, 0);
          
          // Handle undo stack if needed
          if (_0x4a2ccd.surface.isMyself && _0x4a2ccd.strokeBBox && _0x4a2ccd.oldData && _0x4a2ccd.hadImageAtStart) {
            // Ensure bounding box values are integers and valid
            const bbox = [
              Math.max(0, Math.floor(_0x4a2ccd.strokeBBox.minX)),
              Math.max(0, Math.floor(_0x4a2ccd.strokeBBox.minY)),
              Math.min(room.board.canvasWidth, Math.ceil(_0x4a2ccd.strokeBBox.maxX - _0x4a2ccd.strokeBBox.minX)),
              Math.min(room.board.canvasHeight, Math.ceil(_0x4a2ccd.strokeBBox.maxY - _0x4a2ccd.strokeBBox.minY))
            ];
            
            // Ensure minimum size (prevent 0-pixel wide/tall boxes)
            if (bbox[2] < 1) bbox[2] = 1;
            if (bbox[3] < 1) bbox[3] = 1;
            
            // Expand bbox slightly to ensure we capture all affected pixels
            bbox[0] = Math.max(0, bbox[0] - 2);
            bbox[1] = Math.max(0, bbox[1] - 2);
            bbox[2] = Math.min(room.board.canvasWidth - bbox[0], bbox[2] + 4);
            bbox[3] = Math.min(room.board.canvasHeight - bbox[1], bbox[3] + 4);
            
            const layerId = _0x4a2ccd.surface.currentLayer;
            
            // Get the new data only from the affected area
            const newData = ctx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
            
            // Extract the same region from the old data
            const oldCanvas = document.createElement('canvas');
            oldCanvas.width = bbox[2];
            oldCanvas.height = bbox[3];
            const oldCtx = oldCanvas.getContext('2d');
            oldCtx.putImageData(_0x4a2ccd.oldData, -bbox[0], -bbox[1]);
            const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
            
            // Get the stroke ID from the current stroke data
            const currentStrokeData = _0x4a2ccd.surface.currentStrokeData;
            const strokeNumber = currentStrokeData ? currentStrokeData.strokeNumber : null;
            
            // Create undo action with consistent format for both brush types
            const undoAction = {
              layer: layerId,
              bbox: bbox,
              oldData: regionOldData,
              newData: newData,
              actionType: "customBrush",
              strokeNumber: strokeNumber // Use strokeNumber consistently for undo tracking
            };
            
            // Store the index of this stroke in the strokes array for easier removal during undo
            if (strokeNumber !== null && _0x4a2ccd.surface.strokes) {
              // Find the index of this stroke in the array
              const strokeIndex = _0x4a2ccd.surface.strokes.findIndex(
                stroke => stroke.strokeNumber === strokeNumber
              );
              
              if (strokeIndex !== -1) {
                // Store the index and stroke info for removal during undo
                undoAction.strokeIndex = strokeIndex;
                undoAction.strokeInfo = {
                  number: strokeNumber,
                  brushName: "custom"
                };
              }
            }
            
            // Push the changes to the undo stack
            room.board.pushUndo(undoAction);
            
            // Add undo handler if it doesn't exist yet
            if (!room.board.originalHandleUndo && room.board.handleUndo) {
              // Store the original method
              room.board.originalHandleUndo = room.board.handleUndo;
              
              // Replace with our enhanced version
              room.board.handleUndo = function(undoAction) {
                // Call the original method first
                const result = room.board.originalHandleUndo(undoAction);
                
                // Now handle stroke removal for both pen and custom brushes
                if (undoAction.strokeInfo && room.myself && room.myself.surface && room.myself.surface.strokes) {
                  // Find by stroke number first
                  const strokeIdx = room.myself.surface.strokes.findIndex(
                    s => s.strokeNumber === undoAction.strokeInfo.number
                  );
                  
                  // If found, remove it
                  if (strokeIdx >= 0) {
                    room.myself.surface.strokes.splice(strokeIdx, 1);
                  }
                }
                
                return result;
              };
            }
          }
          
          // Reset stroke tracking
          _0x4a2ccd.inStroke = false;
          _0x4a2ccd.strokeBBox = null;
          _0x4a2ccd.oldData = null;
          
          _0x4a2ccd["clearSlate"]();
          _0x4a2ccd["removeClicks"]();
          _0x4a2ccd["compositing"] = false;
        };
        _0x35eb62["src"] = this.surface["slate"]["getData"]();
        
      } else {
        // Standard drawing with user's blend mode
        room["board"]["layers"][this["surface"]["currentLayer"]].advCanvas["setCanvasProperties"]({
          linejoin: "round",
          linecap: "round",
          alpha: this["getOption"]("alpha"),
          blendmode: userBlendMode,
          blur: 0,
          linedash: []
        });
        
        var _0x4a2ccd = this,
          _0x35eb62 = new Image();
        _0x35eb62.onload = function () {
          var _0x41ab20 = room["board"]["getContext"](_0x4a2ccd.surface["currentLayer"]);
          _0x41ab20["imageSmoothingEnabled"] = false;
          _0x41ab20["drawImage"](_0x35eb62, 0, 0);
          
          // Only add to undo stack if the brush had an image at the start of the stroke
          if (_0x4a2ccd.surface.isMyself && _0x4a2ccd.strokeBBox && _0x4a2ccd.oldData && _0x4a2ccd.hadImageAtStart) {
            // Ensure bounding box values are integers and valid
            const bbox = [
              Math.max(0, Math.floor(_0x4a2ccd.strokeBBox.minX)),
              Math.max(0, Math.floor(_0x4a2ccd.strokeBBox.minY)),
              Math.min(room.board.canvasWidth, Math.ceil(_0x4a2ccd.strokeBBox.maxX - _0x4a2ccd.strokeBBox.minX)),
              Math.min(room.board.canvasHeight, Math.ceil(_0x4a2ccd.strokeBBox.maxY - _0x4a2ccd.strokeBBox.minY))
            ];
            
            // Ensure minimum size (prevent 0-pixel wide/tall boxes)
            if (bbox[2] < 1) bbox[2] = 1;
            if (bbox[3] < 1) bbox[3] = 1;
            
            // Expand bbox slightly to ensure we capture all affected pixels
            bbox[0] = Math.max(0, bbox[0] - 2);
            bbox[1] = Math.max(0, bbox[1] - 2);
            bbox[2] = Math.min(room.board.canvasWidth - bbox[0], bbox[2] + 4);
            bbox[3] = Math.min(room.board.canvasHeight - bbox[1], bbox[3] + 4);
            
            const layerId = _0x4a2ccd.surface.currentLayer;
            
            // Get the new data only from the affected area
            const newData = _0x41ab20.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
            
            // Extract the same region from the old data
            const oldCanvas = document.createElement('canvas');
            oldCanvas.width = bbox[2];
            oldCanvas.height = bbox[3];
            const oldCtx = oldCanvas.getContext('2d');
            oldCtx.putImageData(_0x4a2ccd.oldData, -bbox[0], -bbox[1]);
            const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
            
            // Get the stroke ID from the current stroke data
            const currentStrokeData = _0x4a2ccd.surface.currentStrokeData;
            const strokeNumber = currentStrokeData ? currentStrokeData.strokeNumber : null;
            
            // Create undo action with consistent format for both brush types
            const undoAction = {
              layer: layerId,
              bbox: bbox,
              oldData: regionOldData,
              newData: newData,
              actionType: "customBrush",
              strokeNumber: strokeNumber // Use strokeNumber consistently for undo tracking
            };
            
            // Store the index of this stroke in the strokes array for easier removal during undo
            if (strokeNumber !== null && _0x4a2ccd.surface.strokes) {
              // Find the index of this stroke in the array
              const strokeIndex = _0x4a2ccd.surface.strokes.findIndex(
                stroke => stroke.strokeNumber === strokeNumber
              );
              
              if (strokeIndex !== -1) {
                // Store the index and stroke info for removal during undo
                undoAction.strokeIndex = strokeIndex;
                undoAction.strokeInfo = {
                  number: strokeNumber,
                  brushName: "custom"
                };
              }
            }
            
            // Push the changes to the undo stack
            room.board.pushUndo(undoAction);
            
            // Add undo handler if it doesn't exist yet
            if (!room.board.originalHandleUndo && room.board.handleUndo) {
              // Store the original method
              room.board.originalHandleUndo = room.board.handleUndo;
              
              // Replace with our enhanced version
              room.board.handleUndo = function(undoAction) {
                // Call the original method first
                const result = room.board.originalHandleUndo(undoAction);
                
                // Now handle stroke removal for both pen and custom brushes
                if (undoAction.strokeInfo && room.myself && room.myself.surface && room.myself.surface.strokes) {
                  // Find by stroke number first
                  const strokeIdx = room.myself.surface.strokes.findIndex(
                    s => s.strokeNumber === undoAction.strokeInfo.number
                  );
                  
                  // If found, remove it
                  if (strokeIdx >= 0) {
                    room.myself.surface.strokes.splice(strokeIdx, 1);
                  }
                }
                
                return result;
              };
            }
          }
          
          // Reset stroke tracking
          _0x4a2ccd.inStroke = false;
          _0x4a2ccd.strokeBBox = null;
          _0x4a2ccd.oldData = null;
          
          _0x4a2ccd["clearSlate"]();
          _0x4a2ccd["removeClicks"]();
          _0x4a2ccd["compositing"] = false;
        };
        _0x35eb62["src"] = this.surface["slate"]["getData"]();
      }
    }
  }
  ["addClick"](_0x44a68b, _0x32694b) {
    this.clickX["push"](_0x44a68b), this["clickY"]["push"](_0x32694b);
  }
  ["removeClicks"]() {
    this["clickX"] = new Array(), this.clickY = new Array();
  }
  ["clearSlate"]() {
    this.contextSlate["clearRect"](0, 0, this.contextSlate["canvas"].width, this["contextSlate"]["canvas"]["height"]);
  }
  ["cancel"]() {
    if (this.inStroke && this.surface.isMyself) {
      
      // Check values to debug what's happening
      const hasPoints = this.clickX && this.clickX.length > 0;
      const hasImage = this.hadImageAtStart === true;
      const hasMovements = this.hasMadeFirstMove === true;
      
      // IMPROVED: Check for SIGNIFICANT option changes only
      // Exclude rotationvalue changes if randomrotation is enabled
      const hasRandomRotation = this.getOption("randomrotation") === true;
      
      // Get all option changes except rotationvalue when randomrotation is enabled
      const significantChanges = {};
      let hasSignificantChanges = false;
      
      if (this._lastOptionChanges) {
        for (const option in this._lastOptionChanges) {
          // Skip rotationvalue changes if randomrotation is enabled
          if (option === 'rotationvalue' && hasRandomRotation) {
            continue;
          }
          // Only include significant options (size, alpha, tint, etc.)
          significantChanges[option] = this._lastOptionChanges[option];
          hasSignificantChanges = true;
        }
      }
      
      // MODIFIED: Only create undo if we have SIGNIFICANT option changes
      // Ignore auto-generated rotationvalue changes from randomrotation
      const shouldCreateUndo = hasImage && 
                            this.strokeBBox && 
                            this.oldData &&
                            hasSignificantChanges; // Now checking significant changes only
      
      if (shouldCreateUndo) {
        
        // Same bbox calculation and undo creation as before
        const bbox = [
          Math.max(0, Math.floor(this.strokeBBox.minX)),
          Math.max(0, Math.floor(this.strokeBBox.minY)),
          Math.min(room.board.canvasWidth - Math.floor(this.strokeBBox.minX), 
                 Math.ceil(this.strokeBBox.maxX - this.strokeBBox.minX)),
          Math.min(room.board.canvasHeight - Math.floor(this.strokeBBox.minY), 
                 Math.ceil(this.strokeBBox.maxY - this.strokeBBox.minY))
        ];
        
        // Rest of code remains the same...
        // Ensure minimum size (prevent 0-pixel wide/tall boxes)
        if (bbox[2] < 1) bbox[2] = 1;
        if (bbox[3] < 1) bbox[3] = 1;
        
        // Expand bbox slightly
        bbox[0] = Math.max(0, bbox[0] - 2);
        bbox[1] = Math.max(0, bbox[1] - 2);
        bbox[2] = Math.min(room.board.canvasWidth - bbox[0], bbox[2] + 4);
        bbox[3] = Math.min(room.board.canvasHeight - bbox[1], bbox[3] + 4);
        
        const layerId = this.surface.currentLayer;
        const ctx = room.board.getContext(layerId);
        
        const newData = ctx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
        
        const oldCanvas = document.createElement('canvas');
        oldCanvas.width = bbox[2];
        oldCanvas.height = bbox[3];
        const oldCtx = oldCanvas.getContext('2d');
        oldCtx.putImageData(this.oldData, -bbox[0], -bbox[1]);
        const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
        
        const currentStrokeData = this.surface.currentStrokeData;
        const strokeNumber = currentStrokeData ? currentStrokeData.strokeNumber : null;
        
        // Create undo action
        const undoAction = {
          layer: layerId,
          bbox: bbox,
          oldData: regionOldData,
          newData: newData,
          actionType: "customBrush",
          strokeNumber: strokeNumber,
          partialStroke: true
        };
        
        if (strokeNumber !== null && this.surface.strokes) {
          const strokeIndex = this.surface.strokes.findIndex(
            stroke => stroke.strokeNumber === strokeNumber
          );
          
          if (strokeIndex !== -1) {
            undoAction.strokeIndex = strokeIndex;
            undoAction.strokeInfo = {
              number: strokeNumber,
              brushName: "custom"
            };
          }
        }
        
        room.board.pushUndo(undoAction);
      } else {
      }
    }
    
    // Always clear slate and remove clicks
    this["clearSlate"]();
    this["removeClicks"]();
    
    // Reset stroke tracking
    if (this.inStroke) {
      this.inStroke = false;
      this.strokeBBox = null;
      this.oldData = null;
      this.hadImageAtStart = false;
      this.hasOptionChangedDuringStroke = false;
      this.hasMadeFirstMove = false;
      this._lastOptionChanges = null;
    }
  }
  ["getSync"]() {
    var _0x2af73b = {};
    return _0x2af73b.clickX = this["clickX"], _0x2af73b.clickY = this["clickY"], _0x2af73b;
  }
  ["setSync"](_0x85510a) {
    this.clickX = _0x85510a["clickX"], this["clickY"] = _0x85510a["clickY"], this["redraw"]();
  }
  ["redraw"]() {
    if (this["brushCache"]) {
      var _0x2286f8 = this["getOption"]("size");
      this.clearSlate(), this["surface"]["slate"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x2286f8,
        strokestyle: this["surface"]["drawColor"],
        alpha: 1,
        blendmode: "normal",
        blur: 0,
        linedash: []
      });
      for (var _0x4ab5d0 = 0; _0x4ab5d0 < this.clickX["length"]; _0x4ab5d0++) {
        this["contextSlate"]["drawImage"](this["brushCache"], this["clickX"][_0x4ab5d0] - _0x2286f8 / 2, this["clickY"][_0x4ab5d0] - _0x2286f8 / 2);
      }
    }
  }

  };
}
})();

class BrushBlurModded extends BrushStub {
  constructor(_0x66f3f6) {
    super(_0x66f3f6);
    this.lastX;
    this.lastY;
    this.advCanvas;
    this.options = {};
    this.options.size = new SizeOption();
    this.options.cursor = new CursorOption("square");
    
    // Add state variables for undo support
    this.inStroke = false;
    this.strokeLayer = null;
    this.boundingBox = null;
    this.originalStateCanvas = null; // Will store a snapshot of the entire canvas before any blur
  }
  
  brushStart() {
    this.advCanvas = new AdvancedCanvas(this.getOption("size"), this.getOption("size"));
    this.surface.cursor.changePointer(this.getOption("cursor"));
  }
  
  brushStop() {
    this.advCanvas.remove();
    if (this.originalStateCanvas) {
      this.originalStateCanvas.remove();
      this.originalStateCanvas = null;
    }
  }
  
  optionChanged(_0x3d62a1, _0xfc9ef8) {
    _0x3d62a1 == "cursor" && this.surface.cursor.changePointer(_0xfc9ef8);
  }
  
  drawStart(_0x1af9b7, _0x24519f, _0x1b5db1) {
    // Mark that we're starting a stroke
    this.inStroke = true;
    this.strokeLayer = this.surface.currentLayer;
    
    // Initialize bounding box for the blur stroke
    const brushSize = this.getOption("size");
    const padding = Math.max(10, brushSize); // Extra padding for blur effects
    
    this.boundingBox = {
      minX: Math.max(0, Math.floor(_0x1af9b7 - brushSize/2 - padding)),
      minY: Math.max(0, Math.floor(_0x24519f - brushSize/2 - padding)),
      maxX: Math.min(room.board.canvasWidth, Math.ceil(_0x1af9b7 + brushSize/2 + padding)),
      maxY: Math.min(room.board.canvasHeight, Math.ceil(_0x24519f + brushSize/2 + padding))
    };
    
    // Create a full snapshot of the canvas BEFORE any blur - ONLY for my strokes
    if (this.surface.isMyself) {
      const ctx = room.board.getContext(this.strokeLayer);
      
      // Create a new canvas to store the original state
      this.originalStateCanvas = document.createElement('canvas');
      this.originalStateCanvas.width = ctx.canvas.width;
      this.originalStateCanvas.height = ctx.canvas.height;
      const tempCtx = this.originalStateCanvas.getContext('2d');
      
      // Copy the entire canvas
      tempCtx.drawImage(ctx.canvas, 0, 0);
    }
    
    this.drawBlur(_0x1af9b7, _0x24519f);
    this.lastX = _0x1af9b7;
    this.lastY = _0x24519f;
  }
  
  drawStep(_0x57a293, _0x44ee3a, _0x5d5de7) {
    if (this.getDistance(_0x57a293.x, _0x57a293.y, this.lastX, this.lastY) >= this.getOption("size") / 4) {
      // Update bounding box with brush size and padding
      const brushSize = this.getOption("size");
      const padding = Math.max(10, brushSize);
      
      if (this.boundingBox) {
        this.boundingBox.minX = Math.min(this.boundingBox.minX, Math.max(0, Math.floor(_0x57a293.x - brushSize/2 - padding)));
        this.boundingBox.minY = Math.min(this.boundingBox.minY, Math.max(0, Math.floor(_0x57a293.y - brushSize/2 - padding)));
        this.boundingBox.maxX = Math.max(this.boundingBox.maxX, Math.min(room.board.canvasWidth, Math.ceil(_0x57a293.x + brushSize/2 + padding)));
        this.boundingBox.maxY = Math.max(this.boundingBox.maxY, Math.min(room.board.canvasHeight, Math.ceil(_0x57a293.y + brushSize/2 + padding)));
      }
      
      // Apply blur but don't create undo actions yet
      this.drawBlur(_0x57a293.x, _0x57a293.y);
      this.lastX = _0x57a293.x;
      this.lastY = _0x57a293.y;
    }
  }
  
  drawEnd(_0x15f7fb, _0x3df570, _0x5d5de7) {
    if (!this.inStroke) return; // Safety check
    
    // Apply one final blur if needed
    if (this.getDistance(_0x15f7fb, _0x3df570, this.lastX, this.lastY) >= this.getOption("size") / 4) {
      // Update bounding box one last time
      const brushSize = this.getOption("size");
      const padding = Math.max(10, brushSize);
      
      if (this.boundingBox) {
        this.boundingBox.minX = Math.min(this.boundingBox.minX, Math.max(0, Math.floor(_0x15f7fb - brushSize/2 - padding)));
        this.boundingBox.minY = Math.min(this.boundingBox.minY, Math.max(0, Math.floor(_0x3df570 - brushSize/2 - padding)));
        this.boundingBox.maxX = Math.max(this.boundingBox.maxX, Math.min(room.board.canvasWidth, Math.ceil(_0x15f7fb + brushSize/2 + padding)));
        this.boundingBox.maxY = Math.max(this.boundingBox.maxY, Math.min(room.board.canvasHeight, Math.ceil(_0x3df570 + brushSize/2 + padding)));
      }
      
      this.drawBlur(_0x15f7fb, _0x3df570);
    }
    
    // After completing the stroke, handle undo - ONLY if this is the local user
    if (this.surface.isMyself && this.boundingBox && this.originalStateCanvas) {
      // Get the current context
      const ctx = room.board.getContext(this.strokeLayer);
      
      // Calculate the bbox for the undo operation - ensure integer coordinates
      const bbox = [
        Math.max(0, Math.floor(this.boundingBox.minX)),
        Math.max(0, Math.floor(this.boundingBox.minY)),
        Math.min(ctx.canvas.width - Math.floor(this.boundingBox.minX), 
                Math.ceil(this.boundingBox.maxX - this.boundingBox.minX)),
        Math.min(ctx.canvas.height - Math.floor(this.boundingBox.minY), 
                Math.ceil(this.boundingBox.maxY - this.boundingBox.minY))
      ];
      
      // Get the original image data from our saved canvas
      const originalCtx = this.originalStateCanvas.getContext('2d');
      const originalData = originalCtx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
      
      // Get the current (post-blur) state
      const newData = ctx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
      
      // Push to undo stack - now with full stroke as single action
      room.board.pushUndo({
        layer: this.strokeLayer,
        bbox: bbox,
        oldData: originalData,
        newData: newData,
        isFullStroke: true  // Mark this as a full stroke action
      });
    }
    
    // Reset stroke tracking
    this.inStroke = false;
    this.strokeLayer = null;
    if (this.originalStateCanvas) {
      this.originalStateCanvas.remove();
      this.originalStateCanvas = null;
    }
    this.boundingBox = null;
  }
  
  cancel() {
    // Reset stroke tracking if canceling mid-stroke
    if (this.inStroke) {
      this.inStroke = false;
      this.strokeLayer = null;
      if (this.originalStateCanvas) {
        this.originalStateCanvas.remove();
        this.originalStateCanvas = null;
      }
      this.boundingBox = null;
    }
  }
  
  drawBlur(_0x15f7fb, _0x3df570) {
    const brushSize = this.getOption("size");
    const x = Math.max(0, Math.floor(_0x15f7fb - brushSize/2));
    const y = Math.max(0, Math.floor(_0x3df570 - brushSize/2));
    
    // Ensure we don't go out of bounds
    const effectiveWidth = Math.min(brushSize, room.board.canvasWidth - x);
    const effectiveHeight = Math.min(brushSize, room.board.canvasHeight - y);
    
    if (effectiveWidth <= 0 || effectiveHeight <= 0) return;
    
    // Get the image data for the region we're about to blur
    var _0x38faa4 = room.board.getImageData(
      this.surface.currentLayer, 
      x, y, effectiveWidth, effectiveHeight
    );
    
    // Get the context for the layer we're working on
    var _0x4db252 = room.board.getContext(this.surface.currentLayer);
    
    // Prepare the advanced canvas
    this.advCanvas.changeSize(effectiveWidth, effectiveHeight);
    this.advCanvas.putImageData(_0x38faa4);
    
    // Apply blur effect
    this.advCanvas.blur(1);
    
    // Put the blurred data back to the exact same position
    _0x4db252.putImageData(this.advCanvas.getImageData(), x, y);
  }
  
  getSync() {
    // Return information needed to synchronize this brush state
    var syncData = {};
    if (this.inStroke) {
      syncData.lastX = this.lastX;
      syncData.lastY = this.lastY;
      syncData.boundingBox = this.boundingBox;
    }
    return syncData;
  }
  
  setSync(syncData) {
    // Apply synchronized state
    if (syncData.lastX && syncData.lastY) {
      this.drawBlur(syncData.lastX, syncData.lastY);
      this.lastX = syncData.lastX;
      this.lastY = syncData.lastY;
      this.boundingBox = syncData.boundingBox;
    }
  }
}
class BrushPixelModded extends BrushStub {
  constructor(_0xee5f3e) {
    super(_0xee5f3e);
    this.clickX = new Array();
    this.clickY = new Array();
    this.options = {};
    this.options.size = new SizeOption();
    this.options.drawgrid = new DrawGridOption(true);
    this.options.erasermode = new EraserModeOption();
    this.options.rightclick = new RightClickOption("pixel");
    this.options.cursor = new CursorOption("square");
    this.options.locktransparency = new LockTransparencyOption(); // Add Lock Transparency option
    
    // Add state variables for undo support
    this.inStroke = false;
    this.oldData = null;
    this.pixelBBox = null;
    
    // Add tracking for option changes and first pixel placement
    this.hasOptionChangedDuringStroke = false;
    this.hasMadeFirstMove = false;
    this._lastOptionChanges = {};
  }
  
  ["brushStart"]() {
    this.surface.cursor.changePointer(this.getOption("cursor"));
    this.drawGrid();
  }
  
  ["brushStop"]() {
    this.clearSlate();
  }
  
  ["drawStart"](_0x224047, _0x3994ca, _0x1a01ee) {
    // Mark that we're starting a stroke
    this.inStroke = true;
    this.hasMadeFirstMove = false; // Reset first move flag
    this.hasOptionChangedDuringStroke = false; // Reset option changes tracking
    this._lastOptionChanges = {};
    
    // Initialize bounding box for pixel stroke
    const pixelSize = this.getOption("size");
    const pixelX = Math.floor(_0x224047 / pixelSize);
    const pixelY = Math.floor(_0x3994ca / pixelSize);
    
    this.pixelBBox = {
      minX: pixelX * pixelSize,
      minY: pixelY * pixelSize,
      maxX: (pixelX + 1) * pixelSize,
      maxY: (pixelY + 1) * pixelSize
    };
    
    // Save the original state ONLY if this is the local user's drawing
    if (this.surface.isMyself) {
      const ctx = room.board.getContext(this.surface.currentLayer);
      this.oldData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    }
    
    this.setupSlate();
    this.removeClicks();
    
    // Mark that we've made our first move
    this.hasMadeFirstMove = true;
    
    this.addClick(pixelX, pixelY);
    if (this.getOption("erasermode")) {
      this.composite();
      this.drawGrid();
    } else {
      this.contextSlate.fillRect(pixelX * pixelSize, pixelY * pixelSize, pixelSize, pixelSize);
    }
  }
  
  ["drawStep"](_0x4ba038, _0x156579, _0x42df1e) {
    // Already marked hasMadeFirstMove in drawStart since we place a pixel immediately
    
    var _0x2a953 = this.getOption("size"),
      _0x3f4cb1 = new Array();
    
    this.getOption("erasermode") ? _0x3f4cb1.push(new Point(_0x156579.x, _0x156579.y)) : _0x3f4cb1 = this.calculateLine(_0x4ba038.x, _0x4ba038.y, _0x156579.x, _0x156579.y);
    
    var _0x339733 = this;
    $.each(_0x3f4cb1, function (_0x1f1b51, _0x45fba5) {
      var _0x3bec86 = Math.floor(_0x45fba5.x / _0x2a953),
        _0x12acff = Math.floor(_0x45fba5.y / _0x2a953);
      
      if (!_0x339733.clickExists(_0x3bec86, _0x12acff)) {
        _0x339733.addClick(_0x3bec86, _0x12acff);
        
        // Update bounding box for undo
        if (_0x339733.pixelBBox) {
          _0x339733.pixelBBox.minX = Math.min(_0x339733.pixelBBox.minX, _0x3bec86 * _0x2a953);
          _0x339733.pixelBBox.minY = Math.min(_0x339733.pixelBBox.minY, _0x12acff * _0x2a953);
          _0x339733.pixelBBox.maxX = Math.max(_0x339733.pixelBBox.maxX, (_0x3bec86 + 1) * _0x2a953);
          _0x339733.pixelBBox.maxY = Math.max(_0x339733.pixelBBox.maxY, (_0x12acff + 1) * _0x2a953);
        }
        
        _0x339733.getOption("erasermode") ? (_0x339733.composite(), _0x339733.drawGrid()) : _0x339733.contextSlate.fillRect(_0x3bec86 * _0x2a953, _0x12acff * _0x2a953, _0x2a953, _0x2a953);
      }
    });
  }
  
  ["optionChange"](_0x342843, _0x156b59) {
    // Track option changes, but only if we've already started placing pixels
    if (this.inStroke && this.hasMadeFirstMove) {
        
      this.hasOptionChangedDuringStroke = true;
      
      // Track which specific options changed
      if (!this._lastOptionChanges) this._lastOptionChanges = {};
      this._lastOptionChanges[_0x342843] = _0x156b59;
    }
    
    // Original behavior
    if (_0x342843 == "size") {
      var _0x4901be = this.clickX.length;
      _0x4901be > 0 && this.composite();
    }
  }
  
  ["drawEnd"](_0x318789, _0x319502, _0x38e559) {
    this.composite();
    this.clearSlate();
    this.drawGrid();
    
    // After completing the stroke, push to undo stack
    // ONLY if this is the local user's drawing
    if (this.surface.isMyself && this.inStroke && this.oldData && this.pixelBBox) {
      const layer = this.surface.currentLayer;
      const ctx = room.board.getContext(layer);
      
      // Ensure bounding box values are integers and valid
      const bbox = [
        Math.max(0, Math.floor(this.pixelBBox.minX)),
        Math.max(0, Math.floor(this.pixelBBox.minY)),
        Math.min(room.board.canvasWidth - Math.floor(this.pixelBBox.minX), 
                Math.ceil(this.pixelBBox.maxX - this.pixelBBox.minX)),
        Math.min(room.board.canvasHeight - Math.floor(this.pixelBBox.minY), 
                Math.ceil(this.pixelBBox.maxY - this.pixelBBox.minY))
      ];
      
      // Get the new data from the affected area
      const newData = ctx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
      
      // Extract the same region from the old data
      const oldCanvas = document.createElement('canvas');
      oldCanvas.width = bbox[2];
      oldCanvas.height = bbox[3];
      const oldCtx = oldCanvas.getContext('2d');
      oldCtx.putImageData(this.oldData, -bbox[0], -bbox[1]);
      const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
      
      // Push this as an undo action
      room.board.pushUndo({
        layer: layer,
        bbox: bbox,
        oldData: regionOldData,
        newData: newData
      });
    }
    
    // Reset stroke tracking
    this.inStroke = false;
    this.oldData = null;
    this.pixelBBox = null;
  }
  
  ["composite"]() {
    var _0x212574 = this.getOption("size");
    
    // Determine the blend mode:
    // - If eraser mode is on, use destination-out (eraser takes precedence)
    // - If lock transparency is on, use source-atop
    // - Otherwise use normal
    var _0xc7d52f = "normal";
    
    if (this.getOption("erasermode")) {
      _0xc7d52f = "destination-out";
    } else if (this.getOption("locktransparency")) {
      _0xc7d52f = "source-atop";
    }
    
    room.board.layers[this.surface.currentLayer].advCanvas.setCanvasProperties({
      fillstyle: _0xc7d52f == "normal" || _0xc7d52f == "source-atop" ? this.surface.drawColor : room.board.backgroundColor,
      alpha: 1,
      blendmode: _0xc7d52f,
      blur: 0,
      linedash: []
    });
    
    var _0x5c8b03 = room.board.getContext(this.surface.currentLayer);
    for (var _0x50c913 = 0; _0x50c913 < this.clickX.length; _0x50c913++) {
      _0x5c8b03.fillRect(this.clickX[_0x50c913] * _0x212574, this.clickY[_0x50c913] * _0x212574, _0x212574, _0x212574);
    }
    
    this.removeClicks();
    this.clearSlate();
  }
    
  ["addClick"](_0x140f1a, _0x5e886a) {
    this.clickX.push(_0x140f1a);
    this.clickY.push(_0x5e886a);
  }
  
  ["removeClicks"]() {
    this.clickX = new Array();
    this.clickY = new Array();
  }
  
  ["clickExists"](_0x163e11, _0x4a833f) {
    for (var _0xc84aee = 0; _0xc84aee < this.clickX.length; _0xc84aee++) {
      if (this.clickX[_0xc84aee] == _0x163e11 && this.clickY[_0xc84aee] == _0x4a833f) return true;
    }
    return false;
  }
  
  ["optionChanged"](_0x4fb3c5, _0x273cd5) {
    if (_0x4fb3c5 == "size") this.clickX.length > 0 ? this.composite() : this.clearSlate(), this.drawGrid(); else {
      if (_0x4fb3c5 == "drawgrid") this.clickX.length > 0 ? this.composite() : this.clearSlate(), this.drawGrid(); else _0x4fb3c5 == "cursor" && this.surface.cursor.changePointer(_0x273cd5);
    }
  }
  
  ["drawGrid"]() {
    var _0x417588 = this.getOption("size");
    if (this.getOption("drawgrid") && _0x417588 >= 3 && this.surface.isMyself) {
      this.surface.slate.setCanvasProperties({
        linejoin: "round",
        linecap: "round",
        linewidth: 1,
        strokestyle: "#808080",
        alpha: 1,
        blendmode: "normal",
        blur: 0,
        linedash: []
      });
      
      this.surface.slate.setCSSProperties({
        alpha: 1,
        blendmode: "normal",
        blur: 0
      });
      
      this.contextSlate.beginPath();
      for (var _0x19a0c9 = 0; _0x19a0c9 < room.board.canvasWidth / _0x417588; _0x19a0c9++) {
        this.contextSlate.moveTo(_0x19a0c9 * _0x417588, 0);
        this.contextSlate.lineTo(_0x19a0c9 * _0x417588, room.board.canvasHeight);
      }
      for (var _0x9234cc = 0; _0x9234cc < room.board.canvasHeight / _0x417588; _0x9234cc++) {
        this.contextSlate.moveTo(0, _0x9234cc * _0x417588);
        this.contextSlate.lineTo(room.board.canvasWidth, _0x9234cc * _0x417588);
      }
      this.contextSlate.stroke();
    }
  }
  
  ["setupSlate"]() {
    this.surface.slate.setCanvasProperties({
      fillstyle: this.surface.drawColor,
      alpha: 1,
      blendmode: "normal",
      blur: 0
    });
    
    this.surface.slate.setCSSProperties({
      alpha: 1,
      blendmode: "normal",
      blur: 0
    });
  }
  
  ["clearSlate"]() {
    this.contextSlate.clearRect(0, 0, this.contextSlate.canvas.width, this.contextSlate.canvas.height);
  }
  
  ["cancel"]() {
    if (this.inStroke && this.surface.isMyself) {
      
      // Check if we should create an undo entry
      // Only create undo if we placed pixels AND options changed AFTER pixel placement began
      const hasMadePixelChanges = this.hasMadeFirstMove === true;
      
      const shouldCreateUndo = hasMadePixelChanges && 
                              this.hasOptionChangedDuringStroke === true && 
                              this.oldData && 
                              this.pixelBBox;
      
      if (shouldCreateUndo) {
        
        const layer = this.surface.currentLayer;
        const ctx = room.board.getContext(layer);
        
        // Ensure bounding box values are integers and valid
        const bbox = [
          Math.max(0, Math.floor(this.pixelBBox.minX)),
          Math.max(0, Math.floor(this.pixelBBox.minY)),
          Math.min(room.board.canvasWidth - Math.floor(this.pixelBBox.minX), 
                  Math.ceil(this.pixelBBox.maxX - this.pixelBBox.minX)),
          Math.min(room.board.canvasHeight - Math.floor(this.pixelBBox.minY), 
                  Math.ceil(this.pixelBBox.maxY - this.pixelBBox.minY))
        ];
        
        // Get the new data from the affected area
        const newData = ctx.getImageData(bbox[0], bbox[1], bbox[2], bbox[3]);
        
        // Extract the same region from the old data
        const oldCanvas = document.createElement('canvas');
        oldCanvas.width = bbox[2];
        oldCanvas.height = bbox[3];
        const oldCtx = oldCanvas.getContext('2d');
        oldCtx.putImageData(this.oldData, -bbox[0], -bbox[1]);
        const regionOldData = oldCtx.getImageData(0, 0, bbox[2], bbox[3]);
        
        // Push this as an undo action
        room.board.pushUndo({
          layer: layer,
          bbox: bbox,
          oldData: regionOldData,
          newData: newData,
          partialStroke: true
        });
      } else {
      }
    }
    
    // Always clear slate and remove clicks
    this.clearSlate();
    this.removeClicks();
    
    // Reset stroke tracking if canceling in the middle of a stroke
    if (this.inStroke) {
      this.inStroke = false;
      this.oldData = null;
      this.pixelBBox = null;
      this.hasOptionChangedDuringStroke = false;
      this.hasMadeFirstMove = false;
      this._lastOptionChanges = null;
    }
    
    // Redraw the grid if needed
    this.drawGrid();
  }
  
  ["isUsingSlate"]() {
    return this.surface.isMyself && this.getOption("drawgrid");
  }
}
class BrushPen extends BrushStub {
constructor(_0x2222ae) {
  super(_0x2222ae), this.clickX = new Array(), this.clickY = new Array(), this.lastPosition, this["distance"], this["options"] = {}, this["options"]["size"] = new SizeOption(), this["options"]["alpha"] = new AlphaOption(), this.options["blur"] = new BlurOption(), this["options"]["smooth"] = new SmoothOption(), this["options"]["spacing"] = new SpacingOption(0), this.options["blendmode"] = new BlendModeOption(), this.options["pressure"] = new PressureOption([true, 1]), this["options"].rightclick = new RightClickOption("pen"), this["options"].cursor = new CursorOption("circle"), this.options["togglepressureopacity"] = new PressureOpacityOption();
  this.options["locktransparency"] = new LockTransparencyOption(); // Add this line
}
  ["brushStart"]() {
    this.surface["cursor"]["changePointer"](this.getOption("cursor"));
  }
  ["drawStart"](_0x483e39, _0x205d89, _0x1b587b) {
    this.setupSlate(), this.removeClicks(), this["addClick"](_0x483e39, _0x205d89), this.contextSlate["beginPath"](), this["lastPosition"] = null, this["distance"] = 0, this["getOption"]("spacing") > 0 && (this["contextSlate"]["moveTo"](_0x483e39, _0x205d89), this["contextSlate"]["lineTo"](_0x483e39, _0x205d89), this["contextSlate"].stroke());
  }
  ["drawStep"](_0x684ce0, _0x5c5254, _0x1cb21d) {
    var _0x1869b1 = true;
    this.surface["isMyself"] && UI["userPreferences"]["getProperty"]("strokequality", "high") == "high" && (_0x1869b1 = false);
    if (this["getOption"]("spacing") > 0) this.distance += this["getDistance"](_0x684ce0.x, _0x684ce0.y, _0x5c5254.x, _0x5c5254.y), this.distance >= this["getOption"]("size") * (this["getOption"]("spacing") / 15) && (this["addClick"](_0x5c5254.x, _0x5c5254.y), _0x1869b1 && (this["contextSlate"]["moveTo"](_0x5c5254.x, _0x5c5254.y), this.contextSlate["lineTo"](_0x5c5254.x, _0x5c5254.y), this["contextSlate"]["stroke"]()), this["distance"] = 0);
     else {
      this["addClick"](_0x5c5254.x, _0x5c5254.y);
      var _0x3373e7 = (_0x5c5254.x + _0x684ce0.x) / 2,
        _0x66c8f1 = (_0x5c5254.y + _0x684ce0.y) / 2;
      _0x1869b1 && (this["contextSlate"].beginPath(), this["lastPosition"] ? this["contextSlate"].moveTo(this["lastPosition"].x, this.lastPosition.y) : this["contextSlate"].moveTo(_0x684ce0.x, _0x684ce0.y), this["contextSlate"]["quadraticCurveTo"](_0x684ce0.x, _0x684ce0.y, _0x3373e7, _0x66c8f1), this["contextSlate"].stroke()), this.lastPosition = new Point(_0x3373e7, _0x66c8f1);
    }
    this["surface"]["isMyself"] && UI["userPreferences"]["getProperty"]("strokequality", "high") == "high" && this["redraw"]();
  }
  ["drawEnd"](_0x287f6c, _0x491ceb, _0x1cd8db) {
    this.getOption("spacing") == 0 && this["addClick"](_0x287f6c, _0x491ceb), this.composite();
  }
  ["optionChange"](_0x5b4d99, _0x52b65e) {
    var _0x7b21d6 = this["clickX"]["length"];
    if (_0x7b21d6 > 0) {
      // This seems to print whenever you change brush settings WHILE drawing
      var _0xd27fd6 = new Point(this["clickX"][_0x7b21d6 - 1], this["clickY"][_0x7b21d6 - 1]);
      this["composite"](), this.getOption("spacing") == 0 && this["addClick"](_0xd27fd6.x, _0xd27fd6.y), this.contextSlate["beginPath"](), this.contextSlate.moveTo(_0xd27fd6.x, _0xd27fd6.y);
    }
  }
  ["optionChanged"](_0xfe7535, _0x27c2b3) {
    this.setupSlate(), _0xfe7535 == "cursor" && this["surface"]["cursor"]["changePointer"](_0x27c2b3);
  }
  ["colorChange"](_0x5a726f) {
    var _0x36f91b = this["clickX"]["length"];
    if (_0x36f91b > 0) {
      var _0x5df15a = new Point(this["clickX"][_0x36f91b - 1], this.clickY[_0x36f91b - 1]);
      this["composite"](), this.addClick(_0x5df15a.x, _0x5df15a.y);
    }
  }
  ["colorChanged"](_0x3b26d3) {
    this["setupSlate"]();
  }
  ["setupSlate"]() {
    var _0x5d2d36 = this["getOption"]("pressure")[0] ? this.getOption("pressure")[1] : 1,
      _0x1fa2f1 = Math["max"](this["getOption"]("size") * _0x5d2d36, 1);
    
    // For the drawing canvas properties, use normal blend mode for better performance
    this.surface["slate"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: _0x1fa2f1,
      strokestyle: this["surface"]["drawColor"],
      alpha: 1,
      blendmode: "normal",
      blur: 0,
      linedash: []
    });
    
    // For the CSS preview, check if transparency is locked
    const lockTransparency = this.getOption("locktransparency");
    const previewBlendMode = lockTransparency ? "source-atop" : (this.getOption("blendmode") || "normal");
    
    this["surface"]["slate"]["setCSSProperties"]({
      alpha: this["getOption"]("alpha"),
      blendmode: previewBlendMode,
      blur: this.getOption("blur")
    });
  }
  ["compositeSpacing"]() {
    var _0x1bf1dc = this["getOption"]("pressure")[0] ? this.getOption("pressure")[1] : 1,
    _0x4e4b96 = Math["max"](this["getOption"]("size") * _0x1bf1dc, 1);
    
    // Get user's chosen blend mode and transparency lock status
    const lockTransparency = this.getOption("locktransparency");
    
    // If pressure is ON and transparency is locked, use source-atop only
    // Otherwise use user's blend mode
    const isPressureEnabled = this["getOption"]("pressure")[0] || this.getOption("togglepressureopacity");;
    const userBlendMode = this["getOption"]("blendmode") || "normal";
    const blendMode = (isPressureEnabled && lockTransparency) ? "source-atop" : userBlendMode;
        
    var _0x1e47ec = room["board"].getContext(this["surface"]["currentLayer"]);
    
    if (lockTransparency && !isPressureEnabled) {
      // Two-step process for locked transparency - only when pressure is OFF
      // ... [existing complex transparency lock implementation] ...
      
      // Step 1: Save the current canvas state
      const currentState = _0x1e47ec.getImageData(0, 0, _0x1e47ec.canvas.width, _0x1e47ec.canvas.height);
      
      // Apply the stroke with user's blend mode
      room["board"].layers[this.surface["currentLayer"]].advCanvas["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x4e4b96,
        strokestyle: this.surface.drawColor,
        alpha: this.getOption("alpha"),
        blendmode: userBlendMode,
        blur: this.getOption("blur"),
        linedash: []
      });
      
      // Draw the dots
      _0x1e47ec["beginPath"]();
      for (var _0x4d6eb4 = 0; _0x4d6eb4 < this["clickX"]["length"]; _0x4d6eb4++) {
        _0x1e47ec["moveTo"](this["clickX"][_0x4d6eb4], this["clickY"][_0x4d6eb4]), _0x1e47ec["lineTo"](this["clickX"][_0x4d6eb4], this["clickY"][_0x4d6eb4]);
      }
      _0x1e47ec["stroke"]();
      
      // Step 2: Get the result after drawing
      const newState = _0x1e47ec.getImageData(0, 0, _0x1e47ec.canvas.width, _0x1e47ec.canvas.height);
      
      // Step 3: Preserve original alpha values
      const resultData = newState.data;
      const originalData = currentState.data;
      
      for (let i = 0; i < resultData.length; i += 4) {
        // Preserve original transparency levels
        const originalAlpha = originalData[i + 3];
        const newAlpha = resultData[i + 3];
        
        // If a pixel was originally semitransparent, keep it semitransparent
        if (originalAlpha < 255) {
          resultData[i + 3] = Math.min(newAlpha, originalAlpha);
        }
      }
      
      // Update canvas with masked result
      _0x1e47ec.putImageData(newState, 0, 0);
      
    } else {
      // Standard drawing approach with conditional blend mode
      room["board"].layers[this.surface["currentLayer"]].advCanvas["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x4e4b96,
        strokestyle: this.surface.drawColor,
        alpha: this.getOption("alpha"),
        blendmode: blendMode,
        blur: this.getOption("blur"),
        linedash: []
      });
      
      _0x1e47ec["beginPath"]();
      for (var _0x4d6eb4 = 0; _0x4d6eb4 < this["clickX"]["length"]; _0x4d6eb4++) {
        _0x1e47ec["moveTo"](this["clickX"][_0x4d6eb4], this["clickY"][_0x4d6eb4]), _0x1e47ec["lineTo"](this["clickX"][_0x4d6eb4], this["clickY"][_0x4d6eb4]);
      }
      _0x1e47ec["stroke"]();
    }
  }
  
  ["compositeRegular"]() {
    var _0x1049b5 = this["getOption"]("pressure")[0] ? this["getOption"]("pressure")[1] : 1,
      _0x3945ba = Math["max"](this["getOption"]("size") * _0x1049b5, 1);
    
    // Get user's chosen blend mode and transparency lock status
    const lockTransparency = this.getOption("locktransparency");
    
    // If pressure is ON and transparency is locked, use source-atop only
    // Otherwise use user's blend mode
    const isPressureEnabled = this["getOption"]("pressure")[0] || this.getOption("togglepressureopacity");;
    const userBlendMode = this["getOption"]("blendmode") || "normal";
    const blendMode = (isPressureEnabled && lockTransparency) ? "source-atop" : userBlendMode;
    
    var _0x2061c5 = room["board"].getContext(this.surface["currentLayer"]);
    
    if (lockTransparency && !isPressureEnabled) {
      // Two-step process for locked transparency - only when pressure is OFF
      // ... [existing complex transparency lock implementation] ...
      
      // Step 1: Save the current canvas state
      const currentState = _0x2061c5.getImageData(0, 0, _0x2061c5.canvas.width, _0x2061c5.canvas.height);
      
      // Apply the stroke with normal blending
      room["board"]["layers"][this["surface"].currentLayer]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x3945ba,
        strokestyle: this.surface["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: userBlendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the stroke
      if (this["clickX"]["length"] < 6) {
        var _0x359e38 = new Point(this["clickX"][0], this["clickY"][0]);
        _0x2061c5["beginPath"](), _0x2061c5["moveTo"](this.clickX[0], this["clickY"][0]);
        for (var _0x1689cc = 1; _0x1689cc < this["clickX"]["length"]; _0x1689cc++) {
          _0x2061c5["lineTo"](this.clickX[_0x1689cc], this["clickY"][_0x1689cc]);
        }
      } else {
        _0x2061c5["beginPath"](), _0x2061c5["moveTo"](this.clickX[0], this["clickY"][0]);
        for (var _0x1689cc = 1; _0x1689cc < this.clickX["length"] - 2; _0x1689cc++) {
          var _0x20fd76 = (this["clickX"][_0x1689cc] + this["clickX"][_0x1689cc + 1]) / 2,
            _0xd09e9f = (this["clickY"][_0x1689cc] + this.clickY[_0x1689cc + 1]) / 2;
          _0x2061c5["quadraticCurveTo"](this["clickX"][_0x1689cc], this.clickY[_0x1689cc], _0x20fd76, _0xd09e9f);
        }
        _0x2061c5["quadraticCurveTo"](this["clickX"][_0x1689cc], this.clickY[_0x1689cc], this.clickX[_0x1689cc + 1], this["clickY"][_0x1689cc + 1]);
      }
      _0x2061c5["stroke"]();
      
      // Step 2: Get the result after drawing the stroke
      const newState = _0x2061c5.getImageData(0, 0, _0x2061c5.canvas.width, _0x2061c5.canvas.height);
      
      // Step 3: Preserve original alpha values instead of binary transparent/opaque
      const resultData = newState.data;
      const originalData = currentState.data;
      
      for (let i = 0; i < resultData.length; i += 4) {
        // Preserve the original alpha value - multiply by original alpha percentage
        const originalAlpha = originalData[i + 3];
        const newAlpha = resultData[i + 3];
        
        // If a pixel was originally semitransparent, keep it semitransparent
        // Calculate new alpha based on original alpha percentage
        if (originalAlpha < 255) {
          // Scale the new alpha by the original alpha percentage
          resultData[i + 3] = Math.min(newAlpha, originalAlpha);
        }
      }
      
      // Update canvas with masked result
      _0x2061c5.putImageData(newState, 0, 0);
      
    } else {
      // Standard drawing with conditional blend mode
      room["board"]["layers"][this["surface"].currentLayer]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round", 
        linewidth: _0x3945ba,
        strokestyle: this.surface["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: blendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the stroke
      if (this["clickX"]["length"] < 6) {
        var _0x359e38 = new Point(this["clickX"][0], this["clickY"][0]);
        _0x2061c5["beginPath"](), _0x2061c5["moveTo"](this.clickX[0], this["clickY"][0]);
        for (var _0x1689cc = 1; _0x1689cc < this["clickX"]["length"]; _0x1689cc++) {
          _0x2061c5["lineTo"](this.clickX[_0x1689cc], this["clickY"][_0x1689cc]);
        }
      } else {
        _0x2061c5["beginPath"](), _0x2061c5["moveTo"](this.clickX[0], this["clickY"][0]);
        for (var _0x1689cc = 1; _0x1689cc < this.clickX["length"] - 2; _0x1689cc++) {
          var _0x20fd76 = (this["clickX"][_0x1689cc] + this["clickX"][_0x1689cc + 1]) / 2,
            _0xd09e9f = (this["clickY"][_0x1689cc] + this.clickY[_0x1689cc + 1]) / 2;
          _0x2061c5["quadraticCurveTo"](this["clickX"][_0x1689cc], this.clickY[_0x1689cc], _0x20fd76, _0xd09e9f);
        }
        _0x2061c5["quadraticCurveTo"](this["clickX"][_0x1689cc], this.clickY[_0x1689cc], this.clickX[_0x1689cc + 1], this["clickY"][_0x1689cc + 1]);
      }
      _0x2061c5["stroke"]();
    }
  }
  
  ["compositeSmooth"]() {
    var _0x18f04c = this["getOption"]("pressure")[0] ? this.getOption("pressure")[1] : 1,
      _0x3f50f8 = Math["max"](this["getOption"]("size") * _0x18f04c, 1);
    
    // Get user's chosen blend mode and transparency lock status
    const lockTransparency = this.getOption("locktransparency");
    
    // If pressure is ON and transparency is locked, use source-atop only
    // Otherwise use user's blend mode
    const isPressureEnabled = this["getOption"]("pressure")[0] || this.getOption("togglepressureopacity");;
    const userBlendMode = this["getOption"]("blendmode") || "normal";
    const blendMode = (isPressureEnabled && lockTransparency) ? "source-atop" : userBlendMode;
    
    var _0x5efeb3 = room.board.getContext(this.surface["currentLayer"]);
    
    if (lockTransparency && !isPressureEnabled) {
      // Two-step process for locked transparency - only when pressure is OFF
      // ... [existing complex transparency lock implementation] ...
      
      // Step 1: Save the current canvas state
      const currentState = _0x5efeb3.getImageData(0, 0, _0x5efeb3.canvas.width, _0x5efeb3.canvas.height);
      
      // Apply the stroke with user's blend mode
      room["board"]["layers"][this["surface"]["currentLayer"]]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x3f50f8,
        strokestyle: this["surface"]["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: userBlendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the smooth path
      var _0x54b90d, _0xdb0823, _0x5d5462, _0x532223,
        _0x3dbf9d = parseInt(this["getOption"]("smooth") > this["clickX"].length / 3 ? this["clickX"].length / 3 : this.getOption("smooth") + 1);
      _0x5d5462 = null, _0x532223 = null;
      
      _0x5efeb3.beginPath(), _0x5efeb3.moveTo(this["clickX"][0], this["clickY"][0]);
      var _0x382947 = this.clickX["length"];
      for (var _0x544aed = _0x3dbf9d; _0x544aed < _0x382947; _0x544aed++) {
        _0x544aed % _0x3dbf9d == 0 && (_0x54b90d = new Point(this["clickX"][_0x544aed - _0x3dbf9d], this.clickY[_0x544aed - _0x3dbf9d]), _0xdb0823 = new Point(this["clickX"][_0x544aed], this["clickY"][_0x544aed]), _0x532223 = new Point(_0x54b90d.x + (_0xdb0823.x - _0x54b90d.x) / 2, _0x54b90d.y + (_0xdb0823.y - _0x54b90d.y) / 2), _0x5d5462 ? (_0x5efeb3["moveTo"](_0x5d5462.x, _0x5d5462.y), _0x5efeb3["quadraticCurveTo"](_0x54b90d.x, _0x54b90d.y, _0x532223.x, _0x532223.y)) : _0x5efeb3["lineTo"](_0x532223.x, _0x532223.y), _0x5d5462 = _0x532223), _0x544aed == _0x382947 - 1 && _0x5efeb3["lineTo"](this["clickX"][_0x544aed], this.clickY[_0x544aed]);
      }
      _0x5efeb3["stroke"]();
      
      // Step 2: Get the result after drawing
      const newState = _0x5efeb3.getImageData(0, 0, _0x5efeb3.canvas.width, _0x5efeb3.canvas.height);
      
      // Step 3: Preserve original alpha values
      const resultData = newState.data;
      const originalData = currentState.data;
      
      for (let i = 0; i < resultData.length; i += 4) {
        // Preserve original transparency levels
        const originalAlpha = originalData[i + 3];
        const newAlpha = resultData[i + 3];
        
        // If a pixel was originally semitransparent, keep it semitransparent
        if (originalAlpha < 255) {
          resultData[i + 3] = Math.min(newAlpha, originalAlpha);
        }
      }
      
      // Update canvas with masked result
      _0x5efeb3.putImageData(newState, 0, 0);
    
    } else {
      // Standard drawing with conditional blend mode
      room["board"]["layers"][this["surface"]["currentLayer"]]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x3f50f8,
        strokestyle: this["surface"]["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: blendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the smooth path
      var _0x54b90d, _0xdb0823, _0x5d5462, _0x532223,
        _0x3dbf9d = parseInt(this["getOption"]("smooth") > this["clickX"].length / 3 ? this["clickX"].length / 3 : this.getOption("smooth") + 1);
      _0x5d5462 = null, _0x532223 = null;
      
      _0x5efeb3.beginPath(), _0x5efeb3.moveTo(this["clickX"][0], this["clickY"][0]);
      var _0x382947 = this.clickX["length"];
      for (var _0x544aed = _0x3dbf9d; _0x544aed < _0x382947; _0x544aed++) {
        _0x544aed % _0x3dbf9d == 0 && (_0x54b90d = new Point(this["clickX"][_0x544aed - _0x3dbf9d], this.clickY[_0x544aed - _0x3dbf9d]), _0xdb0823 = new Point(this["clickX"][_0x544aed], this["clickY"][_0x544aed]), _0x532223 = new Point(_0x54b90d.x + (_0xdb0823.x - _0x54b90d.x) / 2, _0x54b90d.y + (_0xdb0823.y - _0x54b90d.y) / 2), _0x5d5462 ? (_0x5efeb3["moveTo"](_0x5d5462.x, _0x5d5462.y), _0x5efeb3["quadraticCurveTo"](_0x54b90d.x, _0x54b90d.y, _0x532223.x, _0x532223.y)) : _0x5efeb3["lineTo"](_0x532223.x, _0x532223.y), _0x5d5462 = _0x532223), _0x544aed == _0x382947 - 1 && _0x5efeb3["lineTo"](this["clickX"][_0x544aed], this.clickY[_0x544aed]);
      }
      _0x5efeb3["stroke"]();
    }
  }
  ["composite"]() {
    if (this["getOption"]("spacing") > 0) this["compositeSpacing"](); else this["getOption"]("smooth") > 0 && this["clickX"]["length"] >= 3 ? this["compositeSmooth"]() : this["compositeRegular"]();
    this["clearSlate"](), this["removeClicks"]();
  }
  ["addClick"](_0x236c0e, _0x94363a) {
    this["clickX"]["push"](_0x236c0e), this["clickY"].push(_0x94363a);
  }
  ["removeClicks"]() {
    this["clickX"] = new Array(), this["clickY"] = new Array();
  }
["setupSlate"]() {
  var _0x5d2d36 = this["getOption"]("pressure")[0] ? this.getOption("pressure")[1] : 1,
    _0x1fa2f1 = Math["max"](this["getOption"]("size") * _0x5d2d36, 1);
  
  this.surface["slate"]["setCanvasProperties"]({
    linejoin: "round",
    linecap: "round",
    linewidth: _0x1fa2f1,
    strokestyle: this["surface"]["drawColor"],
    alpha: 1,
    blendmode: "normal",
    blur: 0,
    linedash: []
  });
  
  // For the CSS preview, use special blend mode if transparency locked
  const lockTransparency = this.getOption("locktransparency");
  const previewBlendMode = lockTransparency ? "source-atop" : (this.getOption("blendmode") || "normal");
  
  this["surface"]["slate"]["setCSSProperties"]({
    alpha: this["getOption"]("alpha"),
    blendmode: previewBlendMode,
    blur: this.getOption("blur")
  });
}
  ["clearSlate"]() {
    this["contextSlate"]["clearRect"](0, 0, this.contextSlate["canvas"]["width"], this["contextSlate"]["canvas"]["height"]);
  }
  ["cancel"]() {
    this.clearSlate(), this["removeClicks"]();
  }
  ["getSync"]() {
    var _0x507502 = {};
    return _0x507502["clickX"] = this["clickX"], _0x507502["clickY"] = this["clickY"], _0x507502;
  }
  ["setSync"](_0x505594) {
    if (_0x505594["clickX"]["length"] > 0) {
      this.drawStart(_0x505594["clickX"][0], _0x505594["clickY"][0], this["surface"]["drawColor"]);
      for (var _0x48fedf = 1; _0x48fedf < _0x505594.clickX.length; _0x48fedf++) {
        this["drawStep"](new Point(_0x505594["clickX"][_0x48fedf - 1], _0x505594["clickY"][_0x48fedf - 1]), new Point(_0x505594["clickX"][_0x48fedf], _0x505594["clickY"][_0x48fedf]), this["surface"]["drawColor"]);
      }
    }
  }
  ["redraw"]() {
    this["clearSlate"](), this["setupSlate"]();
    var _0x25fa00 = this["contextSlate"];
    if (this["getOption"]("spacing") > 0) {
      _0x25fa00.beginPath();
      for (var _0x428151 = 0; _0x428151 < this["clickX"]["length"]; _0x428151++) {
        _0x25fa00["moveTo"](this["clickX"][_0x428151], this["clickY"][_0x428151]), _0x25fa00.lineTo(this["clickX"][_0x428151], this.clickY[_0x428151]);
      }
      _0x25fa00["stroke"]();
    } else {
      if (this["clickX"]["length"] < 6) {
        var _0x18b766 = new Point(this.clickX[0], this["clickY"][0]);
        _0x25fa00["beginPath"](), _0x25fa00["moveTo"](this["clickX"][0], this["clickY"][0]);
        for (var _0x428151 = 1; _0x428151 < this.clickX["length"]; _0x428151++) {
          _0x25fa00["lineTo"](this["clickX"][_0x428151], this["clickY"][_0x428151]);
        }
      } else {
        _0x25fa00["beginPath"](), _0x25fa00["moveTo"](this["clickX"][0], this["clickY"][0]);
        for (var _0x428151 = 1; _0x428151 < this["clickX"]["length"] - 2; _0x428151++) {
          var _0xc4585 = (this["clickX"][_0x428151] + this["clickX"][_0x428151 + 1]) / 2,
            _0x2f86bf = (this["clickY"][_0x428151] + this["clickY"][_0x428151 + 1]) / 2;
          _0x25fa00["quadraticCurveTo"](this.clickX[_0x428151], this["clickY"][_0x428151], _0xc4585, _0x2f86bf);
        }
        _0x25fa00["quadraticCurveTo"](this.clickX[_0x428151], this.clickY[_0x428151], this["clickX"][_0x428151 + 1], this["clickY"][_0x428151 + 1]);
      }
      _0x25fa00.stroke();
    }
  }
}

class BrushText extends BrushStub {
  constructor(_0x4da651) {
    super(_0x4da651);
    this.textfield;
    this["enabled"] = false;
    this["options"] = {};
    this["options"].size = new SizeOption();
    this["options"]["alpha"] = new AlphaOption();
    this.options["font"] = new FontOption();
    this.options["rightclick"] = new RightClickOption("text");
    this.options["locktransparency"] = new LockTransparencyOption(); // Add Lock Transparency option
    this["posX"];
    this.posY;
    this["maxLength"] = 200;
    this["minSize"] = 8;
    this["defaultSize"] = 6;
    this["textCursor"] = "<i>|</i>";
    this["disabledCursor"] = "";
    
    // Mirror functionality setup if enabled
    if (mirroredText) {
      this.mirroredFeatureEnabled = true;
      this.startFlipXCheck();
    }
  }
  
  // Mirror-related methods (only used if mirroredText is true)
  startFlipXCheck() {
    if (!mirroredText) return;
    
    this.flipXInterval = setInterval(() => {
      if (typeof UI !== "undefined" && UI.flipX === false) {
        this.mirroredFeatureEnabled = false;
        if (this.mirroredField) this.mirroredField.hide();
      } else {
        this.mirroredFeatureEnabled = true;
        if (this.mirroredField) this.mirroredField.show();
      }
    }, 100);
  }
  
  stopFlipXCheck() {
    if (this.flipXInterval) clearInterval(this.flipXInterval);
  }
  
  ["brushStart"]() {
    this["disabledCursor"] = "<span class=\"disabledCursor\">" + textManager["getString"]("global.lblClickOrEnterToChat", null, false) + "</span>";
    this["surface"]["cursor"]["changePointer"]("invisible");
    this.textfield = $("<div />");
    this["textfield"]["addClass"]("textfield");
    this.textfield["css"]({
      color: this.surface.drawColor,
      opacity: this["getOption"]("alpha"),
      "font-family": '"' + this["getOption"]("font") + '"'
    });
    
    // Create mirrored text field if feature is enabled
    if (mirroredText) {
      this.mirroredField = $("<div />").addClass("mirroredField");
      this.mirroredField.css({
        color: this.surface.drawColor,
        opacity: this["getOption"]("alpha"),
        "font-family": '"' + this["getOption"]("font") + '"',
        transform: "scaleX(-1)",
        "text-align": "right",
        position: "absolute",
        bottom: "calc(100% + 10px)",
        left: 0,
        width: "100%"
      });
      this.surface.cursor.graphic.append(this.mirroredField);
      
      if (!this.mirroredFeatureEnabled) this.mirroredField.hide();
    }
    
    this.changeSize(this["getOption"]("size"));
    this.disable();
    this["surface"]["cursor"]["graphic"].append(this["textfield"]);
    this["surface"].slate["setCSSProperties"]({
      alpha: this["getOption"]("alpha"),
      blendmode: "normal",
      blur: 0
    });
    this.textfield["hide"]();
    this["positionText"]();
    this["textfield"]["fadeIn"](500);
  }
  
  ["brushStop"]() {
    this.textfield.remove();
    if (mirroredText && this.mirroredField) this.mirroredField.remove();
  }
  
  ["setText"](_0x4d3d04, _0x1016bf = true) {
    if (_0x1016bf) {
      this["textfield"]["html"](_0x4d3d04);
      if (mirroredText && this.mirroredField && this.mirroredFeatureEnabled) 
        this.mirroredField.html(_0x4d3d04);
    } else {
      this["textfield"]["text"](_0x4d3d04);
      if (mirroredText && this.mirroredField && this.mirroredFeatureEnabled) 
        this.mirroredField.text(_0x4d3d04);
    }
  }
  
  ["positionText"]() {
    if (this["textfield"]) {
      var _0x34c1fe = this["surface"]["cursor"]["label"],
        _0x45603d = Number(_0x34c1fe.css("top")["replace"]("px", "")),
        _0x7961ae = Number(_0x34c1fe.css("left").replace("px", "")),
        _0x5496b7 = _0x34c1fe["height"]();
      
      this["textfield"]["css"]({
        top: _0x45603d + _0x5496b7 + "px",
        left: _0x7961ae + "px"
      });
      
      if (mirroredText && this.mirroredField) {
        if (this.mirroredFeatureEnabled) {
          this.mirroredField.css({
            top: _0x45603d - _0x5496b7 - 10 + "px",
            left: _0x7961ae + "px"
          }).show();
        } else {
          this.mirroredField.hide();
        }
      }
    }
  }
  
  ["drawEnd"](_0x142ad6, _0x4b7c13, _0x37267c) {
    var _0x4f9747 = this["getPlainText"]();
    if (_0x4f9747 != "" && this["enabled"]) {
      var _0x4558f8 = this["surface"]["cursor"]["labelOffset"];
      this["posX"] = _0x142ad6 + _0x4558f8.x, this["posY"] = _0x4b7c13 + _0x4558f8.y + this.surface["cursor"]["label"]["height"]();
      this["composite"]();
      this["setText"](this.textCursor);
    } else this.toggle();
  }
  
  ["colorChange"](_0x4a3609) {
    this.textfield["css"]("color", _0x4a3609);
  }
  
  ["optionChange"](_0x380535, _0x193c93) {
    if (_0x380535 == "size") this["enabled"] && this["changeSize"](_0x193c93), this.positionText(); else {
      if (_0x380535 == "alpha") this.enabled && this["textfield"] && this.textfield["css"]("opacity", _0x193c93); else _0x380535 == "font" && this["textfield"] && this.textfield["css"]("font-family", '"' + _0x193c93 + '"');
    }
  }
  
  ["onModifierDown"](_0x28b0a3) {
    if (_0x28b0a3 == 13) this["enabled"] ? this["isEmpty"]() ? this.disable() : this["setText"](this["textCursor"]) : this["enable"](); else _0x28b0a3 == 32 && this.onKeyPress(32);
  }
  
  ["getCurrentLength"]() {
    return $("<textarea/>").html(this["removeTextCursor"](this["getText"]())).text()["length"];
  }
  
  ["onKeyPress"](_0x261405) {
    if (this.enabled) {
      if (_0x261405 >= 8) {
        var _0x17efa1 = $("<textarea/>").html(this.removeTextCursor(this["getText"]())).text();
        if (_0x261405 == 8) this["setText"](_0x17efa1["substring"](0, _0x17efa1.length - 1), false); else {
          if (_0x261405 >= 32) {
            if (_0x261405 == 32) {
              var _0x59a21d = _0x17efa1[_0x17efa1["length"] - 1];
              _0x59a21d == " " && (_0x261405 = 0);
            }
            _0x17efa1["length"] < this["maxLength"] && _0x261405 > 0 && String.fromCharCode(_0x261405) != "" && this.setText(_0x17efa1 + String["fromCharCode"](_0x261405), false);
          } else this.setText(_0x17efa1, false);
        }
        this.enabled && _0x17efa1.length <= this["maxLength"] && _0x261405 > 0 && this["textfield"].append(this["textCursor"]), this.positionText();
      }
    }
  }
  
  ["getText"]() {
    return this["textfield"]["html"]();
  }
  
  ["getPlainText"]() {
    return this["removeTextCursor"](this.textfield["html"]());
  }
  
  ["isEmpty"]() {
    return this["getPlainText"]() == "";
  }
  
  ["getSync"]() {
    var _0x15a052 = {};
    return _0x15a052.enabled = this.enabled, _0x15a052.enabled && (_0x15a052["text"] = this["getPlainText"]()), _0x15a052;
  }
  
  ["setSync"](_0x153c15) {
    _0x153c15["enabled"] && (this["enable"](), _0x153c15["text"] != "" && (this["setText"](_0x153c15["text"], false), this["textfield"]["append"](this["textCursor"]))), this.positionText();
  }
  
  ["cancel"]() {
    this["enabled"] && this["setText"](this["textCursor"]);
  }
  
  ["removeTextCursor"](_0x1a982c) {
    return _0x1a982c.substring(0, _0x1a982c["length"] - this["textCursor"]["length"]);
  }
  
  ["composite"]() {
    // Check if transparency lock is enabled
    const lockTransparency = this.getOption("locktransparency");
    
    // Use source-atop composite operation when transparency is locked
    const blendMode = lockTransparency ? "source-atop" : "normal";
    
    room["board"]["layers"][this["surface"]["currentLayer"]].advCanvas["setCanvasProperties"]({
      font: this["getOption"]("size") + this["minSize"] + "px \"" + this.getOption("font") + '"',
      strokestyle: this["surface"]["drawColor"],
      fillstyle: this["surface"]["drawColor"],
      alpha: this["getOption"]("alpha"),
      blendmode: blendMode,
      blur: 0,
      linedash: [],
      textBaseline: "top"
    });
    var _0x48f9e6 = room["board"].getContext(this.surface["currentLayer"]);
    
    // Get plain text without HTML tags
    const plainText = $("<textarea/>").html(this.getPlainText()).text();
    
    // Draw text
    _0x48f9e6.fillText(plainText, this["posX"], this["posY"]);
  }
  
  ["enable"]() {
    this["enabled"] = true, this["changeSize"](this["getOption"]("size")), this["textfield"]["css"]("opacity", this.getOption("alpha")), this["setText"](this.textCursor);
  }
  
  ["disable"]() {
    this["enabled"] = false, this["changeSize"](this["defaultSize"]), this["textfield"]["css"]("opacity", 1), this["setText"](this["disabledCursor"]);
  }
  
  ["changeSize"](_0xa4a966) {
    this.textfield && this["textfield"]["css"]({
      "font-size": _0xa4a966 + this["minSize"] + "px",
      "line-height": _0xa4a966 + this["minSize"] + "px"
    });
  }
  
  ["toggle"]() {
    this.enabled ? this["disable"]() : this["enable"]();
  }
  
  destroy() {
    if (mirroredText) this.stopFlipXCheck();
  }
}

class BrushRect extends BrushStub {
  constructor(_0x43dfb9) {
    super(_0x43dfb9);
    this["options"] = {};
    this["options"]["size"] = new SizeOption();
    this["options"]["alpha"] = new AlphaOption();
    this["options"].blur = new BlurOption();
    this["options"]["blendmode"] = new BlendModeOption();
    this["options"]["fill"] = new FillOption();
    this["options"]["aspectratio"] = new AspectRatioOption();
    this["options"]["rightclick"] = new RightClickOption("rect");
    this["options"]["cursor"] = new CursorOption("circle");
    this.options["locktransparency"] = new LockTransparencyOption(); // Add Lock Transparency option
    this["start"];
    this["end"];
  }
  
  ["brushStart"]() {
    this["surface"]["cursor"].changePointer(this["getOption"]("cursor"));
  }
  
  ["drawStart"](_0x148eaa, _0x756cf7, _0x294274) {
    // Always use normal blending for preview so it remains visible
    this["surface"]["slate"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: this["getOption"]("size"),
      strokestyle: _0x294274,
      fillstyle: _0x294274,
      alpha: 1,
      blendmode: "normal", // Always use normal for preview visibility
      blur: 0,
      linedash: []
    });
    
    this.surface["slate"].setCSSProperties({
      alpha: this["getOption"]("alpha"),
      blendmode: this["getOption"]("blendmode") || "normal",
      blur: this["getOption"]("blur")
    });
    
    this.start = new Point(_0x148eaa, _0x756cf7);
  }
  
  ["drawStep"](_0x5324ee, _0x193eaa, _0x52fb23) {
    this["redraw"](this.start, _0x193eaa, _0x52fb23), this["end"] = _0x193eaa;
  }
  
  ["drawEnd"](_0x10378e, _0x4a317b, _0x109fef) {
    this["end"] = new Point(_0x10378e, _0x4a317b), this.composite();
  }
  
  ["redraw"](_0x1a360f, _0x1bc83b, _0x32381f) {
    this["clearSlate"]();
    if (this.getOption("aspectratio")) {
      var _0x264a01 = this["getMinDistance"](_0x1bc83b.x - _0x1a360f.x, _0x1bc83b.y - _0x1a360f.y),
        _0x21f9a5 = _0x1bc83b.x - _0x1a360f.x > 0 ? 1 : -1,
        _0x3479dc = _0x1bc83b.y - _0x1a360f.y > 0 ? 1 : -1;
      this["getOption"]("fill") ? this["contextSlate"]["fillRect"](_0x1a360f.x, _0x1a360f.y, _0x264a01 * _0x21f9a5, _0x264a01 * _0x3479dc) : this["contextSlate"]["strokeRect"](_0x1a360f.x, _0x1a360f.y, _0x264a01 * _0x21f9a5, _0x264a01 * _0x3479dc);
    } else this["getOption"]("fill") ? this["contextSlate"].fillRect(_0x1a360f.x, _0x1a360f.y, _0x1bc83b.x - _0x1a360f.x, _0x1bc83b.y - _0x1a360f.y) : this["contextSlate"]["strokeRect"](_0x1a360f.x, _0x1a360f.y, _0x1bc83b.x - _0x1a360f.x, _0x1bc83b.y - _0x1a360f.y);
  }
  
  ["getMinDistance"](_0x34b68a, _0x374146) {
    return _0x34b68a = _0x34b68a < 0 ? -_0x34b68a : _0x34b68a, _0x374146 = _0x374146 < 0 ? -_0x374146 : _0x374146, Math.min(_0x34b68a, _0x374146);
  }
  
  ["composite"]() {
    // Get user's blend mode and transparency lock status
    const userBlendMode = this.getOption("blendmode") || "normal";
    const lockTransparency = this.getOption("locktransparency");
    
    var _0x397440 = room["board"].getContext(this["surface"].currentLayer);
    
    if (lockTransparency) {
      // Two-step process for locked transparency
      
      // Step 1: Save the current canvas state
      const currentState = _0x397440.getImageData(0, 0, _0x397440.canvas.width, _0x397440.canvas.height);
      
      // Apply the rectangle with user's blend mode
      room["board"]["layers"][this["surface"]["currentLayer"]]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: this["getOption"]("size"),
        strokestyle: this["surface"].drawColor,
        fillstyle: this["surface"]["drawColor"],
        alpha: this.getOption("alpha"),
        blendmode: userBlendMode,
        blur: this.getOption("blur"),
        linedash: []
      });
      
      // Draw the rectangle
      if (this.getOption("aspectratio")) {
        var _0x23592a = this.getMinDistance(this["end"].x - this["start"].x, this["end"].y - this["start"].y),
          _0x440046 = this["end"].x - this.start.x > 0 ? 1 : -1,
          _0x21b617 = this["end"].y - this["start"].y > 0 ? 1 : -1;
        this["getOption"]("fill") ? _0x397440["fillRect"](this["start"].x, this["start"].y, _0x23592a * _0x440046, _0x23592a * _0x21b617) : _0x397440["strokeRect"](this.start.x, this["start"].y, _0x23592a * _0x440046, _0x23592a * _0x21b617);
      } else {
        this["getOption"]("fill") ? _0x397440["fillRect"](this.start.x, this["start"].y, this["end"].x - this["start"].x, this["end"].y - this.start.y) : _0x397440["strokeRect"](this["start"].x, this["start"].y, this.end.x - this["start"].x, this["end"].y - this["start"].y);
      }
      
      // Step 2: Get the result after drawing
      const newState = _0x397440.getImageData(0, 0, _0x397440.canvas.width, _0x397440.canvas.height);
      
      // Step 3: Preserve original alpha values
      const resultData = newState.data;
      const originalData = currentState.data;
      
      for (let i = 0; i < resultData.length; i += 4) {
        // Preserve original transparency levels
        const originalAlpha = originalData[i + 3];
        const newAlpha = resultData[i + 3];
        
        // If a pixel was originally semitransparent, keep it semitransparent
        if (originalAlpha < 255) {
          resultData[i + 3] = Math.min(newAlpha, originalAlpha);
        }
      }
      
      // Update canvas with masked result
      _0x397440.putImageData(newState, 0, 0);
      
    } else {
      // Standard drawing with user's blend mode
      room["board"]["layers"][this["surface"]["currentLayer"]]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: this["getOption"]("size"),
        strokestyle: this["surface"].drawColor,
        fillstyle: this["surface"]["drawColor"],
        alpha: this.getOption("alpha"),
        blendmode: userBlendMode,
        blur: this.getOption("blur"),
        linedash: []
      });
      
      // Draw the rectangle
      if (this.getOption("aspectratio")) {
        var _0x23592a = this.getMinDistance(this["end"].x - this["start"].x, this["end"].y - this["start"].y),
          _0x440046 = this["end"].x - this.start.x > 0 ? 1 : -1,
          _0x21b617 = this["end"].y - this["start"].y > 0 ? 1 : -1;
        this["getOption"]("fill") ? _0x397440["fillRect"](this["start"].x, this["start"].y, _0x23592a * _0x440046, _0x23592a * _0x21b617) : _0x397440["strokeRect"](this.start.x, this["start"].y, _0x23592a * _0x440046, _0x23592a * _0x21b617);
      } else {
        this["getOption"]("fill") ? _0x397440["fillRect"](this.start.x, this["start"].y, this["end"].x - this["start"].x, this["end"].y - this.start.y) : _0x397440["strokeRect"](this["start"].x, this["start"].y, this.end.x - this["start"].x, this["end"].y - this["start"].y);
      }
    }
    
    this["clearSlate"]();
    this["start"] = null;
    this.end = null;
  }
  ["clearSlate"]() {
    this["contextSlate"]["clearRect"](0, 0, this["contextSlate"]["canvas"]["width"], this["contextSlate"].canvas["height"]);
  }
  ["getSync"]() {
    var _0x5ddcc2 = {};
    return _0x5ddcc2["start"] = this.start, _0x5ddcc2;
  }
  ["setSync"](_0x5960d3) {
    this["drawStart"](_0x5960d3.start.x, _0x5960d3["start"].y, this["surface"].drawColor);
  }
  ["cancel"]() {
    this["clearSlate"](), this["start"] = null, this.end = null;
  }
  ["colorChange"](_0x294baf) {
    this["contextSlate"]["strokeStyle"] = _0x294baf, this["start"] && this["end"] && this["redraw"](this["start"], this.end, _0x294baf);
  }
  ["optionChange"](_0x3edca0, _0x1f1c15) {
    if (_0x3edca0 == "size") this["surface"]["slate"]["setCanvasProperties"]({
      linewidth: _0x1f1c15
    }); else {
      if (_0x3edca0 == "alpha") this["surface"]["slate"].setCSSProperties({
        alpha: _0x1f1c15
      }); else {
        if (_0x3edca0 == "blendmode") this.surface.slate["setCSSProperties"]({
          blendmode: _0x1f1c15
        }); else _0x3edca0 == "blur" && this.surface["slate"]["setCSSProperties"]({
          blur: _0x1f1c15
        });
      }
    }
  }
  ["optionChanged"](_0x134c9a, _0x13a192) {
    this["start"] && this.end && this["redraw"](this["start"], this["end"], this.surface["drawColor"]), _0x134c9a == "cursor" && this["surface"].cursor.changePointer(_0x13a192);
  }
}
class BrushLine extends BrushStub {
  constructor(_0x3ad08f) {
    super(_0x3ad08f);
    this["options"] = {};
    this["options"]["size"] = new SizeOption();
    this["options"].alpha = new AlphaOption();
    this.options["blur"] = new BlurOption();
    this["options"]["blendmode"] = new BlendModeOption();
    this.options["snap"] = new SnapOption();
    this["options"]["rightclick"] = new RightClickOption("line");
    this["options"]["cursor"] = new CursorOption("circle");
    this.options["locktransparency"] = new LockTransparencyOption(); // Add Lock Transparency option
    this["start"];
    this.end;
  }
  
  ["brushStart"]() {
    this["surface"]["cursor"]["changePointer"](this["getOption"]("cursor"));
  }
  
  ["drawStart"](_0x4e2f91, _0x16e8a0, _0x284300) {
    // Always use normal blending for preview so it remains visible
    this.surface["slate"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: this["getOption"]("size"),
      strokestyle: _0x284300,
      alpha: 1,
      blendmode: "normal", // Always use normal for preview visibility
      blur: 0,
      linedash: []
    });
    
    this["surface"].slate["setCSSProperties"]({
      alpha: this["getOption"]("alpha"),
      blendmode: this["getOption"]("blendmode") || "normal",
      blur: this.getOption("blur")
    });
    
    this["start"] = new Point(_0x4e2f91, _0x16e8a0);
  }
  
  ["drawStep"](_0x1ca757, _0x348692, _0x5f27f2) {
    this.redraw(this["start"], _0x348692, _0x5f27f2), this["end"] = _0x348692;
  }
  
  ["redraw"](_0x27decc, _0x3cc7a0, _0x359e09) {
    this.clearSlate(), this["contextSlate"]["beginPath"](), this["contextSlate"]["moveTo"](_0x27decc.x, _0x27decc.y);
    if (!this.getOption("snap")) this.contextSlate["lineTo"](_0x3cc7a0.x, _0x3cc7a0.y); else {
      var _0x196d77 = this["snapPosition"](_0x27decc, _0x3cc7a0);
      this["contextSlate"]["lineTo"](_0x196d77.x, _0x196d77.y);
    }
    this["contextSlate"]["stroke"]();
  }
  
  ["drawEnd"](_0x5457c2, _0x7fb7fe, _0x337600) {
    this.end = new Point(_0x5457c2, _0x7fb7fe), this.composite();
  }
  
  ["composite"]() {
    // Get user's blend mode and transparency lock status
    const userBlendMode = this.getOption("blendmode") || "normal";
    const lockTransparency = this.getOption("locktransparency");
    
    var _0x5cb0bf = room["board"]["getContext"](this["surface"]["currentLayer"]);
    
    if (lockTransparency) {
      // Two-step process for locked transparency
      
      // Step 1: Save the current canvas state
      const currentState = _0x5cb0bf.getImageData(0, 0, _0x5cb0bf.canvas.width, _0x5cb0bf.canvas.height);
      
      // Apply the line with user's blend mode
      room["board"]["layers"][this.surface.currentLayer].advCanvas["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: this.getOption("size"),
        strokestyle: this.surface["drawColor"],
        alpha: this.getOption("alpha"),
        blendmode: userBlendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the line
      _0x5cb0bf["beginPath"]();
      _0x5cb0bf["moveTo"](this["start"].x, this.start.y);
      
      if (!this["getOption"]("snap")) {
        _0x5cb0bf["lineTo"](this["end"].x, this["end"].y);
      } else {
        var _0x1d40de = this["snapPosition"](this.start, this["end"]);
        _0x5cb0bf["lineTo"](_0x1d40de.x, _0x1d40de.y);
      }
      
      _0x5cb0bf["stroke"]();
      
      // Step 2: Get the result after drawing
      const newState = _0x5cb0bf.getImageData(0, 0, _0x5cb0bf.canvas.width, _0x5cb0bf.canvas.height);
      
      // Step 3: Preserve original alpha values
      const resultData = newState.data;
      const originalData = currentState.data;
      
      for (let i = 0; i < resultData.length; i += 4) {
        // Preserve original transparency levels
        const originalAlpha = originalData[i + 3];
        const newAlpha = resultData[i + 3];
        
        // If a pixel was originally semitransparent, keep it semitransparent
        if (originalAlpha < 255) {
          resultData[i + 3] = Math.min(newAlpha, originalAlpha);
        }
      }
      
      // Update canvas with masked result
      _0x5cb0bf.putImageData(newState, 0, 0);
      
    } else {
      // Standard drawing with user's blend mode
      room["board"]["layers"][this.surface.currentLayer].advCanvas["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: this.getOption("size"),
        strokestyle: this.surface["drawColor"],
        alpha: this.getOption("alpha"),
        blendmode: userBlendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the line
      _0x5cb0bf["beginPath"]();
      _0x5cb0bf["moveTo"](this["start"].x, this.start.y);
      
      if (!this["getOption"]("snap")) {
        _0x5cb0bf["lineTo"](this["end"].x, this["end"].y);
      } else {
        var _0x1d40de = this["snapPosition"](this.start, this["end"]);
        _0x5cb0bf["lineTo"](_0x1d40de.x, _0x1d40de.y);
      }
      
      _0x5cb0bf["stroke"]();
    }
    
    this.clearSlate();
    this.start = null;
    this["end"] = null;
  }
  
  ["cancel"]() {
    this.clearSlate(), this.start = null, this.end = null;
  }
  ["getSync"]() {
    var _0x329027 = {};
    return _0x329027["start"] = this["start"], _0x329027;
  }
  ["setSync"](_0x54914c) {
    this["drawStart"](_0x54914c["start"].x, _0x54914c["start"].y, this["surface"]["drawColor"]);
  }
  ["snapPosition"](_0x1a5c71, _0x406ad6) {
    var _0x1a4fde = _0x406ad6.x - _0x1a5c71.x,
      _0x262a37 = _0x406ad6.y - _0x1a5c71.y,
      _0x673dfb = Math.sqrt(_0x1a4fde * _0x1a4fde + _0x262a37 * _0x262a37),
      _0x1b789f = Math["atan2"](_0x262a37, _0x1a4fde) / Math.PI * 180;
    _0x1b789f = angleSnap(_0x1b789f);
    var _0x21ecb5 = _0x673dfb * Math["cos"](_0x1b789f * Math.PI / 180),
      _0x19ddce = _0x673dfb * Math["sin"](_0x1b789f * Math.PI / 180);
    return new Point(_0x21ecb5 + _0x1a5c71.x, _0x19ddce + _0x1a5c71.y);
  }
  ["clearSlate"]() {
    this["contextSlate"]["clearRect"](0, 0, this["contextSlate"]["canvas"]["width"], this.contextSlate.canvas.height);
  }
  ["colorChange"](_0x25d7d5) {
    this.contextSlate["strokeStyle"] = _0x25d7d5, this["start"] && this["end"] && this["redraw"](this["start"], this["end"], _0x25d7d5);
  }
  ["optionChange"](_0x231195, _0x2cb6a3) {
    if (_0x231195 == "size") this["surface"]["slate"]["setCanvasProperties"]({
      linewidth: _0x2cb6a3
    }); else {
      if (_0x231195 == "alpha") this["surface"]["slate"]["setCSSProperties"]({
        alpha: _0x2cb6a3
      }); else {
        if (_0x231195 == "blendmode") this["surface"].slate["setCSSProperties"]({
          blendmode: _0x2cb6a3
        }); else _0x231195 == "blur" && this["surface"]["slate"].setCSSProperties({
          blur: _0x2cb6a3
        });
      }
    }
  }
  ["optionChanged"](_0x16bce9, _0x5ad32f) {
    this["start"] && this["end"] && this.redraw(this["start"], this.end, this["surface"]["drawColor"]), _0x16bce9 == "cursor" && this["surface"].cursor["changePointer"](_0x5ad32f);
  }
}
class BrushEllipse extends BrushStub {
  constructor(_0xa98314) {
    super(_0xa98314);
    this["options"] = {};
    this.options["size"] = new SizeOption();
    this.options["alpha"] = new AlphaOption();
    this["options"]["blur"] = new BlurOption();
    this.options["blendmode"] = new BlendModeOption();
    this["options"]["fill"] = new FillOption();
    this.options["aspectratio"] = new AspectRatioOption();
    this.options["rightclick"] = new RightClickOption("ellipse");
    this["options"].cursor = new CursorOption("circle");
    this.options["locktransparency"] = new LockTransparencyOption(); // Add Lock Transparency option
    this.start;
    this.end;
  }
  
  ["brushStart"]() {
    this.surface.cursor["changePointer"](this["getOption"]("cursor"));
  }
  
  ["drawStart"](_0x3765cd, _0x641bf3, _0x4a2443) {
    // Always use normal blending for preview so it remains visible
    this.surface["slate"]["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: this["getOption"]("size"),
      strokestyle: _0x4a2443,
      fillstyle: _0x4a2443,
      alpha: 1,
      blendmode: "normal", // Always use normal for preview visibility
      blur: 0,
      linedash: []
    });
    
    this.surface["slate"]["setCSSProperties"]({
      alpha: this.getOption("alpha"),
      blendmode: this["getOption"]("blendmode") || "normal",
      blur: this["getOption"]("blur")
    });
    
    this["start"] = new Point(_0x3765cd, _0x641bf3);
  }
  
  ["drawStep"](_0x2df993, _0x31f7aa, _0x39eb5b) {
    this.redraw(this["start"], _0x31f7aa, _0x39eb5b), this["end"] = _0x31f7aa;
  }
  
  ["drawEnd"](_0x5aa548, _0x4ac7a6, _0x5a46b4) {
    this.end = new Point(_0x5aa548, _0x4ac7a6), this["composite"]();
  }
  
  ["redraw"](_0x2473b8, _0x40f649, _0x36adcc) {
    this["clearSlate"](), this.contextSlate["beginPath"]();
    if (this.getOption("aspectratio")) {
      var _0x11d494 = this["getMinDistance"](_0x40f649.x - _0x2473b8.x, _0x40f649.y - _0x2473b8.y) / 2,
        _0x1adb72 = _0x40f649.x - _0x2473b8.x > 0 ? 1 : -1,
        _0x322f9c = _0x40f649.y - _0x2473b8.y > 0 ? 1 : -1,
        _0x51425a = _0x11d494 < 0 ? -_0x11d494 : _0x11d494;
      this["contextSlate"]["ellipse"](_0x2473b8.x + _0x11d494 * _0x1adb72, _0x2473b8.y + _0x11d494 * _0x322f9c, _0x51425a, _0x51425a, 0, 0, Math.PI * 2), this["getOption"]("fill") && this["contextSlate"]["fill"]();
    } else {
      var _0x484352 = (_0x40f649.x - _0x2473b8.x) / 2,
        _0x2ef185 = (_0x40f649.y - _0x2473b8.y) / 2,
        _0x1942ea = _0x484352 < 0 ? -_0x484352 : _0x484352,
        _0x1b381f = _0x2ef185 < 0 ? -_0x2ef185 : _0x2ef185;
      this["contextSlate"]["ellipse"](_0x2473b8.x + _0x484352, _0x2473b8.y + _0x2ef185, _0x1942ea, _0x1b381f, 0, 0, Math.PI * 2), this["getOption"]("fill") && this["contextSlate"]["fill"]();
    }
    this.contextSlate["stroke"]();
  }
  
  ["composite"]() {
    // Get user's blend mode and transparency lock status
    const userBlendMode = this["getOption"]("blendmode") || "normal";
    const lockTransparency = this.getOption("locktransparency");
    
    var _0x29302f = room["board"]["getContext"](this["surface"]["currentLayer"]);
    
    if (lockTransparency) {
      // Two-step process for locked transparency
      
      // Step 1: Save the current canvas state
      const currentState = _0x29302f.getImageData(0, 0, _0x29302f.canvas.width, _0x29302f.canvas.height);
      
      // Apply the ellipse with user's blend mode
      room["board"].layers[this["surface"]["currentLayer"]].advCanvas.setCanvasProperties({
        linejoin: "round",
        linecap: "round",
        linewidth: this["getOption"]("size"),
        strokestyle: this.surface["drawColor"],
        fillstyle: this["surface"]["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: userBlendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the ellipse
      _0x29302f["beginPath"]();
      
      if (this.getOption("aspectratio")) {
        var _0x2a1e83 = this["getMinDistance"](this.end.x - this["start"].x, this["end"].y - this["start"].y) / 2,
          _0x55f04d = this.end.x - this["start"].x > 0 ? 1 : -1,
          _0xe60a43 = this["end"].y - this["start"].y > 0 ? 1 : -1,
          _0x3fb647 = _0x2a1e83 < 0 ? -_0x2a1e83 : _0x2a1e83;
        _0x29302f.ellipse(this["start"].x + _0x2a1e83 * _0x55f04d, this.start.y + _0x2a1e83 * _0xe60a43, _0x3fb647, _0x3fb647, 0, 0, Math.PI * 2);
        if (this["getOption"]("fill")) _0x29302f["fill"]();
      } else {
        var _0x49e0c5 = (this["end"].x - this["start"].x) / 2,
          _0x2c5b7b = (this["end"].y - this["start"].y) / 2,
          _0x1b22c4 = _0x49e0c5 < 0 ? -_0x49e0c5 : _0x49e0c5,
          _0x41ab15 = _0x2c5b7b < 0 ? -_0x2c5b7b : _0x2c5b7b;
        _0x29302f["ellipse"](this.start.x + _0x49e0c5, this["start"].y + _0x2c5b7b, _0x1b22c4, _0x41ab15, 0, 0, Math.PI * 2);
        if (this.getOption("fill")) _0x29302f["fill"]();
      }
      
      _0x29302f.stroke();
      
      // Step 2: Get the result after drawing
      const newState = _0x29302f.getImageData(0, 0, _0x29302f.canvas.width, _0x29302f.canvas.height);
      
      // Step 3: Preserve original alpha values
      const resultData = newState.data;
      const originalData = currentState.data;
      
      for (let i = 0; i < resultData.length; i += 4) {
        // Preserve original transparency levels
        const originalAlpha = originalData[i + 3];
        const newAlpha = resultData[i + 3];
        
        // If a pixel was originally semitransparent, keep it semitransparent
        if (originalAlpha < 255) {
          resultData[i + 3] = Math.min(newAlpha, originalAlpha);
        }
      }
      
      // Update canvas with masked result
      _0x29302f.putImageData(newState, 0, 0);
      
    } else {
      // Standard drawing with user's blend mode
      room["board"].layers[this["surface"]["currentLayer"]].advCanvas.setCanvasProperties({
        linejoin: "round",
        linecap: "round",
        linewidth: this["getOption"]("size"),
        strokestyle: this.surface["drawColor"],
        fillstyle: this["surface"]["drawColor"],
        alpha: this["getOption"]("alpha"),
        blendmode: userBlendMode,
        blur: this["getOption"]("blur"),
        linedash: []
      });
      
      // Draw the ellipse
      _0x29302f["beginPath"]();
      
      if (this.getOption("aspectratio")) {
        var _0x2a1e83 = this["getMinDistance"](this.end.x - this["start"].x, this["end"].y - this["start"].y) / 2,
          _0x55f04d = this.end.x - this["start"].x > 0 ? 1 : -1,
          _0xe60a43 = this["end"].y - this["start"].y > 0 ? 1 : -1,
          _0x3fb647 = _0x2a1e83 < 0 ? -_0x2a1e83 : _0x2a1e83;
        _0x29302f.ellipse(this["start"].x + _0x2a1e83 * _0x55f04d, this.start.y + _0x2a1e83 * _0xe60a43, _0x3fb647, _0x3fb647, 0, 0, Math.PI * 2);
        if (this["getOption"]("fill")) _0x29302f["fill"]();
      } else {
        var _0x49e0c5 = (this["end"].x - this["start"].x) / 2,
          _0x2c5b7b = (this["end"].y - this["start"].y) / 2,
          _0x1b22c4 = _0x49e0c5 < 0 ? -_0x49e0c5 : _0x49e0c5,
          _0x41ab15 = _0x2c5b7b < 0 ? -_0x2c5b7b : _0x2c5b7b;
        _0x29302f["ellipse"](this.start.x + _0x49e0c5, this["start"].y + _0x2c5b7b, _0x1b22c4, _0x41ab15, 0, 0, Math.PI * 2);
        if (this.getOption("fill")) _0x29302f["fill"]();
      }
      
      _0x29302f.stroke();
    }
    
    this["clearSlate"]();
    this["start"] = null;
    this["end"] = null;
  }

  ["getMinDistance"](_0x4ca266, _0x4d1aee) {
    return _0x4ca266 = _0x4ca266 < 0 ? -_0x4ca266 : _0x4ca266, _0x4d1aee = _0x4d1aee < 0 ? -_0x4d1aee : _0x4d1aee, Math["min"](_0x4ca266, _0x4d1aee);
  }
  ["clearSlate"]() {
    this["contextSlate"]["clearRect"](0, 0, this["contextSlate"]["canvas"]["width"], this["contextSlate"]["canvas"]["height"]);
  }
  ["getSync"]() {
    var _0x22f0e3 = {};
    return _0x22f0e3["start"] = this.start, _0x22f0e3;
  }
  ["setSync"](_0x41611b) {
    this["drawStart"](_0x41611b["start"].x, _0x41611b.start.y, this["surface"]["drawColor"]);
  }
  ["cancel"]() {
    this["clearSlate"](), this.start = null, this.end = null;
  }
  ["colorChange"](_0x1fb82b) {
    this["contextSlate"]["strokeStyle"] = _0x1fb82b, this["start"] && this["end"] && this.redraw(this["start"], this["end"], _0x1fb82b);
  }
  ["optionChange"](_0x3ec07b, _0x3bff78) {
    if (_0x3ec07b == "size") this["surface"]["slate"]["setCanvasProperties"]({
      linewidth: _0x3bff78
    }); else {
      if (_0x3ec07b == "alpha") this["surface"]["slate"]["setCSSProperties"]({
        alpha: _0x3bff78
      }); else {
        if (_0x3ec07b == "blendmode") this.surface.slate.setCSSProperties({
          blendmode: _0x3bff78
        }); else _0x3ec07b == "blur" && this["surface"]["slate"]["setCSSProperties"]({
          blur: _0x3bff78
        });
      }
    }
  }
  ["optionChanged"](_0x3c3e17, _0x2741b3) {
    this["start"] && this["end"] && this["redraw"](this.start, this["end"], this["surface"]["drawColor"]), _0x3c3e17 == "cursor" && this["surface"]["cursor"].changePointer(_0x2741b3);
  }
}
class BrushFill extends BrushStub {
  constructor(_0x18d953) {
    super(_0x18d953), this["start"], this["colorLayer"], this["filledPixels"], this["maxPixels"] = 1e5, this.options = {}, this.options["size"] = new SizeOption(33, true), this["options"]["alpha"] = new AlphaOption(), this["options"]["rightclick"] = new RightClickOption("fill"), this.options["cursor"] = new CursorOption("crosshair");
  }
  ["brushStart"]() {
    this["surface"]["cursor"]["changePointer"](this.getOption("cursor"));
  }
  ["optionChanged"](_0x3feabe, _0x3ae26c) {
    _0x3feabe == "cursor" && this["surface"]["cursor"]["changePointer"](_0x3ae26c);
  }
  ["drawEnd"](_0x3b260b, _0x78972f, _0x5dfca9) {
    this["start"] = new Point(parseInt(_0x3b260b), parseInt(_0x78972f)), this.draw();
  }
  ["draw"]() {
    this["filledPixels"] = 0;
    var _0x21bfce = room["board"]["getContext"](this["surface"]["currentLayer"]),
      _0x1148a9 = room["board"]["canvasWidth"],
      _0x226544 = room["board"].canvasHeight;
    this["colorLayer"] = _0x21bfce["getImageData"](0, 0, _0x1148a9, _0x226544);
    var _0x1af81e = (this.start.y * _0x1148a9 + this["start"].x) * 4,
      _0x571e1f = {
        r: this["colorLayer"]["data"][_0x1af81e],
        g: this["colorLayer"].data[_0x1af81e + 1],
        b: this["colorLayer"]["data"][_0x1af81e + 2],
        a: this["colorLayer"]["data"][_0x1af81e + 3]
      },
      _0x279a08 = this["surface"]["drawColor"];
    this["surface"].drawColor[0] != "#" && (_0x279a08 = rgb2hex(this["surface"]["drawColor"]));
    var _0x4a23b8 = hex2rgb(_0x279a08);
    _0x4a23b8.a = this["getOption"]("alpha") * 255;
    this["surface"].currentLayer == 0 && !room.bottomTransparency && (_0x4a23b8 = rgba2rgb(_0x4a23b8.r, _0x4a23b8.g, _0x4a23b8.b, _0x4a23b8.a / 255), _0x4a23b8.a = 255);
    if (!this["sameColor"](_0x571e1f, _0x4a23b8)) {
      var _0x2a0056 = [[this.start.x, this["start"].y]],
        _0x4cfe5c = 0;
      while (_0x2a0056["length"]) {
        var _0x1ffaf0, _0x186a56, _0x405241, _0x1af81e, _0x15590f, _0xee1724;
        _0x1ffaf0 = _0x2a0056["pop"](), _0x186a56 = _0x1ffaf0[0], _0x405241 = _0x1ffaf0[1], _0x1af81e = (_0x405241 * _0x1148a9 + _0x186a56) * 4;
        while (_0x405241-- >= _0x4cfe5c && this.matchesColor(_0x1af81e, _0x571e1f)) {
          _0x1af81e -= _0x1148a9 * 4;
        }
        _0x1af81e += _0x1148a9 * 4, _0x405241++, _0x15590f = false, _0xee1724 = false;
        while (_0x405241++ < _0x226544 - 1 && this.matchesColor(_0x1af81e, _0x571e1f)) {
          if (!this["fillPixel"](_0x1af81e, _0x4a23b8)) {
            this["surface"]["isMyself"] && UI["dialogHandler"].showAlert(textManager["getString"]("alerts.txtAreaTooBig"));
            return;
          }
          if (_0x186a56 > 0) {
            if (this.matchesColor(_0x1af81e - 4, _0x571e1f)) !_0x15590f && (_0x2a0056["push"]([_0x186a56 - 1, _0x405241]), _0x15590f = true); else _0x15590f && (_0x15590f = false);
          }
          if (_0x186a56 < _0x1148a9 - 1) {
            if (this["matchesColor"](_0x1af81e + 4, _0x571e1f)) !_0xee1724 && (_0x2a0056["push"]([_0x186a56 + 1, _0x405241]), _0xee1724 = true); else _0xee1724 && (_0xee1724 = false);
          }
          _0x1af81e += _0x1148a9 * 4;
        }
      }
      this["filledPixels"] < this["maxPixels"] && _0x21bfce["putImageData"](this.colorLayer, 0, 0);
    }
  }
  ["sameColor"](_0x32a649, _0x3e0904) {
    return _0x32a649.r == _0x3e0904.r && _0x32a649.g == _0x3e0904.g && _0x32a649.b == _0x3e0904.b && _0x32a649.a == _0x3e0904.a;
  }
  ["matchesColor"](_0x3c770b, _0xe3d25e) {
    var _0x549bb4 = {
      r: this.colorLayer["data"][_0x3c770b],
      g: this["colorLayer"]["data"][_0x3c770b + 1],
      b: this.colorLayer.data[_0x3c770b + 2],
      a: this["colorLayer"]["data"][_0x3c770b + 3]
    };
    return this.sameColor(_0x549bb4, _0xe3d25e);
  }
  ["fillPixel"](_0x575ce6, _0x443e92) {
    return this["colorLayer"]["data"][_0x575ce6] = _0x443e92.r, this["colorLayer"]["data"][_0x575ce6 + 1] = _0x443e92.g, this["colorLayer"]["data"][_0x575ce6 + 2] = _0x443e92.b, this["colorLayer"]["data"][_0x575ce6 + 3] = _0x443e92.a, ++this["filledPixels"] < this["maxPixels"];
  }
}
class BrushBlend extends BrushStub {
  constructor(_0x110ba3) {
    super(_0x110ba3), this.lastX, this["lastY"], this.options = {}, this["options"]["size"] = new SizeOption(), this["options"]["alpha"] = new AlphaOption(), this["options"]["blur"] = new BlurOption(), this["options"]["blendmode"] = new BlendModeOption(), this.options["cursor"] = new CursorOption("circle");
  }
  ["brushStart"]() {
    this["surface"]["cursor"].changePointer(this["getOption"]("cursor"));
  }
  ["optionChanged"](_0x59c86a, _0x1fc3d8) {
    _0x59c86a == "cursor" && this.surface.cursor["changePointer"](_0x1fc3d8);
  }
  ["drawStart"](_0x381a2b, _0xa5a79a, _0x4c5744) {
    this.plotCircle(_0x381a2b, _0xa5a79a), this["lastX"] = _0x381a2b, this["lastY"] = _0xa5a79a;
  }
  ["drawStep"](_0x36d3b, _0x48ae50, _0xa2b83c) {
    this["getDistance"](_0x36d3b.x, _0x36d3b.y, this.lastX, this.lastY) >= this["getOption"]("size") / 4 && (this["plotCircle"](_0x36d3b.x, _0x36d3b.y), this.lastX = _0x36d3b.x, this["lastY"] = _0x36d3b.y);
  }
  ["onBrushParameter"](_0x584faf) {
    if (_0x584faf && _0x584faf["type"] == "plot") {
      room["board"]["layers"][this.surface["currentLayer"]]["advCanvas"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: this.getOption("size"),
        strokestyle: _0x584faf["color"],
        alpha: this["getOption"]("alpha"),
        blendmode: this["getOption"]("blendmode") || "normal",
        blur: this["getOption"]("blur")
      });
      var _0x3d1a07 = room["board"]["getContext"](this["surface"].currentLayer);
      _0x3d1a07.beginPath(), _0x3d1a07["moveTo"](_0x584faf.x - 0.5, _0x584faf.y - 0.5), _0x3d1a07["lineTo"](_0x584faf.x + 0.5, _0x584faf.y + 0.5), _0x3d1a07["stroke"]();
    }
  }
  ["plotCircle"](_0x53ed81, _0xc51016) {
    if (this["surface"]["isMyself"]) {
      var _0x4de9a5 = getRadialAvg(room.board["getImageData"](this["surface"]["currentLayer"]), _0x53ed81, _0xc51016, Math["max"](this["getOption"]("size") / 2, 1), room["board"]["backgroundColor"]);
      if (!isNaN(_0x4de9a5[0])) {
        _0x4de9a5 = rgba2rgb(_0x4de9a5[0], _0x4de9a5[1], _0x4de9a5[2], _0x4de9a5[3] / 255);
        var _0x544d46 = rgb2hex("rgb(" + _0x4de9a5.r + "," + _0x4de9a5.g + "," + _0x4de9a5.b + ")"),
          _0x4d5af6 = {};
        _0x4d5af6["type"] = "plot", _0x4d5af6["color"] = _0x544d46, _0x4d5af6.x = _0x53ed81, _0x4d5af6.y = _0xc51016, this["surface"].brushParameter(_0x4d5af6);
      }
    }
  }
}
class BrushCustom extends BrushStub {
  constructor(_0x2085ef) {
    super(_0x2085ef);
    this["clickX"] = new Array();
    this["clickY"] = new Array();
    this["options"] = {};
    this["options"]["size"] = new SizeOption();
    this["options"]["alpha"] = new AlphaOption();
    this["options"]["blendmode"] = new BlendModeOption();
    this["options"]["spacing"] = new SpacingOption(15);
    this["options"].tint = new TintOption();
    this["options"]["randomrotation"] = new RandomRotationOption();
    this["options"]["rotationvalue"] = new RotationValueOption();
    this["options"]["gallery"] = new GalleryOption(openBrushGallery);
    this.options["customize"] = new CustomizeOption(openBrushDesigner);
    this["options"]["rightclick"] = new RightClickOption("custom");
    this["options"]["cursor"] = new CursorOption("square");
    this["options"]["image"] = new ImageOption(null);
    this.options["locktransparency"] = new LockTransparencyOption(); // Add Lock Transparency option
    this.brushImage = null;
    this["brushCache"] = null;
    this.compositing = false;
    this["distance"];
    
    // Reusable objects to prevent frequent allocation
    this._cacheCanvas = null;
    this._cacheImg = new Image();
    this._compositeImg = new Image();
  }
  
  ["brushStart"]() {
    this.surface["cursor"]["changePointer"](this["getOption"]("cursor")), this["cache"](this["getOption"]("size"), this["getOption"]("tint"), this.surface["drawColor"]);
  }
  ["optionChanged"](_0x438916, _0x102ff1) {
    if (_0x438916 == "cursor") {
      this.surface["cursor"]["changePointer"](_0x102ff1);
    } else if (_0x438916 == "image") {
      var _0x57d5bf = this;
      
      // Reuse image object if possible
      if (!this._loaderImage) {
        this._loaderImage = new Image();
        this._loaderImage["onload"] = function() {
          // Clear previous reference before assigning new one
          if (_0x57d5bf.brushImage) {
            _0x57d5bf.brushImage.onload = null;
          }
          _0x57d5bf.brushImage = this;
          _0x57d5bf.cache(_0x57d5bf["getOption"]("size"), 
                          _0x57d5bf["getOption"]("tint"), 
                          _0x57d5bf["surface"]["drawColor"]);
        };
        this._loaderImage.onerror = function() {
        };
      }
      this._loaderImage["src"] = _0x102ff1;
    }
  }
  ["cache"](_0x2fc01e, _0x27e49e, _0x4c16e1) {
    if (!this.brushImage) return;
    
    var _0x2fee47;
    _0x4c16e1[0] == "#" ? _0x2fee47 = hex2rgb(_0x4c16e1) : _0x2fee47 = rgb2obj(_0x4c16e1);
    if (!_0x2fee47) return;
    
    // Reuse canvas to prevent memory leaks
    if (!this._cacheCanvas || 
        this._cacheCanvas.width !== _0x2fc01e || 
        this._cacheCanvas.height !== _0x2fc01e) {
      // Clean up old canvas if it exists
      if (this._cacheCanvas) {
        this._cacheCanvas.width = this._cacheCanvas.height = 1;
        this._cacheCanvas = null;
      }
      this._cacheCanvas = new AdvancedCanvas(_0x2fc01e, _0x2fc01e);
    }
    
    var _0x22bf8e = this._cacheCanvas.getContext();
    // Clear previous content
    _0x22bf8e.clearRect(0, 0, _0x2fc01e, _0x2fc01e);
    _0x22bf8e["drawImage"](this.brushImage, 0, 0, _0x2fc01e, _0x2fc01e);
    
    if (_0x27e49e) {
      var _0x313647 = _0x22bf8e["getImageData"](0, 0, _0x2fc01e, _0x2fc01e),
          _0x31fb69 = _0x313647["data"];
      
      for (var _0x2fa361 = 0; _0x2fa361 < _0x31fb69["length"]; _0x2fa361 += 4) {
        let _0x122e28 = parseInt((_0x31fb69[_0x2fa361] + _0x31fb69[_0x2fa361 + 1] + _0x31fb69[_0x2fa361 + 2]) / 3);
        _0x31fb69[_0x2fa361] = _0x122e28 + _0x2fee47.r;
        _0x31fb69[_0x2fa361 + 1] = _0x122e28 + _0x2fee47.g;
        _0x31fb69[_0x2fa361 + 2] = _0x122e28 + _0x2fee47.b;
      }
      _0x22bf8e["putImageData"](_0x313647, 0, 0);
      
      // Explicitly help garbage collection
      _0x313647 = null;
      _0x31fb69 = null;
    }
    
    var _0x388afa = this;
    
    // Reuse the existing cache image
    this._cacheImg.onload = function() {
      // Clear old brush cache if it exists
      if (_0x388afa["brushCache"]) {
        _0x388afa["brushCache"].onload = null;
      }
      _0x388afa["brushCache"] = this;
    };
    
    this._cacheImg["src"] = this._cacheCanvas.getData();
  }
  ["drawStart"](_0x4f03e0, _0x3a65d2, _0x2456dc) {
    if (this["brushCache"]) {
      var _0x58cf3c = this.getOption("size");
      this["surface"]["slate"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x58cf3c,
        strokestyle: this["surface"]["drawColor"],
        alpha: 1,
        blendmode: "normal",
        blur: 0,
        linedash: []
      }), this["surface"].slate["setCSSProperties"]({
        alpha: this["getOption"]("alpha"),
        blendmode: this["getOption"]("blendmode") || "normal",
        blur: this["getOption"]("blur")
      }), this["removeClicks"](), this["addClick"](_0x4f03e0, _0x3a65d2);
      if (this.getOption("randomrotation")) {
        this["surface"]["isMyself"] && this["surface"].setBrushOption("rotationvalue", Math.floor(Math.random() * 361 + 0));
        var _0x96f84c = parseInt(this["getOption"]("rotationvalue")) * (Math.PI / 180);
        this["contextSlate"]["translate"](_0x4f03e0, _0x3a65d2), this["contextSlate"]["rotate"](_0x96f84c), this.contextSlate.drawImage(this["brushCache"], -_0x58cf3c / 2, -_0x58cf3c / 2, _0x58cf3c, _0x58cf3c), this["contextSlate"]["rotate"](-_0x96f84c), this["contextSlate"]["translate"](-_0x4f03e0, -_0x3a65d2);
      } else this["contextSlate"].drawImage(this.brushCache, _0x4f03e0 - _0x58cf3c / 2, _0x3a65d2 - _0x58cf3c / 2);
      this["distance"] = 0;
    }
  }
  ["drawStep"](_0x44f702, _0x32953c, _0x4e78a1) {
    if (this["brushCache"] && !this["compositing"]) {
      this["getOption"]("randomrotation") && this["surface"].isMyself && this["surface"]["setBrushOption"]("rotationvalue", Math.floor(Math.random() * 361 + 0));
      var _0x76ca90 = new Point(_0x32953c.x - _0x44f702.x, _0x32953c.y - _0x44f702.y),
        _0x4e53d8 = Math["sqrt"](_0x76ca90.x * _0x76ca90.x + _0x76ca90.y * _0x76ca90.y),
        _0x332089 = this["getOption"]("size"),
        _0x294f05 = this["getOption"]("spacing") * 4;
      let _0x576b9c = this["calculateLine"](_0x44f702.x, _0x44f702.y, _0x32953c.x, _0x32953c.y);
      var _0x497fbd = this;
      $["each"](_0x576b9c, function (_0x3922af, _0x904d07) {
        if (++_0x497fbd["distance"] >= _0x332089 * _0x294f05 / 100) {
          _0x497fbd.addClick(_0x904d07.x, _0x904d07.y);
          if (_0x497fbd["getOption"]("randomrotation")) {
            var _0xffe5a7 = parseInt(loopValue(_0x497fbd["getOption"]("rotationvalue") + _0x3922af * 25, 360)) * (Math.PI / 180);
            _0x497fbd["contextSlate"]["translate"](_0x904d07.x, _0x904d07.y), _0x497fbd.contextSlate["rotate"](_0xffe5a7), _0x497fbd["contextSlate"]["drawImage"](_0x497fbd["brushCache"], -_0x332089 / 2, -_0x332089 / 2, _0x332089, _0x332089), _0x497fbd["contextSlate"].rotate(-_0xffe5a7), _0x497fbd["contextSlate"]["translate"](-_0x904d07.x, -_0x904d07.y);
          } else _0x497fbd["contextSlate"]["drawImage"](_0x497fbd.brushCache, _0x904d07.x - _0x332089 / 2, _0x904d07.y - _0x332089 / 2);
          _0x497fbd["distance"] = 0;
        }
      });
    }
  }
  ["drawEnd"](_0x379517, _0x2872a8, _0x5113c1) {
    this["composite"]();
  }
  ["colorChange"](_0x3bd546) {
    this.cache(this["getOption"]("size"), this.getOption("tint"), _0x3bd546);
  }
  ["optionChange"](_0x4a8f34, _0xa3f451) {
    if (_0x4a8f34 == "blendmode") this["surface"]["slate"]["canvas"]["css"]("mix-blend-mode", _0xa3f451); else {
      if (_0x4a8f34 == "blur") this["contextSlate"]["filter"] = "blur(" + _0xa3f451 + "px)"; else {
        if (_0x4a8f34 == "size") this["cache"](_0xa3f451, this["getOption"]("tint"), this["surface"]["drawColor"]); else _0x4a8f34 == "tint" && this["cache"](this["getOption"]("size"), _0xa3f451, this["surface"]["drawColor"]);
      }
    }
    if (_0x4a8f34 != "rotationvalue") {
      var _0x20643d = this["clickX"]["length"];
      if (_0x20643d > 0) {
        var _0xbf678d = new Point(this["clickX"][_0x20643d - 1], this.clickY[_0x20643d - 1]);
        this["composite"](), this["addClick"](_0xbf678d.x, _0xbf678d.y);
      }
    }
  }
  ["dispose"]() {
    // Clear all click arrays
    this.removeClicks();
    
    // Clean up image references
    if (this.brushImage) {
      this.brushImage.onload = null;
      this.brushImage = null;
    }
    
    if (this._loaderImage) {
      this._loaderImage.onload = null;
      this._loaderImage.onerror = null;
      this._loaderImage = null;
    }
    
    if (this["brushCache"]) {
      this["brushCache"].onload = null;
      this["brushCache"] = null;
    }
    
    if (this._cacheImg) {
      this._cacheImg.onload = null;
      this._cacheImg = null;
    }
    
    if (this._compositeImg) {
      this._compositeImg.onload = null;
      this._compositeImg.onerror = null;
      this._compositeImg = null;
    }
    
    // Clean up canvas
    if (this._cacheCanvas) {
      this._cacheCanvas.width = this._cacheCanvas.height = 1;
      this._cacheCanvas = null;
    }
    
    this.clearSlate();
  }
  ["composite"]() {
    if (this["compositing"]) return;
    
    this["compositing"] = true;
    
    // Get user's blend mode and transparency lock status
    const userBlendMode = this.getOption("blendmode") || "normal";
    const lockTransparency = this.getOption("locktransparency");
    
    // Always set the user's chosen blend mode regardless of transparency lock
    room["board"]["layers"][this["surface"]["currentLayer"]].advCanvas["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      alpha: this["getOption"]("alpha"),
      blendmode: userBlendMode, // Always use the user's blend mode
      blur: 0,
      linedash: []
    });
    
    var _0x4a2ccd = this;
    
    // Reuse the composite image
    this._compositeImg.onload = function() {
      var _0x41ab20 = room["board"]["getContext"](_0x4a2ccd.surface["currentLayer"]);
      
      if (lockTransparency) {
        // Two-step process for locked transparency
        
        // Step 1: Save the current canvas state
        const currentState = _0x41ab20.getImageData(0, 0, _0x41ab20.canvas.width, _0x41ab20.canvas.height);
        
        // Draw the brush with user's blend mode
        _0x41ab20["imageSmoothingEnabled"] = false;
        _0x41ab20["drawImage"](this, 0, 0);
        
        // Step 2: Get the result after drawing
        const newState = _0x41ab20.getImageData(0, 0, _0x41ab20.canvas.width, _0x41ab20.canvas.height);
        
        // Step 3: Preserve original alpha values
        const resultData = newState.data;
        const originalData = currentState.data;
        
        for (let i = 0; i < resultData.length; i += 4) {
          // Preserve original transparency levels
          const originalAlpha = originalData[i + 3];
          const newAlpha = resultData[i + 3];
          
          // If a pixel was originally semitransparent, keep it semitransparent
          if (originalAlpha < 255) {
            resultData[i + 3] = Math.min(newAlpha, originalAlpha);
          }
        }
        
        // Update canvas with masked result
        _0x41ab20.putImageData(newState, 0, 0);
        
      } else {
        // Standard drawing with user's blend mode
        _0x41ab20["imageSmoothingEnabled"] = false;
        _0x41ab20["drawImage"](this, 0, 0);
      }
      
      _0x4a2ccd["clearSlate"]();
      _0x4a2ccd["removeClicks"]();
      _0x4a2ccd["compositing"] = false;
      
      // Help garbage collection
      _0x41ab20 = null;
    };
    
    this._compositeImg.onerror = function() {
      _0x4a2ccd["compositing"] = false;
    };
    
    this._compositeImg["src"] = this.surface["slate"]["getData"]();
  }
  ["addClick"](_0x44a68b, _0x32694b) {
    this.clickX["push"](_0x44a68b), this["clickY"]["push"](_0x32694b);
  }
  ["removeClicks"]() {
    this["clickX"] = new Array(), this.clickY = new Array();
  }
  ["clearSlate"]() {
    this.contextSlate["clearRect"](0, 0, this.contextSlate["canvas"].width, this["contextSlate"]["canvas"]["height"]);
  }
  ["cancel"]() {
    this["clearSlate"]();
    this.removeClicks();
    // Help garbage collection
    this.contextSlate.canvas.width = this.contextSlate.canvas.width;
  }
  ["getSync"]() {
    var _0x2af73b = {};
    return _0x2af73b.clickX = this["clickX"], _0x2af73b.clickY = this["clickY"], _0x2af73b;
  }
  ["setSync"](_0x85510a) {
    this.clickX = _0x85510a["clickX"], this["clickY"] = _0x85510a["clickY"], this["redraw"]();
  }
  ["redraw"]() {
    if (this["brushCache"]) {
      var _0x2286f8 = this["getOption"]("size");
      this.clearSlate(), this["surface"]["slate"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: _0x2286f8,
        strokestyle: this["surface"]["drawColor"],
        alpha: 1,
        blendmode: "normal",
        blur: 0,
        linedash: []
      });
      for (var _0x4ab5d0 = 0; _0x4ab5d0 < this.clickX["length"]; _0x4ab5d0++) {
        this["contextSlate"]["drawImage"](this["brushCache"], this["clickX"][_0x4ab5d0] - _0x2286f8 / 2, this["clickY"][_0x4ab5d0] - _0x2286f8 / 2);
      }
    }
  }
}
class BrushBlur extends BrushStub {
  constructor(_0x66f3f6) {
    super(_0x66f3f6), this["lastX"], this["lastY"], this["advCanvas"], this.options = {}, this["options"]["size"] = new SizeOption(), this.options["cursor"] = new CursorOption("square");
  }
  ["brushStart"]() {
    this["advCanvas"] = new AdvancedCanvas(this["getOption"]("size"), this["getOption"]("size")), this["surface"]["cursor"]["changePointer"](this["getOption"]("cursor"));
  }
  ["brushStop"]() {
    this.advCanvas["remove"]();
  }
  ["optionChanged"](_0x3d62a1, _0xfc9ef8) {
    _0x3d62a1 == "cursor" && this["surface"].cursor["changePointer"](_0xfc9ef8);
  }
  ["drawStart"](_0x1af9b7, _0x24519f, _0x1b5db1) {
    this["drawBlur"](_0x1af9b7, _0x24519f), this["lastX"] = _0x1af9b7, this.lastY = _0x24519f;
  }
  ["drawStep"](_0x57a293, _0x44ee3a, _0x5d5de7) {
    this["getDistance"](_0x57a293.x, _0x57a293.y, this.lastX, this["lastY"]) >= this["getOption"]("size") / 4 && (this["drawBlur"](_0x57a293.x, _0x57a293.y), this.lastX = _0x57a293.x, this["lastY"] = _0x57a293.y);
  }
  ["drawBlur"](_0x15f7fb, _0x3df570) {
    var _0x38faa4 = room["board"]["getImageData"](this["surface"]["currentLayer"], _0x15f7fb - this.getOption("size") / 2, _0x3df570 - this["getOption"]("size") / 2, this["getOption"]("size"), this.getOption("size")),
      _0x4db252 = room["board"].getContext(this["surface"]["currentLayer"]);
    this.advCanvas.changeSize(this["getOption"]("size"), this["getOption"]("size")), this["advCanvas"]["putImageData"](_0x38faa4), this["advCanvas"].blur(1), _0x4db252.putImageData(this.advCanvas["getImageData"](), _0x15f7fb - this["getOption"]("size") / 2, _0x3df570 - this.getOption("size") / 2);
  }
}
class BrushPixel extends BrushStub {
  constructor(_0xee5f3e) {
    super(_0xee5f3e);
    this["clickX"] = new Array();
    this.clickY = new Array();
    this["options"] = {};
    this.options["size"] = new SizeOption();
    this["options"].drawgrid = new DrawGridOption(true);
    this.options["erasermode"] = new EraserModeOption();
    this["options"].rightclick = new RightClickOption("pixel");
    this["options"]["cursor"] = new CursorOption("square");
    this.options["locktransparency"] = new LockTransparencyOption(); // Add Lock Transparency option
  }
  
  ["brushStart"]() {
    this["surface"]["cursor"]["changePointer"](this["getOption"]("cursor")), this["drawGrid"]();
  }
  
  ["brushStop"]() {
    this["clearSlate"]();
  }
  
  ["drawStart"](_0x224047, _0x3994ca, _0x1a01ee) {
    this["setupSlate"](), this["removeClicks"]();
    var _0x5eed31 = this["getOption"]("size"),
      _0x505bf1 = Math["floor"](_0x224047 / _0x5eed31),
      _0x430444 = Math["floor"](_0x3994ca / _0x5eed31);
    this.addClick(_0x505bf1, _0x430444), this.getOption("erasermode") ? (this["composite"](), this["drawGrid"]()) : this.contextSlate["fillRect"](_0x505bf1 * _0x5eed31, _0x430444 * _0x5eed31, _0x5eed31, _0x5eed31);
  }
  
  ["drawStep"](_0x4ba038, _0x156579, _0x42df1e) {
    var _0x2a953 = this["getOption"]("size"),
      _0x3f4cb1 = new Array();
    this["getOption"]("erasermode") ? _0x3f4cb1["push"](new Point(_0x156579.x, _0x156579.y)) : _0x3f4cb1 = this.calculateLine(_0x4ba038.x, _0x4ba038.y, _0x156579.x, _0x156579.y);
    var _0x339733 = this;
    $["each"](_0x3f4cb1, function (_0x1f1b51, _0x45fba5) {
      var _0x3bec86 = Math["floor"](_0x45fba5.x / _0x2a953),
        _0x12acff = Math["floor"](_0x45fba5.y / _0x2a953);
      !_0x339733["clickExists"](_0x3bec86, _0x12acff) && (_0x339733["addClick"](_0x3bec86, _0x12acff), _0x339733["getOption"]("erasermode") ? (_0x339733["composite"](), _0x339733["drawGrid"]()) : _0x339733.contextSlate["fillRect"](_0x3bec86 * _0x2a953, _0x12acff * _0x2a953, _0x2a953, _0x2a953));
    });
  }
  
  ["optionChange"](_0x342843, _0x156b59) {
    if (_0x342843 == "size") {
      var _0x4901be = this["clickX"].length;
      _0x4901be > 0 && this["composite"]();
    }
  }
  
  ["drawEnd"](_0x318789, _0x319502, _0x38e559) {
    this["composite"](), this["clearSlate"](), this.drawGrid();
  }
  
  ["addClick"](_0x140f1a, _0x5e886a) {
    this.clickX["push"](_0x140f1a), this.clickY["push"](_0x5e886a);
  }
  
  ["removeClicks"]() {
    this["clickX"] = new Array(), this["clickY"] = new Array();
  }
  
  ["clickExists"](_0x163e11, _0x4a833f) {
    for (var _0xc84aee = 0; _0xc84aee < this.clickX["length"]; _0xc84aee++) {
      if (this.clickX[_0xc84aee] == _0x163e11 && this["clickY"][_0xc84aee] == _0x4a833f) return true;
    }
    return false;
  }
  
  ["optionChanged"](_0x4fb3c5, _0x273cd5) {
    if (_0x4fb3c5 == "size") this["clickX"]["length"] > 0 ? this["composite"]() : this.clearSlate(), this["drawGrid"](); else {
      if (_0x4fb3c5 == "drawgrid") this["clickX"]["length"] > 0 ? this["composite"]() : this["clearSlate"](), this["drawGrid"](); else _0x4fb3c5 == "cursor" && this.surface["cursor"]["changePointer"](_0x273cd5);
    }
  }
  
  ["composite"]() {
    var _0x212574 = this["getOption"]("size");
    
    // Determine the blend mode:
    // - If eraser mode is on, use destination-out (eraser takes precedence)
    // - If lock transparency is on, use source-atop
    // - Otherwise use normal
    var _0xc7d52f = "normal";
    
    if (this["getOption"]("erasermode")) {
      _0xc7d52f = "destination-out";
    } else if (this.getOption("locktransparency")) {
      _0xc7d52f = "source-atop";
    }
    
    room["board"]["layers"][this.surface.currentLayer].advCanvas["setCanvasProperties"]({
      fillstyle: _0xc7d52f == "normal" || _0xc7d52f == "source-atop" ? this["surface"]["drawColor"] : room["board"]["backgroundColor"],
      alpha: 1,
      blendmode: _0xc7d52f,
      blur: 0,
      linedash: []
    });
    
    var _0x5c8b03 = room["board"]["getContext"](this["surface"]["currentLayer"]);
    for (var _0x50c913 = 0; _0x50c913 < this["clickX"].length; _0x50c913++) {
      _0x5c8b03["fillRect"](this.clickX[_0x50c913] * _0x212574, this["clickY"][_0x50c913] * _0x212574, _0x212574, _0x212574);
    }
    this["removeClicks"](), this["clearSlate"]();
  }
  
  ["drawGrid"]() {
    var _0x417588 = this["getOption"]("size");
    if (this["getOption"]("drawgrid") && _0x417588 >= 3 && this["surface"]["isMyself"]) {
      this["surface"]["slate"].setCanvasProperties({
        linejoin: "round",
        linecap: "round",
        linewidth: 1,
        strokestyle: "#808080",
        alpha: 1,
        blendmode: "normal",
        blur: 0,
        linedash: []
      }), this["surface"]["slate"]["setCSSProperties"]({
        alpha: 1,
        blendmode: "normal",
        blur: 0
      }), this["contextSlate"].beginPath();
      for (var _0x19a0c9 = 0; _0x19a0c9 < room["board"].canvasWidth / _0x417588; _0x19a0c9++) {
        this["contextSlate"].moveTo(_0x19a0c9 * _0x417588, 0), this["contextSlate"].lineTo(_0x19a0c9 * _0x417588, room["board"]["canvasHeight"]);
      }
      for (var _0x9234cc = 0; _0x9234cc < room["board"].canvasHeight / _0x417588; _0x9234cc++) {
        this["contextSlate"].moveTo(0, _0x9234cc * _0x417588), this.contextSlate["lineTo"](room["board"].canvasWidth, _0x9234cc * _0x417588);
      }
      this["contextSlate"]["stroke"]();
    }
  }
  ["setupSlate"]() {
    this.surface["slate"]["setCanvasProperties"]({
      fillstyle: this["surface"]["drawColor"],
      alpha: 1,
      blendmode: "normal",
      blur: 0
    }), this["surface"]["slate"]["setCSSProperties"]({
      alpha: 1,
      blendmode: "normal",
      blur: 0
    });
  }
  ["clearSlate"]() {
    this["contextSlate"]["clearRect"](0, 0, this["contextSlate"]["canvas"]["width"], this["contextSlate"]["canvas"]["height"]);
  }
  ["cancel"]() {
    this["clearSlate"](), this["removeClicks"]();
  }
  ["isUsingSlate"]() {
    return this.surface["isMyself"] && this["getOption"]("drawgrid");
  }
}
class Component {
  constructor() { }
}
class UIComponent extends Component {
  constructor(_0x253bc1) {
    super(), this["container"] = _0x253bc1, this["readOnly"] = false;
  }
  ["setName"](_0x3ae159) {
    this["container"]["attr"]("name", _0x3ae159);
  }
  ["getName"]() {
    return this["container"]["attr"]("name");
  }
  ["setReadOnly"](_0x47e78b) {
    this["readOnly"] = _0x47e78b, _0x47e78b ? (this["container"]["addClass"]("readOnly"), $(this)["triggerHandler"](new componentDisabledEvent().getEvent())) : (this.container.removeClass("readOnly"), $(this)["triggerHandler"](new componentEnabledEvent()["getEvent"]()));
  }
  ["focus"]() { }
}
class Slider extends UIComponent {
  constructor(_0x4e1dd6, _0x57c5b6 = 10, _0x42397f = 20, _0x7b7f1 = 1, _0x151f68 = null, _0x1c29b0 = "slider") {
    super(_0x4e1dd6);
    !this.container["hasClass"]("fmSlider") && this["container"]["addClass"]("fmSlider");
    this.thumb = $("<div />"), this["thumb"]["addClass"]("fmThumb"), this.selectedArea = $("<div />"), this.selectedArea["addClass"]("fmSelectedArea"), this["namespace"] = _0x1c29b0, this["container"]["empty"](), this.container["append"](this["thumb"]), this["container"]["append"](this.selectedArea), this["isDragging"] = false, this.min, this["max"], this["step"], this["setup"](_0x57c5b6, _0x42397f, _0x7b7f1), this.labelCallback = _0x151f68, this["value"] = _0x57c5b6, this["snap"] = true, this.tmpValue = this["value"], this["setLabel"](this["value"]);
    var _0xc33f3e = this;
    this["thumb"].on(UI.pointerEvent("down", this["namespace"]), function (_0x300a83) {
      _0x300a83.preventDefault(), (!_0x300a83.which || _0x300a83["which"] == 1) && !_0xc33f3e["readOnly"] && (_0xc33f3e["dragging"](true), UI["setFocusElement"](_0xc33f3e));
    }), this["container"].on(UI["pointerEvent"]("down", this.namespace), function (_0x212487) {
      _0x212487.preventDefault();
      if (!_0x212487["which"] || _0x212487["which"] == 1) {
        if (!_0xc33f3e.readOnly) {
          _0xc33f3e["dragging"](true), UI["setFocusElement"](_0xc33f3e);
          if (_0xc33f3e["steps"] > 1) {
            var _0x49fe22 = UI["getInputPosition"](_0x212487),
              _0xe011cc = _0xc33f3e["container"]["offset"](),
              _0x54af03 = _0xc33f3e.thumb["width"]();
            _0xc33f3e["moveThumb"](_0x49fe22.x - _0xe011cc["left"] - _0x54af03 / 2, true);
          }
        }
      }
    }), $(document).on(UI["pointerEvent"]("move", this.namespace), function (_0x33578f) {
      if (!_0xc33f3e["readOnly"]) {
        if (_0xc33f3e["isDragging"]) {
          if (_0xc33f3e["steps"] > 1) {
            var _0x35150d = UI["getInputPosition"](_0x33578f),
              _0x33351f = _0xc33f3e["container"]["offset"](),
              _0x11bffe = _0xc33f3e["thumb"]["width"](),
              _0x5aa294 = _0xc33f3e["container"]["width"]() - _0x11bffe,
              _0x49ee18 = Math.max(Math.min(_0x35150d.x - _0x33351f["left"] - _0x11bffe / 2, _0x5aa294), 0);
            _0xc33f3e.moveThumb(_0x49ee18);
            var _0x4dc568 = _0xc33f3e["nearest"](_0x49ee18 / (_0x5aa294 / (_0xc33f3e["steps"] - 1)) * _0xc33f3e["step"] + _0xc33f3e["min"], _0xc33f3e["min"], _0xc33f3e["max"], _0xc33f3e["step"]);
            _0x4dc568 != _0xc33f3e["tmpValue"] && ($(_0xc33f3e)["triggerHandler"](new sliderMovedEvent(_0x4dc568, _0xc33f3e["tmpValue"]).getEvent()), _0xc33f3e.tmpValue = _0x4dc568);
          }
        }
      }
    }), $(document).on(UI["pointerEvent"]("up", this.namespace), function (_0x2ec967) {
      _0x2ec967["preventDefault"]();
      if (!_0xc33f3e["readOnly"]) {
        if (_0xc33f3e["isDragging"]) {
          if (_0xc33f3e.steps > 1) {
            var _0x3f04f2 = parseInt(_0xc33f3e["container"]["width"]() - _0xc33f3e["thumb"].width()),
              _0x15422d = parseInt(_0xc33f3e["thumb"]["css"]("left")["replace"]("px", "")),
              _0x50fce7 = _0xc33f3e["nearest"](_0x15422d / (_0x3f04f2 / (_0xc33f3e["steps"] - 1)) * _0xc33f3e.step + _0xc33f3e["min"], _0xc33f3e.min, _0xc33f3e.max, _0xc33f3e["step"]);
            _0xc33f3e["updateValue"](_0x50fce7), _0xc33f3e["snapThumb"]();
          }
          _0xc33f3e.dragging(false), UI["setFocusElement"](_0xc33f3e);
        }
      }
    });
    try {
      if (ResizeObserver) {
        const _0x540a3b = new ResizeObserver(_0x20cb84 => {
          this.refresh();
        });
        _0x540a3b["observe"](this.container[0]);
      }
    } catch (_0x236a57) { }
  }
  ["dragging"](_0x52e85f) {
    this["isDragging"] = _0x52e85f;
  }
  ["setup"](_0x214c57, _0x14233c, _0x2ce257) {
    this["min"] = _0x214c57, this.max = _0x14233c, this["step"] = _0x2ce257, this.steps = (_0x14233c - _0x214c57 + _0x2ce257) / _0x2ce257;
    var _0x277eaf = parseInt(this["container"]["width"]());
    this["setThumbSize"](Math.max(25, _0x277eaf / this["steps"])), this["steps"] > 0 ? this["thumb"]["show"]() : this.thumb["hide"]();
  }
  ["snapThumb"]() {
    var _0x70267f = this["container"]["width"]() - this["thumb"]["width"]();
    this["setThumbPosition"](this.valueToIndex(this["value"]) * (_0x70267f / (this["steps"] - 1)));
  }
  ["updateValue"](_0x3c3057, _0x4eb2fd = false) {
    (this["value"] != _0x3c3057 || _0x4eb2fd) && (_0x3c3057 = this.nearest(_0x3c3057, this.min, this["max"], this["step"]), $(this)["triggerHandler"](new sliderMovedEvent(_0x3c3057, this["value"])["getEvent"]()), $(this).triggerHandler(new sliderChangeEvent(_0x3c3057, this["value"])["getEvent"]()), this.value = _0x3c3057, $(this)["triggerHandler"](new sliderChangedEvent(_0x3c3057, this["value"])["getEvent"]()), this["setLabel"](Math["round"](this["value"] * 100) / 100));
  }
  ["moveThumb"](_0x4af4c7, _0x1acd4a = false) {
    var _0x52361c = this.container["width"]() - this["thumb"]["width"](),
      _0x5434b3 = Math["max"](Math["min"](_0x4af4c7, _0x52361c), 0);
    this.setThumbPosition(_0x5434b3);
    var _0x41a532 = this["nearest"](_0x5434b3 / (_0x52361c / (this["steps"] - 1)) * this["step"] + this["min"], this.min, this["max"], this["step"]);
    _0x1acd4a ? this.updateValue(_0x41a532) : this["setLabel"](Math.round(_0x41a532 * 100) / 100), this["snap"] && !this["isDragging"] && this["snapThumb"]();
  }
  ["nearest"](_0x4f00d7, _0x1755fc, _0x37ca90, _0x37de1e) {
    var _0x2231a3 = (_0x37ca90 - _0x1755fc) / _0x37de1e,
      _0xd64307 = Math["round"]((_0x4f00d7 - _0x1755fc) * _0x2231a3 / (_0x37ca90 - _0x1755fc)) / _0x2231a3;
    return _0xd64307 * (_0x37ca90 - _0x1755fc) + _0x1755fc;
  }
  ["setLabel"](_0x3a06b6) {
    this.labelCallback != null ? this.thumb["text"](this["labelCallback"](_0x3a06b6)) : this["thumb"]["text"](_0x3a06b6);
  }
  ["setValue"](_0x1f6151, _0x1d7d4e = false) {
    if (this.value != _0x1f6151 && _0x1f6151 >= this["min"] && _0x1f6151 <= this.max || _0x1d7d4e) {
      if (!isNaN(_0x1f6151)) {
        this["updateValue"](_0x1f6151, _0x1d7d4e);
        var _0x2bfc4e = this["container"]["width"]() - this["thumb"]["width"]();
        this["moveThumb"](this["valueToIndex"](this["value"]) * (_0x2bfc4e / (this["steps"] - 1))), this.tmpValue = this.value;
      }
    }
  }
  ["refresh"]() {
    var _0xfaf22c = this["container"]["width"]() - this["thumb"]["width"]();
    this["moveThumb"](this["valueToIndex"](this.value) * (_0xfaf22c / (this.steps - 1)));
  }
  ["setThumbSize"](_0xf005b8) {
    var _0xc44985 = _0xf005b8 * 100 / this["container"]["width"]();
    this["thumb"].css("width", _0xc44985 + "%");
  }
  ["setThumbPosition"](_0xf4a6cd) {
    var _0x58bedc = _0xf4a6cd * 100 / this.container["width"]();
    this["thumb"].css("left", _0x58bedc + "%");
    var _0x426ab2 = (_0xf4a6cd + this.thumb["width"]() / 2) * 100 / this["container"]["width"]();
    this["selectedArea"]["css"]("width", _0x426ab2 + "%");
  }
  ["valueToIndex"](_0x19ac90) {
    return (_0x19ac90 - this["min"]) / this["step"];
  }
  ["getValue"]() {
    return this["value"];
  }
  ["keyPress"](_0x5a1536) {
    if (_0x5a1536 == 39 || _0x5a1536 == 38) this["increase"](); else (_0x5a1536 == 37 || _0x5a1536 == 40) && this.decrease();
  }
  ["increase"]() {
    this["setValue"](this.value + this.step);
  }
  ["decrease"]() {
    this["setValue"](this["value"] - this.step);
  }
  ["destroy"]() {
    this["thumb"]["off"]("." + this["namespace"]), this["container"]["off"]("." + this.namespace), $(document)["off"]("." + this["namespace"]), this.container["empty"]();
  }
  ["focus"]() {
    UI["setFocusElement"](this);
  }
}
class SliderCheck extends UIComponent {
  constructor(_0x3600ec, _0x120ac1 = "", _0xff421a = 10, _0x4e7a4f = 20, _0x9a319b = 1, _0x49ef9c = null, _0x5eb7a5 = null, _0x2931a9 = "slidercheck") {
    super(_0x3600ec), _0x3600ec["append"]('<div class="checkbox" style="width: 25px; margin-right: 2px; float: left;"></div><div class="slider" style="width: calc(100% - 27px); float: left;"></div>'), this["checkbox"] = new Checkbox(_0x3600ec["find"](".checkbox"), _0x120ac1, _0x49ef9c, _0x2931a9), this.slider = new Slider(_0x3600ec["find"](".slider"), _0xff421a, _0x4e7a4f, _0x9a319b, _0x5eb7a5, _0x2931a9);
    var _0x4f2bf7 = this;
    $(this["slider"]).on("sliderChange sliderChanged", function (_0x468bc0) {
      _0x4f2bf7["sliderChanged"](_0x468bc0.oldvalue, _0x468bc0.newvalue, _0x468bc0.type == "sliderChange");
    }), $(this.checkbox).on("checkboxChange checkboxChanged", function (_0x4395c8) {
      _0x4f2bf7.checkboxChanged(_0x4395c8["checked"], _0x4395c8["type"] == "checkboxChange");
    });
  }
  ["sliderChanged"](_0x20f76d, _0x46da20, _0xa5c380) {
    var _0x4df636 = this["getValue"](),
      _0x517f34 = [_0x4df636[0], _0x20f76d],
      _0x3fbc02 = [_0x4df636[0], _0x46da20];
    _0xa5c380 ? $(this)["triggerHandler"](new sliderCheckChangeEvent(_0x517f34, _0x3fbc02)["getEvent"]()) : $(this).triggerHandler(new sliderCheckChangedEvent(_0x517f34, _0x3fbc02).getEvent());
  }
  ["checkboxChanged"](_0x440143, _0x370d2d) {
    var _0x5d7c9d = this["getValue"](),
      _0x95ce7c = [_0x440143, _0x5d7c9d[1]],
      _0x33c3d3 = [!_0x440143, _0x5d7c9d[1]];
    _0x370d2d ? $(this)["triggerHandler"](new sliderCheckChangeEvent(_0x95ce7c, _0x33c3d3).getEvent()) : $(this)["triggerHandler"](new sliderCheckChangedEvent(_0x95ce7c, _0x33c3d3)["getEvent"]());
  }
  ["getValue"]() {
    var _0x258962 = [];
    return _0x258962["push"](this["checkbox"]["getValue"]()), _0x258962["push"](this.slider["getValue"]()), _0x258962;
  }
  ["setValue"](_0x21a2fd, _0x5acc62 = false) {
    this["checkbox"]["setValue"](_0x21a2fd[0], _0x5acc62), this["slider"]["setValue"](_0x21a2fd[1], _0x5acc62);
  }
  ["setReadOnlySubcomponents"](_0x5086fa) {
    this["checkbox"].setReadOnly(_0x5086fa[0]), this["slider"].setReadOnly(_0x5086fa[1]);
  }
  ["destroy"]() {
    this["checkbox"]["destroy"](), this["slider"]["destroy"](), this["container"].empty();
  }
  ["focus"]() {
    UI["setFocusElement"](this);
  }
}
class Button extends UIComponent {
  constructor(_0x5436ad, _0xdc6497 = null, _0x4cc324 = "...", _0x41c76f = "button") {
    super(_0x5436ad);
    !this["container"].hasClass("fmButton") && this.container["addClass"]("fmButton");
    this["namespace"] = _0x41c76f, this["clickCallback"] = _0xdc6497, this.link = $("<a />"), this.link["attr"]("href", "#"), this.link["addClass"]("p-0 m-0 buttonOption optionField"), this["link"]["text"](_0x4cc324), this["container"]["html"](this["link"]);
    var _0xfb31d7 = this;
    this["link"].on(UI.pointerEvent("click", this.namespace), function (_0x1344fe) {
      _0x1344fe["preventDefault"]();
    }), this["link"].on(UI["pointerEvent"]("up", this["namespace"]), function (_0x5157e3) {
      _0x5157e3["preventDefault"](), !_0xfb31d7["readOnly"] && _0xfb31d7["clicked"]();
    });
  }
  ["clicked"]() {
    this.clickCallback && this["clickCallback"](), $(this)["triggerHandler"](new buttonClickedEvent()["getEvent"]()), UI["setFocusElement"](this);
  }
  ["destroy"]() {
    this["link"]["off"]("." + this["namespace"]), this.container["empty"]();
  }
}
class List extends UIComponent {
  constructor(_0x1046d4, _0xb951c6, _0x49641e, _0x5c4dea = null, _0x58c220 = "list") {
    super(_0x1046d4);
    !this["container"]["hasClass"]("fmList") && this["container"]["addClass"]("fmList");
    this["namespace"] = _0x58c220, this.funcCallback = _0x5c4dea, this.select = $("<select />"), this["select"]["addClass"]("browser-default custom-select p-0 m-0 menuOption optionField");
    var _0x57ba92 = this;
    $["each"](_0xb951c6, function (_0x21b4c8, _0x211744) {
      _0x57ba92["select"]["append"]("<option value=\"" + _0x21b4c8 + '" ' + (_0x21b4c8 == _0x49641e ? 'selected="selected"' : "") + ">" + _0x211744 + "</option>");
    }), this.container["html"](this["select"]), this["select"].on("change." + this["namespace"], function (_0x175ed3) {
      !_0x57ba92["readOnly"] && (_0x57ba92["selected"](_0x57ba92["select"].val()), this["blur"]());
    }), this.select.on("keydown." + this["namespace"], function (_0xe71855) {
      _0xe71855["preventDefault"](), this["blur"]();
    });
  }
  ["selected"](_0x58f313) {
    this["funcCallback"] && this["funcCallback"](), $(this)["triggerHandler"](new listChangedEvent(_0x58f313)["getEvent"]()), UI["setFocusElement"](this);
  }
  ["destroy"]() {
    this["select"].off("." + this["namespace"]), this["container"]["empty"]();
  }
  ["focus"]() {
    this.select["focus"]();
  }
}
class Switch extends UIComponent {
  constructor(_0x33ff59, _0x23bc5e = null, _0x480f5a = "switch") {
    super(_0x33ff59), this["checked"];
    !this.container.hasClass("fmSwitch") && this["container"]["addClass"]("fmSwitch");
    this.namespace = _0x480f5a, this["onLabel"] = $("<div />"), this["onLabel"].addClass("fmOn checkLabel"), this["onLabel"].html(_0x23bc5e ? _0x23bc5e(true) : "on"), this.offLabel = $("<div />"), this.offLabel["addClass"]("fmOff checkLabel"), this.offLabel["html"](_0x23bc5e ? _0x23bc5e(false) : "off"), this["thumb"] = $("<div />"), this["thumb"]["addClass"]("fmThumb"), this["container"].append(this["onLabel"]), this.container.append(this["offLabel"]), this["container"]["append"](this["thumb"]), this["setValue"](false);
    var _0x1aea66 = this;
    this.thumb.on(UI["pointerEvent"]("up", this["namespace"]), function (_0x4dd0a7) {
      _0x4dd0a7.preventDefault(), (!_0x4dd0a7.which || _0x4dd0a7["which"] == 1) && !_0x1aea66["readOnly"] && _0x1aea66["clicked"]();
    }), this["onLabel"].on(UI["pointerEvent"]("up", this["namespace"]), function (_0x1f3ed9) {
      _0x1f3ed9["preventDefault"](), (!_0x1f3ed9["which"] || _0x1f3ed9.which == 1) && !_0x1aea66.readOnly && _0x1aea66.clicked();
    }), this.offLabel.on(UI["pointerEvent"]("up", this["namespace"]), function (_0xeb9c20) {
      _0xeb9c20["preventDefault"](), (!_0xeb9c20["which"] || _0xeb9c20["which"] == 1) && !_0x1aea66.readOnly && _0x1aea66["clicked"]();
    });
  }
  ["clicked"]() {
    this["setValue"](!this["checked"]), UI.setFocusElement(this);
  }
  ["getValue"]() {
    return this["checked"];
  }
  ["setValue"](_0x2f521a, _0x243718 = false) {
    if (this.checked != _0x2f521a || _0x243718) {
      if (_0x2f521a) {
        var _0x4df2db = parseInt(this["container"]["css"]("width")["replace"]("px", "")),
          _0x51fec3 = parseInt(this["thumb"]["css"]("width")["replace"]("px", ""));
        this.onLabel["css"]("width", "100%"), this["offLabel"].css("width", "0%"), this["thumb"]["css"]("left", "calc(100% - " + _0x51fec3 + "px)");
      } else this["onLabel"]["css"]("width", "0%"), this["offLabel"].css("width", "100%"), this["thumb"]["css"]("left", 0);
      $(this)["triggerHandler"](new checkboxChangeEvent(_0x2f521a)["getEvent"]()), this.checked = _0x2f521a, $(this)["triggerHandler"](new checkboxChangedEvent(_0x2f521a)["getEvent"]());
    }
  }
  ["keyPress"](_0x46f6d1) {
    if (_0x46f6d1 == 32) this["setValue"](!this["checked"]); else {
      if (_0x46f6d1 == 39 || _0x46f6d1 == 38) this.setValue(true); else (_0x46f6d1 == 37 || _0x46f6d1 == 40) && this["setValue"](false);
    }
  }
  ["destroy"]() {
    this["thumb"]["off"]("." + this["namespace"]), this["onLabel"]["off"]("." + this["namespace"]), this["offLabel"]["off"]("." + this["namespace"]), this.container.empty();
  }
  ["focus"]() {
    UI.setFocusElement(this);
  }
}
class Checkbox extends UIComponent {
  constructor(_0x447ae3, _0x53746d = "", _0x41c159 = null, _0xac9114 = "simplecheckbox") {
    super(_0x447ae3), this["checked"];
    !this["container"]["hasClass"]("fmCheckbox") && this["container"]["addClass"]("fmCheckbox");
    this["namespace"] = _0xac9114, this["labelCallback"] = _0x41c159 ? _0x41c159 : this["defaultLabel"], this.label = $("<div />"), this["label"]["addClass"]("fmOff checkLabel simpleBox fmCheckbox"), this.label["html"](this["labelCallback"](false)), this.container["append"](this["label"]);
    var _0x17073f = this;
    _0x53746d != "" && (this["caption"] = $("<a href=\"#\" />"), this["caption"]["addClass"]("checkCaption"), this["caption"]["html"](_0x53746d), this.container.append(this.caption), this["caption"].on(UI["pointerEvent"]("down", this["namespace"]), function (_0x23306a) {
      _0x23306a["preventDefault"](), (!_0x23306a["which"] || _0x23306a["which"] == 1) && !_0x17073f["readOnly"] && _0x17073f["clicked"]();
    })), this["setValue"](false), this["label"].on(UI["pointerEvent"]("down", this["namespace"]), function (_0xcb9e51) {
      _0xcb9e51["preventDefault"](), (!_0xcb9e51["which"] || _0xcb9e51.which == 1) && !_0x17073f.readOnly && _0x17073f["clicked"]();
    });
  }
  ["defaultLabel"](_0x5aa480) {
    return _0x5aa480 ? "&#10004;" : "";
  }
  ["clicked"]() {
    this.setValue(!this["checked"]), UI.setFocusElement(this);
  }
  ["getValue"]() {
    return this.checked;
  }
  ["setValue"](_0x1faddc, _0x3e11c2 = false) {
    (this.checked != _0x1faddc || _0x3e11c2) && (this["label"].html(this["labelCallback"](_0x1faddc)), $(this).triggerHandler(new checkboxChangeEvent(_0x1faddc)["getEvent"]()), this["checked"] = _0x1faddc, this["checked"] ? this["label"].removeClass("fmOff").addClass("fmOn") : this["label"]["removeClass"]("fmOn")["addClass"]("fmOff"), $(this).triggerHandler(new checkboxChangedEvent(_0x1faddc)["getEvent"]()));
  }
  ["keyPress"](_0x1a93ae) {
    if (_0x1a93ae == 32) this["setValue"](!this["checked"]); else {
      if (_0x1a93ae == 39 || _0x1a93ae == 38) this.setValue(true); else (_0x1a93ae == 37 || _0x1a93ae == 40) && this["setValue"](false);
    }
  }
  ["destroy"]() {
    this["label"]["off"]("." + this["namespace"]), this["container"].empty();
  }
  ["focus"]() {
    UI.setFocusElement(this);
  }
}
class Pagination extends UIComponent {
  constructor(_0x527f2f) {
    super(_0x527f2f), this["page"] = 1, this["pages"] = 0, this["create"]();
  }
  ["create"]() {
    this.container["append"]('<ul class="pagination"></ul>');
    var _0x2a1f79 = this;
    this["container"].on(UI.pointerEvent("click"), "a.tablePagination", function (_0x553c1f) {
      _0x553c1f["preventDefault"](), _0x2a1f79["selectPage"]($(this)["attr"]("name"));
    });
  }
  ["update"](_0x3684d5) {
    var _0x1df67a = this["container"]["find"]("ul.pagination");
    if (_0x3684d5 != this.pages) {
      this["pages"] = _0x3684d5;
      var _0x5f20fc = this;
      _0x1df67a["empty"](), _0x1df67a.append("<li class=\"tablePaginationItem noPage\"><a name=\"previous\" class=\"tablePagination\" href=\"#\"><span>&laquo;</span></a></li>");
      for (var _0x581841 = 1; _0x581841 <= _0x3684d5; _0x581841++) {
        var _0x5747f1 = "";
        _0x581841 == 1 && (_0x5747f1 += " firstPage"), _0x581841 == _0x3684d5 && (_0x5747f1 += " lastPage"), _0x581841 == this["page"] && (_0x5747f1 += " currentPage"), _0x1df67a["append"]("<li class=\"tablePaginationItem regularPage" + _0x5747f1 + '"><a name="' + _0x581841 + "\" class=\"tablePaginationNumber tablePagination" + (this.page == _0x581841 ? " selected" : "") + '" href="#">' + _0x581841 + "</a></li>");
      }
      _0x1df67a["append"]("<li class=\"tablePaginationItem noPage\"><a name=\"next\" class=\"tablePagination\" href=\"#\"><span>&raquo;</span></a></li>");
    }
    _0x1df67a["find"]("li.divisorPage")["remove"](), _0x1df67a["find"]("li.regularPage")["addClass"]("hidden"), _0x1df67a["find"]("li.firstPage")["removeClass"]("hidden"), _0x1df67a.find("li.lastPage").removeClass("hidden");
    var _0x494e69 = _0x1df67a["find"]("li.currentPage");
    _0x494e69["removeClass"]("hidden");
    var _0x40a3f4 = 2;
    for (var _0x581841 = 1; _0x581841 <= _0x40a3f4; _0x581841++) {
      var _0x32ed6b = _0x494e69["prevAll"]("li.regularPage.hidden:first");
      _0x32ed6b && _0x32ed6b["removeClass"]("hidden");
      var _0x40099e = _0x494e69["nextAll"]("li.regularPage.hidden:first");
      _0x40099e && _0x40099e.removeClass("hidden");
    }
    var _0xe3a8e = _0x1df67a["find"]("li.firstPage")["next"]("li.regularPage");
    _0xe3a8e && _0xe3a8e.hasClass("hidden") && _0xe3a8e["before"]("<li class=\"tablePaginationItem divisorPage\"><a name=\"-\" class=\"tablePagination\" href=\"#\"><span>...</span></a></li>");
    var _0x7df1ea = _0x1df67a.find("li.lastPage")["prev"]("li.regularPage");
    ;
    _0x7df1ea && _0x7df1ea["hasClass"]("hidden") && _0x7df1ea["after"]("<li class=\"tablePaginationItem divisorPage\"><a name=\"-\" class=\"tablePagination\" href=\"#\"><span>...</span></a></li>");
  }
  ["selectPage"](_0x1c635c, _0x2b7aab = true) {
    if (_0x1c635c == "next") _0x1c635c = this["page"] + 1; else {
      if (_0x1c635c == "previous") _0x1c635c = this["page"] - 1; else _0x1c635c == "-" ? _0x1c635c = 0 : _0x1c635c = parseInt(_0x1c635c);
    }
    var _0x5f416b = this["container"]["find"]("ul.pagination");
    if (_0x1c635c >= 1 && _0x1c635c <= this["pages"]) {
      this["page"] = _0x1c635c;
      var _0x5f416b = this["container"]["find"]("ul.pagination");
      _0x5f416b["find"](".currentPage").removeClass("currentPage"), _0x5f416b["find"](".selected").removeClass("selected");
      var _0x1edf07 = _0x5f416b["find"]("a[name=\"" + _0x1c635c + '"]');
      _0x1edf07["addClass"]("selected"), _0x1edf07["parent"]()["addClass"]("currentPage"), _0x2b7aab && $(this)["triggerHandler"](new pageSelectedEvent(_0x1c635c)["getEvent"]());
    }
  }
  ["setPage"](_0x524c0d) {
    this["page"] != _0x524c0d && this["selectPage"](_0x524c0d, false);
  }
}
class Table extends UIComponent {
  constructor(_0xcb29b5, _0x3b0c93 = null, _0x488415 = null, _0x4d702f = null) {
    super(_0xcb29b5);
    _0x3b0c93 != null && this["setHeight"](_0x3b0c93);
    !this["container"]["hasClass"]("tableContainer") && this["container"]["addClass"]("tableContainer");
    this.title = "", this["filter"] = $("<div />"), this["filter"].addClass("pb-2 fmTableFilter"), this["header"] = $("<div />"), this.header["addClass"]("tableHeader"), this["body"] = $("<div />"), this["body"]["addClass"]("tableBody"), this["paginationContainer"] = $("<div><nav class=\"pull-right pe-1\"></nav></div>"), this.page = 1, this.orderByColumn = -1, this["orderAscendent"] = true, this["hiddenColumns"] = [0], this["columnLinks"] = {}, this["columnAlignments"] = [], this.pagination = new Pagination(this["paginationContainer"]["find"]("nav")), this["pagination"]["update"](1), this["createFilter"](this.filter), this["createHeader"](this.header, _0x4d702f), this.createTable(this["body"], _0x488415, _0x4d702f), this["createPagination"](this["pagination"]), this.filterable = false, this.selectable = true, this["showPagination"] = true, this.rows = [], this["rowCount"] = 0, this["rowsPerPage"] = 50, this.emptyRowVisible = false, this["headerFields"] = {}, this["container"]["append"](this["filter"]), this["container"]["append"](this["header"]);
    var _0x7175b9 = $("<div />");
    _0x7175b9["addClass"]("dataBody"), _0x7175b9["append"](this["body"]), _0x7175b9["append"](this["paginationContainer"]), this["container"]["append"](_0x7175b9), this["updateTimeout"] = null, this["setFilterable"](false), this.printEmpty();
    var _0x56cb31 = this;
    this.body.on(UI["pointerEvent"]("click"), "tr.regularRow", function () {
      !_0x56cb31["readOnly"] && _0x56cb31.select($(this)["attr"]("data-rowid"));
    }), this.body.on(UI["pointerEvent"]("dblclick"), "tr.regularRow", function () {
      !_0x56cb31["readOnly"] && (_0x56cb31["select"]($(this)["attr"]("data-rowid")), $(_0x56cb31)["triggerHandler"](new tableRowDoubleClickEvent(_0x56cb31["getSelected"]())["getEvent"]()));
    }), this["header"].on(UI["pointerEvent"]("click"), ".headerCell", function () {
      var _0x9ca9a5 = _0x56cb31.header["find"](".headerCell")["index"](this);
      _0x9ca9a5 == _0x56cb31["orderByColumn"] ? _0x56cb31.sort(_0x9ca9a5, !_0x56cb31["orderAscendent"]) : _0x56cb31["sort"](_0x9ca9a5);
    }), this["body"].on("scroll", function () {
      _0x56cb31["header"]["find"](".headerTable")["scrollLeft"]($(this).scrollLeft());
    });
  }
  ["createPagination"](_0x3597ec) {
    this["container"]["append"](this["paginationContainer"]);
    var _0x2fbfb7 = this;
    $(this.pagination).on("pageSelected", function (_0xcf57b6) {
      _0x2fbfb7["showPage"](_0xcf57b6.page, _0x2fbfb7["filter"]["find"]("input[name=\"filter\"]").val());
    }), this["paginationContainer"]["hide"]();
  }
  ["updatePagination"](_0x27bf3a = "") {
    var _0x43b59c = this["getFilteredRowCount"](_0x27bf3a),
      _0x1cf015 = Math["ceil"](_0x43b59c / this["rowsPerPage"]);
    (_0x1cf015 != this["pagination"]["pages"] || _0x1cf015 > 1 && !this["paginationContainer"].is(":visible")) && (this["pagination"]["update"](_0x1cf015), _0x1cf015 > 1 ? this.paginationContainer["fadeIn"](800) : this["paginationContainer"]["hide"](), this["updated"]());
  }
  ["createFilter"](_0x4d8aa9) {
    var _0x1ca3c5 = new Icon("fa-search");
    _0x4d8aa9["html"]('<span class="sub-title"></span><div class="filterField pull-right"><div class="input-group"><span class="input-group-text darkInput">' + _0x1ca3c5["html"]() + '</span><input type="text" class="form-control" placeholder="Filter" data-i18n="[placeholder]global.phFilter" name="filter"><span class="fieldRemove fas fa-times"></span></div></div>'), _0x4d8aa9["find"](".fieldRemove")["hide"]();
    var _0x49d37b = this;
    _0x4d8aa9["find"]("input[name=\"filter\"]").on("keyup", function (_0x248c1d) {
      var _0x4b3214 = $(this)["val"]();
      _0x49d37b["body"].find("tbody tr.regularRow")["remove"](), _0x49d37b["updatePagination"](_0x4b3214), _0x49d37b["showPage"](1, _0x4b3214), _0x4b3214 == "" ? _0x4d8aa9["find"](".fieldRemove")["hide"]() : _0x4d8aa9["find"](".fieldRemove").show();
    }), _0x4d8aa9.find(".fieldRemove").on(UI["pointerEvent"]("click"), function (_0x1db581) {
      _0x1db581.preventDefault(), _0x4d8aa9["find"]("input[name=\"filter\"]")["val"](""), _0x49d37b["body"]["find"]("tbody tr.regularRow").remove(), _0x49d37b["updatePagination"](), _0x49d37b["showPage"](1), _0x4d8aa9["find"](".fieldRemove")["hide"]();
    });
  }
  ["createHeader"](_0x1acf6a, _0x1091e3 = null) {
    var _0x5bbb04 = $("<div />");
    _0x5bbb04.addClass("headerTable"), _0x1091e3 != null && _0x5bbb04["addClass"](_0x1091e3), _0x1acf6a.append(_0x5bbb04);
  }
  ["createTable"](_0x24a242, _0x2885d3 = null, _0x53b1f9 = null) {
    var _0x3c7cb7 = $("<table />");
    _0x3c7cb7.append($("<tbody />")), _0x3c7cb7["addClass"]("fmTable table m-0 p-0"), _0x2885d3 != null && _0x3c7cb7["attr"]("id", _0x2885d3), _0x53b1f9 != null && _0x3c7cb7["addClass"](_0x53b1f9), _0x24a242["append"](_0x3c7cb7);
  }
  ["hideRow"](_0x57400b) {
    let _0x4eb440 = this["body"]["find"]("tbody tr.regularRow:nth-child(" + (_0x57400b + 1) + ")");
    _0x4eb440["hasClass"]("selected") && this["unselect"](), _0x4eb440["hide"]();
  }
  ["showRow"](_0x2b2956) {
    let _0xeb93f2 = this["body"]["find"]("tbody tr.regularRow:nth-child(" + (_0x2b2956 + 1) + ")");
    _0xeb93f2["hasClass"]("selected") && _0xeb93f2["data"]("rowid") && this.select(_0xeb93f2["data"]("rowid")), _0xeb93f2["show"]();
  }
  ["columnLink"](_0x16fcf5, _0x3dad87) {
    this["columnLinks"][_0x16fcf5] = _0x3dad87;
  }
  ["columnAlignment"](_0x9bc626, _0x3d0169 = "left") {
    this["header"]["find"]("div.headerTable div.headerRow div.headerCell:nth-child(" + (_0x9bc626 + 1) + ")")["css"]("text-align", _0x3d0169), this["body"]["find"]("tbody tr.regularRow td:nth-child(" + (_0x9bc626 + 1) + ")").css("text-align", _0x3d0169), this["columnAlignments"][_0x9bc626] = _0x3d0169;
  }
  ["getColumnOrder"](_0x1a6a11) {
    if (_0x1a6a11 in this["columnLinks"]) return this["columnLinks"][_0x1a6a11];
    return _0x1a6a11;
  }
  ["hideHeaderRow"](_0x1317d1) {
    hideRow(_0x1317d1, true);
  }
  ["showHeaderRow"](_0x4535d0) {
    showRow(_0x4535d0, true);
  }
  ["hideColumns"](_0x3b2284) {
    var _0x19e781 = this;
    $(_0x3b2284)["each"](function (_0x2cc1ea, _0x190034) {
      _0x19e781["hideColumn"](_0x190034, false);
    }), this["updated"]();
  }
  ["hideColumn"](_0x22fa80, _0x5210d1 = true) {
    if (this.hiddenColumns.indexOf(_0x22fa80) == -1) {
      this["hiddenColumns"]["push"](_0x22fa80);
      var _0x485f44 = this;
      $(this["hiddenColumns"])["each"](function (_0x34fb95, _0x17bba0) {
        _0x485f44["header"]["find"]("div.headerTable div.headerRow div.headerCell:nth-child(" + (_0x17bba0 + 1) + ")").hide(), _0x485f44["body"]["find"]("tbody tr.regularRow td:nth-child(" + (_0x17bba0 + 1) + ")")["hide"]();
      }), _0x5210d1 && this.updated();
    }
  }
  ["showColumn"](_0x5a9865) {
    this["hiddenColumns"]["indexOf"](_0x5a9865) > -1 && (this.hiddenColumns["pop"](_0x5a9865), this["header"]["find"]("div.headerTable div.headerRow div.headerCell:nth-child(" + (_0x5a9865 + 1) + ")").show(), this["body"]["find"]("tbody tr.regularRow td:nth-child(" + (_0x5a9865 + 1) + ")").show(), this["updated"]());
  }
  ["headerClass"](_0x1877cf, _0x408f3a) {
    this["header"]["find"]("div.headerTable div.headerRow div.headerCell:nth-child(" + (_0x1877cf + 1) + ")")["addClass"](_0x408f3a);
  }
  ["headerTooltip"](_0x3200be, _0x4621ba) {
    this.header.find("div.headerTable div.headerRow div.headerCell:nth-child(" + (_0x3200be + 1) + ")")["attr"]("data-tooltip", _0x4621ba);
  }
  ["headerCaption"](_0x319448, _0x4c4d06) {
    this["header"]["find"]("div.headerTable div.headerRow div.headerCell:nth-child(" + (_0x319448 + 1) + ") .headerCaption")["html"](_0x4c4d06);
  }
  ["setHeader"](_0x524302) {
    _0x524302["unshift"]("rowId");
    var _0x4afc8a = '<div class="headerRow fixedHeader">';
    $["each"](_0x524302, function (_0x9e3b78, _0x5cb7c2) {
      _0x4afc8a += "<div class=\"headerCell\"><div class=\"headerCaption\" data-headerid=\"" + escapeHTML(_0x5cb7c2) + '">' + _0x5cb7c2 + "</div></div>";
    }), _0x4afc8a += "</div>", this["header"]["find"]("div.headerTable").append(_0x4afc8a);
    var _0x6e4e21 = this;
    $(this["hiddenColumns"])["each"](function (_0x58adc7, _0x1591fc) {
      _0x6e4e21["header"]["find"]("div.headerTable div.headerRow:last div.headerCell:nth-child(" + (_0x1591fc + 1) + ")")["hide"]();
    }), $(this.columnAlignments)["each"](function (_0x354797, _0x5a867d) {
      _0x6e4e21["header"]["find"]("div.headerTable div.headerRow:last div.headerCell:nth-child(" + (_0x354797 + 1) + ")")["css"]("text-alignment", _0x5a867d);
    }), this["headerFields"] = _0x524302, this["rows"] == 0 && this["header"]["find"]("div.headerCell")["width"](100 / (_0x524302["length"] - this.hiddenColumns["length"]) + "%"), this["printEmpty"](), this["updated"]();
  }
  ["addRow"](_0x54182a, _0x2ee0e5 = true) {
    this["removeEmpty"](), this.removeFilter();
    var _0x118387 = this["rowCount"];
    _0x54182a["unshift"](_0x118387), this["rows"].push(_0x54182a), this["rowCount"]++;
    var _0x15320f = Math.floor(_0x118387 / this["rowsPerPage"]) + 1;
    return _0x15320f == this.page && (this["removeEmpty"](), this["printRow"](_0x118387, _0x54182a), _0x2ee0e5 && this.updated()), this.update(), _0x118387;
  }
  ["deleteRow"](_0x88534c) {
    var _0x2da47f = false,
      _0x88d83b = this;
    return $["each"](this["rows"], function (_0x28e962, _0xcc21c9) {
      if (_0xcc21c9 && _0xcc21c9[0] == _0x88534c) {
        let _0xc39be0 = _0x88d83b["body"]["find"]('tr.regularRow[data-rowid="' + _0x88534c + '"]');
        _0xc39be0["hasClass"]("selected") && _0x88d83b["unselect"](), _0xc39be0.remove(), delete _0x88d83b["rows"][_0x28e962], _0x88d83b["rowCount"]--;
      }
    }), _0x2da47f;
  }
  ["removeEmpty"]() {
    this["emptyRowVisible"] && (this["body"].find("tbody tr.emptyRow")["remove"](), this["emptyRowVisible"] = false);
  }
  ["printEmpty"]() {
    if (!this["emptyRowVisible"]) {
      let _0x30111e = Object.keys(this["headerFields"]).length - this["hiddenColumns"].length;
      if (_0x30111e > 0) {
        this["removeEmpty"]();
        var _0x355d61 = $("<tr />");
        _0x355d61["attr"]("name", "null"), _0x355d61.attr("data-rowid", -1), _0x355d61.addClass("emptyRow");
        var _0x1579c0 = $("<td />");
        _0x1579c0["attr"]("colspan", _0x30111e), _0x1579c0["html"](textManager.getString("global.lblNoResults")), _0x355d61["append"](_0x1579c0), _0x1579c0["show"](), this.body["find"]("tbody").append(_0x355d61);
      }
      this["emptyRowVisible"] = true;
    }
  }
  ["printRow"](_0x58ac09, _0xc80b59) {
    if (_0xc80b59) {
      var _0x42d33c = $("<tr />");
      _0x42d33c["attr"]("name", _0x58ac09), _0x42d33c["attr"]("data-rowid", _0xc80b59[0]), _0x42d33c.addClass("regularRow"), $["each"](_0xc80b59, function (_0x31d6aa, _0x4694a3) {
        var _0x9b625 = $("<td />");
        _0x4694a3 && $["type"](_0x4694a3) == "object" && _0x4694a3["container"] ? _0x9b625["html"](_0x4694a3["container"][0]) : _0x9b625.html(_0x4694a3), _0x42d33c["append"](_0x9b625);
      }), this["body"].find("tbody")["append"](_0x42d33c);
      var _0x5279e4 = this;
      $(this.hiddenColumns)["each"](function (_0x133e60, _0x186a4d) {
        _0x5279e4["body"]["find"]("tbody tr.regularRow:last td:nth-child(" + (_0x186a4d + 1) + ")")["hide"]();
      }), $(this.columnAlignments)["each"](function (_0x10ae4c, _0x3a18a9) {
        _0x5279e4.body["find"]("tbody tr.regularRow:last td:nth-child(" + (_0x10ae4c + 1) + ")")["css"]("text-align", _0x3a18a9);
      });
    }
  }
  ["getRow"](_0x51d7d5) {
    var _0x42dcb3 = false,
      _0x32da7e = this;
    return $.each(this.rows, function (_0x176715, _0x4003c7) {
      _0x4003c7 && _0x4003c7[0] == _0x51d7d5 && (_0x42dcb3 = _0x32da7e["rows"][_0x176715]);
    }), _0x42dcb3;
  }
  ["unselect"]() {
    this.body["find"](".selected")["removeClass"]("selected"), $(this).triggerHandler(new tableRowUnselectedEvent().getEvent());
  }
  ["select"](_0xdfd9c1) {
    this["body"]["find"](".selected")["removeClass"]("selected");
    if (this["selectable"]) {
      var _0x495855 = this["body"]["find"]("tr.regularRow[data-rowid=\"" + _0xdfd9c1 + '"]');
      _0x495855["length"] > 0 && (_0x495855["addClass"]("selected"), $(this)["triggerHandler"](new tableRowSelectedEvent(this["getSelected"]())["getEvent"]()));
    }
  }
  ["reset"]() {
    this["header"]["find"]("div.headerTable")["empty"](), this["headerFields"] = {}, this["clear"]();
  }
  ["clear"]() {
    this["body"]["find"]("tbody")["empty"](), this.rowCount = 0, this["rows"] = [], this.page = 1, this["printEmpty"](), this["pagination"]["setPage"](1), this["updated"]();
  }
  ["update"]() {
    this.updateTimeout != null && clearTimeout(this.updateTimeout);
    var _0x56937e = this;
    this["updateTimeout"] = setTimeout(function () {
      _0x56937e["updatePagination"](), _0x56937e["updateTimeout"] = null;
    }, 100);
  }
  ["updated"]() {
    var _0x540c64 = this,
      _0x3f14a7 = 0;
    this["body"]["find"]("tbody tr.regularRow:first td.hasMinWidth").removeClass("hasMinWidth")["css"]("min-width", "unset"), this["header"]["find"]("div.headerTable div.headerRow:first div.headerCell")["each"](function (_0x5c169b, _0x553814) {
      var _0x29e769 = _0x540c64["calculateTextWidth"]($(_0x553814)["find"](".headerCaption")["text"]()),
        _0x12a933 = _0x540c64["body"]["find"]("tbody tr.regularRow:first td:nth-child(" + (_0x5c169b + 1) + ")");
      _0x12a933.is(":visible") && _0x12a933["addClass"]("hasMinWidth")["css"]("min-width", _0x29e769);
    }), this["header"]["find"]("div.headerTable div.headerRow:first div.headerCell")["each"](function (_0x4cca09, _0x8229b7) {
      var _0x3aabb2 = _0x540c64.body["find"]("tbody tr.regularRow:first td:nth-child(" + (_0x4cca09 + 1) + ")"),
        _0x5a5e5b = _0x3aabb2["width"](),
        _0x264c50 = _0x3aabb2["outerWidth"]();
      $(_0x8229b7)["width"](_0x5a5e5b), _0x3f14a7 += _0x264c50;
    }), this.header["find"]("div.headerTable div.headerRow").width(_0x3f14a7);
    var _0x4b4930 = Math["ceil"](this["rowCount"] / this["rowsPerPage"]),
      _0x11399b = this["header"]["outerHeight"](),
      _0x2d31df = _0x4b4930 == 1 ? 0 : this["paginationContainer"]["outerHeight"]() || 35.6,
      _0x217c89 = this["filterable"] ? this["filter"]["outerHeight"]() : 0;
    this["pagination"]["update"](_0x4b4930), this["body"]["css"]("height", "calc(100% - " + (_0x11399b + _0x2d31df + _0x217c89) + "px)");
  }
  ["getColumnId"](_0x42885c) {
    var _0x1125d4 = null;
    return $.each(this.headerFields, function (_0x440f23, _0x5e8590) {
      _0x5e8590 && _0x5e8590 == _0x42885c && (_0x1125d4 = _0x440f23);
    }), _0x1125d4;
  }
  ["getHeader"](_0x4c4667) {
    var _0x2c6c49 = [];
    return this["header"]["find"]("div.headerRow:first div.headerCell div.headerCaption")["each"](function (_0x2535f4, _0x5cb8da) {
      _0x2c6c49["push"]($(_0x5cb8da)["data"]("headerid"));
    }), _0x2c6c49[_0x4c4667];
  }
  ["getSelected"]() {
    var _0x1a6860 = this,
      _0x6ffe32 = [];
    return this["body"]["find"]("tr.selected")["each"](function (_0x4f5931, _0x1ae0bc) {
      var _0x153dd6 = {};
      _0x153dd6["rowNumber"] = $(this)["attr"]("name"), $(_0x1ae0bc)["find"]("td")["each"](function (_0x466b2b, _0x47b720) {
        var _0x18c784 = _0x1a6860.getHeader(_0x466b2b);
        _0x153dd6[_0x18c784] = $(_0x47b720).text();
      }), _0x6ffe32["push"](_0x153dd6);
    }), _0x6ffe32;
  }
  ["find"](_0x49da8d, _0x3b15a2) {
    var _0x57414c = null;
    return $["each"](this.rows, function (_0xb2c545, _0x3c73bb) {
      _0x3c73bb && _0x3c73bb[_0x49da8d] == _0x3b15a2 && (_0x57414c = _0x3c73bb[0]);
    }), _0x57414c;
  }
  ["locate"](_0x262c29, _0x584a75 = true) {
    var _0x5774a9 = this,
      _0x32a645 = -1;
    $.each(this["getFilteredRows"](this.filter["find"]("input[name=\"filter\"]")["val"]()), function (_0x4fc80d, _0x5dc082) {
      _0x5dc082 && _0x5dc082[0] == _0x262c29 && (_0x32a645 = Math["ceil"](_0x4fc80d / _0x5774a9["rowsPerPage"]));
    });
    if (_0x32a645 > -1) {
      _0x32a645 != this.page && this["showPage"](_0x32a645, this.filter["find"]("input[name=\"filter\"]")["val"]());
      _0x584a75 && this["selectable"] && this["select"](_0x262c29);
      var _0x336d4a = this.body["find"]("tr.regularRow[data-rowid=\"" + _0x262c29 + '"]'),
        _0x3a836f = _0x336d4a["position"]();
      _0x3a836f && this["body"].scrollTop(_0x3a836f["top"]);
    }
  }
  ["setHeight"](_0x459303) {
    this["container"].css("height", _0x459303 + "px"), this["updated"]();
  }
  ["setFilterable"](_0x309a46) {
    this.filterable = _0x309a46, this["showFilterbar"]();
  }
  ["setTitle"](_0xb263d8) {
    this["title"] = _0xb263d8, this["filter"]["find"]("span.sub-title")["html"](_0xb263d8), this["showFilterbar"]();
  }
  ["showFilterbar"]() {
    this["title"] != "" ? this["filter"]["find"]("span.sub-title")["show"]() : this["filter"]["find"]("span.sub-title").hide(), this.filterable ? this["filter"].find(".filterField")["show"]() : this["filter"]["find"](".filterField")["hide"](), this["title"] != "" || this["filterable"] ? this["filter"].show() : this.filter["hide"]();
  }
  ["refresh"]() {
    var _0x2fe14c = this["getSelected"](),
      _0x3dd667 = this["body"].scrollTop();
    this["showPage"](this["page"], this["filter"]["find"]("input[name=\"filter\"]").val()), this["body"]["scrollTop"](_0x3dd667);
    if (_0x2fe14c && this["selectable"]) {
      var _0x5145a8 = this;
      $["each"](_0x2fe14c, function (_0xbe84e0, _0x203137) {
        _0x5145a8.body["find"]("tr.regularRow[data-rowid=\"" + _0x203137["rowId"] + '"]')["addClass"]("selected");
      });
    }
  }
  ["updateRow"](_0x14d67e, _0x585684) {
    var _0xaea0dc = false,
      _0x170ea8 = this;
    return $.each(this.rows, function (_0x1a324a, _0x1e0d3c) {
      _0x1e0d3c && _0x1e0d3c[0] == _0x14d67e && ($.each(_0x585684, function (_0x32b7c4, _0x4de948) {
        _0x170ea8.rows[_0x1a324a][_0x32b7c4] = _0x4de948;
      }), _0x170ea8["refresh"](), _0xaea0dc = true);
    }), _0xaea0dc;
  }
  ["getFilteredRowCount"](_0x365f3d = "") {
    return _0x365f3d == "" ? this["rowCount"] : this["getFilteredRows"](_0x365f3d)["length"];
  }
  ["getSortedRows"](_0x2029a1) {
    if (this["orderByColumn"] == -1) return _0x2029a1; else {
      var _0x35f87f = this;
      return _0x2029a1["sort"](function (_0x1e9f3b, _0x26cf3b) {
        var _0x2895d4 = _0x35f87f["getColumnOrder"](_0x35f87f["orderByColumn"]);
        if (_0x1e9f3b[_0x2895d4] < _0x26cf3b[_0x2895d4]) return _0x35f87f["orderAscendent"] ? -1 : 1;
        if (_0x1e9f3b[_0x2895d4] > _0x26cf3b[_0x2895d4]) return _0x35f87f["orderAscendent"] ? 1 : -1;
        return 0;
      });
    }
  }
  ["getFilteredRows"](_0x4e12e0 = "") {
    _0x4e12e0 = _0x4e12e0["toUpperCase"]();
    if (_0x4e12e0 == "") return this["rows"]; else {
      var _0x10b029 = [];
      return $.each(this.rows, function (_0x23ded2, _0x3be158) {
        var _0x3a0723 = false;
        $["each"](_0x3be158, function (_0x13819a, _0x3754b3) {
          if (_0x3754b3 != null && !($["type"](_0x3754b3) == "object" || $["type"](_0x3754b3) == "array")) {
            var _0x527f19 = isNaN(_0x3754b3) ? _0x3754b3.toUpperCase() : _0x3754b3.toString()["toUpperCase"]();
            _0x527f19["includes"](_0x4e12e0) && (_0x3a0723 = true);
          }
        }), _0x3a0723 && _0x10b029["push"](_0x3be158);
      }), _0x10b029;
    }
  }
  ["showPage"](_0x1e5b43, _0x2afd15 = "") {
    this["removeEmpty"]();
    if (_0x1e5b43 == "next") _0x1e5b43 = this["page"] + 1; else {
      if (_0x1e5b43 == "previous") _0x1e5b43 = this["page"] - 1; else _0x1e5b43 == "-" ? _0x1e5b43 = 0 : _0x1e5b43 = parseInt(_0x1e5b43);
    }
    if (_0x1e5b43 >= 1 && _0x1e5b43 <= this["pagination"]["pages"]) {
      this["body"]["find"]("tbody tr.regularRow").remove();
      var _0x9bac0d = this,
        _0x2f1494 = this.rowsPerPage * (_0x1e5b43 - 1),
        _0x6ef299 = _0x2f1494 + this.rowsPerPage;
      let _0x163775 = this["getSortedRows"](this["getFilteredRows"](_0x2afd15))["slice"](_0x2f1494, _0x6ef299);
      $(_0x163775)["each"](function (_0x5de9b1, _0x573489) {
        _0x9bac0d["printRow"](_0x2f1494 + _0x5de9b1, _0x573489);
      }), _0x163775["length"] == 0 && this["printEmpty"](), this["body"]["scrollTop"](0), this["page"] = _0x1e5b43, this["updatePagination"](_0x2afd15), this["pagination"]["setPage"](_0x1e5b43), this.updated(), this.unselect();
    }
  }
  ["calculateTextWidth"](_0x384707) {
    var _0x5d4186 = $('<span class="headerCell">')["hide"]()["appendTo"](document.body);
    _0x5d4186.html(_0x384707);
    var _0x32ab44 = _0x5d4186["width"]();
    return _0x5d4186["remove"](), _0x32ab44;
  }
  ["sort"](_0x5dc549, _0x228f4c = true) {
    this.orderByColumn = _0x5dc549, this.orderAscendent = _0x228f4c, this.showPage(1, this["filter"]["find"]("input[name=\"filter\"]")["val"]());
  }
  ["removeFilter"]() {
    this["filter"]["find"]("input[name=\"filter\"]")["val"]("");
  }
  ["destroy"]() {
    this["container"]["empty"]();
  }
  ["focus"]() {
    UI.setFocusElement(this), this["filterable"] && this["filter"].find('input[name="filter"]')["focus"]();
  }
}
class ShortcutManager extends Component {
  constructor(_0x2a7a04 = null) {
    super(), this["storage"] = _0x2a7a04, this["setupMode"] = false, this["keySeparator"] = "+", this["shortcuts"] = new Array(), this["holdingShortcuts"] = {}, this["reservedShortcuts"] = ["CTRL+C", "CTRL+V", "CTRL+F5"], this["generateShortcuts"](), this.loadFromStorage();
  }
  ["process"](_0x39d22a, _0xc41dc2, _0x55fb36) {
    var _0x5ba4fd,
      _0x5591e8 = false;
    typeof _0x39d22a == "string" ? _0x5ba4fd = _0x39d22a : _0x5ba4fd = this["getShortcutString"](_0x39d22a.ctrlKey, _0x39d22a["altKey"], _0x39d22a["shiftKey"], _0x39d22a["which"], _0x39d22a["key"], _0x39d22a["location"] || _0x39d22a["originalEvent"]["location"]);
    _0x5591e8 = this["trigger"](_0x5ba4fd, _0xc41dc2, _0x55fb36);
    var _0x21f0cc = this;
    return _0xc41dc2 == "keyup" && $["each"](this["holdingShortcuts"], function (_0x1e3667, _0x45ceca) {
      _0x5591e8 = _0x5591e8 || _0x21f0cc["trigger"](_0x1e3667, "keyup", _0x55fb36), !_0x5591e8 && delete _0x21f0cc["holdingShortcuts"][_0x5ba4fd];
    }), _0x5591e8;
  }
  ["trigger"](_0x59fcf2, _0x17a606 = "keyup", _0x3eca61 = false, _0xb1e8aa = false) {
    if (!(_0x59fcf2 in this["holdingShortcuts"]) || _0x17a606 != "keydown" || _0xb1e8aa) {
      var _0x11efe8 = this,
        _0x3b487d = false;
      return _0x59fcf2 != "" && $["each"](this["shortcuts"], function (_0x51e24f, _0xe7576f) {
        if (_0xe7576f.shortcut == _0x59fcf2 || _0xe7576f["shortcut2"] == _0x59fcf2) {
          if (_0x17a606 == "keydown") (!_0x3eca61 || _0xe7576f["worksOnDialogs"] && _0x3eca61) && (_0xe7576f.heldSince = new Date().getTime() / 1e3, _0x11efe8.holdingShortcuts[_0x59fcf2] = true, $(_0x11efe8)["triggerHandler"](new shortcutPressedEvent(_0xe7576f.id, _0xe7576f["stype"], _0x59fcf2, _0xe7576f["category"], _0xe7576f["worksOnDialogs"], _0xe7576f["eventType"])["getEvent"]()), _0xe7576f["repeatInterval"] > 0 && setTimeout(function () {
            _0x59fcf2 in _0x11efe8.holdingShortcuts && _0x11efe8["trigger"](_0x59fcf2, _0x17a606, _0x3eca61, true);
          }, !_0xb1e8aa ? 500 : _0xe7576f.repeatInterval), _0x3b487d = true); else {
            if (_0x17a606 == "keyup") {
              var _0x267926 = new Date()["getTime"]() / 1e3,
                _0x58f263 = _0x267926 - _0xe7576f["heldSince"];
              (!_0x3eca61 || _0xe7576f.worksOnDialogs && _0x3eca61 || _0x59fcf2 in _0x11efe8["holdingShortcuts"] && _0xe7576f.eventType == "holdable") && (delete _0x11efe8["holdingShortcuts"][_0x59fcf2], _0xe7576f["heldSince"] = null, $(_0x11efe8)["triggerHandler"](new shortcutReleasedEvent(_0xe7576f.id, _0xe7576f.stype, _0x59fcf2, _0xe7576f["category"], _0xe7576f.worksOnDialogs, _0xe7576f["eventType"], _0x58f263)["getEvent"]()), _0x3b487d = true);
            }
          }
        }
      }), _0x3b487d;
    } else return true;
  }
  ["releaseShortcuts"](_0x335bee = false) {
    var _0x168659 = this;
    $["each"](this["holdingShortcuts"], function (_0x31ae4f) {
      _0x168659["process"](_0x31ae4f, "keyup", _0x335bee);
    });
  }
  ["generateShortcuts"]() {
    this["shortcuts"] = new Array(), this["shortcuts"]["push"](new ShortcutObject("drag", "tool", "SPACE", "", "tools", "holdable", 0, false)), this["shortcuts"]["push"](new ShortcutObject("rotate", "tool", "RIGHT ALT", "", "tools", "holdable", 0, false)), this.shortcuts.push(new ShortcutObject("picker", "tool", "TAB", "", "tools", "holdable", 0, false)), this["shortcuts"].push(new ShortcutObject("selection", "tool", "S", "", "tools", "holdable", 0, false)), this.shortcuts.push(new ShortcutObject("pen", "tool", "B", "", "tools", "holdable", 0, false)), this["shortcuts"]["push"](new ShortcutObject("eraser", "tool", "E", "", "tools", "holdable", 0, false)), this["shortcuts"]["push"](new ShortcutObject("text", "tool", "T", "", "tools", "holdable", 0, false)), this["shortcuts"]["push"](new ShortcutObject("line", "tool", "L", "", "tools", "holdable", 0, false)), this.shortcuts["push"](new ShortcutObject("rect", "tool", "R", "", "tools", "holdable", 0, false)), this.shortcuts["push"](new ShortcutObject("ellipse", "tool", "P", "", "tools", "holdable", 0, false)), this.shortcuts["push"](new ShortcutObject("blend", "tool", "A", "", "tools", "holdable", 0, false)), this.shortcuts["push"](new ShortcutObject("fill", "tool", "F", "", "tools", "holdable", 0, false)), this["shortcuts"].push(new ShortcutObject("pixel", "tool", "X", "", "tools", "holdable", 0, false)), this["shortcuts"]["push"](new ShortcutObject("custom", "tool", "C", "", "tools", "holdable", 0, false)), this.shortcuts["push"](new ShortcutObject("rightclick", "custom", "", "", "tools", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("cancelstroke", "custom", "BACKSPACE", "", "tools", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("previoustool", "custom", "CTRL+LEFT", "", "tools", "keydown", 0, false)), this.shortcuts.push(new ShortcutObject("nexttool", "custom", "CTRL+RIGHT", "", "tools", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("switchprev", "custom", "", "", "tools", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("+size", "slideroption", "", "", "tooloptions", "keydown", 50, false)), this["shortcuts"].push(new ShortcutObject("-size", "slideroption", "", "", "tooloptions", "keydown", 50, false)), this.shortcuts["push"](new ShortcutObject("+alpha", "slideroption", "", "", "tooloptions", "keydown", 50, false)), this["shortcuts"]["push"](new ShortcutObject("-alpha", "slideroption", "", "", "tooloptions", "keydown", 50, false)), this["shortcuts"]["push"](new ShortcutObject("+blur", "slideroption", "", "", "tooloptions", "keydown", 50, false)), this["shortcuts"]["push"](new ShortcutObject("-blur", "slideroption", "", "", "tooloptions", "keydown", 50, false)), this["shortcuts"].push(new ShortcutObject("+smooth", "slideroption", "", "", "tooloptions", "keydown", 50, false)), this["shortcuts"].push(new ShortcutObject("-smooth", "slideroption", "", "", "tooloptions", "keydown", 50, false)), this["shortcuts"]["push"](new ShortcutObject("+spacing", "slideroption", "", "", "tooloptions", "keydown", 50, false)), this["shortcuts"]["push"](new ShortcutObject("-spacing", "slideroption", "", "", "tooloptions", "keydown", 50, false)), this["shortcuts"]["push"](new ShortcutObject("+multilayer", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("-multilayer", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("!multilayer", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("+areaaverage", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts.push(new ShortcutObject("-areaaverage", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("!areaaverage", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("+tint", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("-tint", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("!tint", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("+randomrotation", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("-randomrotation", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("!randomrotation", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("+selectiontype", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("-selectiontype", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("!selectiontype", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("+pressure", "slidercheckoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("-pressure", "slidercheckoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("!pressure", "slidercheckoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("+blendmode", "listoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("-blendmode", "listoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("normal", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("darken", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("lighten", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("difference", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("exclusion", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("hard-light", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("soft-light", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("multiply", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("overlay", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("screen", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("saturation", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("luminosity", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("hue", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("color", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("color-dodge", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("color-burn", "blendmode", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("kickuser", "userlist", "", "", "userlist", "keydown", 0, false)), this.shortcuts.push(new ShortcutObject("banuser", "userlist", "", "", "userlist", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("muteuser", "userlist", "", "", "userlist", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("unmuteuser", "userlist", "", "", "userlist", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("silenceuser", "userlist", "", "", "userlist", "keydown", 0, false)), this.shortcuts.push(new ShortcutObject("unsilenceuser", "userlist", "", "", "userlist", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("toggleignoreuser", "userlist", "", "", "userlist", "keydown", 0, false)), this.shortcuts.push(new ShortcutObject("config", "dialog", "ALT+F", "", "dialogs", "keydown", 0, true)), this["shortcuts"]["push"](new ShortcutObject("roommanager", "dialog", "ALT+R", "", "dialogs", "keydown", 0, true)), this["shortcuts"]["push"](new ShortcutObject("messenger", "dialog", "ALT+M", "", "dialogs", "keydown", 0, true)), this["shortcuts"].push(new ShortcutObject("profile", "dialog", "ALT+P", "", "dialogs", "keydown", 0, true)), this.shortcuts["push"](new ShortcutObject("chat", "dialog", "ALT+C", "", "dialogs", "keydown", 0, true)), this["shortcuts"]["push"](new ShortcutObject("undo", "dialog", "ALT+U", "", "dialogs", "keydown", 0, true)), this["shortcuts"]["push"](new ShortcutObject("upload", "dialog", "ALT+L", "", "dialogs", "keydown", 0, true)), this["shortcuts"]["push"](new ShortcutObject("save", "dialog", "ALT+S", "", "dialogs", "keydown", 0, true)), this["shortcuts"]["push"](new ShortcutObject("color", "dialog", "ALT+O", "", "dialogs", "keydown", 0, true)), this["shortcuts"]["push"](new ShortcutObject("radialmenu", "custom", "", "", "dialogs", "holdable", 0, false)), this["shortcuts"]["push"](new ShortcutObject("maximizedialog", "custom", "", "", "dialogs", "keydown", 0, true)), this.shortcuts.push(new ShortcutObject("closedialog", "custom", "ESC", "", "dialogs", "keydown", 0, true)), this["shortcuts"]["push"](new ShortcutObject("leaveroom", "custom", "", "", "dialogs", "keydown", 0, true)), this.shortcuts["push"](new ShortcutObject("fullscreen", "custom", "F11", "", "UI", "keydown", 0, true)), this["shortcuts"]["push"](new ShortcutObject("zoomin", "custom", "NUMPAD +", "", "UI", "keydown", 100, false)), this.shortcuts["push"](new ShortcutObject("zoomout", "custom", "NUMPAD -", "", "UI", "keydown", 100, false)), this["shortcuts"]["push"](new ShortcutObject("resetzoom", "custom", "", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("nextlayerup", "custom", "SHIFT+UP", "", "UI", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("nextlayerdown", "custom", "SHIFT+DOWN", "", "UI", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("changeprimarycolor", "custom", "SHIFT+C", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("changesecondarycolor", "custom", "", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("swapcolors", "custom", "CTRL+SPACE", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("+r", "coloroption", "", "", "UI", "keydown", 25, false)), this.shortcuts["push"](new ShortcutObject("-r", "coloroption", "", "", "UI", "keydown", 25, false)), this["shortcuts"]["push"](new ShortcutObject("+g", "coloroption", "", "", "UI", "keydown", 25, false)), this["shortcuts"]["push"](new ShortcutObject("-g", "coloroption", "", "", "UI", "keydown", 25, false)), this["shortcuts"].push(new ShortcutObject("+b", "coloroption", "", "", "UI", "keydown", 25, false)), this["shortcuts"]["push"](new ShortcutObject("-b", "coloroption", "", "", "UI", "keydown", 25, false)), this["shortcuts"]["push"](new ShortcutObject("+h", "coloroption", "", "", "UI", "keydown", 50, false)), this["shortcuts"]["push"](new ShortcutObject("-h", "coloroption", "", "", "UI", "keydown", 50, false)), this["shortcuts"]["push"](new ShortcutObject("+s", "coloroption", "", "", "UI", "keydown", 50, false)), this.shortcuts["push"](new ShortcutObject("-s", "coloroption", "", "", "UI", "keydown", 50, false)), this["shortcuts"]["push"](new ShortcutObject("+v", "coloroption", "", "", "UI", "keydown", 50, false)), this.shortcuts["push"](new ShortcutObject("-v", "coloroption", "", "", "UI", "keydown", 50, false)), this["shortcuts"].push(new ShortcutObject("rotatereset", "custom", "ALT+NUMPAD 0", "", "UI", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("rotate45left", "custom", "ALT+LEFT", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("rotate45right", "custom", "ALT+RIGHT", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("moveboard", "custom", "LEFT CTRL", "RIGHT CTRL", "UI", "holdable", 0, false)), this["shortcuts"]["push"](new ShortcutObject("fittoscreen", "custom", "", "", "UI", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("centerboard", "custom", "", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("viewflip", "custom", "ALT+DOWN", "", "UI", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("pixelsmoothing", "custom", "", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("pickcolor1", "color", "NUMPAD 1", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("pickcolor2", "color", "NUMPAD 2", "", "UI", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("pickcolor3", "color", "NUMPAD 3", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("pickcolor4", "color", "NUMPAD 4", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("pickcolor5", "color", "NUMPAD 5", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("pickcolor6", "color", "NUMPAD 6", "", "UI", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("pickcolor7", "color", "NUMPAD 7", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("pickcolor8", "color", "NUMPAD 8", "", "UI", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("pickcolor9", "color", "NUMPAD 9", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("pickcolor10", "color", "NUMPAD 0", "", "UI", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("loadpreset1", "preset", "1", "", "UI", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("loadpreset2", "preset", "2", "", "UI", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("loadpreset3", "preset", "3", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("loadpreset4", "preset", "4", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("loadpreset5", "preset", "5", "", "UI", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("loadpreset6", "preset", "6", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("loadpreset7", "preset", "7", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("loadpreset8", "preset", "8", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("loadpreset9", "preset", "9", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("loadpreset10", "preset", "0", "", "UI", "keydown", 0, false)), this.shortcuts.push(new ShortcutObject("loadpreset11", "preset", "", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("loadpreset12", "preset", "", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("loadpreset13", "preset", "", "", "UI", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("loadpreset14", "preset", "", "", "UI", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("loadpreset15", "preset", "", "", "UI", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("loadpreset16", "preset", "", "", "UI", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("loadpreset17", "preset", "", "", "UI", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("loadpreset18", "preset", "", "", "UI", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("+togglepressureopacity", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("-togglepressureopacity", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("!togglepressureopacity", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("+togglezoom", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("undomodded", "dialog", "", "", "dialogs", "keydown", 0, false)), this["shortcuts"].push(new ShortcutObject("redomodded", "dialog", "", "", "dialogs", "keydown", 0, false)), this["shortcuts"]["push"](new ShortcutObject("blur", "tool", "", "", "tools", "holdable", 0, false)), this.shortcuts["push"](new ShortcutObject("+erasermode", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("-erasermode", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), this.shortcuts["push"](new ShortcutObject("!erasermode", "checkboxoption", "", "", "tooloptions", "keydown", 0, false));
    this.shortcuts["push"](new ShortcutObject("+togglewholepixels", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), 
    this.shortcuts["push"](new ShortcutObject("-togglewholepixels", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), 
    this.shortcuts["push"](new ShortcutObject("!togglewholepixels", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)),
    this.shortcuts["push"](new ShortcutObject("+polygonalselection", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), 
    this.shortcuts["push"](new ShortcutObject("-polygonalselection", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)), 
    this.shortcuts["push"](new ShortcutObject("!polygonalselection", "checkboxoption", "", "", "tooloptions", "keydown", 0, false)),  
    this.shortcuts["push"](new ShortcutObject("+finalizepolygonalselection", "checkboxoption", "", "", "tooloptions", "keydown", 0, false))  
  }
  ["changeShortcut"](_0x19c595, _0x5c117f, _0xecc49b = true) {
    return !this["shortcutExists"](_0x5c117f) && !this["shortcutReserved"](_0x5c117f) ? (this.setShortcut(_0x19c595, _0x5c117f, _0xecc49b), this["saveToStorage"](), true) : false;
  }
  ["setShortcut"](_0x20a6b4, _0x4aede6, _0x4195a7 = true) {
    $["each"](this["shortcuts"], function (_0x477661, _0x4c349e) {
      _0x4c349e.id == _0x20a6b4 && (_0x4195a7 ? _0x4c349e.shortcut = _0x4aede6 : _0x4c349e["shortcut2"] = _0x4aede6);
    });
  }
  ["getShortcutString"](_0x1462ca, _0x1d024c, _0x15ea83, _0x222e4f, _0x4bf11d, _0x22570a) {
    if (_0x222e4f == 16) _0x15ea83 = false; else {
      if (_0x222e4f == 17) _0x1462ca = false; else {
        if (_0x222e4f == 18) _0x1d024c = false;
      }
    }
    return (_0x1462ca ? "CTRL+" : "") + (_0x1d024c ? "ALT+" : "") + (_0x15ea83 ? "SHIFT+" : "") + this["getLocation"](_0x22570a) + this["getKeyCharacter"](_0x222e4f, _0x4bf11d);
  }
  ["getShortcut"](_0x3ad712) {
    var _0x53862e = null;
    return $["each"](this["shortcuts"], function (_0x18b144, _0x130d34) {
      _0x130d34.id == _0x3ad712 && (_0x53862e = _0x130d34);
    }), _0x53862e;
  }
  ["getShortcutId"](_0x300335) {
    var _0x13a0b2 = null;
    return _0x300335 != "" && $["each"](this["shortcuts"], function (_0x36a474, _0x2e39b6) {
      (_0x2e39b6.shortcut == _0x300335 || _0x2e39b6.shortcut2 == _0x300335) && (_0x13a0b2 = _0x2e39b6.id);
    }), _0x13a0b2;
  }
  ["getLocation"](_0x4eecda) {
    if (_0x4eecda == KeyboardEvent["DOM_KEY_LOCATION_NUMPAD"]) return "NUMPAD ";
    if (_0x4eecda == KeyboardEvent.DOM_KEY_LOCATION_LEFT) return "LEFT ";
    if (_0x4eecda == KeyboardEvent.DOM_KEY_LOCATION_RIGHT) return "RIGHT ";
    return "";
  }
  ["isValidShortcut"](_0x155961) {
    var _0x67e856 = this["getShortcutInfo"](_0x155961);
    return !_0x67e856["nonprintablechars"];
  }
  ["getShortcutInfo"](_0x5ccb15) {
    var _0x809dc1 = _0x5ccb15["split"](this["keySeparator"]),
      _0x324110 = this["getSpecialKeys"](),
      _0x3cb0c8 = {};
    return _0x3cb0c8["ctrl"] = false, _0x3cb0c8["alt"] = false, _0x3cb0c8["shift"] = false, _0x3cb0c8["specialchars"] = false, _0x3cb0c8.functionkeys = false, _0x3cb0c8["nonprintablechars"] = false, _0x3cb0c8["printablechars"] = false, _0x3cb0c8["numbers"] = false, $.each(_0x809dc1, function (_0x370416, _0x16db8f) {
      if (_0x16db8f == "CTRL") _0x3cb0c8["ctrl"] = true; else {
        if (_0x16db8f == "ALT") _0x3cb0c8.alt = true; else {
          if (_0x16db8f == "SHIFT") _0x3cb0c8["shift"] = true; else {
            if (_0x16db8f == "F1" || _0x16db8f == "F2" || _0x16db8f == "F3" || _0x16db8f == "F4" || _0x16db8f == "F5" || _0x16db8f == "F6" || _0x16db8f == "F7" || _0x16db8f == "F8" || _0x16db8f == "F9" || _0x16db8f == "F10" || _0x16db8f == "F11" || _0x16db8f == "F12") _0x3cb0c8["functionkeys"] = true; else {
              if (_0x16db8f == "0" || _0x16db8f == "1" || _0x16db8f == "2" || _0x16db8f == "3" || _0x16db8f == "4" || _0x16db8f == "5" || _0x16db8f == "6" || _0x16db8f == "7" || _0x16db8f == "8" || _0x16db8f == "9") _0x3cb0c8.numbers = true; else {
                if (_0x324110["indexOf"](_0x16db8f) > -1) _0x3cb0c8.specialchars = true; else _0x16db8f["charCodeAt"](0) <= 31 ? _0x3cb0c8["nonprintablechars"] = true : _0x3cb0c8["printablechars"] = true;
              }
            }
          }
        }
      }
    }), _0x3cb0c8;
  }
  ["getKeyCharacter"](_0x1937e4, _0x307b1e) {
    var _0xa4f712,
      _0x49f4b4 = this.getKeyNames();
    try {
      _0x1937e4 in _0x49f4b4 ? _0xa4f712 = _0x49f4b4[_0x1937e4] : (_0xa4f712 = _0x307b1e["toUpperCase"](), _0xa4f712["length"] > 1 && _0xa4f712[0] == "~" && (_0xa4f712 = _0xa4f712["substr"](1)));
    } catch (_0x398d46) { }
    return _0xa4f712;
  }
  ["getSpecialKeys"]() {
    return [8, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 16, 17, 18, 27, 19, 144, 145, 20, 91, 92];
  }
  ["getKeyNames"]() {
    var _0x3d56bc = new Array();
    return _0x3d56bc[112] = "F1", _0x3d56bc[113] = "F2", _0x3d56bc[114] = "F3", _0x3d56bc[115] = "F4", _0x3d56bc[116] = "F5", _0x3d56bc[117] = "F6", _0x3d56bc[118] = "F7", _0x3d56bc[119] = "F8", _0x3d56bc[120] = "F9", _0x3d56bc[121] = "F10", _0x3d56bc[122] = "F11", _0x3d56bc[123] = "F12", _0x3d56bc[8] = "BACKSPACE", _0x3d56bc[9] = "TAB", _0x3d56bc[13] = "ENTER", _0x3d56bc[33] = "PAGE UP", _0x3d56bc[34] = "PAGE DOWN", _0x3d56bc[35] = "END", _0x3d56bc[36] = "HOME", _0x3d56bc[37] = "LEFT", _0x3d56bc[38] = "UP", _0x3d56bc[39] = "RIGHT", _0x3d56bc[40] = "DOWN", _0x3d56bc[45] = "INSERT", _0x3d56bc[46] = "DELETE", _0x3d56bc[16] = "SHIFT", _0x3d56bc[17] = "CTRL", _0x3d56bc[18] = "ALT", _0x3d56bc[27] = "ESC", _0x3d56bc[19] = "PAUSE", _0x3d56bc[32] = "SPACE", _0x3d56bc[144] = "NUM LOCK", _0x3d56bc[145] = "SCROLL LOCK", _0x3d56bc[20] = "CAPS LOCK", _0x3d56bc[91] = "WINDOWS", _0x3d56bc[92] = "WINDOWS", _0x3d56bc;
  }
  ["shortcutReserved"](_0x212fdc) {
    return this["reservedShortcuts"]["indexOf"](_0x212fdc) > -1;
  }
  ["shortcutExists"](_0x5e58a4, _0x128404 = null) {
    if (_0x5e58a4 == "") return false;
    var _0x5181e7 = false;
    return $["each"](this["shortcuts"], function (_0x8ff223, _0x4f2335) {
      (_0x128404 == null || _0x128404 != _0x4f2335.id) && (_0x4f2335["shortcut"] == _0x5e58a4 || _0x4f2335.shortcut2 == _0x5e58a4) && (_0x5181e7 = true);
    }), _0x5181e7;
  }
  ["loadDefaults"]() {
    this["clearFromStorage"](), this["generateShortcuts"]();
  }
  ["clearFromStorage"]() {
    this["storage"]["removeParameter"]("shortcuts");
  }
  ["loadFromStorage"]() {
    if (this["storage"]) {
      var _0x489494 = this["storage"]["getParameter"]("shortcuts");
      if (_0x489494) {
        var _0x1ed98f = this;
        $.each(JSON["parse"](_0x489494), function (_0x2d825e, _0x1b5aed) {
          _0x1ed98f["setShortcut"](_0x1b5aed.id, _0x1b5aed.shortcut, true), _0x1ed98f["setShortcut"](_0x1b5aed.id, _0x1b5aed["shortcut2"], false);
        });
      }
    }
  }
  ["saveToStorage"]() {
    this.storage && this["storage"]["setParameter"]("shortcuts", JSON["stringify"](getNewListOfObjects(this.shortcuts, ["id", "shortcut", "shortcut2"])));
  }
}
class ShortcutObject extends Component {
  constructor(_0x32dc58, _0x5bd79c, _0x386076, _0x45f5f2, _0x5752f0, _0x854c65, _0x11f912, _0x1b389b) {
    super(), this.id = _0x32dc58, this["stype"] = _0x5bd79c, this["shortcut"] = _0x386076, this["shortcut2"] = _0x45f5f2, this["category"] = _0x5752f0, this.eventType = _0x854c65, this["repeatInterval"] = _0x11f912, this.worksOnDialogs = _0x1b389b;
  }
}
class LayerPreview extends UIComponent {
  constructor(_0x3caf14) {
    super(_0x3caf14), this["container"]["addClass"]("p-0 m-0"), this.currentLayer = 0, this.previews = new Array(), this["previewTimers"] = new Array(), this["create"]();
    var _0x249ae0 = this;
    $["contextMenu"]({
      selector: ".layerPreview",
      build: function (_0x509a46) {
        var _0x3d8789 = {
          callback: function (_0x471d32, _0x312c6f) {
            var _0x2c7d02 = _0x312c6f.$trigger["attr"]("name");
            _0x471d32 == "clear" && $(_0x249ae0)["triggerHandler"](new layerOptionClickedEvent(_0x471d32, _0x2c7d02, {})["getEvent"]());
          },
          items: {
            clear: {
              name: "Clear layer",
              visible: function (_0x292673, _0x3659c1) {
                return room["myself"]["isLogged"]();
              },
              icon: "fa-eraser"
            }
          }
        };
        return $["each"](_0x3d8789["items"], function (_0x595b13, _0x1286aa) {
          _0x3d8789.items[_0x595b13]["name"] && (_0x3d8789["items"][_0x595b13]["name"] = function () {
            return textManager.getString("menu.layerPreview." + _0x595b13, null, false);
          });
        }), _0x3d8789;
      }
    }), this["container"].on(UI["pointerEvent"]("click"), "span.layerNumber", function (_0x50531b) {
      $(_0x249ae0)["triggerHandler"](new layerOptionClickedEvent("select", $(this).attr("name"), {})["getEvent"]());
    }), this["container"].on(UI["pointerEvent"]("click"), ".layerOption, .selectedLayerOption", function (_0x40dbc3) {
      _0x40dbc3["preventDefault"]();
      if (!(_0x249ae0["readOnly"] || $(this)["hasClass"]("disabled"))) {
        var _0x402c09 = $(this).hasClass("selectedLayerOption") ? $(this)["closest"](".layerPreview")["attr"]("name") : _0x249ae0["currentLayer"],
          _0x55a985 = $(this)["attr"]("name"),
          _0x82bf6f = {};
        $(this)["hasClass"]("mergeLayer") && (_0x55a985 = "merge", _0x82bf6f = {
          target: $(this)["attr"]("name")
        }), $(_0x249ae0)["triggerHandler"](new layerOptionClickedEvent(_0x55a985, _0x402c09, _0x82bf6f)["getEvent"]());
      }
      this["blur"]();
    }), $(room.board).on("layerChanged", function (_0x344d8c) {
      _0x344d8c["immediate"] ? _0x249ae0["updatePreview"](_0x344d8c.layer) : _0x249ae0["previewTimers"][_0x344d8c["layer"]] == null && (_0x249ae0.previewTimers[_0x344d8c["layer"]] = setTimeout(function (_0x1fb0a4) {
        _0x249ae0["updatePreview"](_0x1fb0a4);
      }, 1e3, _0x344d8c["layer"]));
    }), $(room["board"]).on("layerLocked", function (_0x2dfd6e) {
      var _0x3e915a = _0x249ae0.container["find"]('.layerPreview[name="' + _0x2dfd6e["layer"] + '"]');
      _0x3e915a && (_0x3e915a["find"](".selectedLayerOption[name=\"locktoggle\"]")["html"](new Icon("fa-lock").html()), _0x3e915a["find"](".layerPreviewOverlay")["html"](new Icon("fa-lock")["html"]()));
    }), $(room["board"]).on("layerUnlocked", function (_0x47299e) {
      var _0x3bfc0f = _0x249ae0.container["find"](".layerPreview[name=\"" + _0x47299e["layer"] + '"]');
      _0x3bfc0f && (_0x3bfc0f["find"](".selectedLayerOption[name=\"locktoggle\"]")["html"](new Icon("fa-unlock")["html"]()), _0x3bfc0f["find"](".layerPreviewOverlay")["empty"]());
    }), $(room["myself"].surface).on("layerSelected", function (_0x5af55f) {
      _0x249ae0.highlight(_0x5af55f["layer"]);
    });
  }
  ["create"]() {
    this["container"]["empty"]();
    var _0x37683c = "";
    _0x37683c += '<nav class="navbar navbar-expand navbar-light p-0 m-0 sticky-top sidebarNavbar">', _0x37683c += "<div class=\"container full-width\">", _0x37683c += "<ul class=\"navbar-nav\">", _0x37683c += "<li class=\"nav-item\"><a data-tooltipcallback=\"tooltipText\" data-tooltipparam=\"layerPreview.btnClear\" name=\"clear\" class=\"layerOption layerButton nav-link\" href=\"#\"><i class=\"fas fa-eraser\"></i></a></li>", _0x37683c += "<li class=\"nav-item dropdown mergLayer\">", _0x37683c += "<a class=\"nav-link dropdown-toggle layerButton\" href=\"#\" id=\"mergLayer\" name=\"mergeLayer\" role=\"button\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\">", _0x37683c += '<i class="fas fa-object-group"></i></a><ul class="dropdown-menu" aria-labelledby="mergLayer"></ul></li>', _0x37683c += "<li class=\"nav-item\"><a data-tooltipcallback=\"tooltipText\" data-tooltipparam=\"layerPreview.btnFlipHorizontally\" name=\"fliph\" class=\"layerOption layerButton nav-link\" href=\"#\"><i class=\"fas fa-arrows-alt-h\"></i></a></li>", _0x37683c += "<li class=\"nav-item\"><a data-tooltipcallback=\"tooltipText\" data-tooltipparam=\"layerPreview.btnFlipVertically\" name=\"flipv\" class=\"layerOption layerButton nav-link\" href=\"#\"><i class=\"fas fa-arrows-alt-v\"></i></a></li>", _0x37683c += '<li class="nav-item"><a data-tooltipcallback="tooltipText" data-tooltipparam="layerPreview.btnSave" name="save" class="layerOption layerButton nav-link" href="#"><i class="fas fa-save"></i></a></li>', _0x37683c += '</ul></div></nav><div class="layerPreviews"></div>', this["container"]["append"](_0x37683c), this["updateLayerCount"](true), this["highlight"](0);
  }
  ["createLayerRow"](_0x1bbc09, _0x4fcb4b = false) {
    var _0x148f3a = new Icon("fa-eye"),
      _0xec7901 = new Icon(room["board"]["layers"][_0x1bbc09]["locked"] ? "fa-lock" : "fa-unlock"),
      _0x1ba97b = "";
    _0x1ba97b += "<div class=\"row layerPreview p-0 m-0\" name=\"" + _0x1bbc09 + "\"><div class=\"col-12 m-0 p-1\">", _0x1ba97b += "<div class=\"layerPreviewImg\"><a href=\"#\" name=\"" + _0x1bbc09 + "\"><div class=\"layerPreviewOverlay\"></div><img name=\"select\" class=\"selectedLayerOption preview\" alt=\"" + _0x1bbc09 + "\" /></a></div>", _0x1ba97b += '<div class="layerPreviewContent">', _0x1ba97b += "<span name=\"" + _0x1bbc09 + "\" class=\"btn layerNumber btn-square\">" + (_0x1bbc09 + 1) + "</span>", _0x1ba97b += '<a data-tooltipcallback="tooltipText" data-tooltipparam="layerPreview.btnHide" name="toggle" class="selectedLayerOption layerButton btn btn-square">' + _0x148f3a["html"]() + "</a>", _0x1ba97b += "<a data-tooltipcallback=\"tooltipText\" data-tooltipparam=\"layerPreview.btnLock\" name=\"locktoggle\" class=\"selectedLayerOption layerButton btn btn-square" + (_0x4fcb4b ? " disabled" : "") + '">' + _0xec7901["html"]() + "</a>", this.container["find"]("div.layerPreviews")["append"](_0x1ba97b);
  }
  ["highlight"](_0x90c37b) {
    this["currentLayer"] = _0x90c37b, this["container"]["find"]("div").each(function (_0x279e0a, _0x134758) {
      $(_0x134758).attr("name") == _0x90c37b ? $(_0x134758)["addClass"]("selectedLayer") : $(_0x134758).removeClass("selectedLayer");
    }), this["container"]["find"](".currentLayerOption")["attr"]("name", _0x90c37b);
  }
  ["reset"]() {
    this["container"].find('.layerPreview .layerButton[name="toggle"]')["html"](new Icon("fa-eye")["html"]()), this.container.find(".layerPreview .layerButton[name=\"locktoggle\"]").html(new Icon("fa-unlock")["html"]());
  }
  ["showLayer"](_0x1d21d6) {
    var _0x456e77 = this["container"]["find"](".layerPreview[name=\"" + _0x1d21d6 + "\"] .selectedLayerOption[name=\"toggle\"]");
    _0x456e77 && _0x456e77["html"](new Icon("fa-eye")["html"]());
  }
  ["hideLayer"](_0x5eef7b) {
    var _0x1acb8f = this["container"].find('.layerPreview[name="' + _0x5eef7b + "\"] .selectedLayerOption[name=\"toggle\"]");
    _0x1acb8f && _0x1acb8f["html"](new Icon("fa-eye-slash")["html"]());
  }
  ["nextLayerUp"]() {
    var _0x4f3a65 = room["myself"]["surface"]["currentLayer"] + 1;
    _0x4f3a65 > room["board"]["nLayers"] - 1 && (_0x4f3a65 = 0), room["myself"]["surface"]["setCurrentLayer"](_0x4f3a65), this.highlight(_0x4f3a65);
  }
  ["nextLayerDown"]() {
    var _0x310e38 = room["myself"]["surface"]["currentLayer"] - 1;
    _0x310e38 < 0 && (_0x310e38 = room["board"].nLayers - 1), room.myself["surface"].setCurrentLayer(_0x310e38), this["highlight"](_0x310e38);
  }
  ["updatePreview"](_0x3d3fd6) {
    var _0x2e98ca = this;
    if (this["previews"][_0x3d3fd6]) {
      this.previewTimers[_0x3d3fd6] = null, this["previews"][_0x3d3fd6]["clear"](), this["previews"][_0x3d3fd6]["drawImage"](room["board"]["layers"][_0x3d3fd6].getCanvas(), 0, 0, this["previews"][_0x3d3fd6].width, this["previews"][_0x3d3fd6].height);
      var _0x4e2b5b = new Image();
      _0x4e2b5b["onload"] = function () {
        _0x2e98ca["container"]["find"](".preview[alt=\"" + _0x3d3fd6 + '"]')["attr"]("src", _0x4e2b5b.src);
      }, _0x4e2b5b.src = this.previews[_0x3d3fd6]["getData"]();
    }
  }
  ["updateLayerCount"](_0x65ae60 = false) {
    var _0x4902eb = this["container"]["find"](".layerPreviews > .layerPreview")["length"];
    if (_0x65ae60 || room["board"]["nLayers"] != _0x4902eb) {
      var _0x11996c = this["container"].find(".mergLayer .dropdown-menu");
      _0x11996c["empty"]();
      for (var _0x2d0bc3 = room["board"]["nLayers"] - 1; _0x2d0bc3 >= 0; _0x2d0bc3--) {
        _0x11996c["append"]('<a name="' + _0x2d0bc3 + "\" class=\"layerOption mergeLayer dropdown-item\" href=\"#\">" + textManager["getString"]("menu.layers.MergeWithLayer", _0x2d0bc3 + 1, false) + "</a>");
      }
      var _0x5b54fd = this["container"]["find"]('.layerButton[name="locktoggle"]')["hasClass"]("disabled");
      this["container"]["find"]("div.layerPreviews")["empty"](), this["removePreviews"]();
      for (var _0x2d0bc3 = room["board"]["nLayers"] - 1; _0x2d0bc3 >= 0; _0x2d0bc3--) {
        var _0x5bbb0c = new AdvancedCanvas(parseInt(room.board["canvasWidth"] / 8), parseInt(room["board"]["canvasHeight"] / 8));
        this["previews"]["push"](_0x5bbb0c), this["updatePreview"](_0x2d0bc3), this["createLayerRow"](_0x2d0bc3, _0x5b54fd);
      }
    }
  }
  ["updatePreviewSize"]() {
    this["removePreviews"]();
    for (var _0x1266c0 = 0; _0x1266c0 < room["board"]["nLayers"]; _0x1266c0++) {
      var _0x14ddcc = new AdvancedCanvas(parseInt(room["board"]["canvasWidth"] / 8), parseInt(room["board"]["canvasHeight"] / 8));
      this["previews"]["push"](_0x14ddcc), this["updatePreview"](_0x1266c0);
    }
  }
  ["updatePreviews"]() {
    for (var _0x55b844 = 0; _0x55b844 < room["board"]["nLayers"]; _0x55b844++) {
      this["updatePreview"](_0x55b844);
    }
  }
  ["removePreviews"]() {
    for (var _0x57a560 = 0; _0x57a560 < this["previews"]["length"]; _0x57a560++) {
      this["previews"][_0x57a560]["remove"]();
    }
    this["previews"] = new Array();
  }
  ["disableButton"](_0xd48437) {
    this["container"]["find"]('.layerButton[name="' + _0xd48437 + '"]')["addClass"]("disabled");
  }
  ["enableButton"](_0x2e6264) {
    this["container"]["find"](".layerButton[name=\"" + _0x2e6264 + '"]')["removeClass"]("disabled");
  }
}
class AnimationOptions extends UIComponent {
  constructor(_0x122e92) {
    super(_0x122e92), this.container.addClass("p-0 m-0"), this.frameSlider, this["create"]();
    var _0x3ef270 = this;
  }
  ["create"]() {
    this["container"]["empty"]();
    var _0x5cf39f = "";
    _0x5cf39f += "<div class=\"p-1\">", _0x5cf39f += "<div><div class=\"input-group\"><a name=\"play\" class=\"btn btn-sm btn-success\" style=\"width: 83%; border-top-right-radius: 0px; border-bottom-right-radius: 0px;\"><i class=\"fas fa-play\"></i> <span data-i18n=\"animation.sidebar.btnPlay\">Play</span></a>", _0x5cf39f += '<a name="config" class="btn btn-sm btn-success" style=""><i class="fas fa-cog"></i></a></div></div>';
    room["board"]["onionSkin"] && (_0x5cf39f += '<p><div class="optionTitle"><span data-i18n="tooloption.alpha">Opacity</span></div><div name="frameSlider" class="optionField fmSlider"></div></p>');
    _0x5cf39f += '<p><span data-i18n="animation.sidebar.lblFrames">Frames:</span></p>', _0x5cf39f += '<p class="text-center"><a name="prevframe" class="btn btn-sm btn-success text-start"><i class="fa fa-backward"></i></a>', _0x5cf39f += '<a name="viewall" class="btn btn-sm btn-success text-center me-1 ms-1"><i class="fa fa-th-large"></i> <span data-i18n="animation.sidebar.btnViewAll">View all</span></a>', _0x5cf39f += "<a name=\"nextframe\" class=\"btn btn-sm btn-success text-end\"><i class=\"fa fa-forward\"></i></a></p>", _0x5cf39f += '<div id="frames"><table class="fmTable animationTable w-100" style="text-align: center;"></table></div></div>', this["container"]["append"](_0x5cf39f), this.container.find("a[name=\"viewall\"]")["addClass"]("disabled"), this["container"]["find"]("a[name=\"prevframe\"]")["addClass"]("disabled"), this["container"]["find"]('a[name="nextframe"]')["addClass"]("disabled");
    room["board"].onionSkin && (this["frameSlider"] = new Slider(this.container["find"]('div[name="frameSlider"]'), 0, 1, 0.1), $(this["frameSlider"]).on("sliderChange", function (_0x4d39d1) {
      room.board["changeOnionSkinOpacity"](_0x4d39d1["value"]);
    }));
    textManager["updateElement"](this["container"]);
    var _0x9df9c1 = this;
    $(room).on("animationFrameChanged", function (_0x3aac21) {
      _0x9df9c1["container"]["find"]("#frames table").empty();
      var _0x21b225 = 0;
      for (var _0x446246 = 0; _0x446246 < room["animRows"]; _0x446246++) {
        _0x9df9c1["container"]["find"]("#frames table")["append"]("<tr></tr>");
        for (var _0x339ddd = 0; _0x339ddd < room["animCols"]; _0x339ddd++) {
          _0x9df9c1["container"].find("#frames table tr:last-child")["append"]("<td><a name=\"" + _0x21b225 + "\" class=\"animationFrame\" href=\"#\">" + (_0x21b225 + 1) + "</a></td>"), _0x21b225++;
        }
      }
    }), this.container.on(UI["pointerEvent"]("down"), "a[name=\"viewall\"]", function (_0x282b5a) {
      _0x282b5a.preventDefault(), (!_0x282b5a["which"] || _0x282b5a["which"] == 1) && (UI["resetViewSize"](), UI["fitToScreen"]());
    }), this.container.on(UI["pointerEvent"]("down"), 'a[name="prevframe"]', function (_0x28a5b9) {
      _0x28a5b9["preventDefault"]();
      if (!_0x28a5b9.which || _0x28a5b9.which == 1) {
        var _0x65dfa2 = parseInt(_0x9df9c1["container"]["find"](".animationTable td.selected a").attr("name"));
        --_0x65dfa2 < 0 && (_0x65dfa2 = room["animRows"] * room["animCols"] - 1), _0x9df9c1["select"](_0x65dfa2);
      }
    }), this["container"].on(UI["pointerEvent"]("down"), "a[name=\"nextframe\"]", function (_0x4f9441) {
      _0x4f9441["preventDefault"]();
      if (!_0x4f9441.which || _0x4f9441["which"] == 1) {
        var _0x3bac9d = parseInt(_0x9df9c1["container"]["find"](".animationTable td.selected a")["attr"]("name"));
        ++_0x3bac9d >= room.animRows * room.animCols && (_0x3bac9d = 0), _0x9df9c1["select"](_0x3bac9d);
      }
    }), this["container"].on(UI["pointerEvent"]("down"), "a[name=\"play\"]", function (_0x3de944) {
      _0x3de944["preventDefault"](), (!_0x3de944.which || _0x3de944["which"] == 1) && UI["dialogHandler"].showDialog("animation", "play");
    }), this["container"].on(UI["pointerEvent"]("down"), 'a[name="config"]', function (_0x2ef967) {
      _0x2ef967["preventDefault"](), (!_0x2ef967["which"] || _0x2ef967.which == 1) && UI["dialogHandler"].showDialog("animation", "frames");
    }), this["container"].on(UI["pointerEvent"]("down"), "a[name=\"onionskin\"]", function (_0x37de4f) {
      _0x37de4f.preventDefault();
      if (!_0x37de4f["which"] || _0x37de4f["which"] == 1) {
        var _0xcbf226 = room["board"]["getAllLayers"]();
        _0xcbf226.then(function (_0x54c818) {
          var _0x351a07 = new AdvancedCanvas(room["board"]["canvasWidth"], room.board["canvasHeight"]),
            _0x379007 = Object["keys"](_0x54c818)["length"],
            _0x47ba3e = {},
            _0x10062e = 0;
          $.each(_0x54c818, function (_0x42e034, _0x4854f6) {
            var _0x4c912a = new Image();
            _0x47ba3e[_0x42e034] = _0x4c912a, _0x4c912a["onload"] = function () {
              if (++_0x10062e == _0x379007) {
                for (var _0x25b91a = 0; _0x25b91a < room["board"].nLayers; _0x25b91a++) {
                  _0x25b91a in _0x47ba3e && _0x351a07["drawImage"](_0x47ba3e[_0x25b91a], 0, 0);
                }
                _0x9df9c1["onionSkin"](_0x351a07);
              }
            }, _0x4c912a.src = _0x4854f6;
          });
        });
      }
    }), this["container"].on(UI.pointerEvent("down"), ".animationTable td", function (_0x54bf46) {
      _0x54bf46["preventDefault"]();
      if (!_0x54bf46["which"] || _0x54bf46["which"] == 1) {
        var _0x46278e = room["board"].canvasWidth / room.animCols,
          _0x335936 = room["board"]["canvasHeight"] / room.animRows,
          _0x36c857 = parseInt($(this)["find"]("a")["attr"]("name"));
        _0x9df9c1["select"](_0x36c857);
      }
    }), $(UI).on("viewSizeChanged", function (_0x368964) {
      !_0x368964["limited"] ? (_0x9df9c1.container.find(".animationTable td.selected")["removeClass"]("selected"), _0x9df9c1["container"]["find"]("a[name=\"viewall\"]")["addClass"]("disabled"), _0x9df9c1["container"]["find"]("a[name=\"prevframe\"]")["addClass"]("disabled"), _0x9df9c1.container["find"]("a[name=\"nextframe\"]")["addClass"]("disabled")) : (_0x9df9c1["container"]["find"]("a[name=\"viewall\"]")["removeClass"]("disabled"), _0x9df9c1["container"]["find"]("a[name=\"prevframe\"]")["removeClass"]("disabled"), _0x9df9c1.container["find"]("a[name=\"nextframe\"]").removeClass("disabled"));
    });
  }
  ["onionSkin"](_0x21e468) {
    if (room.board["onionSkin"]) {
      var _0x301ef8 = new AdvancedCanvas(room["board"]["canvasWidth"], room["board"]["canvasHeight"]),
        _0xd79f24 = room.board["canvasWidth"] / room["animCols"],
        _0x2e4a4a = room.board["canvasHeight"] / room.animRows;
      for (var _0x523bf0 = 0; _0x523bf0 < room["animRows"]; _0x523bf0++) {
        for (var _0x4c1d06 = 0; _0x4c1d06 < room["animCols"]; _0x4c1d06++) {
          var _0x1e935c = _0x21e468["getImageData"](_0x4c1d06 * _0xd79f24, _0x523bf0 * _0x2e4a4a, _0xd79f24, _0x2e4a4a),
            _0x29a5dc = _0x4c1d06 + 1,
            _0x3b86f1 = _0x523bf0;
          _0x29a5dc >= room["animCols"] && (_0x29a5dc = 0, _0x3b86f1 = _0x523bf0 + 1, _0x3b86f1 >= room["animRows"] && (_0x3b86f1 = 0)), _0x301ef8["putImageData"](_0x1e935c, _0x29a5dc * _0xd79f24, _0x3b86f1 * _0x2e4a4a);
        }
      }
      room["board"]["onionSkin"](_0x301ef8["getImageData"]());
    }
  }
  ["select"](_0x22c35a) {
    var _0x132604 = room["board"]["canvasWidth"] / room["animCols"],
      _0x3f4d40 = room["board"].canvasHeight / room["animRows"],
      _0x2ecd6a = Math["floor"](_0x22c35a / room["animCols"]),
      _0x5a69d3 = _0x22c35a % room["animCols"];
    UI.setViewSize(_0x132604, _0x3f4d40), UI.setViewOffset(_0x132604 * _0x5a69d3 * -1, _0x3f4d40 * _0x2ecd6a * -1), UI["fitToScreen"](), this["container"]["find"](".animationTable td.selected")["removeClass"]("selected"), this["container"].find(".animationTable td a[name=\"" + _0x22c35a + '"]')["parents"]("td")["addClass"]("selected");
  }
  ["enableButton"](_0x3e612b) {
    _0x3e612b == "frameOptions" && this["container"].find("a[name=\"config\"]")["removeClass"]("disabled");
  }
  ["disableButton"](_0x55cbe1) {
    _0x55cbe1 == "frameOptions" && this["container"]["find"]("a[name=\"config\"]")["addClass"]("disabled");
  }
}
class UserList extends UIComponent {
  constructor(_0x2db849) {
    super(_0x2db849);
    var _0x2a247f = this;
    $["contextMenu"]({
      selector: "#userlistBox table tbody tr.myself",
      build: function (_0x287db2) {
        var _0x10401c = {
          callback: function (_0x10b5a2, _0x585230) {
            var _0x27c833 = _0x585230["$trigger"]["attr"]("name");
            _0x2a247f.select(_0x27c833);
            if (_0x10b5a2 == "Pfl") UI["profileDialog"].show(); else {
              if (_0x10b5a2 == "Ugd") UI["userGalleryDialog"]["show"]({
                uid: room["myself"]["uid"]
              }); else {
                if (_0x10b5a2 == "Reg") {
                  var _0x5a9fab = {};
                  _0x5a9fab["command"] = "ROOMREQUEST", _0x5a9fab.action = "Register", socket["send"](_0x5a9fab, true);
                } else {
                  if (_0x10b5a2 == "Dbg") {
                    var _0x5a9fab = {};
                    _0x5a9fab.command = "GLOBALFUNCTIONS", _0x5a9fab["option"] = "DEBUG", _0x5a9fab["target"] = _0x27c833, socket["send"](_0x5a9fab, true);
                  }
                }
              }
            }
          },
          items: {
            Dbg: {
              name: "Debug",
              visible: function (_0x229eff, _0x13a04d) {
                return room.myself["rank"] == "GM";
              },
              icon: "fa-bug"
            },
            Pfl: {
              name: "Profile",
              icon: "fa-user-tie"
            },
            Ugd: {
              name: "Gallery",
              visible: function (_0x71e9c3, _0x2da3d6) {
                return room.myself["isLogged"]();
              },
              icon: "fa-image"
            },
            Reg: {
              name: "Register room",
              visible: function (_0x45808c, _0x265303) {
                return room.myself["isLogged"]();
              },
              icon: "fa-flag"
            }
          }
        };
        return $["each"](_0x10401c["items"], function (_0xcb9db2, _0x4e29fc) {
          _0x10401c["items"][_0xcb9db2]["name"] && (_0x10401c["items"][_0xcb9db2]["name"] = function () {
            return textManager["getString"]("menu.userList." + _0xcb9db2, null, false);
          });
        }), _0x10401c;
      }
    }), $.contextMenu({
      selector: "#userlistBox table tbody tr.someoneelse",
      build: function (_0x5c40e0) {
        var _0x10063e = {
          callback: function (_0x2581d5, _0x5e04bd) {
            var _0x223d71 = _0x5e04bd.$trigger.attr("name");
            _0x2a247f["select"](_0x223d71);
            if (_0x2581d5 == "Snc") UI["syncBoard"](_0x223d71); else {
              if (_0x2581d5 == "Ugd") UI["userGalleryDialog"]["show"]({
                username: room.users[_0x223d71]["username"]
              }); else {
                if (_0x2581d5 == "Dbg") {
                  var _0x1ed865 = {};
                  _0x1ed865["command"] = "GLOBALFUNCTIONS", _0x1ed865["option"] = "DEBUG", _0x1ed865.target = _0x223d71, socket["send"](_0x1ed865, true);
                } else {
                  if (_0x2581d5 == "Ccb") UI["setCustomBrush"](room.users[_0x223d71]["surface"].getBrushesOptions()["custom"].image); else {
                    if (_0x2581d5 == "IgnToggle") room.toggleIgnoreUser(_0x223d71); else _0x2581d5 == "Pm" ? (UI["chatDialog"].show(), !UI["chatDialog"]["existsChannel"](_0x223d71, "user") && UI["chatDialog"]["addChannel"](_0x223d71, "user"), UI["chatDialog"].selectChannel(_0x223d71, "user")) : room["myself"]["surface"]["userRequestAction"](_0x2581d5, _0x223d71);
                  }
                }
              }
            }
          },
          items: {
            Nm: {
              name: "-",
              disabled: true
            },
            Rnk: {
              name: "-",
              disabled: true
            },
            Ipa: {
              name: "-",
              disabled: true,
              visible: function (_0x45fdf5, _0xb4418d) {
                return room["can"]("ban");
              },
              icon: "fa-ellipsis"
            },
            sep0: {
              type: "cm_separator"
            },
            Snc: {
              name: "Sync board",
              icon: "fa-arrow-left"
            },
            Dbg: {
              name: "Debug",
              visible: function (_0x2cfd4c, _0x535401) {
                return room["myself"]["rank"] == "GM";
              },
              icon: "fa-bug"
            },
            Ugd: {
              name: "Gallery",
              visible: function (_0x4a171f, _0x35c638) {
                return room["users"][_0x35c638.$trigger.attr("name")]["isLogged"]();
              },
              icon: "fa-image"
            },
            Ccb: {
              name: "Copy custom brush",
              visible: function (_0x50cfed, _0x1636f2) {
                return room["myself"]["rank"] == "GM";
              },
              icon: "fa-copy"
            },
            Pm: {
              name: "Private message",
              icon: "fa-envelope"
            },
            sep1: {
              type: "cm_separator"
            },
            IgnToggle: {
              name: "Ignore / Unignore",
              icon: "fa-user-slash"
            },
            sep2: {
              type: "cm_separator",
              visible: function (_0x29eabf, _0x46e12b) {
                return room.can("kick") || room["can"]("ban");
              }
            },
            Kck: {
              name: "Kick",
              visible: function (_0x1641be, _0x25824a) {
                return room["can"]("kick");
              },
              icon: "fa-user-minus"
            },
            Bn: {
              name: "Ban",
              visible: function (_0x514dd8, _0xa9d604) {
                return room["can"]("ban");
              },
              icon: "fa-user-xmark"
            },
            sep3: {
              type: "cm_separator",
              visible: function (_0x49f3ad, _0x100103) {
                return room.can("mute");
              }
            },
            Muu: {
              name: "Mute",
              visible: function (_0x4f1358, _0x473063) {
                return room["can"]("mute");
              },
              icon: "fa-ban"
            },
            Umu: {
              name: "Unmute",
              visible: function (_0x54c85d, _0x507277) {
                return room.can("mute");
              },
              icon: "fa-pencil"
            },
            sep4: {
              type: "cm_separator",
              visible: function (_0x20eaad, _0xfed407) {
                return room["can"]("silence");
              }
            },
            Siu: {
              name: "Silence",
              visible: function (_0x34e216, _0x708dfb) {
                return room["can"]("silence");
              },
              icon: "fa-comment-slash"
            },
            Usi: {
              name: "Unsilence",
              visible: function (_0x69b58d, _0x22a071) {
                return room["can"]("silence");
              },
              icon: "fa-comment"
            },
            sep5: {
              type: "cm_separator",
              visible: function (_0xe2f206, _0x26fcc1) {
                return room.can("addmod");
              }
            },
            Pru: {
              name: "Promote",
              visible: function (_0x1afb91, _0xfc6579) {
                return room["can"]("addmod");
              },
              disabled: function (_0x3317af, _0x488318) {
                var _0xafec63 = _0x488318["$trigger"].attr("name");
                return room.users[_0xafec63].rank == "UU";
              },
              icon: "fa-person-arrow-up-from-line"
            },
            Deu: {
              name: "Demote",
              visible: function (_0x2a7f4a, _0x5e974c) {
                return room["can"]("addmod");
              },
              disabled: function (_0x483ff8, _0x2fb926) {
                var _0x28f81b = _0x2fb926["$trigger"].attr("name");
                return room["users"][_0x28f81b]["rank"] == "UU";
              },
              icon: "fa-person-arrow-down-to-line"
            }
          }
        };
        return $["each"](_0x10063e.items, function (_0x1b6f9c, _0x5bfeda) {
          _0x10063e["items"][_0x1b6f9c]["name"] && (_0x10063e["items"][_0x1b6f9c]["name"] = function () {
            return textManager["getString"]("menu.userList." + _0x1b6f9c, null, false);
          });
        }), _0x10063e["items"].Nm["name"] = _0x5c40e0["attr"]("name"), _0x10063e["items"]["Rnk"]["name"] = UI["userRank"](room["users"][_0x5c40e0["attr"]("name")]["rank"], null, false), _0x10063e["items"]["Ipa"].name = room["users"][_0x5c40e0.attr("name")].ip, _0x10063e["items"]["Ipa"].icon = room["users"][_0x5c40e0.attr("name")]["proxy"] ? "fa-network-wired" : "", _0x10063e;
      }
    }), $(this["container"]).on(UI.pointerEvent("click"), "tr", function (_0x5ee073) {
      _0x2a247f["select"]($(this)["attr"]("name"));
    });
  }
  ["addMyself"]() {
    if (this["container"].find("tr.myself")["length"] == 0) {
      var _0x29c518 = this;
      this["container"]["append"]("<tr class=\"myself\" name=\"" + room["myself"]["username"] + "\"></tr>"), this["updateMyself"](), $(room["myself"]).on("usernameChanged statusChanged rankChanged muteChanged silenceChanged", function (_0x1d5fb7) {
        _0x29c518["updateMyself"]();
      });
    } else this["updateMyself"]();
  }
  ["addUser"](_0x1f276c, _0x19dbe6 = true) {
    var _0x2aa79d = this,
        _0x116925 = room["users"][_0x1f276c["username"]];
    this.container.find("tr").filter((_, el) => el.getAttribute("name") === _0x116925.username).length == 0
      ? ( this.container.append("<tr class=\"someoneelse\" name=\"" + _0x116925["username"] + "\"></tr>"),
          this.updateUser(_0x116925),
          _0x19dbe6 && (
            $(_0x116925["surface"]).on("brushChanged colorChanged uploadModeChanged", function (_0x92d544) {
              _0x2aa79d.updateUser(_0x116925);
            }),
            $(_0x116925).on("usernameChanged statusChanged rankChanged muteChanged silenceChanged ignoreChanged inactiveChanged connectionIssueChanged", function (_0x53f78c) {
              if (_0x53f78c["type"] == "usernameChanged") {
                _0x2aa79d.container.find("tr").filter((_, el) => el.getAttribute("name") === _0x53f78c.oldname).attr("name", _0x53f78c.newname);
              }
              _0x2aa79d.updateUser(_0x116925);
            })
          )
        )
      : this.updateUser(_0x116925);
  }
  ["removeUser"](_0x2fef1f) {
    this.container
      .find('tr')
      .filter((_, el) => el.getAttribute("name") === _0x2fef1f.username)
      .remove();
  }
  ["updateUser"](_0x8f4c5e) {
    var _0x5034c1 = this,
        _0x245f03 = "";

    if (_0x8f4c5e["connectionIssues"])
      _0x245f03 += "<div class=\"brushIcon userlistIcon\">" + new Icon("fa-exclamation-triangle")["html"]() + "</div><div class=\"brushIcon userlistIcon\">" + new Icon("fa-wifi")["html"]() + "</div>";
    else if (_0x8f4c5e["muted"])
      _0x245f03 += "<div class=\"brushIcon userlistIcon\">" + new Icon("fa-ban")["html"]() + "</div>";
    else {
      _0x245f03 += '<div class="colorbox userlistIcon" style="background-color: ' + _0x8f4c5e.surface["drawColor"] + "\"></div>";
      _0x8f4c5e.surface["uploadMode"]
        ? _0x245f03 += "<div class=\"brushIcon userlistIcon\">" + new Icon("fa-image")["html"]() + "</div>"
        : _0x245f03 += '<div class="brushIcon userlistIcon">' + UI["brushToIcon"](_0x8f4c5e["surface"]["getCurrentBrush"]()).html() + "</div>";
    }

    _0x8f4c5e["silenced"] &&
      (_0x245f03 += "<div class=\"brushIcon userlistIcon\">" + new Icon("fa-comment-slash")["html"]() + "</div>");

    this.container.find('tr').filter((_, el) => el.getAttribute("name") === _0x8f4c5e.username).html(
      "<td class=\"text-center\">" + _0x245f03 + '</td><td class="' +
      UI["rankToStyle"](_0x8f4c5e["rank"]) +
      (_0x8f4c5e["ignored"] ? " strikeThrough" : "") +
      "\" style=\"" + (_0x8f4c5e["inactive"] ? "font-style: italic;" : "") + '">' +
      _0x8f4c5e["username"] +
      "<span class=\"userlistStatus\">" + _0x5034c1.statusString(_0x8f4c5e["status"]) + "</span></td>"
    );
  }
  ["sort"]() {
    var _0xc5604c = this["container"].find("tr.selected").attr("name");
    this["container"].empty();
    var _0x5a749f = new Array();
    _0x5a749f["push"](room.myself.username), $.each(room.users, function (_0x168320, _0x3887c0) {
      _0x5a749f["push"](_0x168320);
    }), _0x5a749f.sort(function (_0x2e0ff7, _0x435252) {
      return _0x2e0ff7["toLowerCase"]()["localeCompare"](_0x435252["toLowerCase"]());
    });
    var _0x2b9662 = this;
    $.each(_0x5a749f, function (_0x134cab, _0x265b1a) {
      _0x265b1a == room["myself"]["username"] ? _0x2b9662["addMyself"]() : _0x2b9662["addUser"](room.users[_0x265b1a], false);
    }), _0xc5604c && this["select"](_0xc5604c);
  }
  ["updateMyself"]() {
    var _0x3a3e39 = room.myself;
    this["container"]["find"]("tr.myself")["html"]("<td class=\"text-center\">" + textManager["getString"]("global.lblYou") + "</td><td class=\"" + UI.rankToStyle(_0x3a3e39["rank"]) + '">' + _0x3a3e39["username"] + "<span class=\"userlistStatus\">" + this.statusString(_0x3a3e39["status"]) + "</span></td>"), this["container"]["find"]("tr.myself")["attr"]("name", _0x3a3e39["username"]);
  }
  ["refresh"]() {
    var _0x36fd16 = this;
    this["addMyself"](), $["each"](room["users"], function (_0x347199, _0x8a0735) {
      _0x36fd16["addUser"](_0x8a0735);
    }), $["each"](this.container["find"]("tr"), function (_0x14de92, _0x2abd02) {
      !room["users"][$(this).attr("name")] && !$(this)["hasClass"]("myself") && $(this)["remove"]();
    });
  }
  ["statusString"](_0x6a16e9) {
    var _0x248bee = "";
    return _0x6a16e9 != "" && (_0x248bee = " (" + escapeHTML(_0x6a16e9) + ")"), _0x248bee;
  }
  ["select"](_0xe79572) {
    this.container["find"]("tr.selected")["removeClass"]("selected"), this["container"]["find"]("tr[name=\"" + _0xe79572 + '"]')["addClass"]("selected");
  }
  ["getSelected"]() {
    return this["container"]["find"]("tr.selected").attr("name");
  }
  ["clear"]() {
    this.container["find"]("tr")["remove"]();
  }
}
class Toolbar extends UIComponent {
  constructor(_0x3c026f) {
    super(_0x3c026f), this["tools"] = ["drag", "rotate", "picker", "selection", "pen", "eraser", "text", "line", "rect", "ellipse", "fill", "blend", "pixel", "custom", "blur"], this.createTools();
  }
  ["createTools"]() {
    var _0x4dfd6a = this;
    this["container"]["empty"](), $["each"](this["tools"], function (_0x3a2236, _0x55aa52) {
      var _0x24e738 = $("<a href=\"#\" name=\"" + _0x55aa52 + '" class="btn">' + UI["brushToIcon"](_0x55aa52)["html"]() + "</a>");
      _0x24e738["attr"]("data-tooltipcallback", "tooltipShortcut"), _0x24e738["attr"]("data-tooltipparam", "tool." + _0x55aa52 + ";" + _0x55aa52), _0x4dfd6a.container["append"](_0x24e738);
    }), this["container"]["find"]("a").on(UI["pointerEvent"]("click"), function (_0x2901c6) {
      _0x2901c6["preventDefault"]();
    }), this["container"]["find"]("a").on(UI.pointerEvent("down"), function (_0x4c85ec) {
      _0x4c85ec["preventDefault"]();
      if (!_0x4c85ec.which || _0x4c85ec["which"] == 1) {
        if (!_0x4dfd6a.readOnly) {
          var _0x2c1359 = $(this).attr("name");
          _0x2c1359 && _0x4dfd6a["select"](_0x2c1359);
        }
      }
    });
  }
  ["select"](_0x235f0a) {
    _0x235f0a && this["tools"].indexOf(_0x235f0a) > -1 && (room["myself"]["surface"]["setBrush"](_0x235f0a), this["highlight"](_0x235f0a));
  }
  ["selectPreviouslyUsed"]() {
    var _0x58ca50 = room["myself"]["surface"]["brushHandler"]["previousBrush"];
    _0x58ca50 && (room["myself"]["surface"]["setBrush"](_0x58ca50), this["highlight"](_0x58ca50));
  }
  ["selectNextTool"]() {
    var _0x5e54b6 = this.container["find"]("a.selectedTool").next();
    _0x5e54b6["length"] == 0 && (_0x5e54b6 = this["container"]["find"]("a:first")), this["select"](_0x5e54b6["attr"]("name"));
  }
  ["selectPreviousTool"]() {
    var _0x3a299c = this["container"]["find"]("a.selectedTool")["prev"]();
    _0x3a299c["length"] == 0 && (_0x3a299c = this["container"]["find"]("a:last")), this["select"](_0x3a299c["attr"]("name"));
  }
  ["highlight"](_0x4dd93b) {
    this.container["find"]("a.selectedTool")["removeClass"]("selectedTool"), this.container["find"]("a[name=\"" + _0x4dd93b + '"]').addClass("selectedTool");
  }
  ["getHighlighted"]() {
    return this.container.find("a.selectedTool")["attr"]("name");
  }
  ["hideTool"](_0x15dfb0) {
    var _0x4c3e80 = this.container.find('[name="' + _0x15dfb0 + '"]');
    _0x4c3e80.hide();
  }
  ["showTool"](_0x4f15a0) {
    var _0x4702a9 = this["container"]["find"]("[name=\"" + _0x4f15a0 + '"]');
    _0x4702a9.show();
  }
  ["isToolAvailable"](_0x30e189) {
    var _0x329535 = this.container["find"]("[name=\"" + _0x30e189 + '"]');
    return _0x329535.is(":visible");
  }
}
class PresetBox extends Component {
  constructor(_0x2f6923, _0x28d8fc, _0x36851a) {
    super(), this.color = _0x2f6923, this["brush"] = _0x28d8fc, this["options"] = _0x36851a;
  }
}
class PresetGrid extends UIComponent {
  constructor(_0x4d9269, _0x4a8239, _0x30d6f0, _0x42a815 = null) {
    super(_0x4a8239), this.id = _0x4d9269, this["storage"] = _0x42a815, this["objects"] = [], this["amount"] = _0x30d6f0, this["createGrid"](), this["loadFromStorage"](), this["saveableOptions"] = ["size", "alpha", "blur", "smooth", "selectiontype", "multilayer", "spacing", "blendmode", "areaaverage", "erasermode", "aspectratio", "snap", "drawgrid", "cursor", "rightclick", "image", "tint", "randomrotation"], this.redraw();
  }
  ["createGrid"]() {
    var _0x348b33 = {};
    _0x348b33.size = 8, _0x348b33["alpha"] = 1, _0x348b33.blur = 0, _0x348b33["blendmode"] = "normal";
    for (var _0x149cb6 = 0; _0x149cb6 < this.amount; _0x149cb6++) {
      this.objects[_0x149cb6] = new PresetBox("#FFFFFF", "pen", _0x348b33);
    }
  }
  ["bindEvents"]() {
    var _0x3e4dc0 = this,
      _0x2c134b = false;
    this.container["find"]("span")["contextmenu"](function (_0x38f278) {
      _0x38f278["preventDefault"]();
    }), this["container"]["find"]("span").on(UI["pointerEvent"]("click", "presetbubble"), function (_0x288972) {
      _0x288972["preventDefault"]();
    }).on(UI["pointerEvent"]("down", "presetbubble"), function (_0x22fb8d) {
      if (!_0x22fb8d["which"] || _0x22fb8d["which"] == 1) {
        _0x2c134b = true;
        var _0x1a97e5 = $(this);
        if (UI["holdingSHIFT"]) {
          var _0x58c9e6 = _0x1a97e5["attr"]("name");
          $(_0x3e4dc0)["triggerHandler"](new bubbleClickedEvent(_0x3e4dc0.id, _0x58c9e6, "save", "preset")["getEvent"]()), _0x2c134b = false;
        } else setTimeout(function () {
          if (_0x2c134b) {
            var _0x24005d = _0x1a97e5["attr"]("name");
            $(_0x3e4dc0).triggerHandler(new bubbleClickedEvent(_0x3e4dc0.id, _0x24005d, "save", "preset")["getEvent"]()), _0x2c134b = false;
          }
        }, 500);
      }
    }).on(UI["pointerEvent"]("up", "presetbubble"), function (_0x183541) {
      if (_0x2c134b) {
        var _0x14c117 = $(this)["attr"]("name");
        _0x3e4dc0["loadBubble"](_0x14c117);
      }
      _0x2c134b = false;
    }).on(UI["pointerEvent"]("dragstart", "colorbubble"), function (_0x53fe6e) {
      _0x53fe6e.preventDefault();
    });
  }
  ["loadBubble"](_0x4ff35e) {
    var _0x43c8ff = this["getPreset"](_0x4ff35e);
    $(this)["triggerHandler"](new bubbleClickedEvent(this.id, _0x4ff35e, "load", "preset", _0x43c8ff).getEvent());
  }
  ["saveBubble"](_0x63fd1, _0x9e7ee5) {
    this.objects[_0x9e7ee5] = new PresetBox(_0x63fd1["color"], _0x63fd1["brush"], _0x63fd1["options"]), this.redrawPreset(_0x9e7ee5), this["saveToStorage"]();
  }
  ["getPreset"](_0x5ed79f) {
    return this["objects"][_0x5ed79f];
  }
  ["redrawPreset"](_0x1eb941) {
    this["container"]["find"]("span[name=\"" + _0x1eb941 + '"]')["css"]("background-color", this["objects"][_0x1eb941].color);
  }
  ["redraw"]() {
    this["container"]["empty"]();
    for (var _0x46cb63 = 0; _0x46cb63 < this.amount; _0x46cb63++) {
      var _0x239ebb = $("<span />");
      _0x239ebb["attr"]("name", _0x46cb63), _0x239ebb["attr"]("data-tooltipcallback", "presetBubbleTooltip"), _0x239ebb["attr"]("data-tooltipparam", _0x46cb63), _0x239ebb["addClass"]("fmBubble presetBubble"), _0x239ebb["text"](_0x46cb63 + 1), _0x46cb63 in this["objects"] && _0x239ebb["css"]("background-color", this["objects"][_0x46cb63].color), this.container.append(_0x239ebb);
    }
    this["bindEvents"]();
  }
  ["loadFromStorage"]() {
    if (this["storage"]) {
      var _0x538817 = this["storage"].getParameter("presets." + this.id);
      _0x538817 && (this["objects"] = JSON["parse"](_0x538817));
    }
  }
  ["saveToStorage"]() {
    this.storage && this["storage"].setParameter("presets." + this.id, JSON.stringify(this.objects));
  }
}
class ColorBubble extends Component {
  constructor(_0x2d4f05) {
    super(), this.color = _0x2d4f05;
  }
}
class ColorGrid extends UIComponent {
  constructor(_0x5acaaf, _0x5a8780, _0x17f0e3, _0x4c76de = null) {
    super(_0x5a8780), this.id = _0x5acaaf, this["storage"] = _0x4c76de, this.objects = [], this["amount"] = _0x17f0e3, this["defaultColor"] = "white", this["createGrid"](), this["loadFromStorage"](), this.redraw();
  }
  ["createGrid"]() {
    for (var _0x122d61 = 0; _0x122d61 < this["amount"]; _0x122d61++) {
      this.objects[_0x122d61] = new ColorBubble("#FFFFFF");
    }
  }
  ["bindEvents"]() {
    var _0x343344 = this,
      _0x3d39c0 = false;
    this["container"]["find"]("span")["contextmenu"](function (_0x46b9f3) {
      _0x46b9f3["preventDefault"]();
    }), this["container"].find("span").on(UI["pointerEvent"]("click", "colorbubble"), function (_0xa06ffc) {
      _0xa06ffc["preventDefault"]();
    }).on(UI["pointerEvent"]("down", "colorbubble"), function (_0x4dc386) {
      if (!_0x4dc386["which"] || _0x4dc386["which"] == 1) {
        _0x3d39c0 = true;
        var _0x5edd23 = $(this);
        if (UI["holdingSHIFT"]) {
          var _0x5f3f3d = _0x5edd23["attr"]("name");
          $(_0x343344)["triggerHandler"](new bubbleClickedEvent(_0x343344.id, _0x5f3f3d, "save", "color").getEvent()), _0x3d39c0 = false;
        } else setTimeout(function () {
          if (_0x3d39c0) {
            var _0x96b5dd = _0x5edd23["attr"]("name");
            $(_0x343344)["triggerHandler"](new bubbleClickedEvent(_0x343344.id, _0x96b5dd, "save", "color").getEvent()), _0x3d39c0 = false;
          }
        }, 500);
      }
    }).on(UI["pointerEvent"]("up", "colorbubble"), function (_0x104d14) {
      if (_0x3d39c0) {
        var _0x1cf32c = $(this)["attr"]("name");
        _0x343344["loadBubble"](_0x1cf32c);
      }
      _0x3d39c0 = false;
    }).on(UI.pointerEvent("dragstart", "colorbubble"), function (_0x3682d6) {
      _0x3682d6.preventDefault();
    });
  }
  ["loadBubble"](_0x5e1a48) {
    var _0x7a2487 = this.getColor(_0x5e1a48);
    _0x7a2487 && $(this)["triggerHandler"](new bubbleClickedEvent(this.id, _0x5e1a48, "load", "color", _0x7a2487).getEvent());
  }
  ["saveBubble"](_0x3ed08d, _0x13bc20) {
    this["objects"][_0x13bc20] = new ColorBubble(_0x3ed08d["color"], _0x3ed08d.brush, _0x3ed08d.options), this["redrawColor"](_0x13bc20), this["saveToStorage"]();
  }
  ["colorExists"](_0x3f55b1) {
    return _0x3f55b1 in this["objects"] && this["objects"][_0x3f55b1];
  }
  ["getColor"](_0x5ae785) {
    if (this["colorExists"](_0x5ae785)) return this["objects"][_0x5ae785];
    return null;
  }
  ["redrawColor"](_0x18c882) {
    this["container"].find("span[name=\"" + _0x18c882 + '"]').css("background-color", this.objects[_0x18c882]["color"]);
  }
  ["redraw"]() {
    this.container["empty"]();
    var _0x24968d = this["amount"] == 10;
    for (var _0x4e2ec6 = 0; _0x4e2ec6 < this["amount"]; _0x4e2ec6++) {
      var _0x3c0013 = $("<span />");
      _0x3c0013["attr"]("name", _0x4e2ec6);
      _0x24968d && (_0x3c0013.attr("data-tooltipcallback", "colorBubbleTooltip"), _0x3c0013["attr"]("data-tooltipparam", _0x4e2ec6));
      var _0x57ec3f = this["defaultColor"];
      this["colorExists"](_0x4e2ec6) && (_0x57ec3f = this["objects"][_0x4e2ec6]["color"]), _0x3c0013["addClass"]("fmBubble colorBubble"), _0x3c0013["css"]("background-color", _0x57ec3f), this.container["append"](_0x3c0013);
    }
    this.bindEvents();
  }
  ["loadFromStorage"]() {
    if (this["storage"]) {
      var _0x4314b7 = this["storage"]["getParameter"]("colorbubbles." + this.id);
      _0x4314b7 && (this.objects = JSON["parse"](_0x4314b7));
    }
  }
  ["saveToStorage"]() {
    this["storage"] && this["storage"]["setParameter"]("colorbubbles." + this.id, JSON.stringify(this["objects"]));
  }
}
class ColorWheel extends UIComponent {
  constructor(_0x1d3bb5, _0x2273c8 = true) {
    super(_0x1d3bb5), this.showSliders = _0x2273c8, this["hueRotation"] = 90, this.selectedColor = rgb2hsv(0, 0, 0), this.currentRGB = hex2rgb("#000000"), this.dragging1 = false, this.dragging2 = false, this["slidersMode"] = false, this["setupMode"] = false, this["wheel"] = $("<div />"), this["wheel"]["addClass"]("fmWheel");
    var _0x29c665 = this;
    this.wheelCanvas = new AdvancedCanvas(195, 195), $(this["wheelCanvas"]["canvas"][0]).addClass("noMouseInteraction");
    var _0x5764b0 = $("<div />");
    _0x5764b0["addClass"]("colorWheel");
    var _0x52825f = new Image();
    _0x52825f.onload = function (_0x2a9e5a) {
      _0x29c665["wheelCanvas"].drawImage(_0x52825f, 0, 0), _0x5764b0["append"](_0x29c665.wheelCanvas.canvas[0]);
    }, _0x52825f["src"] = UI.baseDir + "images/colorwheel.png", this.squares = $("<div />"), this["squares"]["addClass"]("colorSquares"), this["currentColor"] = $("<div />"), this["currentColor"]["addClass"]("colorSquare color noMouseInteraction");
    var _0x217d36 = $("<div />");
    _0x217d36["addClass"]("colorSquare saturation noMouseInteraction"), this.marker1 = $("<div />"), this["marker1"]["addClass"]("marker bigMarker"), this["marker2"] = $("<div />"), this["marker2"]["addClass"]("marker smallMarker"), this["wheel"]["append"](_0x5764b0), this["wheel"].append(this.squares), this["wheel"]["append"](this["marker1"]), this["squares"]["append"](this["currentColor"]), this["squares"]["append"](_0x217d36), this["squares"]["append"](this["marker2"]), _0x2273c8 && (this.switchIcon = $("<div />"), this["switchIcon"]["addClass"]("colorSwitch"), this["sliders"] = $("<div>\n\t\t\t\t<div class=\"optionBG\"><div class=\"optionTitle\">" + textManager.getString("color.lblR") + " </div><div name=\"red\" class=\"optionField\"></div></div>\n\t\t\t\t<div class=\"optionBG\"><div class=\"optionTitle\">" + textManager["getString"]("color.lblG") + ' </div><div name="green" class="optionField"></div></div>\n				<div class="optionBG"><div class="optionTitle">' + textManager["getString"]("color.lblB") + " </div><div name=\"blue\" class=\"optionField\"></div></div>\n\t\t\t\t<div class=\"optionBG\"><div class=\"optionTitle\">" + textManager["getString"]("color.lblH") + " </div><div name=\"hue\" class=\"optionField\"></div></div>\n\t\t\t\t<div class=\"optionBG\"><div class=\"optionTitle\">" + textManager["getString"]("color.lblS") + " </div><div name=\"saturation\" class=\"optionField\"></div></div>\n\t\t\t\t<div class=\"optionBG\"><div class=\"optionTitle\">" + textManager["getString"]("color.lblV") + ' </div><div name="value" class="optionField"></div></div>\n			</div>'), this.colorR = new Slider(this["sliders"].find('div[name="red"]'), 0, 255, 1), this["colorG"] = new Slider(this["sliders"].find("div[name=\"green\"]"), 0, 255, 1), this["colorB"] = new Slider(this["sliders"].find("div[name=\"blue\"]"), 0, 255, 1), this["colorH"] = new Slider(this["sliders"]["find"]("div[name=\"hue\"]"), 0, 360, 1), this["colorS"] = new Slider(this.sliders["find"]("div[name=\"saturation\"]"), 0, 100, 1), this["colorV"] = new Slider(this.sliders["find"]("div[name=\"value\"]"), 0, 100, 1), $(this["colorR"]).on("sliderChanged", function (_0x4ead83) {
      !_0x29c665["setupMode"] && _0x29c665["slidersChanged"](true);
    }), $(this["colorG"]).on("sliderChanged", function (_0x41bb65) {
      !_0x29c665["setupMode"] && _0x29c665["slidersChanged"](true);
    }), $(this["colorB"]).on("sliderChanged", function (_0x561ace) {
      !_0x29c665["setupMode"] && _0x29c665["slidersChanged"](true);
    }), $(this["colorH"]).on("sliderChanged", function (_0x303d45) {
      !_0x29c665["setupMode"] && _0x29c665["slidersChanged"](false);
    }), $(this.colorS).on("sliderChanged", function (_0x2fffd6) {
      !_0x29c665.setupMode && _0x29c665["slidersChanged"](false);
    }), $(this["colorV"]).on("sliderChanged", function (_0x318ba5) {
      !_0x29c665["setupMode"] && _0x29c665["slidersChanged"](false);
    }), this["container"]["append"](this.sliders), this["container"].append(this["switchIcon"]), this["switchIcon"].on(UI["pointerEvent"]("click", "colorWheel"), function (_0x245d59) {
      _0x29c665["slidersMode"] ? _0x29c665["showWheelMode"]() : _0x29c665["showSlidersMode"]();
    })), this.showWheelMode(), this.container["append"](this["wheel"]), this["wheel"].find(".colorWheel").on(UI.pointerEvent("down", "colorWheel"), function (_0x26a8e7) {
      if (!_0x26a8e7["which"] || _0x26a8e7["which"] == 1) {
        _0x26a8e7["preventDefault"]();
        var _0x4cdc7c = UI["getInputPosition"](_0x26a8e7),
          _0x893bb8 = _0x29c665["wheel"].find(".colorWheel")["offset"](),
          _0x2a924c = _0x29c665["wheelCanvas"]["getImageData"](_0x4cdc7c.x - _0x893bb8["left"], _0x4cdc7c.y - _0x893bb8["top"], 1, 1).data;
        _0x2a924c[3] != 0 && (_0x29c665["dragging1"] = true, _0x29c665["click"](_0x4cdc7c.x, _0x4cdc7c.y));
      }
    }), this.wheel["find"](".colorSquares").on(UI["pointerEvent"]("down", "colorWheel"), function (_0x2605c7) {
      if (!_0x2605c7.which || _0x2605c7.which == 1) {
        _0x2605c7["preventDefault"](), _0x29c665.dragging2 = true;
        var _0x1a33e3 = UI["getInputPosition"](_0x2605c7);
        _0x29c665.click(_0x1a33e3.x, _0x1a33e3.y);
      }
    }), $(document).on(UI["pointerEvent"]("move", "colorWheel"), function (_0x332873) {
      if (_0x29c665["dragging1"] || _0x29c665["dragging2"]) {
        var _0x1d519c = UI["getInputPosition"](_0x332873);
        _0x29c665["click"](_0x1d519c.x, _0x1d519c.y);
      }
    }), $(document).on(UI["pointerEvent"]("up", "colorWheel"), function (_0x2c70a3) {
      (_0x29c665["dragging1"] || _0x29c665["dragging2"]) && (_0x2c70a3["preventDefault"](), _0x29c665.dragging1 = false, _0x29c665["dragging2"] = false);
    }), this["updateColor"](this["selectedColor"].h, this["selectedColor"].s, this.selectedColor.v);
  }
  ["click"](_0x200a32, _0x429dc0) {
    if (!this["readOnly"]) {
      var _0x19ff63 = 84,
        _0x3da3c4 = 100,
        _0x5948ec = 194;
      if (this["dragging1"]) {
        var _0x12c2d2 = this.wheel.find(".colorWheel").offset(),
          _0x574291 = new Point(_0x12c2d2.left + _0x5948ec / 2, _0x12c2d2["top"] + _0x5948ec / 2),
          _0x5c67e6 = Math.atan2(_0x574291.y - _0x429dc0, _0x200a32 - _0x574291.x),
          _0x2401d4 = parseInt(-_0x5c67e6 * 180 / Math.PI + 90 - this["hueRotation"]);
        this.updateColor(loopValue(_0x2401d4, 360), this["selectedColor"].s, this.selectedColor.v);
      }
      if (this["dragging2"]) {
        var _0x12c2d2 = this["wheel"]["find"](".colorSquares").offset(),
          _0x11fc05 = new Point(_0x200a32 - _0x12c2d2["left"], _0x429dc0 - _0x12c2d2["top"]);
        _0x11fc05.x = Math["min"](Math["max"](_0x11fc05.x, 0), _0x3da3c4), _0x11fc05.y = 100 - Math["min"](Math["max"](_0x11fc05.y, 0), _0x3da3c4), this["updateColor"](this.selectedColor.h, _0x11fc05.x, _0x11fc05.y);
      }
    }
  }
  ["updateColor"](_0x3ec8fb, _0x4380e3, _0x451b93, _0x29d673 = true) {
    _0x3ec8fb = Math.round(_0x3ec8fb), _0x4380e3 = Math["round"](_0x4380e3), _0x451b93 = Math["round"](_0x451b93);
    if (_0x3ec8fb == 360) _0x3ec8fb = 0;
    this["selectedColor"] = {
      h: _0x3ec8fb,
      s: _0x4380e3,
      v: _0x451b93
    }, this["updateMarkers"](_0x3ec8fb, _0x4380e3, _0x451b93);
    var _0x30c53e = hsl2rgb(_0x3ec8fb, 100, 50);
    this.currentColor["css"]("background-color", "rgb(" + _0x30c53e.r + ", " + _0x30c53e.g + ", " + _0x30c53e.b + ")");
    var _0x5c9157 = hsv2rgb(_0x3ec8fb, _0x4380e3, _0x451b93);
    this.setupMode = true, this["updateSliders"](_0x5c9157, this["selectedColor"]), this["setupMode"] = false, _0x29d673 && (this.currentRGB = _0x5c9157, $(this).triggerHandler(new colorChangedEvent("rgb(" + _0x5c9157.r + ", " + _0x5c9157.g + ", " + _0x5c9157.b + ")")["getEvent"]()));
  }
  ["updateMarkers"](_0x11dde8, _0x4cb214, _0x527910) {
    var _0x36dfb8 = 84,
      _0x42f6a8 = 100,
      _0x3289e1 = 194,
      _0x1bf149 = _0x11dde8 + this.hueRotation,
      _0x1dd222 = _0x1bf149 * Math.PI / 180;
    !this.dragging2 && this.marker1.css({
      left: Math.round(Math["sin"](_0x1dd222) * _0x36dfb8 + _0x3289e1 / 2) + "px",
      top: Math["round"](-Math.cos(_0x1dd222) * _0x36dfb8 + _0x3289e1 / 2) + "px"
    }), !this.dragging1 && this["marker2"]["css"]({
      left: Math["round"](_0x4cb214) + "px",
      top: Math.round(100 - _0x527910) + "px"
    });
  }
  ["setColor"](_0x4c6f9d, _0x58d1ee = false) {
    if (_0x4c6f9d[0] == "#") _0x4c6f9d = hex2rgb(_0x4c6f9d); else _0x4c6f9d["slice"](0, 3) == "rgb" && (_0x4c6f9d = rgb2obj(_0x4c6f9d));
    this["setColorRGB"](_0x4c6f9d, _0x58d1ee);
  }
  ["setColorRGB"](_0x584214, _0x2ba2d5 = false) {
    if (!this["rgbMatches"](this["currentRGB"], _0x584214)) {
      var _0x3a5dd3 = rgb2hsv(_0x584214.r, _0x584214.g, _0x584214.b);
      this["updateColor"](_0x3a5dd3.h, _0x3a5dd3.s, _0x3a5dd3.v, _0x2ba2d5), this["currentRGB"] = _0x584214, this["setupMode"] = true, this["updateSliders"](_0x584214, _0x3a5dd3), this["setupMode"] = false;
    }
  }
  ["rgbMatches"](_0x308db2, _0x405851) {
    return parseInt(_0x308db2.r) == parseInt(_0x405851.r) && parseInt(_0x308db2.g) == parseInt(_0x405851.g) && parseInt(_0x308db2.b) == parseInt(_0x405851.b);
  }
  ["updateSliders"](_0xb51a51 = null, _0xcf8ad5 = null) {
    if (!this.showSliders) return;
    _0xb51a51 && (this["colorR"]["setValue"](_0xb51a51.r), this["colorG"]["setValue"](_0xb51a51.g), this["colorB"]["setValue"](_0xb51a51.b)), _0xcf8ad5 && (this["colorH"]["setValue"](parseInt(_0xcf8ad5.h)), this["colorS"]["setValue"](parseInt(_0xcf8ad5.s)), this["colorV"]["setValue"](parseInt(_0xcf8ad5.v)));
  }
  ["slidersChanged"](_0x29a1d2 = true) {
    if (!this.showSliders) return;
    this["setupMode"] = true;
    var _0x40931d;
    if (_0x29a1d2) {
      _0x40931d = "rgb(" + Math["min"](Math["max"](this["colorR"]["getValue"](), 0), 255) + "," + Math["min"](Math["max"](this["colorG"]["getValue"](), 0), 255) + "," + Math["min"](Math["max"](this["colorB"].getValue(), 0), 255) + ")";
      var _0xf243f5 = rgb2hsv(this["colorR"]["getValue"](), this["colorG"]["getValue"](), this["colorB"]["getValue"]());
      this["colorH"].setValue(parseInt(_0xf243f5.h)), this["colorS"]["setValue"](parseInt(_0xf243f5.s)), this["colorV"].setValue(parseInt(_0xf243f5.v));
    } else {
      var _0x42a5ab = hsv2rgb(loopValue(this["colorH"]["getValue"](), 360), loopValue(this["colorS"]["getValue"](), 100), loopValue(this["colorV"].getValue(), 100));
      _0x40931d = "rgb(" + _0x42a5ab.r + "," + _0x42a5ab.g + "," + _0x42a5ab.b + ")", this["colorR"]["setValue"](_0x42a5ab.r), this.colorG["setValue"](_0x42a5ab.g), this.colorB["setValue"](_0x42a5ab.b);
    }
    this.setColor(_0x40931d, true), this["setupMode"] = false;
  }
  ["showSlidersMode"]() {
    if (!this["showSliders"]) return;
    this.slidersMode = true, this.wheel["hide"](), this["sliders"]["fadeIn"](300), this.switchIcon["html"](new Icon("fa-palette")["html"]());
  }
  ["showWheelMode"]() {
    if (!this["showSliders"]) return;
    this["slidersMode"] = false, this["sliders"]["hide"](), this["wheel"]["fadeIn"](300), this["switchIcon"]["html"](new Icon("fa-sliders-h").html());
  }
}
class ColorBox extends UIComponent {
  constructor(_0x354a87, _0x5a4445, _0x3ad2f3, _0x2eedf5 = null) {
    super(_0x354a87), this.storage = _0x2eedf5, this["primaryColor"] = _0x5a4445, this["secondaryColor"] = _0x3ad2f3, this["loadFromStorage"]();
    var _0x5c90f4 = new Icon("fa-share", "fas", "fa-rotate-90");
    this["container"]["html"]("<a href=\"#\" class=\"exchange\" data-tooltipcallback=\"tooltipShortcut\"  data-tooltipparam=\"tooltip.lblSwapColors;swapcolors\">" + _0x5c90f4["html"]() + "</a><a href=\"#\" class=\"primary color\" data-tooltipcallback=\"tooltipShortcut\" data-tooltipparam=\"tooltip.lblChangePrimaryColor;changeprimarycolor\"></a><a href=\"#\" class=\"secondary color\" data-tooltipcallback=\"tooltipShortcut\"  data-tooltipparam=\"tooltip.lblChangeSecondaryColor;changesecondarycolor\"></a>");
    var _0x463a3c = this;
    this["container"]["find"](".exchange").on(UI["pointerEvent"]("click"), function (_0x5b62fc) {
      _0x5b62fc["preventDefault"](), !_0x463a3c["readOnly"] && _0x463a3c["swap"]();
    }), this.container["find"](".primary").on(UI["pointerEvent"]("click"), function (_0x3bb204) {
      _0x3bb204.preventDefault(), _0x463a3c.changePrimary();
    }), this.container["find"](".secondary").on(UI["pointerEvent"]("click"), function (_0x5b6661) {
      _0x5b6661.preventDefault(), _0x463a3c["changeSecondary"]();
    }), this["redraw"]();
  }
  ["changePrimary"]() {
    var _0x2bed6b = this;
    $(UI["colorDialog"]).on("colorChanged.colorbox", function (_0x550c9f) {
      _0x2bed6b["setPrimary"](_0x550c9f["color"]), $(UI.colorDialog)["off"](".colorbox");
    }), $(UI["colorDialog"]).on("dialogClosed.colorbox", function (_0x3b7d82) {
      $(UI["colorDialog"])["off"](".colorbox");
    }), UI["colorDialog"]["show"](_0x2bed6b.primaryColor);
  }
  ["changeSecondary"]() {
    var _0x80f0f3 = this;
    $(UI["colorDialog"]).on("colorChanged.colorbox", function (_0x6c752a) {
      _0x80f0f3["setSecondary"](_0x6c752a.color), $(UI["colorDialog"])["off"](".colorbox");
    }), $(UI["colorDialog"]).on("dialogClosed.colorbox", function (_0x418cb2) {
      $(UI["colorDialog"])["off"](".colorbox");
    }), UI["colorDialog"].show(_0x80f0f3["secondaryColor"]);
  }
  ["setPrimary"](_0x380d16) {
    this["primaryColor"] != _0x380d16 && (this["primaryColor"] = _0x380d16, this["redraw"](), this["saveToStorage"](), $(this).triggerHandler(new colorChangedEvent(_0x380d16)["getEvent"]()));
  }
  ["setSecondary"](_0x196a4f) {
    this["secondaryColor"] != _0x196a4f && (this["secondaryColor"] = _0x196a4f, this["redraw"](), this.saveToStorage());
  }
  ["swap"]() {
    if (this.primaryColor != this["secondaryColor"]) {
      var _0x4b60a7 = this["secondaryColor"];
      this.secondaryColor = this["primaryColor"], this["primaryColor"] = _0x4b60a7, this["redraw"](), this["saveToStorage"](), $(this).triggerHandler(new colorChangedEvent(_0x4b60a7)["getEvent"]());
    }
  }
  ["redraw"]() {
    this["container"].find(".primary")["css"]("background-color", this.primaryColor), this["container"]["find"](".secondary")["css"]("background-color", this["secondaryColor"]);
  }
  ["loadFromStorage"]() {
    if (this.storage) {
      var _0x362f87 = this["storage"]["getParameter"]("colorbox");
      if (_0x362f87) {
        var _0x493716 = JSON["parse"](_0x362f87);
        this["primaryColor"] = _0x493716["primary"], this["secondaryColor"] = _0x493716["secondary"];
      }
    }
  }
  ["saveToStorage"]() {
    if (this["storage"]) {
      var _0x3c8aef = {};
      _0x3c8aef["primary"] = this["primaryColor"], _0x3c8aef["secondary"] = this["secondaryColor"], this["storage"]["setParameter"]("colorbox", JSON["stringify"](_0x3c8aef));
    }
  }
}
class SidebarContainer extends UIComponent {
  constructor(_0x5b3ea5, _0x5e055c, _0x3f43fb, _0xd6564d = "", _0x307532 = 150, _0x8bc81b = true, _0x2cb4ac = true, _0x1f8c0f = "") {
    super($("<div />")), this.id = _0x5b3ea5, this.container, this["title"], this["footer"], this["content"], this["resizable"] = _0x8bc81b, this["scrollable"] = _0x2cb4ac, this.resizing = false, this["resizePoint"] = null, this["innerContent"] = _0x5e055c, _0x5e055c.wrap("<div class=\"containerContent\"></div>"), this["content"] = _0x5e055c["parent"](), this.content["wrap"]("<div class=\"containerSidebar " + _0x1f8c0f + "\"></div>"), this["container"] = this["content"]["parent"]();
    var _0x2010fb = new Icon(_0xd6564d),
      _0x59b761 = new Icon("fa-chevron-up"),
      _0x37789a = new Icon("fa-grip-lines");
    this.container.prepend("<div class=\"containerTitle\"><span>" + _0x2010fb["html"]() + " " + _0x3f43fb + "</span><a href=\"#\" class=\"sidebarCollapseIcon pull-right\">" + _0x59b761["html"]() + "</a></div>"), this["container"]["append"]('<div class="containerFooter">' + _0x37789a.html() + "</div>"), this["title"] = this.container["find"](".containerTitle"), this["footer"] = this["container"]["find"](".containerFooter"), this["minHeight"] = 50, this["prevHeight"], this["setHeight"](_0x307532);
    if (this["scrollable"]) {
      var _0x3044b3 = this["content"].overlayScrollbars({
        className: "os-theme-light",
        overflowBehavior: {
          x: "hidden"
        }
      })["overlayScrollbars"]();
      _0x3044b3["addExt"]("fmExtension");
    }
    !this.resizable && this["footer"]["hide"]();
    var _0x415f1e = this;
    this["footer"].on(UI.pointerEvent("dblclick"), function (_0x2cc13e) {
      _0x2cc13e.preventDefault(), _0x415f1e["setHeight"](_0x415f1e.innerContent["height"]());
    }), this["footer"].on(UI["pointerEvent"]("down"), function (_0x580b5b) {
      _0x580b5b.preventDefault(), _0x580b5b.stopPropagation();
      if (!_0x580b5b.which || _0x580b5b.which == 1) {
        var _0xa98532 = UI["getInputPosition"](_0x580b5b),
          _0x403863 = _0x415f1e["content"]["offset"]();
        _0x415f1e.resizePoint = new Point(_0xa98532.x - _0x403863.left, _0xa98532.y - _0x403863["top"]), _0x415f1e["resizing"] = true, _0x415f1e["prevHeight"] = _0x415f1e["getHeight"]();
      }
    }), $(document).on(UI["pointerEvent"]("move"), function (_0x2cb558) {
      if (_0x415f1e["resizing"] && _0x415f1e["resizePoint"]) {
        _0x2cb558.stopPropagation();
        var _0x1adddd = _0x415f1e["content"]["offset"](),
          _0x306e8b = new Rect(_0x1adddd["left"], _0x1adddd["top"], _0x415f1e["content"]["width"](), _0x415f1e["content"]["height"]());
        _0x306e8b["height"] = _0x2cb558["clientY"] - _0x306e8b.y, _0x415f1e["setHeight"](_0x306e8b.height);
      }
    }), $(document).on(UI["pointerEvent"]("up"), function (_0x267759) {
      _0x415f1e.resizing = false, _0x415f1e["prevHeight"] != _0x415f1e.getHeight() && $(_0x415f1e)["triggerHandler"](new elementHeightChangedEvent(_0x415f1e.id, _0x415f1e["getHeight"]())["getEvent"]());
    }), this["title"]["find"](".sidebarCollapseIcon").on(UI["pointerEvent"]("click"), function (_0x1f51dc) {
      _0x1f51dc["preventDefault"](), !_0x415f1e["readOnly"] && (_0x415f1e["isCollapsed"]() ? _0x415f1e["uncollapse"]() : _0x415f1e.collapse());
    });
  }
  ["getHeight"]() {
    return this["height"];
  }
  ["setHeight"](_0x46401c) {
    this["content"]["css"]("height", Math.max(_0x46401c, this["minHeight"])), this["height"] = _0x46401c;
  }
  ["isCollapsed"]() {
    return this["title"]["hasClass"]("titleCollapsed");
  }
  ["hide"]() {
    this.container["hide"]();
  }
  ["show"]() {
    this.container["show"]();
  }
  ["collapse"]() {
    this.content["slideUp"](), this["footer"]["fadeOut"](250), this["title"].addClass("titleCollapsed"), this.title["find"](".sidebarCollapseIcon")["html"](new Icon("fa-chevron-down")["html"]()), $(this)["triggerHandler"](new elementCollapsedEvent(this.id)["getEvent"]());
  }
  ["uncollapse"]() {
    this["content"].slideDown(), this["resizable"] && this["footer"]["fadeIn"](250), this["title"]["removeClass"]("titleCollapsed"), this["title"]["find"](".sidebarCollapseIcon")["html"](new Icon("fa-chevron-up").html()), $(this)["triggerHandler"](new elementUncollapsedEvent(this.id)["getEvent"]());
  }
}
class ToolOptions extends UIComponent {
  constructor(_0x24be94) {
    super(_0x24be94), this.controls = {};
    var _0x46d482 = this;
    $(room.myself["surface"]).on("brushOptionChanged brushOptionReadOnly", function (_0x35e077) {
      var _0x275614 = room.myself["surface"].brushHandler["brush"]["options"][_0x35e077["option"]]; // This is the command to change opacity(or any other setting)
      if (_0x275614) {
        if (_0x275614["type"] == "slider" || _0x275614["type"] == "slidercheck" || _0x275614["type"] == "check") _0x35e077["type"] == "brushOptionChanged" ? _0x46d482["controls"][_0x35e077["option"]] && _0x46d482.controls[_0x35e077["option"]]["setValue"](_0x35e077["value"]) : _0x46d482["controls"][_0x35e077["option"]]["setReadOnly"](_0x35e077.status); else _0x275614.type == "list" && (_0x35e077["type"] == "brushOptionChanged" ? _0x46d482["container"]["find"]("#option_" + _0x35e077["option"] + " option[value=\"" + _0x35e077["value"] + '"]')["prop"]("selected", true) : _0x46d482.controls[_0x35e077["option"]]["setReadOnly"](_0x35e077["status"]));
      }
    }), $(room["myself"].surface).on("brushChanged", function (_0x3f8804) {
      _0x46d482["destroyControls"]();
      var _0x190bd7 = "";
      _0x46d482["container"].empty();
      var _0x22b92f = room["myself"].surface["brushHandler"]["brush"];
      $["each"](_0x22b92f["options"], function (_0x53414a) {
        var _0x2eba02 = _0x22b92f["options"][_0x53414a];
        if (!_0x2eba02["hidden"] && _0x2eba02.isCompatible(room["type"], room["board"]["nLayers"])) {
          if (_0x2eba02.type == "slider") {
            _0x190bd7 = '<div class="optionBG"><div class="optionTitle">' + UI["optionToName"](_0x2eba02.id) + "</div> <div id=\"option_" + _0x2eba02.id + "\" class=\"optionField\"></div></div>", _0x46d482["container"]["append"](_0x190bd7);
            var _0x2bd569 = new Slider(_0x46d482["container"].find("#option_" + _0x2eba02.id), _0x2eba02["min"], _0x2eba02["max"], _0x2eba02["step"], _0x2eba02["callbackFunction"], "tooloption");
            _0x2bd569["setValue"](_0x2eba02["value"]), _0x2bd569["setReadOnly"](_0x2eba02["readOnly"]), $(_0x2bd569).on("sliderChanged", function (_0x2cd02c) {
              room.myself.surface["setBrushOption"](_0x2eba02.id, _0x2cd02c["value"]);
            }), _0x46d482["controls"][_0x2eba02.id] = _0x2bd569;
          } else {
            if (_0x2eba02["type"] == "slidercheck") {
              _0x190bd7 = "<div class=\"optionBG\"><div class=\"optionTitle\">" + UI["optionToName"](_0x2eba02.id) + "</div> <div id=\"option_" + _0x2eba02.id + "\" class=\"optionField\"></div></div>", _0x46d482["container"]["append"](_0x190bd7);
              var _0x5104a3 = new SliderCheck(_0x46d482["container"]["find"]("#option_" + _0x2eba02.id), null, _0x2eba02.min, _0x2eba02["max"], _0x2eba02["step"], null, _0x2eba02["callbackFunction"], "tooloption");
              _0x5104a3.setValue(_0x2eba02["value"]), _0x5104a3["setReadOnly"](_0x2eba02["readOnly"]), _0x5104a3["setReadOnlySubcomponents"](_0x2eba02["readOnlySubcomponents"]), $(_0x5104a3).on("sliderCheckChanged", function (_0x531f9c) {
                room["myself"]["surface"]["setBrushOption"](_0x2eba02.id, _0x531f9c.value);
              }), _0x46d482.controls[_0x2eba02.id] = _0x5104a3;
            } else {
              if (_0x2eba02["type"] == "list") {
                _0x190bd7 = "<div class=\"optionBG\"><div class=\"optionTitle\">" + UI["optionToName"](_0x2eba02.id) + "</div> <div id=\"option_" + _0x2eba02.id + "\" class=\"optionField\"></div></div>", _0x46d482["container"]["append"](_0x190bd7);
                var _0x30174a = new List(_0x46d482.container["find"]("#option_" + _0x2eba02.id), _0x2eba02["list"], _0x2eba02["value"], _0x2eba02["callbackFunction"], "tooloption");
                $(_0x30174a).on("listChanged", function (_0x9bbc8f) {
                  room.myself["surface"]["setBrushOption"](_0x2eba02.id, _0x9bbc8f.value);
                }), _0x30174a.setReadOnly(_0x2eba02["readOnly"]), _0x46d482["controls"][_0x2eba02.id] = _0x30174a;
              } else {
                if (_0x2eba02.type == "check") {
                  _0x190bd7 = '<div class="optionBG"><div class="optionTitle">' + UI["optionToName"](_0x2eba02.id) + "</div> <div id=\"option_" + _0x2eba02.id + "\" class=\"optionField\"></div></div>", _0x46d482.container["append"](_0x190bd7);
                  var _0x378524 = new Switch(_0x46d482["container"].find("#option_" + _0x2eba02.id), _0x2eba02["callbackFunction"], "tooloption");
                  _0x378524["setValue"](_0x2eba02["value"]), _0x378524.setReadOnly(_0x2eba02.readOnly), $(_0x378524).on("checkboxChange", function (_0x5d456b) {
                    room["myself"]["surface"]["setBrushOption"](_0x2eba02.id, _0x5d456b["checked"]);
                  }), _0x46d482.controls[_0x2eba02.id] = _0x378524;
                } else {
                  if (_0x2eba02["type"] == "button") {
                    _0x190bd7 = '<div class="optionBG"><div class="optionTitle">' + UI["optionToName"](_0x2eba02.id) + "</div>", _0x190bd7 += '<div id="option_' + _0x2eba02.id + '" class="optionField"></div>', _0x190bd7 += "</div>", _0x46d482["container"]["append"](_0x190bd7);
                    var _0x276cf2 = new Button(_0x46d482["container"]["find"]("#option_" + _0x2eba02.id), _0x2eba02.callbackFunction, "...", "tooloption");
                    _0x276cf2["setReadOnly"](_0x2eba02.readOnly), _0x46d482.controls[_0x2eba02.id] = _0x276cf2;
                  }
                }
              }
            }
          }
        } else !_0x2eba02.hidden && room["myself"]["surface"]["setBrushOption"](_0x2eba02.id, _0x2eba02["defaultvalue"]);
      }), textManager["updateElement"](_0x46d482["container"]);
    });
  }
  ["destroyControls"]() {
    $["each"](this["controls"], function (_0x2ac3f9, _0x1d0559) {
      _0x1d0559.destroy && _0x1d0559["destroy"]();
    }), this.controls = {};
  }
}
var smoothingSetting = JSON.parse(localStorage.getItem("enableSmoothing")) || false;
class Uploader extends UIComponent {
  constructor(_0x442b12) {
    super($("<div />")), this["dragging"] = false, this["dragPoint"], this["flipped"] = false, this["position"] = new Point(0, 0), this["width"], this.height, this["rotation"] = 0, this.originalPosition = new Rect(0, 0, 0, 0), this["imageContainer"] = $("<div>"), this["container"]["append"](this.imageContainer), this["images"] = new UploaderImages(this["imageContainer"]), this["resizer"] = new Resizer(this["container"], room["board"].getLayerZIndex(room["myself"].surface["currentLayer"]) + 2), this["resizable"] = true, this["selectionToolbar"], this["flipImage"](false), this["createToolbar"](), this["fileInput"] = _0x442b12, this.uploadType = "load";
    var _0xc0dbe7 = this;
    this["fileInput"].on("change", function (_0xe51e8f) {
      !_0xc0dbe7["readOnly"] && _0xc0dbe7["uploadFile"](_0xe51e8f["target"].files);
    }), this["container"].on(UI.pointerEvent("down", "uploader"), function (_0x3a0551) {
      _0x3a0551["preventDefault"]();
      if (!_0x3a0551.which || _0x3a0551["which"] == 1) {
        if (!_0xc0dbe7["readOnly"]) {
          var _0x2d7f71 = UI["getInputPosition"](_0x3a0551),
            _0x5a2de0 = $(this)["offset"](),
            _0xc6d9d3 = $(this)[0]["getBoundingClientRect"](),
            _0x4af6a2 = _0xc0dbe7.calculateRotation((_0x2d7f71.x - _0x5a2de0.left) / room["board"]["scale"], (_0x2d7f71.y - _0x5a2de0["top"]) / room["board"]["scale"], _0xc6d9d3["width"], _0xc6d9d3["height"], room["board"].rotation);
          _0xc0dbe7["dragPoint"] = new Point(parseInt(_0xc0dbe7["calculateFlipX"](_0x4af6a2.x) * 100) / 100, parseInt(_0x4af6a2.y * 100) / 100), _0xc0dbe7["dragging"] = true, _0xc0dbe7["mouseMove"](_0x2d7f71.x, _0x2d7f71.y);
        }
      }
    }), $(this["resizer"]).on("elementResized", function (_0x2b6d7b) {
      _0xc0dbe7["moveImage"](_0xc0dbe7["position"].x + _0x2b6d7b.x, _0xc0dbe7["position"].y + _0x2b6d7b.y), _0xc0dbe7.resizeImage(_0x2b6d7b["width"], _0x2b6d7b["height"]);
    }), $(this.resizer).on("rotationChanged", function (_0x2390ca) {
      _0xc0dbe7.rotateImage(_0x2390ca["rotation"]);
    }), $(room["myself"]["surface"]).on("slatePriorityChanged", function (_0x4e8b75) {
      _0xc0dbe7["container"]["css"]("z-index", _0x4e8b75["zindex"]);
    }), $(UI).on("viewFlipped", function (_0x5b2598) {
      _0xc0dbe7["position"] && _0xc0dbe7.moveImage(_0xc0dbe7["position"].x, _0xc0dbe7["position"].y);
    }), this.container["css"]("z-index", room["board"]["getLayerZIndex"](room.myself.surface["currentLayer"]) + 1), this.container["addClass"]("movable");
  }
  ["isFileTypeSupported"](_0x4d3639) {
    var _0x102ad2 = getExtension(_0x4d3639);
    return _0x102ad2 == "JPG" || _0x102ad2 == "JPEG" || _0x102ad2 == "PNG";
  }
  ["uploadFile"](_0x55ff23) {
    if (room["can"]("pload")) {
      var _0x20f9d5 = this,
        _0x29ad67 = _0x55ff23[0];
      if (_0x29ad67 && this["isFileTypeSupported"](_0x29ad67.name)) {
        var _0x4a5376 = new FileReader();
        _0x4a5376.onloadend = function (_0x246c6c) {
          _0x20f9d5["clearLayers"]();
          var _0x5317e1 = new Image();
          _0x5317e1["onload"] = function () {
            _0x20f9d5["addLayer"](0, _0x5317e1, room["board"]["canvasWidth"] / 2 - _0x5317e1["width"] / 2, room["board"].canvasHeight / 2 - _0x5317e1["height"] / 2);
            if (_0x20f9d5.width > room["board"].canvasWidth || _0x20f9d5["height"] > room["board"]["canvasHeight"]) {
              var _0x1d6b2f = calculateAspectRatioFit(_0x5317e1["width"], _0x5317e1["height"], room["board"]["canvasWidth"], room["board"]["canvasHeight"]);
              _0x20f9d5["resizeImage"](_0x1d6b2f["width"], _0x1d6b2f["height"]), _0x20f9d5.moveImage(room["board"]["canvasWidth"] / 2 - _0x20f9d5["width"] / 2, room["board"]["canvasHeight"] / 2 - _0x20f9d5["height"] / 2);
            }
            _0x20f9d5.fileInput["val"]("");
          }, _0x5317e1.src = _0x246c6c.target["result"];
        }, _0x29ad67 ? (_0x4a5376["readAsDataURL"](_0x29ad67), this["show"]()) : $(this["image"])["attr"]("src", "");
      } else UI["dialogHandler"]["showAlert"](textManager["getString"]("alerts.txtFileTypeNotSupported"));
    } else UI["dialogHandler"]["showAlert"](textManager["getString"]("alerts.txtUploadNotAllowed"));
  }
  ["clearLayers"]() {
    this["images"]["clear"]();
  }
  ["addLayer"](_0x61346, _0x326eeb, _0x6659d7, _0x9b7163, _0x550eeb = 0) {
    this["images"].add(_0x326eeb, _0x61346), room["board"].canvasContainer["append"](this["container"]), this["originalPosition"].x = _0x6659d7, this["originalPosition"].y = _0x9b7163, this["originalPosition"]["width"] = _0x326eeb.width, this.originalPosition["height"] = _0x326eeb.height, this.rotateImage(0), this["resizeImage"](_0x326eeb["width"], _0x326eeb["height"]), this["moveImage"](_0x6659d7 + _0x550eeb, _0x9b7163 + _0x550eeb);
  }
  ["flipImage"](_0x4f7cc0) {
    this["flipped"] = _0x4f7cc0, _0x4f7cc0 ? $(this["imageContainer"])["css"]("transform", "scaleX(-1)") : $(this["imageContainer"])["css"]("transform", "scaleX(1)");
  }
  ["toggleFlip"]() {
    this["flipImage"](!this["flipped"]);
  }
  ["rotateImage"](_0x105135) {
    this["rotation"] = _0x105135, this.container["css"]({
      "transform-origin": "center",
      transform: "rotate(" + _0x105135 + "deg)"
    }), this.imageChanged();
  }
  ["moveImage"](_0x582031, _0x4bf988) {
    this["position"] = new Point(_0x582031, _0x4bf988);
    if (this["selectionToolbar"]) {
      var _0x245e0d = UI["boardToScreen"]((UI["flipX"] ? _0x582031 + this.width : _0x582031) + UI.viewOffset.x, _0x4bf988 + UI["viewOffset"].y),
        _0x506521 = this["selectionToolbar"]["height"](),
        _0x16f5d3 = this.selectionToolbar["width"](),
        _0x419a14 = 10,
        _0x471caf = room["board"]["scale"];
      this["selectionToolbar"]["position"](_0x245e0d.x - _0x16f5d3 / 2 + this["width"] * _0x471caf / 2, _0x245e0d.y - _0x506521 - _0x419a14);
    }
    this["container"]["css"]({
      position: "absolute",
      left: _0x582031 + "px",
      top: _0x4bf988 + "px"
    }), this["resizer"].move(_0x582031, _0x4bf988), this["imageChanged"]();
  }
  ["resizeImage"](_0x377327, _0x8ca6a9) {
    this["images"]["resize"](_0x377327, _0x8ca6a9), this["container"]["css"]({
      width: _0x377327 + "px",
      height: _0x8ca6a9 + "px"
    }), this.width = _0x377327, this.height = _0x8ca6a9, this.imageChanged();
  }
  ["mouseMove"](_0x32ac2b, _0x4fd583) {
    if (this.dragging && this["dragPoint"]) {
      var _0x5cb73a = UI.screenToBoard(_0x32ac2b, _0x4fd583);
      this["moveImage"](parseInt((_0x5cb73a.x - this["dragPoint"].x) * 100) / 100, parseInt((_0x5cb73a.y - this["dragPoint"].y) * 100) / 100);
    }
  }
  ["mouseUp"](_0x596429, _0x51ab72) {
    this.dragging = false, this["dragPoint"] = null;
  }
  ["cancel"]() {
    this["clear"](), this["hide"]();
  }
  ["clear"]() {
    this["images"].clear(), this.container.hide();
  }
  ["imageChanged"]() {
    $(this)["triggerHandler"](new imageChangedEvent(this["position"].x, this["position"].y, this.width, this["height"], this["rotation"])["getEvent"]());
  }
  ["calculateFlipX"](_0x2b560a) {
    return UI["flipX"] ? this["width"] - _0x2b560a : _0x2b560a;
  }
  ["calculateRotation"](_0x19eaa3, _0x44fda4, _0x53a1e7, _0x3c4d35, _0xba41c8) {
    var _0x16f19b = _0x53a1e7 / 2 / room.board["scale"],
      _0x3d22a7 = _0x3c4d35 / 2 / room.board.scale,
      _0x5c158a = -_0xba41c8 * Math.PI / 180,
      _0x5f23f2 = (_0x19eaa3 - _0x16f19b) * Math["cos"](_0x5c158a) - (_0x44fda4 - _0x3d22a7) * Math["sin"](_0x5c158a) + this["width"] / 2,
      _0x2574ac = (_0x44fda4 - _0x3d22a7) * Math["cos"](_0x5c158a) + (_0x19eaa3 - _0x16f19b) * Math["sin"](_0x5c158a) + this["height"] / 2;
    return new Point(_0x5f23f2, _0x2574ac);
  }
  ["createToolbar"]() {
    this["selectionToolbar"] = new FloatingToolbar($("#dialogContainer")), this["selectionToolbar"].clearButtons(), this["selectionToolbar"]["addButton"]("flip", textManager["getString"]("toolbar.btnFlip"), "fa-exchange-alt", "btn-primary"), this["selectionToolbar"]["addSeparator"](), this["selectionToolbar"]["addButton"]("confirm", textManager["getString"]("toolbar.btnConfirm"), "fa-check"), this["selectionToolbar"]["addButton"]("delete", textManager["getString"]("toolbar.btnDelete"), "fa-trash", "btn-danger"), this["selectionToolbar"]["addButton"]("cancel", textManager["getString"]("toolbar.btnCancel"), "fa-times", "btn-secondary");
    var _0x5306ea = this;
    $(this.selectionToolbar).on("optionSelected", function (_0x55e99a) {
      if (_0x55e99a["option"] == "flip") _0x5306ea["toggleFlip"](); else {
        if (_0x55e99a["option"] == "confirm") _0x5306ea["position"] && (!UI.layerIsLocked(room["myself"].surface["currentLayer"]) || room["can"]("drawlockedlayers") ? _0x5306ea["draw"]() : UI.dialogHandler["showAlert"](textManager["getString"]("alerts.txtLayerIsLocked"))); else {
          if (_0x55e99a["option"] == "delete") _0x5306ea.clear(), _0x5306ea["hide"](); else _0x55e99a["option"] == "cancel" && (
            _0x5306ea["flipped"] && _0x5306ea["flipImage"](false), 
            _0x5306ea["selectionToolbar"].hide(), 
            _0x5306ea.rotateImage(0),
            localStorage.getItem('fixResizingShift') === "true" ? (
              // If fixResizingShift is on, just draw at the current position
              _0x5306ea["moveImage"](_0x5306ea.originalPosition.x + 4.0, _0x5306ea["originalPosition"].y + 4.0), 
              _0x5306ea.resizeImage(_0x5306ea.originalPosition["width"], _0x5306ea.originalPosition["height"]), 
              _0x5306ea["position"] && (!UI.layerIsLocked(room["myself"].surface["currentLayer"]) || room["can"]("drawlockedlayers") ? 
                _0x5306ea["draw"]() : 
                UI.dialogHandler["showAlert"](textManager["getString"]("alerts.txtLayerIsLocked")))
            ) : (
              // Apply -4.5px shift instead of resetting to original position
              _0x5306ea["moveImage"](_0x5306ea.originalPosition.x - 0, _0x5306ea["originalPosition"].y - 0), 
              _0x5306ea.resizeImage(_0x5306ea.originalPosition["width"], _0x5306ea.originalPosition["height"]), 
              _0x5306ea["draw"]()
            )
          );
        }
      }
    });
  }
  ["show"](_0x538c02 = "load", _0x4e1f14 = false) {
    this.uploadType = _0x538c02, UI["setUploadMode"](true), UI.mousePointer["cursor"]("auto"), this["container"]["show"](), _0x4e1f14 ? this["selectionToolbar"]["showButton"]("cancel") : this["selectionToolbar"]["hideButton"]("cancel"), this.selectionToolbar.show(), this.flipImage(false), this.resizer["show"](), $(this)["triggerHandler"](new uploaderOpenedEvent().getEvent()), this["imageChanged"]();
  }
  ["hide"]() {
    UI.setUploadMode(false), this["container"]["hide"](), this["selectionToolbar"]["hide"](), this["resizer"]["hide"](), $(this)["triggerHandler"](new uploaderClosedEvent()["getEvent"]());
  }
  ["isVisible"]() {
    return this.container.is(":visible");
  }
  ["isOutOfBounds"]() {
    return this["position"].x > room.board["canvasWidth"] || this["position"].y > room["board"]["canvasHeight"];
  }
  ["resetPosition"]() {
    this["moveImage"](room["board"]["canvasWidth"] / 2 - this.width / 2, room["board"]["canvasHeight"] / 2 - this.height / 2);
  }
  ["keyPress"](_0x2de397) {
    _0x2de397 == 37 && (UI["holdingSHIFT"] ? this["rotateImage"](this.rotation - 1) : this["moveImage"](this["position"].x - 1, this["position"].y));
    if (_0x2de397 == 38) this["moveImage"](this["position"].x, this["position"].y - 1); else {
      if (_0x2de397 == 39) UI["holdingSHIFT"] ? this["rotateImage"](this["rotation"] + 1) : this["moveImage"](this["position"].x + 1, this["position"].y); else _0x2de397 == 40 && this.moveImage(this["position"].x, this["position"].y + 1);
    }
  }
  ["modifierUp"](_0x363776) {
    this["resizer"].modifierUp(_0x363776);
  }
  ["modifierDown"](_0x3ea740) {
    this["resizer"]["modifierDown"](_0x3ea740);
  }
  // ["draw"]() {
  //   var _0x15334b = new Transfer("BROADCAST", null, this["uploadType"], new Date().getTime(), true);
  //   $(_0x15334b).on("transferStart transferChunkReady", sendChunk);
  //   var _0x26c2df = this;
  //   $.each(this.images["imgs"], function (_0x406d59, _0x131a20) {
  //     var _0x198af4 = _0x26c2df["width"] / _0x26c2df["originalPosition"].width,
  //       _0x1976d7 = _0x26c2df.height / _0x26c2df["originalPosition"]["height"],
  //       _0x244ff0 = _0x198af4 <= 0.5 || _0x1976d7 <= 0.5,
  //       _0x4a53e9 = new AdvancedCanvas(_0x26c2df.width, _0x26c2df.height),
  //       _0x3b5ffa = _0x4a53e9["getContext"]();
  //     _0x26c2df["flipped"] && (_0x3b5ffa.translate(_0x26c2df["width"], 0), _0x3b5ffa.scale(-1, 1)), _0x4a53e9["smoothing"] = smoothingSetting, _0x4a53e9.drawImage(_0x131a20[0], 0, 0, _0x26c2df["width"], _0x26c2df["height"]), _0x15334b["addData"](_0x26c2df["images"]["imgs"].length > 1 ? parseInt(_0x131a20["attr"]("name")) : room["myself"]["surface"]["currentLayer"], _0x26c2df["position"].x, _0x26c2df.position.y, _0x26c2df["width"], _0x26c2df["height"], _0x26c2df["rotation"], btoa(_0x4a53e9["getData"]())), _0x4a53e9["remove"]();
  //   }), _0x15334b["send"](), room["addTransfer"](_0x15334b), this["clear"](), this["hide"]();
  // }
// Updated draw method for Uploader class
// Updated draw method for Uploader class
// Updated draw method for Uploader class
// Updated draw method for Uploader class with proper undo support
// Updated draw method with strokes object integration
// Updated draw method for Uploader class with proper selection handling
["draw"]() {
  // IMPORTANT BUGFIX: Check undo history correctly
  const undoHistoryEnabled = UI?.undoHistoryEnabled
  const inReplayMode = Boolean(this._replaySource);
  
  // COMPLETELY REDESIGNED DETECTION: More reliable check for selection operations
  const isSelectionUpload = this.uploadType === 'selection';
  const hasPendingSelectionStrokes = room.myself?.surface?._pendingSelectionStrokes?.length > 0;
  
  // Skip stroke creation if this is a selection upload (we already have a selection stroke)
  const skipStrokeCreation = isSelectionUpload;
  
  
  // Determine if the image has been resized from its original dimensions
  const hasBeenResized = Math.abs(this.width - this.originalPosition.width) > 0.1 || 
                        Math.abs(this.height - this.originalPosition.height) > 0.1;
  
  // IMPORTANT: Always initialize transfer history if it doesn't exist
  if (!room.board.transferHistory) {
    room.board.transferHistory = [];
    room.board.maxTransferHistory = 15 + room.board.maxUndoSteps;
  }
  
  // Create transfer record regardless of undo history setting
  const imageRecord = {
    timestamp: Date.now(),
    type: this.uploadType,
    position: { x: this.position.x, y: this.position.y },
    dimensions: { width: this.width, height: this.height },
    rotation: this.rotation,
    flipped: this.flipped,
    layer: room.myself.surface.currentLayer,
    imageCount: this.images.imgs.length,
    imageData: [],
    sender: room.myself?.username || "Anonymous",
    roomInfo: {
      boardDimensions: {
        width: room.board.canvasWidth,
        height: room.board.canvasHeight
      },
      currentLayer: room.myself?.surface?.currentLayer,
      username: room.myself?.username
    }
  };
  
  // Determine smoothing based on resize status and rotation
  const useSmoothing = this.rotation !== 0 ? true : 
                      (hasBeenResized ? 
                       (undoHistoryEnabled ? true : smoothingSetting) : 
                       false);
  
  // Process images for transfer record
  const isDuplicate = room.board.transferHistory.some(record => {
    return (Date.now() - record.timestamp < 200) && 
           record.dimensions?.width === this.width && 
           record.dimensions?.height === this.height &&
           record.position?.x === this.position.x &&
           record.position?.y === this.position.y;
  });
  
  if (!isDuplicate && !room.board.isProcessingCommit) {
    $.each(this.images.imgs, (index, img) => {
      const layerIndex = this.images.imgs.length > 1 ? 
        parseInt(img.attr("name")) || room.myself.surface.currentLayer : 
        room.myself.surface.currentLayer;
        
      const tempCanvas = new AdvancedCanvas(this.width, this.height);
      tempCanvas.smoothing = useSmoothing;
      
      if (this.flipped) {
        const ctx = tempCanvas.getContext();
        ctx.translate(this.width, 0);
        ctx.scale(-1, 1);
      }
      
      tempCanvas.drawImage(img[0], 0, 0, this.width, this.height);
      imageRecord.imageData.push({
        layerIndex: layerIndex,
        base64: tempCanvas.getData(),
        wasFlipped: this.flipped
      });
      
      tempCanvas.remove();
    });
    
    // Add to transfer history regardless of which path we take
    imageRecord.strokeId = room.board.currentStrokeId;
    
    // Create mapping between surface stroke count and transfer record
    if (!room.board.strokeToTransferMap) {
      room.board.strokeToTransferMap = new Map();
      room.board.transferToStrokeMap = new Map();
    }
    
    // Record bidirectional mapping between stroke ID and transfer index
    const currentStrokeCount = room.myself?.surface?.strokeCount || 0;
    const transferIndex = room.board.transferHistory.length;
    
    // Map stroke ID to transfer index
    room.board.strokeToTransferMap.set(currentStrokeCount, transferIndex);
    
    // Map transfer index to stroke ID (for reverse lookup)
    room.board.transferToStrokeMap.set(transferIndex, currentStrokeCount);
    
    // Store these IDs in the record itself for direct access
    imageRecord.surfaceStrokeId = currentStrokeCount;
    imageRecord.transferIndex = transferIndex;
    
    room.board.transferHistory.push(imageRecord);
    console.log("pushed", room.board.transferHistory, "stroke:", currentStrokeCount, "transfer:", transferIndex);
  }
  
  // Use network broadcasting ONLY when either in replay mode OR undo history is disabled
  if (inReplayMode || !undoHistoryEnabled) {    
    var _0x15334b = new Transfer("BROADCAST", null, this["uploadType"], new Date().getTime(), true);
    $(_0x15334b).on("transferStart transferChunkReady", sendChunk);
    var _0x26c2df = this;
    
    $.each(this.images["imgs"], function (_0x406d59, _0x131a20) {
      var _0x198af4 = _0x26c2df["width"] / _0x26c2df["originalPosition"].width,
        _0x1976d7 = _0x26c2df.height / _0x26c2df["originalPosition"]["height"],
        _0x244ff0 = _0x198af4 <= 0.5 || _0x1976d7 <= 0.5;
        
      // Determine smoothing based on resize status, rotation, and undo history
      const useSmoothing = _0x26c2df.rotation !== 0 ? true : 
                          (hasBeenResized ? 
                            (undoHistoryEnabled ? true : smoothingSetting) : 
                            false);
      
      var _0x4a53e9 = new AdvancedCanvas(_0x26c2df.width, _0x26c2df.height),
        _0x3b5ffa = _0x4a53e9["getContext"]();
      
      _0x26c2df["flipped"] && (_0x3b5ffa.translate(_0x26c2df["width"], 0), _0x3b5ffa.scale(-1, 1));
      _0x4a53e9["smoothing"] = useSmoothing;
      _0x4a53e9.drawImage(_0x131a20[0], 0, 0, _0x26c2df["width"], _0x26c2df["height"]);
      _0x15334b["addData"](
        _0x26c2df["images"]["imgs"].length > 1 ? parseInt(_0x131a20["attr"]("name")) : room["myself"]["surface"]["currentLayer"],
        _0x26c2df["position"].x,
        _0x26c2df.position.y,
        _0x26c2df["width"],
        _0x26c2df["height"],
        _0x26c2df["rotation"],
        btoa(_0x4a53e9["getData"]())
      );
      _0x4a53e9["remove"]();
    });
    
    _0x15334b["send"]();
    room["addTransfer"](_0x15334b);
    this["clear"]();
    this["hide"]();
  } else {
    try {
      // Record in transfer history for replay functionality (always do this part regardless of selection)
      if (!room.board._replayInProgress) {
        if (!room.board.transferHistory) {
          room.board.transferHistory = [];
        }
        
        const isDuplicate = room.board.transferHistory.some(record => {
          return (Date.now() - record.timestamp < 200) && 
                 record.dimensions?.width === this.width && 
                 record.dimensions?.height === this.height &&
                 record.position?.x === this.position.x &&
                 record.position?.y === this.position.y;
        });
        
        if (!isDuplicate) {
          const imageRecord = {
            timestamp: Date.now(),
            type: this.uploadType,
            position: { x: this.position.x, y: this.position.y },
            dimensions: { width: this.width, height: this.height },
            rotation: this.rotation,
            flipped: this.flipped,
            layer: room.myself.surface.currentLayer,
            imageCount: this.images.imgs.length,
            imageData: [],
            sender: room.myself?.username || "Anonymous",
            roomInfo: {
              boardDimensions: {
                width: room.board.canvasWidth,
                height: room.board.canvasHeight
              },
              currentLayer: room.myself?.surface?.currentLayer,
              username: room.myself?.username
            }
          };
          
          // Determine smoothing based on resize status and rotation
          const useSmoothing = this.rotation !== 0 ? true : 
                              (hasBeenResized ? 
                                (undoHistoryEnabled ? true : smoothingSetting) : 
                                false);
          
          $.each(this.images.imgs, (index, img) => {
            // This is the critical line for layer determination
            const layerIndex = this.images.imgs.length > 1 ? 
              parseInt(img.attr("name")) || room.myself.surface.currentLayer : 
              room.myself.surface.currentLayer;
              
            // Use AdvancedCanvas for proper smoothing
            const tempCanvas = new AdvancedCanvas(this.width, this.height);
            tempCanvas.smoothing = useSmoothing;
            
            if (this.flipped) {
              const ctx = tempCanvas.getContext();
              ctx.translate(this.width, 0);
              ctx.scale(-1, 1);
            }
            
            tempCanvas.drawImage(img[0], 0, 0, this.width, this.height);
            imageRecord.imageData.push({
              layerIndex: layerIndex,
              base64: tempCanvas.getData(),
              wasFlipped: this.flipped
            });
            
            tempCanvas.remove();
          });
          
          // Add to transfer history
      // Change from unshift to push to add to end of array
      imageRecord.strokeId = room.board.currentStrokeId;
      room.board.transferHistory.push(imageRecord);
    }
  }
      
      // CRITICAL FIX: Completely skip undo history for selection operations
      // This prevents duplicate entries in the undo stack
      if (isSelectionUpload) {

        // Just draw the image to the canvas without creating any undo entries
        $.each(this.images.imgs, (index, img) => {
          const layerIndex = this.images.imgs.length > 1 ? 
            parseInt(img.attr("name")) || room.myself.surface.currentLayer : 
            room.myself.surface.currentLayer;
            
          const ctx = room.board.getContext(layerIndex);
          
          // Determine smoothing based on resize status, rotation, and undo history
          const useSmoothing = this.rotation !== 0 ? true : 
                             (hasBeenResized ? 
                               (undoHistoryEnabled ? true : smoothingSetting) : 
                               false);
          
          // IMPORTANT: Save current context to restore later
          ctx.save();
          
          // Reset ALL canvas properties to ensure clean rendering
          this._resetContextProperties(ctx);
          
          // Now apply our specific desired settings
          ctx.imageSmoothingEnabled = useSmoothing;
          ctx.imageSmoothingQuality = useSmoothing ? "high" : "low";
          ctx.globalAlpha = 1.0; // Force full opacity for transformation
          ctx.filter = "none"; // Clear any filters (like blur)
          
          ctx.translate(this.position.x + this.width/2, this.position.y + this.height/2);
          if (this.rotation) {
            ctx.rotate(this.rotation * Math.PI / 180);
          }
          if (this.flipped) {
            ctx.scale(-1, 1);
          }
          
          const tempCanvas = new AdvancedCanvas(this.width, this.height);
          tempCanvas.smoothing = useSmoothing;
          tempCanvas.drawImage(img[0], 0, 0, this.width, this.height);
          
          ctx.drawImage(tempCanvas.canvas[0], -this.width/2, -this.height/2, this.width, this.height);
          tempCanvas.remove();
          
          // Restore the context state to what it was before
          ctx.restore();
          
          room.board.layerChanged(layerIndex, true);
        });
      } else {
        // For normal image uploads (not selection operations), proceed with standard undo tracking
        // For the undo system
        const undoActions = [];
        let _0x26c2df = this;
        
        // Create the image upload stroke data normally for non-selection operations
        if (room.myself && room.myself.surface && !skipStrokeCreation) {
          // Get next stroke number using the same logic as PenSurface
          let newStrokeNumber;
          const surface = room.myself.surface;
          
          if (!surface.strokes) {
            surface.strokes = [];
          }
          
          if (surface.strokes.length === 0) {
            newStrokeNumber = 1;
            surface.strokeCount = 1;
          } else {
            const existingNumbers = new Set(surface.strokes.map(stroke => stroke.strokeNumber));
            newStrokeNumber = Math.max(surface.strokeCount || 0, surface.strokes.length) + 1;
            while (existingNumbers.has(newStrokeNumber)) {
              newStrokeNumber++;
            }
            surface.strokeCount = Math.max(surface.strokeCount || 0, newStrokeNumber);
          }
          
          // Create the image upload stroke data
          const imageStrokeData = {
            strokeNumber: newStrokeNumber,
            color: "#000000", // Default color for uploads
            brushName: "imageUpload", // Special brush name for uploads
            layer: room.myself.surface.currentLayer,
            isImageStroke: true, // Flag to identify as an image stroke
            start: {
              x: this.position.x,
              y: this.position.y,
              time: Date.now(),
              brushOptions: {
                width: this.width,
                height: this.height,
                rotation: this.rotation,
                flipped: this.flipped
              }
            },
            moves: [], // No moves for image uploads
            end: {
              x: this.position.x + this.width,
              y: this.position.y + this.height,
              time: Date.now(),
              brushOptions: {
                width: this.width,
                height: this.height,
                rotation: this.rotation,
                flipped: this.flipped
              }
            },
            // Extra properties specific to image uploads
            imageUploadData: {
              position: { x: this.position.x, y: this.position.y },
              dimensions: { width: this.width, height: this.height },
              rotation: this.rotation,
              flipped: this.flipped,
              uploadType: this.uploadType
            }
          };
          
          // Add the stroke to the surface strokes array
          surface.strokes.push(imageStrokeData);
          
          // Register the stroke mapping for Board <-> Surface
          if (room.board.registerStrokeMapping) {
            room.board.registerStrokeMapping(room.board.currentStrokeId, newStrokeNumber);
          }
        }
        
        // Process the actual image rendering and undo actions for non-selection operations
        $.each(this.images.imgs, (index, img) => {
          // Make layer determination consistent with network code
          const layerIndex = this.images.imgs.length > 1 ? 
            parseInt(img.attr("name")) || room.myself.surface.currentLayer : 
            room.myself.surface.currentLayer;
            
          const ctx = room.board.getContext(layerIndex);
          
          // Store the original image data for undo WITH PADDING
          const padding = 4.5; // Adding padding of 4.5px to each side
          const undoX = _0x26c2df.position.x - padding;
          const undoY = _0x26c2df.position.y - padding;
          const undoWidth = _0x26c2df.width + (padding * 2);
          const undoHeight = _0x26c2df.height + (padding * 2);
          
          // Store before-image data with padding for undo
          const oldImageData = ctx.getImageData(undoX, undoY, undoWidth, undoHeight);
          
          // Use original dimensions for drawing (no padding)
          const x = _0x26c2df.position.x;
          const y = _0x26c2df.position.y;
          const width = _0x26c2df.width;
          const height = _0x26c2df.height;
          
          // Determine smoothing based on resize status, rotation, and undo history
          const useSmoothing = _0x26c2df.rotation !== 0 ? true : 
                            (hasBeenResized ? 
                              (undoHistoryEnabled ? true : smoothingSetting) : 
                              false);
          
          // Create temp canvas with ORIGINAL dimensions (not padded)
          const tempCanvas = new AdvancedCanvas(width, height);
          tempCanvas.smoothing = useSmoothing;
          tempCanvas.drawImage(img[0], 0, 0, width, height);
          
          // IMPORTANT: Save current context to restore later
          ctx.save();
          
          // CRITICAL FIX: Reset ALL canvas properties to ensure clean rendering
          this._resetContextProperties(ctx);
          
          // Now apply our specific desired settings
          ctx.imageSmoothingEnabled = useSmoothing;
          ctx.imageSmoothingQuality = useSmoothing ? "high" : "low";
          ctx.globalAlpha = 1.0; // Force full opacity for transformation
          ctx.filter = "none"; // Clear any filters (like blur)
          
          // Use original position for drawing
          ctx.translate(x + width/2, y + height/2);
          if (_0x26c2df.rotation) {
            ctx.rotate(_0x26c2df.rotation * Math.PI / 180);
          }
          if (_0x26c2df.flipped) {
            ctx.scale(-1, 1);
          }
          
          // Draw with original dimensions
          ctx.drawImage(tempCanvas.canvas[0], -width/2, -height/2, width, height);
          
          // Restore the context state to what it was before
          ctx.restore();
          tempCanvas.remove();
          
          // Get after-image data with padding for undo (same expanded area)
          const newImageData = ctx.getImageData(undoX, undoY, undoWidth, undoHeight);
          
          undoActions.push({
            layer: layerIndex,
            bbox: [undoX, undoY, undoWidth, undoHeight], // Use expanded bbox for undo/redo
            oldData: oldImageData,
            newData: newImageData,
            actionType: 'image'
          });
          
          room.board.layerChanged(layerIndex, true);
        });
        
        if (undoActions.length > 0) {
          // Create a proper group action for the undo stack
          const groupAction = {
            type: 'group',                    // CRITICAL: This was missing and is needed for proper undo
            actions: undoActions,
            actionType: 'image', // Only for image uploads now
            uploadType: this.uploadType,      // Store the upload type
            position: {                       // Store position info for debugging
              x: this.position.x,
              y: this.position.y
            },
            dimensions: {                     // Store size info for debugging  
              width: this.width,
              height: this.height
            },
            rotation: this.rotation,          // Store rotation
            flipped: this.flipped,            // Store flip state
            isImageUpload: true // Mark as image upload
          };
          
          // Push to the undo stack as a group
          room.board.pushGroupUndo(groupAction);
        }
      }
    } catch (err) {
    }
    
    this["clear"]();
    this["hide"]();
  }
}

// Helper method to reset canvas context properties
["_resetContextProperties"](ctx) {
  // Reset transformation matrix
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  
  // Reset composition
  ctx.globalCompositeOperation = "source-over";
  
  // Reset alpha
  ctx.globalAlpha = 1.0;
  
  // Reset shadow properties
  ctx.shadowBlur = 0;
  ctx.shadowColor = "rgba(0,0,0,0)";
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
  
  // Reset line properties
  ctx.lineWidth = 1;
  ctx.lineCap = "butt";
  ctx.lineJoin = "miter";
  ctx.miterLimit = 10;
  
  // Reset text properties
  ctx.font = "10px sans-serif";
  ctx.textAlign = "start";
  ctx.textBaseline = "alphabetic";
  ctx.direction = "inherit";
  
  // Reset filter
  if (typeof ctx.filter !== 'undefined') {
    ctx.filter = "none";
  }
  
  // Reset image smoothing
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "low";
  
  // Reset fill and stroke styles
  ctx.fillStyle = "#000000";
  ctx.strokeStyle = "#000000";
  
  // Reset path
  ctx.beginPath();
}
}
class UploaderImages {
  constructor(_0xf047ab) {
    this["container"] = _0xf047ab, this["imgs"] = new Array();
  }
  ["add"](_0x10c688, _0x5f07ae) {
    var _0x1efc34 = $("<img />");
    _0x1efc34.attr("name", _0x5f07ae), $(_0x1efc34)["attr"]("src", _0x10c688.src), $(_0x1efc34).css({
      width: "100%",
      height: "100%",
      "z-index": _0x5f07ae
    }), this["imgs"]["push"](_0x1efc34), this["container"].append(_0x1efc34);
  }
  ["move"](_0x22db98, _0x43f085) {
    this["container"]["css"]({
      position: "absolute",
      left: _0x22db98 + "px",
      top: _0x43f085 + "px"
    });
  }
  ["resize"](_0x525d1d, _0x456052) {
    this.container.css({
      width: _0x525d1d + "px",
      height: _0x456052 + "px",
      position: "absolute"
    });
  }
  ["clear"]() {
    this["imgs"] = new Array(), this.container.empty();
  }
}
class FloatingToolbar extends UIComponent {
  constructor(_0x26e6cf) {
    super(_0x26e6cf), this.toolbar = $("<div />"), this["toolbar"]["addClass"]("floatingToolbar");
    var _0x539dd5 = this;
    this["toolbar"].on(UI.pointerEvent("click", "toolbar"), "a.toolbarButton", function (_0x52de05) {
      _0x52de05["preventDefault"]();
      if (!_0x539dd5["readOnly"]) {
        var _0x7b1e1d = $(this).attr("name");
        $(_0x539dd5).triggerHandler(new optionSelectedEvent(_0x7b1e1d)["getEvent"]());
      }
    }), this.hide(), this.container["append"](this["toolbar"]);
  }
  ["clearButtons"]() {
    this.toolbar["empty"]();
  }
  ["addSeparator"]() {
    this["toolbar"]["append"]("<a href=\"#\" class=\"toolbarSeparator\">&nbsp;</a>");
  }
  ["addButton"](_0x5e85af, _0x29a075, _0x124c35 = "", _0x236b43 = "btn-success") {
    var _0xe046f5 = new Icon(_0x124c35);
    this["toolbar"].append('<a href="#" draggable="false" name="' + _0x5e85af + "\" class=\"toolbarButton btn btn-xs " + _0x236b43 + '">' + _0xe046f5["html"]() + " " + _0x29a075 + "</a>");
  }
  ["showButton"](_0x8dec0f) {
    this["toolbar"]["find"]("a[name=\"" + _0x8dec0f + '"]')["show"]();
  }
  ["hideButton"](_0x1b4669) {
    this["toolbar"]["find"]("a[name=\"" + _0x1b4669 + '"]').hide();
  }
  ["width"]() {
    return this["toolbar"].outerWidth();
  }
  ["height"]() {
    return this.toolbar["outerHeight"]();
  }
  ["position"](_0x3cde6b, _0x38ce8a) {
    this["toolbar"].css("left", Math["max"](_0x3cde6b, 0) + "px"), this.toolbar["css"]("top", Math["max"](_0x38ce8a, 0) + "px");
  }
  ["show"](_0x3a2bdd, _0x187731) {
    UI["mousePointer"]["cursor"]("auto"), this["position"](_0x3a2bdd, _0x187731), this["toolbar"].fadeIn(200), $(this)["triggerHandler"](new floatingToolbarOpenedEvent()["getEvent"]());
  }
  ["hide"]() {
    this["toolbar"]["hide"](), $(this)["triggerHandler"](new floatingToolbarClosedEvent().getEvent());
  }
  ["visible"]() {
    return this["toolbar"].is(":visible");
  }
}
class Tooltip extends UIComponent {
  constructor(_0x217e84) {
    super(_0x217e84), this["seconds"] = 1.5, this["selectedElement"] = undefined, this.mousePosition, this["tooltip"], this.createTooltip();
    var _0x2c95f7 = this;
    $(document).on(UI.pointerEvent("over"), "[data-tooltip],[data-tooltipcallback]", function (_0x28c111) {
      if (!UI["userPreferences"].getGroupOption("graphics", "disabletooltips", false)) {
        var _0x37bb65 = UI.getInputPosition(_0x28c111);
        _0x2c95f7["mousePosition"] = new Point(_0x37bb65.x, _0x37bb65.y);
        if (_0x2c95f7["select"]($(this))) {
          if (_0x2c95f7["selectedElement"] !== undefined) {
            _0x2c95f7["checkSelectedItem"]();
            var _0x3339d2 = $(this);
            _0x3339d2.on(UI["pointerEvent"]("out", "tooltipEvent"), function (_0x182c6f) {
              _0x3339d2["off"](".tooltipEvent"), _0x2c95f7.hideTooltip();
            });
          }
        }
      }
    });
  }
  ["select"](_0x47bec4) {
    if (!_0x47bec4.is(this.selectedElement)) return this["selectedElement"] = _0x47bec4, true;
    return false;
  }
  ["checkSelectedItem"]() {
    var _0x5bb2b7 = this;
    setTimeout(function () {
      if (_0x5bb2b7["selectedElement"] !== undefined) {
        if (_0x5bb2b7["selectedElement"].is(":hover")) {
          if (!_0x5bb2b7["isVisibleTooltip"]()) {
            if ($(_0x5bb2b7["selectedElement"])["data"]("tooltip") != null) _0x5bb2b7["showTooltip"]($(_0x5bb2b7.selectedElement)["data"]("tooltip")); else {
              if ($(_0x5bb2b7["selectedElement"]).data("tooltipcallback") != null) {
                var _0x1bcb29 = $(_0x5bb2b7["selectedElement"])["data"]("tooltipcallback"),
                  _0x277011;
                $(_0x5bb2b7.selectedElement).data("tooltipparam") != null && (_0x277011 = $(_0x5bb2b7["selectedElement"])["data"]("tooltipparam"), _0x277011 != "" && _0x277011["split"] && (_0x277011 = _0x277011["split"](";"))), _0x5bb2b7.showTooltip(window[_0x1bcb29](_0x277011));
              }
            }
          }
          _0x5bb2b7["checkSelectedItem"]();
        } else _0x5bb2b7.hideTooltip();
      }
    }, _0x5bb2b7["seconds"] * 1e3);
  }
  ["createTooltip"]() {
    this["tooltip"] = $("<div />"), this["tooltip"]["addClass"]("customTooltip"), this["tooltip"]["hide"](), this.container["append"](this.tooltip);
  }
  ["showTooltip"](_0x3f3d46) {
    var _0x165187 = 20;
    this["tooltip"].html(_0x3f3d46), this["tooltip"]["css"]({
      left: this.mousePosition.x + "px",
      top: this.mousePosition.y + _0x165187 + "px"
    });
    !this["isVisibleTooltip"]() && this.tooltip["show"]();
    var _0x5ed1df = this["tooltip"]["offset"]();
    _0x5ed1df.left + this["tooltip"].width() > $(window).width() && this["tooltip"]["css"]("left", this["mousePosition"].x - this["tooltip"]["width"]() + "px"), _0x5ed1df.top + this["tooltip"]["height"]() > $(window)["height"]() && this.tooltip["css"]("top", this["mousePosition"].y - this.tooltip["height"]() - _0x165187 + "px");
  }
  ["hideTooltip"]() {
    this["selectedElement"] = undefined, this["isVisibleTooltip"]() && this.tooltip["fadeOut"]();
  }
  ["isVisibleTooltip"]() {
    return this["tooltip"].is(":visible");
  }
}
class Resizer extends UIComponent {
  constructor(_0x59f17a, _0x15d747) {
    super(_0x59f17a), this["zIndex"] = _0x15d747, this["resizeContainer"], this["position"], this["keepAspectRatio"] = false, this.resizing = false, this.rotating = false, this["movingFrom"], this["rotation"] = 0, this["minWidth"] = 35, this["minHeight"] = 35, this["create"](), this["hide"](), this["bindEvents"]();
    var _0x5f302d = this;
    $(this).on("propertyChanged", function (_0x40983e) {
      _0x40983e.property == "keepAspectRatio" && (_0x40983e["value"] ? _0x5f302d["container"]["addClass"]("keepingAspectRatio") : _0x5f302d.container["removeClass"]("keepingAspectRatio"));
    }), this["setKeepAspectRatio"](true);
  }
  ["create"]() {
    this.resizeContainer = $("<div />");
    
    // Check if preAntsResizing is enabled
    if (localStorage.getItem("preAntsResizing") === "true") {
        // No marching ants
        this.resizeContainer.addClass("resizerContainer ");
    } else {
        // Original with marching ants
        this.resizeContainer.addClass("resizerContainer marching-ants");
    }
    
    this.resizeContainer.css({
      "z-index": this.zIndex
    }), this.container.append(this.resizeContainer);
    var _0x2dde8a = this["createController"]("NW");
    _0x2dde8a.css({
      cursor: "nw-resize",
      top: "0%",
      left: "0%"
    }), this["resizeContainer"]["append"](_0x2dde8a);
    var _0x597383 = this["createController"]("N");
    _0x597383["css"]({
      cursor: "n-resize",
      top: "0%",
      left: "50%"
    }), this["resizeContainer"]["append"](_0x597383);
    var _0x3b02de = this["createController"]("NE");
    _0x3b02de["css"]({
      cursor: "ne-resize",
      top: "0%",
      left: "100%"
    }), this["resizeContainer"]["append"](_0x3b02de);
    var _0x280ee7 = this.createController("W");
    _0x280ee7["css"]({
      cursor: "w-resize",
      top: "50%",
      left: "0%"
    }), this.resizeContainer["append"](_0x280ee7);
    var _0x42b2c4 = this["createController"]("E");
    _0x42b2c4["css"]({
      cursor: "e-resize",
      top: "50%",
      left: "100%"
    }), this["resizeContainer"]["append"](_0x42b2c4);
    var _0x573619 = this.createController("SW");
    _0x573619["css"]({
      cursor: "sw-resize",
      top: "100%",
      left: "0%"
    }), this["resizeContainer"]["append"](_0x573619);
    var _0x6d2fb9 = this["createController"]("S");
    _0x6d2fb9["css"]({
      cursor: "s-resize",
      top: "100%",
      left: "50%"
    }), this["resizeContainer"]["append"](_0x6d2fb9);
    var _0x38abd9 = this["createController"]("SE");
    _0x38abd9["css"]({
      cursor: "se-resize",
      top: "100%",
      left: "100%"
    }), this.resizeContainer["append"](_0x38abd9);
    var _0x2a3b5e = this.createController("ROT", "rotation");
    _0x2a3b5e["css"]({
      top: "calc(100% + 20px)",
      left: "50%"
    }), this.resizeContainer["append"](_0x2a3b5e);
    var _0x34944d = this["createController"]("INVROT", "rotation");
    _0x34944d["css"]({
      top: "calc(0% - 20px)",
      left: "50%"
    }), this["resizeContainer"]["append"](_0x34944d);
  }
  ["bindEvents"]() {
    var _0x214e8a = this;
    this.container["find"](".sizeController").on(UI["pointerEvent"]("down"), function (_0xc93b2d) {
      _0xc93b2d.preventDefault(), _0xc93b2d["stopPropagation"](), !_0x214e8a["readOnly"] && (_0x214e8a["resizing"] = true, _0x214e8a.movingFrom = $(_0xc93b2d["target"])["attr"]("name"));
    }), this["container"]["find"](".rotationController").on(UI.pointerEvent("down"), function (_0x1941bc) {
      _0x1941bc["preventDefault"](), _0x1941bc.stopPropagation(), !_0x214e8a.readOnly && (_0x214e8a["rotating"] = true, _0x214e8a["movingFrom"] = $(_0x1941bc["target"]).attr("name"));
    }), $(document).on(UI["pointerEvent"]("up"), function (_0x4399ce) {
      !_0x214e8a["readOnly"] && (_0x214e8a.resizing = false, _0x214e8a["rotating"] = false);
    }), $(document).on(UI["pointerEvent"]("move"), function (_0x1703af) {
      if (!_0x214e8a["readOnly"]) {
        if (_0x214e8a["resizing"] || _0x214e8a["rotating"]) {
          var _0x330424 = UI["getInputPosition"](_0x1703af),
            _0x3ff9b0 = UI["screenToBoard"](_0x330424.x, _0x330424.y);
          if (_0x214e8a["resizing"]) _0x214e8a["resize"](_0x3ff9b0.x - _0x214e8a["position"].x, _0x3ff9b0.y - _0x214e8a.position.y); else {
            if (_0x214e8a.rotating) {
              _0x3ff9b0.x = _0x3ff9b0.x - _0x214e8a.position.x, _0x3ff9b0.y = _0x3ff9b0.y - _0x214e8a.position.y;
              var _0x5dadb2 = new Size(_0x214e8a.container["width"](), _0x214e8a["container"]["height"]()),
                _0x32e5d1 = Math["atan2"](_0x3ff9b0.x - _0x5dadb2["width"] / 2, _0x3ff9b0.y - _0x5dadb2["height"] / 2),
                _0x20ed25 = _0x32e5d1 * (180 / Math.PI) * -1;
              UI["holdingSHIFT"] && (_0x20ed25 = angleSnap(_0x20ed25)), _0x214e8a["rotate"](_0x20ed25 - (_0x214e8a.movingFrom == "INVROT" ? 180 : 0));
            }
          }
        }
      }
    });
  }
  ["show"]() {
    this.resizeContainer.find(".sizeController")["show"](), this.resizeContainer["find"](".rotationController").show();
  }
  ["hide"]() {
    this["resizeContainer"].find(".sizeController")["hide"](), this["resizeContainer"].find(".rotationController").hide();
  }
  ["modifierUp"](_0x3da408) {
    this["setKeepAspectRatio"](!this.keepAspectRatio);
  }
  ["modifierDown"](_0x42b825) {
    this["setKeepAspectRatio"](!this.keepAspectRatio);
  }
  ["rotate"](_0x4240fe) {
    this["rotation"] = _0x4240fe, $(this)["triggerHandler"](new rotationChangedEvent(_0x4240fe)["getEvent"]());
  }
  ["resize"](_0x1a8447, _0x4272f5) {
    var _0x1963ed = null,
      _0x594dd1 = new Point(0, 0),
      _0x2058b6 = new Size(this["container"]["width"](), this["container"]["height"]()),
      _0x40e3f9 = calculateAspectRatioFit(_0x2058b6["width"], _0x2058b6["height"], this["minWidth"], this["minHeight"]),
      _0x5f0f05 = _0x40e3f9["width"],
      _0xe51e0e = _0x40e3f9.height;
    if (this["movingFrom"] == "NW") {
      var _0x20957e = _0x594dd1.x - _0x1a8447,
        _0x259fef = _0x594dd1.y - _0x4272f5;
      if (this["keepAspectRatio"]) {
        var _0x3e0255 = this["getAspectRatio"](_0x2058b6["width"], _0x2058b6["height"], _0x2058b6["width"] + _0x20957e, _0x2058b6["height"] + _0x259fef),
          _0x42d83e = new Point(_0x2058b6.width + _0x20957e - _0x3e0255["width"], _0x2058b6.height + _0x259fef - _0x3e0255["height"]);
        _0x1963ed = new Rect(_0x1a8447 + _0x42d83e.x, _0x4272f5 + _0x42d83e.y, _0x3e0255["width"], _0x3e0255["height"]);
      } else _0x1963ed = new Rect(_0x1a8447, _0x4272f5, _0x2058b6["width"] + _0x20957e, _0x2058b6["height"] + _0x259fef);
      _0x1963ed["height"] < _0xe51e0e && (_0x1963ed.y -= _0xe51e0e - _0x1963ed["height"], _0x1963ed["height"] = _0xe51e0e), _0x1963ed["width"] < _0x5f0f05 && (_0x1963ed.x -= _0x5f0f05 - _0x1963ed["width"], _0x1963ed.width = _0x5f0f05);
    } else {
      if (this["movingFrom"] == "N") {
        var _0x259fef = _0x594dd1.y - _0x4272f5;
        _0x1963ed = new Rect(_0x594dd1.x, _0x4272f5, _0x2058b6.width, _0x2058b6.height + _0x259fef), _0x1963ed["height"] < _0xe51e0e && (_0x1963ed.y -= _0xe51e0e - _0x1963ed.height, _0x1963ed["height"] = _0xe51e0e);
      } else {
        if (this["movingFrom"] == "NE") {
          var _0x20957e = _0x1a8447 - _0x2058b6["width"] - _0x594dd1.x,
            _0x259fef = _0x594dd1.y - _0x4272f5;
          if (this["keepAspectRatio"]) {
            var _0x3e0255 = this["getAspectRatio"](_0x2058b6["width"], _0x2058b6.height, _0x2058b6["width"] + _0x20957e, _0x2058b6["height"] + _0x259fef),
              _0x42d83e = new Point(_0x2058b6["width"] + _0x20957e - _0x3e0255.width, _0x2058b6["height"] + _0x259fef - _0x3e0255["height"]);
            _0x1963ed = new Rect(_0x594dd1.x, _0x4272f5 + _0x42d83e.y, _0x3e0255["width"], _0x3e0255["height"]);
          } else _0x1963ed = new Rect(_0x594dd1.x, _0x4272f5, _0x2058b6["width"] + _0x20957e, _0x2058b6["height"] + _0x259fef);
          _0x1963ed["height"] < _0xe51e0e && (_0x1963ed.y -= _0xe51e0e - _0x1963ed.height, _0x1963ed["height"] = _0xe51e0e), _0x1963ed.width < _0x5f0f05 && (_0x1963ed["width"] = _0x5f0f05);
        } else {
          if (this["movingFrom"] == "W") {
            var _0x20957e = _0x594dd1.x - _0x1a8447;
            _0x1963ed = new Rect(_0x1a8447, _0x594dd1.y, _0x2058b6["width"] + _0x20957e, _0x2058b6["height"]), _0x1963ed["width"] < _0x5f0f05 && (_0x1963ed.x -= _0x5f0f05 - _0x1963ed["width"], _0x1963ed["width"] = _0x5f0f05);
          } else {
            if (this["movingFrom"] == "E") {
              var _0x20957e = _0x1a8447 - _0x2058b6["width"] - _0x594dd1.x;
              _0x1963ed = new Rect(_0x594dd1.x, _0x594dd1.y, _0x2058b6.width + _0x20957e, _0x2058b6["height"]), _0x1963ed.width < _0x5f0f05 && (_0x1963ed["width"] = _0x5f0f05);
            } else {
              if (this["movingFrom"] == "SW") {
                var _0x20957e = _0x594dd1.x - _0x1a8447,
                  _0x259fef = _0x4272f5 - _0x2058b6.height - _0x594dd1.y;
                if (this.keepAspectRatio) {
                  var _0x3e0255 = this["getAspectRatio"](_0x2058b6["width"], _0x2058b6.height, _0x2058b6.width + _0x20957e, _0x2058b6["height"] + _0x259fef),
                    _0x42d83e = new Point(_0x2058b6["width"] + _0x20957e - _0x3e0255["width"], _0x2058b6["height"] + _0x259fef - _0x3e0255["height"]);
                  _0x1963ed = new Rect(_0x1a8447 + _0x42d83e.x, _0x594dd1.y, _0x3e0255["width"], _0x3e0255["height"]);
                } else _0x1963ed = new Rect(_0x1a8447, _0x594dd1.y, _0x2058b6["width"] + _0x20957e, _0x2058b6.height + _0x259fef);
                _0x1963ed["height"] < _0xe51e0e && (_0x1963ed.height = _0xe51e0e), _0x1963ed.width < _0x5f0f05 && (_0x1963ed.x -= _0x5f0f05 - _0x1963ed["width"], _0x1963ed.width = _0x5f0f05);
              } else {
                if (this.movingFrom == "S") {
                  var _0x259fef = _0x4272f5 - _0x2058b6.height - _0x594dd1.y;
                  _0x1963ed = new Rect(_0x594dd1.x, _0x594dd1.y, _0x2058b6["width"], _0x2058b6["height"] + _0x259fef), _0x1963ed.height < _0xe51e0e && (_0x1963ed["height"] = _0xe51e0e);
                } else {
                  if (this["movingFrom"] == "SE") {
                    var _0x20957e = _0x1a8447 - _0x2058b6.width - _0x594dd1.x,
                      _0x259fef = _0x4272f5 - _0x2058b6.height - _0x594dd1.y;
                    if (this["keepAspectRatio"]) {
                      var _0x3e0255 = this["getAspectRatio"](_0x2058b6["width"], _0x2058b6.height, _0x2058b6["width"] + _0x20957e, _0x2058b6["height"] + _0x259fef);
                      _0x1963ed = new Rect(_0x594dd1.x, _0x594dd1.y, _0x3e0255["width"], _0x3e0255["height"]);
                    } else _0x1963ed = new Rect(_0x594dd1.x, _0x594dd1.y, _0x2058b6.width + _0x20957e, _0x2058b6["height"] + _0x259fef);
                    _0x1963ed["height"] < _0xe51e0e && (_0x1963ed["height"] = _0xe51e0e), _0x1963ed["width"] < _0x5f0f05 && (_0x1963ed["width"] = _0x5f0f05);
                  }
                }
              }
            }
          }
        }
      }
    }
    _0x1963ed && $(this).triggerHandler(new elementResizedEvent(_0x1963ed.x, _0x1963ed.y, _0x1963ed["width"], _0x1963ed["height"], this["movingFrom"])["getEvent"]());
  }
  ["setKeepAspectRatio"](_0x1b97eb) {
    this["keepAspectRatio"] = _0x1b97eb, $(this)["triggerHandler"](new propertyChangedEvent("keepAspectRatio", _0x1b97eb)["getEvent"]());
  }
  ["getAspectRatio"](_0x58a431, _0x3de655, _0x51d039, _0x3a63b5) {
    var _0xaeb089 = Math["min"](_0x51d039 / _0x58a431, _0x3a63b5 / _0x3de655);
    return {
      width: _0x58a431 * _0xaeb089,
      height: _0x3de655 * _0xaeb089
    };
  }
  ["move"](_0x103807, _0x4a75c2) {
    this["position"] = new Point(_0x103807, _0x4a75c2);
  }
  ["createController"](_0x4ce611, _0x339e9a = "size") {
    var _0x3fc89d = $("<div />");
    return _0x339e9a == "size" ? _0x3fc89d["addClass"]("sizeController") : _0x3fc89d["addClass"]("rotationController"), _0x3fc89d["attr"]("name", _0x4ce611), _0x3fc89d;
  }
}
class MousePointer extends UIComponent {
  constructor(_0x4b59df) {
    super(_0x4b59df), this.position, this["currentCursor"], this["currentComment"], this["pointer"] = $("<div />"), this["pointer"]["addClass"]("virtualCursor"), this.cursor("pointer"), this["hide"](), _0x4b59df.append(this.pointer);

    // Sharp single black pixel dot cursor (centered)
this.simpleCursor = $(`
      <svg class="ps-cross" width="21" height="19" viewBox="0 0 21 19" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges">
        <!-- y=0 -->
        <rect x="9" y="0" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="10" y="0" width="1" height="1" fill="#CCCCCC" opacity="0.87" />
        <rect x="11" y="0" width="1" height="1" fill="#CCCCCC" opacity="0.71" />

        <!-- y=1 -->
        <rect x="9" y="1" width="1" height="1" fill="#CCCCCC" opacity="0.79" />
        <rect x="10" y="1" width="1" height="1" fill="#000" opacity="1" />
        <rect x="11" y="1" width="1" height="1" fill="#CCCCCC" opacity="0.78" />

        <!-- y=2 -->
        <rect x="9" y="2" width="1" height="1" fill="#CCCCCC" opacity="0.79" />
        <rect x="10" y="2" width="1" height="1" fill="#000" opacity="1" />
        <rect x="11" y="2" width="1" height="1" fill="#CCCCCC" opacity="0.78" />

        <!-- y=3 -->
        <rect x="9" y="3" width="1" height="1" fill="#CCCCCC" opacity="0.79" />
        <rect x="10" y="3" width="1" height="1" fill="#000" opacity="1" />
        <rect x="11" y="3" width="1" height="1" fill="#CCCCCC" opacity="0.78" />

        <!-- y=4 -->
        <rect x="9" y="4" width="1" height="1" fill="#CCCCCC" opacity="0.79" />
        <rect x="10" y="4" width="1" height="1" fill="#000" opacity="1" />
        <rect x="11" y="4" width="1" height="1" fill="#CCCCCC" opacity="0.78" />

        <!-- y=5 -->
        <rect x="9" y="5" width="1" height="1" fill="#CCCCCC" opacity="0.79" />
        <rect x="10" y="5" width="1" height="1" fill="#000" opacity="1" />
        <rect x="11" y="5" width="1" height="1" fill="#CCCCCC" opacity="0.78" />

        <!-- y=6 -->
        <rect x="9" y="6" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="10" y="6" width="1" height="1" fill="#CCCCCC" opacity="0.71" />
        <rect x="11" y="6" width="1" height="1" fill="#CCCCCC" opacity="0.71" />

        <!-- y=7 (top bridge) -->
        <rect x="10" y="7" width="1" height="1" fill="#CCCCCC" opacity="0.73" />

        <!-- y=8 -->
        <rect x="1" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="2" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.87" />
        <rect x="3" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.87" />
        <rect x="4" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.87" />
        <rect x="5" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.87" />
        <rect x="6" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.87" />
        <rect x="7" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="9" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="10" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.87" />
        <rect x="11" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.71" />
        <rect x="13" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="14" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.87" />
        <rect x="15" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.87" />
        <rect x="16" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.87" />
        <rect x="17" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.87" />
        <rect x="18" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.87" />
        <rect x="19" y="8" width="1" height="1" fill="#CCCCCC" opacity="0.73" />

        <!-- y=9 -->
        <rect x="1" y="9" width="1" height="1" fill="#CCCCCC" opacity="0.79" />
        <rect x="2" y="9" width="1" height="1" fill="#000" opacity="1" />
        <rect x="3" y="9" width="1" height="1" fill="#000" opacity="1" />
        <rect x="4" y="9" width="1" height="1" fill="#000" opacity="1" />
        <rect x="5" y="9" width="1" height="1" fill="#000" opacity="1" />
        <rect x="6" y="9" width="1" height="1" fill="#000" opacity="1" />
        <rect x="7" y="9" width="1" height="1" fill="#CCCCCC" opacity="0.79" />
        <rect x="8" y="9" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="9" y="9" width="1" height="1" fill="#CCCCCC" opacity="0.79" />
        <rect x="10" y="9" width="1" height="1" fill="#000" opacity="1" />
        <rect x="11" y="9" width="1" height="1" fill="#CCCCCC" opacity="0.78" />
        <rect x="12" y="9" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="13" y="9" width="1" height="1" fill="#CCCCCC" opacity="0.79" />
        <rect x="14" y="9" width="1" height="1" fill="#000" opacity="1" />
        <rect x="15" y="9" width="1" height="1" fill="#000" opacity="1" />
        <rect x="16" y="9" width="1" height="1" fill="#000" opacity="1" />
        <rect x="17" y="9" width="1" height="1" fill="#000" opacity="1" />
        <rect x="18" y="9" width="1" height="1" fill="#000" opacity="1" />
        <rect x="19" y="9" width="1" height="1" fill="#CCCCCC" opacity="0.79" />

        <!-- y=10 -->
        <rect x="1" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="2" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="3" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="4" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="5" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="6" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="7" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="9" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="10" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.71" />
        <rect x="11" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.71" />
        <rect x="13" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="14" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="15" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="16" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="17" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="18" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="19" y="10" width="1" height="1" fill="#CCCCCC" opacity="0.73" />

        <!-- y=11 (bottom bridge) -->
        <rect x="10" y="11" width="1" height="1" fill="#CCCCCC" opacity="0.73" />

        <!-- y=12 -->
        <rect x="9" y="12" width="1" height="1" fill="#CCCCCC" opacity="0.73" />
        <rect x="10" y="12" width="1" height="1" fill="#CCCCCC" opacity="0.87" />
        <rect x="11" y="12" width="1" height="1" fill="#CCCCCC" opacity="0.71" />

        <!-- y=13 -->
        <rect x="9" y="13" width="1" height="1" fill="#CCCCCC" opacity="0.77" />
        <rect x="10" y="13" width="1" height="1" fill="#000" opacity="1" />
        <rect x="11" y="13" width="1" height="1" fill="#CCCCCC" opacity="0.78" />

        <!-- y=14 -->
        <rect x="9" y="14" width="1" height="1" fill="#CCCCCC" opacity="0.78" />
        <rect x="10" y="14" width="1" height="1" fill="#000" opacity="1" />
        <rect x="11" y="14" width="1" height="1" fill="#CCCCCC" opacity="0.78" />

        <!-- y=15 -->
        <rect x="9" y="15" width="1" height="1" fill="#CCCCCC" opacity="0.78" />
        <rect x="10" y="15" width="1" height="1" fill="#000" opacity="1" />
        <rect x="11" y="15" width="1" height="1" fill="#CCCCCC" opacity="0.78" />

        <!-- y=16 -->
        <rect x="9" y="16" width="1" height="1" fill="#CCCCCC" opacity="0.78" />
        <rect x="10" y="16" width="1" height="1" fill="#000" opacity="1" />
        <rect x="11" y="16" width="1" height="1" fill="#CCCCCC" opacity="0.78" />

        <!-- y=17 -->
        <rect x="9" y="17" width="1" height="1" fill="#CCCCCC" opacity="0.78" />
        <rect x="10" y="17" width="1" height="1" fill="#000" opacity="1" />
        <rect x="11" y="17" width="1" height="1" fill="#CCCCCC" opacity="0.78" />

        <!-- y=18 -->
        <rect x="9" y="18" width="1" height="1" fill="#CCCCCC" opacity="0.71" />
        <rect x="10" y="18" width="1" height="1" fill="#CCCCCC" opacity="0.71" />
        <rect x="11" y="18" width="1" height="1" fill="#CCCCCC" opacity="0.71" />
      </svg>
    `);

    this.pointer.append(this.simpleCursor);
    if (!$("#ps-cross-styles").length) {
      $("head").append(`
        <style id="ps-cross-styles">
          .ps-cross {
            position: absolute;
            pointer-events: none;
            left: 0;
            top: 0;
            transform: translate(-50%, -50%);
          }
        </style>
      `);
    }
  }
  ["move"](_0x523f05, _0x4c9bc2) {
    this.position = new Point(_0x523f05, _0x4c9bc2), this.pointer["css"]({
      left: _0x523f05 + "px",
      top: _0x4c9bc2 + "px"
    });
  }
  ["processingCursor"](count, total) {
    if (!this.pointer.find('.processing-cursor').length) {
      // Create a processing cursor element if it doesn't exist
      this.pointer.html(`
        <div class="processing-cursor" style="background: rgba(255,165,0,0.8); color: white; padding: 3px 6px; border-radius: 10px; font-size: 11px; white-space: nowrap;">
          Processing ${count}/${total}
        </div>
      `);
    } else {
      // Update existing processing cursor
      this.pointer.find('.processing-cursor').text(`Processing ${count}/${total}`);
    }
    
    // Make sure it's visible
    !this.pointer.is(":visible") && this.show();
    $("body").css("cursor", "none");
  }
// ...existing code...
["cursor"](_0xfda5f8, _0x31af04 = "") {
  // Decide which logic to use based on csCursor flag in localStorage
  const csCursorEnabled =
    localStorage.getItem(
      (window.config && window.config.localStorageKeys && window.config.localStorageKeys.csCursor) || "csCursor"
    ) === "true";

  if (csCursorEnabled) {
    // ===== Modified (Counter-Strike Cursor) Logic =====
    if (room && room.board && room.board.commitProgress && room.board.commitProgress.active) {
      this.processingCursor(
        room.board.commitProgress.processed,
        room.board.commitProgress.total
      );
      return;
    } else {
      if (this.pointer.find(".processing-cursor").length) {
        this.pointer.find(".processing-cursor").remove();
        if (_0xfda5f8 === "crosshair") {
          $("body").css("cursor", "crosshair");
        } else if (_0xfda5f8 === "auto") {
          $("body").css("cursor", "auto");
        } else if (UI.userPreferences.getGroupOption("graphics", "showmouse")) {
          $("body").css("cursor", "none");
        } else {
          $("body").css("cursor", "auto");
        }
      }
    }

    if (_0xfda5f8 !== this.currentCursor) {
      if (_0xfda5f8 === "auto") {
        $("body").css("cursor", "auto");
        this.pointer.html(new Icon("fa-mouse-pointer", "fas", "fa-lg").html());
        this.hide();
      } else {
        if (_0xfda5f8 === "none") {
          $("body").css("cursor", "none");
          this.hide();
        } else {
          if (!this.pointer.is(":visible")) this.show();
          $("body").css("cursor", "none");

            // Modified path: support "simple" custom crosshair variant
          if (_0xfda5f8 === "simple") {
            if (this.simpleCursor) {
              this.pointer.html("").append(this.simpleCursor);
            } else {
              // Fallback if simpleCursor not initialized
              this.pointer.html(new Icon("fa-plus", "fas", "fa-lg").html());
            }
          } else if (_0xfda5f8 === "pointer") {
            this.pointer.html(new Icon("fa-mouse-pointer", "fas", "fa-lg").html());
          } else if (_0xfda5f8 === "not-allowed") {
            this.pointer.html(new Icon("fa-ban", "fas", "fa-lg", "red").html());
          } else if (_0xfda5f8 === "zoom") {
            this.pointer.html(new Icon("fa-search", "fas", "fa-lg", "black").html());
          } else if (_0xfda5f8 === "rotate") {
            this.pointer.html(new Icon("fa-sync-alt", "fas", "fa-lg cursorCenter").html());
          } else if (_0xfda5f8 === "crosshair") {
            $("body").css("cursor", "crosshair");
            this.hide();
          } else if (_0xfda5f8 === "move") {
            this.pointer.html(new Icon("fa-arrows-alt", "fas", "fa-lg cursorCenter").html());
          }
        }
      }
      this.currentCursor = _0xfda5f8;
    }

    if (_0x31af04 !== this.currentComment) {
      this.pointer.find(".cursorComment").remove();
      this.pointer.append('<span class="cursorComment">' + _0x31af04 + "</span>");
      this.currentComment = _0x31af04;
    }
    return;
  }

  // ===== Original (Non-modified) Logic =====
  if (room && room.board && room.board.commitProgress && room.board.commitProgress.active) {
    this.processingCursor(
      room.board.commitProgress.processed,
      room.board.commitProgress.total
    );
    return;
  } else {
    if (this.pointer.find(".processing-cursor").length) {
      this.pointer.find(".processing-cursor").remove();
      if (_0xfda5f8 == "crosshair") {
        $("body").css("cursor", "crosshair");
      } else if (_0xfda5f8 == "auto") {
        $("body").css("cursor", "auto");
      } else if (UI.userPreferences.getGroupOption("graphics", "showmouse")) {
        $("body").css("cursor", "none");
      } else {
        $("body").css("cursor", "auto");
      }
    }
  }

  if (_0xfda5f8 != this.currentCursor) {
    if (_0xfda5f8 == "auto") {
      $("body").css("cursor", "auto");
      this.pointer.html(new Icon("fa-mouse-pointer", "fas", "fa-lg").html());
      this.hide();
    } else {
      if (_0xfda5f8 == "none") {
        $("body").css("cursor", "none");
        this.hide();
      } else {
        if (!this.pointer.is(":visible")) this.show();
        $("body").css("cursor", "none");
        if (_0xfda5f8 == "pointer") {
          this.pointer.html(new Icon("fa-mouse-pointer", "fas", "fa-lg").html());
        } else if (_0xfda5f8 == "not-allowed") {
          this.pointer.html(new Icon("fa-ban", "fas", "fa-lg", "red").html());
        } else if (_0xfda5f8 == "zoom") {
          this.pointer.html(new Icon("fa-search", "fas", "fa-lg", "black").html());
        } else if (_0xfda5f8 == "rotate") {
          this.pointer.html(new Icon("fa-sync-alt", "fas", "fa-lg cursorCenter").html());
        } else if (_0xfda5f8 == "crosshair") {
          $("body").css("cursor", "crosshair");
          this.hide();
        } else if (_0xfda5f8 == "move") {
          this.pointer.html(new Icon("fa-arrows-alt", "fas", "fa-lg cursorCenter").html());
        }
      }
    }
    this.currentCursor = _0xfda5f8;
  }

  if (_0x31af04 != this.currentComment) {
    this.pointer.find(".cursorComment").remove();
    this.pointer.append('<span class="cursorComment">' + _0x31af04 + "</span>");
    this.currentComment = _0x31af04;
  }
}
// ...existing code...
  ["show"]() {
    this["pointer"]["show"]();
  }
  ["hide"]() {
    this["pointer"]["hide"]();
  }
}
class SelectionTool extends UIComponent {
  constructor(_0x1f0e02, _0x50a6cd, _0x3ad406) {
    super(_0x1f0e02), this["width"] = _0x50a6cd, this.height = _0x3ad406, this["clickX"] = new Array(), this["clickY"] = new Array(), this["offset"], this["currentTool"] = "rectangle", this["dragging"] = false, this.scale = 1, this.from, this["initialPosition"], this["positions"] = new Array(), this.layer = new Layer(0, this["width"], this["height"], "slate"), _0x1f0e02.append(this["layer"].advCanvas["canvas"]), this["contextSlate"] = this["layer"]["getContext"]();
    var _0x51995e = this;
    $(document).on(UI["pointerEvent"]("up"), function (_0x5862df) {
      if (_0x51995e["dragging"]) {
        _0x51995e["dragging"] = false;
        if (_0x51995e["initialPosition"]) {
          if (_0x51995e.currentTool == "lasso") _0x51995e["addClick"](_0x51995e["initialPosition"].x, _0x51995e.initialPosition.y); else {
            if (_0x51995e.currentTool == "rectangle") {
              var _0x193f4a = _0x51995e["offset"],
                _0x4fbef4 = UI.getInputPosition(_0x5862df),
                _0x21aaf4 = new Point((_0x4fbef4.x - _0x193f4a.left) / _0x51995e["scale"], (_0x4fbef4.y - _0x193f4a["top"]) / _0x51995e["scale"]);
              _0x51995e["initialPosition"].x == _0x21aaf4.x && _0x51995e["initialPosition"].y == _0x21aaf4.y && _0x51995e["removeClicks"]();
            }
          }
        }
        _0x51995e["redraw"]();
      }
    }), $(document).on(UI["pointerEvent"]("move"), function (_0x238a45) {
      if (_0x51995e.dragging) {
        var _0x20b83f = _0x51995e.offset,
          _0x5b3586 = UI["getInputPosition"](_0x238a45),
          _0x2e7f8d = new Point((_0x5b3586.x - _0x20b83f["left"]) / _0x51995e["scale"], (_0x5b3586.y - _0x20b83f["top"]) / _0x51995e["scale"]);
        _0x2e7f8d.x = Math["min"](Math.max(_0x2e7f8d.x, 0), _0x51995e["width"]) + 0.5, _0x2e7f8d.y = Math["min"](Math.max(_0x2e7f8d.y, 0), _0x51995e["height"]) + 0.5, _0x51995e.currentTool == "lasso" ? _0x51995e["addClick"](_0x2e7f8d.x, _0x2e7f8d.y) : (_0x51995e["clickX"][0] = _0x2e7f8d.x, _0x51995e["clickY"][0] = _0x2e7f8d.y), _0x51995e.redraw();
      }
    }), $(this["layer"]["advCanvas"]["canvas"]).on(UI["pointerEvent"]("down"), function (_0x1cf904) {
      if (!_0x1cf904["which"] || _0x1cf904.which == 1) {
        _0x51995e["dragging"] = true;
        var _0x4fcf99 = $(this)["offset"](),
          _0x4a40d5 = UI["getInputPosition"](_0x1cf904);
        _0x51995e["from"] = new Point((_0x4a40d5.x - _0x4fcf99["left"]) / _0x51995e["scale"], (_0x4a40d5.y - _0x4fcf99["top"]) / _0x51995e.scale), _0x51995e["initialPosition"] = _0x51995e["from"], _0x51995e["removeClicks"](), _0x51995e["addClick"](_0x51995e.from.x, _0x51995e["from"].y), _0x51995e["offset"] = _0x4fcf99;
      }
    });
  }
  ["setScale"](_0x5d7469) {
    this["scale"] = _0x5d7469;
  }
  ["redraw"](_0x34cddc = true, _0x2de902 = true) {
    this["clearSlate"](), this["layer"].advCanvas["setCanvasProperties"]({
      linejoin: "round",
      linecap: "round",
      linewidth: _0x34cddc ? 2 : 1,
      strokestyle: "#808080",
      alpha: 1,
      blendmode: "normal",
      blur: 0,
      linedash: _0x34cddc ? [5, 7] : []
    }), this["contextSlate"].beginPath();
    if (this["currentTool"] == "lasso") {
      this["contextSlate"].moveTo(this["clickX"][0], this["clickY"][0]);
      for (var _0x3600fb = 0; _0x3600fb < this["clickX"]["length"]; _0x3600fb++) {
        this["contextSlate"]["lineTo"](this.clickX[_0x3600fb], this["clickY"][_0x3600fb]);
      }
    } else this["contextSlate"]["moveTo"](this["initialPosition"].x, this["initialPosition"].y), this["contextSlate"].lineTo(this["clickX"][0], this["initialPosition"].y), this["contextSlate"]["lineTo"](this["clickX"][0], this["clickY"][0]), this["contextSlate"]["lineTo"](this.initialPosition.x, this.clickY[0]), this["contextSlate"]["lineTo"](this["initialPosition"].x, this["initialPosition"].y);
    _0x34cddc && this["contextSlate"].stroke(), _0x2de902 && (this["contextSlate"]["closePath"](), this["contextSlate"]["save"](), this["contextSlate"]["clip"](), this["contextSlate"]["globalAlpha"] = 0.2, this["fill"]("#CCCCCC"), this["contextSlate"]["restore"](), this["layer"]["advCanvas"].clearCanvasProperties());
  }
  ["addClick"](_0x52036b, _0x3e8b57) {
    this["clickX"]["push"](parseInt(_0x52036b)), this["clickY"]["push"](parseInt(_0x3e8b57));
  }
  ["removeClicks"]() {
    this["clickX"] = new Array(), this["clickY"] = new Array();
  }
  ["setClicks"](_0xb685d5) {
    this["removeClicks"]();
    for (var _0x3a8a18 = 0; _0x3a8a18 < _0xb685d5["length"]; _0x3a8a18++) {
      this["clickX"]["push"](_0xb685d5[_0x3a8a18].x), this["clickY"]["push"](_0xb685d5[_0x3a8a18].y);
    }
  }
  ["getMask"]() {
    if (this["currentTool"] == "lasso") return this["getClicks"](); else {
      var _0x451a87 = new Array();
      if (this["clickX"]["length"] == 1) {
        let _0x4e9d88 = this["initialPosition"].x > this["clickX"][0] ? -0.5 : 0.5,
          _0x12b775 = this.initialPosition.y > this.clickY[0] ? -0.5 : 0.5;
        _0x451a87["push"](new Point(this["initialPosition"].x + _0x4e9d88, this["initialPosition"].y + _0x12b775)), _0x451a87["push"](new Point(this["clickX"][0] - _0x4e9d88, this["initialPosition"].y + _0x12b775)), _0x451a87["push"](new Point(this["clickX"][0] - _0x4e9d88, this["clickY"][0] - _0x12b775)), _0x451a87.push(new Point(this["initialPosition"].x + _0x4e9d88, this["clickY"][0] - _0x12b775)), _0x451a87.push(new Point(this["initialPosition"].x + _0x4e9d88, this["initialPosition"].y + _0x12b775));
      }
      return _0x451a87;
    }
  }
  ["getContext"]() {
    return this["layer"].getContext();
  }
  ["getData"]() {
    return this["layer"]["getData"]();
  }
  ["getClicks"]() {
    var _0x14a39a = new Array();
    for (var _0x1e6be0 = 0; _0x1e6be0 < this.clickX["length"]; _0x1e6be0++) {
      _0x14a39a["push"](new Point(this["clickX"][_0x1e6be0], this["clickY"][_0x1e6be0]));
    }
    return _0x14a39a;
  }
  ["hasSelection"]() {
    return this.currentTool == "rectangle" && this.clickX["length"] > 0 || this.clickX["length"] > 2;
  }
  ["fill"](_0x609e5d) {
    this.contextSlate["fillColor"] = _0x609e5d, this["contextSlate"].fillRect(0, 0, this["width"], this["height"]);
  }
  ["clearSlate"]() {
    this["layer"]["advCanvas"].clear();
  }
  ["clear"]() {
    this["initialPosition"] = null, this.removeClicks(), this.clearSlate();
  }
  ["changeSize"](_0x3b5526, _0x7e64e7) {
    this["width"] = _0x3b5526, this.height = _0x7e64e7, this["layer"]["advCanvas"]["changeSize"](_0x3b5526, _0x7e64e7);
  }
  ["remove"]() {
    this["layer"].remove();
  }
}
class Topbar extends UIComponent {
  constructor(_0x52c8e4, _0x5c44cc, _0x3025e5) {
    super(_0x52c8e4), this["currentText"] = "";
    var _0x2099c5 = "v" + _0x3025e5["split"](".")[0];
    this["container"]["append"]("<nav class=\"navbar navbar-expand-lg navbar-light p-0 m-0 sticky-top topNavbar\">\n\t\t\t<div class=\"container full-width\">\n\t\t\t\t<div id=\"topbarProgress\"></div>\n\t\t\t\t<span class=\"navbar-brand\">" + _0x5c44cc + ' <sup class="navbar-version" data-tooltip="' + _0x3025e5 + '">' + _0x2099c5 + "</sup></span>\n\t\t\t\t\n\t\t\t\t<button class=\"navbar-toggler\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#navbar-topmost\" aria-controls=\"navbar-topmost\" aria-expanded=\"false\" aria-label=\"Toggle navigation\">\n\t\t\t\t\t<i class=\"fas fa-bars\"></i>\n\t\t\t\t</button>\n\t\t\t\t\n\t\t\t\t<div class=\"collapse navbar-collapse justify-content-end\" id=\"navbar-topmost\">\n\t\t\t\t\t<div class=\"headerBox m-0 p-0\">\n\t\t\t\t\t\t<div id=\"headerTitle\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t\t\n\t\t\t\t\t<ul class=\"navbar-nav topbarButtons\"></ul>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</nav>"), this["addButton"]("configButton", "fa-cog", "tooltip.lblConfiguration", true, "config"), this.addButton("chatButton", "fa-comment", "tooltip.lblChat", true, "chat"), this["addButton"]("fullscreenButton", "fa-expand", "tooltip.lblFullScreen", true, "fullscreen"), this.addButton("leaveButton", "fa-sign-out-alt", "tooltip.lblLeaveRoom", true, "leaveroom"), this["setText"]("Welcome to FlockMod"), this.progressBar = new ProgressBar(this["container"]["find"]("#topbarProgress"));
    var _0x713a9d = this;
    this.container["find"](".topbarButtons li a").on(UI["pointerEvent"]("click"), function (_0x409fd5) {
      _0x409fd5["preventDefault"](), _0x713a9d["pressButton"]($(this)["attr"]("name"), $(this));
    }), this["container"].find("#navbar-topmost").on("show.bs.collapse hide.bs.collapse", function (_0x52bd5b) {
      setTimeout(function () {
        UI["updateViewLimits"]();
      }, 250);
    }), $(UI).on("windowResizingStarted", function (_0x1a8aa0) {
      _0x713a9d.container["find"]("#headerTitle")["css"]("width", 0);
    }), $(UI).on("windowResizingEnded", function (_0x182e2b) {
      var _0x545855 = _0x713a9d["container"]["find"](".headerBox")["width"]();
      _0x713a9d["container"]["find"]("#headerTitle")["width"](_0x545855 - 20);
    }), $(UI).on("sidebarCollapsed sidebarUncollapsed", function (_0x1d3447) {
      _0x713a9d.container["find"]("#headerTitle").css("width", 0), setTimeout(function () {
        var _0x4a2664 = _0x713a9d.container["find"](".headerBox")["width"]();
        _0x713a9d["container"].find("#headerTitle")["width"](_0x4a2664 - 20);
      }, 500);
    });
  }
  ["addButton"](_0x106779, _0x15e8d6, _0x58671e, _0x145e35 = true, _0x463ac0 = null) {
    var _0x3f5d55 = new Icon(_0x15e8d6),
      _0x3a8c3e = "";
    _0x463ac0 ? _0x3a8c3e = "data-tooltipcallback=\"tooltipShortcut\" data-tooltipparam=\"" + _0x58671e + ";" + _0x463ac0 + '"' : _0x3a8c3e = "data-tooltipcallback=\"tooltipText\" data-tooltipparam=\"" + _0x58671e + '"', this["container"]["find"](".topbarButtons").append('<li class="nav-item" ' + _0x3a8c3e + "><a name=\"" + _0x106779 + "\" class=\"nav-link\" href=\"#\">" + _0x3f5d55["html"]() + " <span class=\"d-lg-none\">" + textManager["getString"](_0x58671e) + "</span></a></li>"), !_0x145e35 && this["hideButton"](_0x106779);
  }
  ["setCounter"](_0x155cb1, _0x37f19d, _0x203928 = "danger") {
    _0x37f19d == 0 ? this["container"]["find"]("a[name=\"" + _0x155cb1 + '"] > .badge[name="counter"]')["remove"]() : (this["container"]["find"]("a[name=\"" + _0x155cb1 + "\"] > .badge[name=\"counter\"]")["length"] > 0 ? this["container"]["find"]("a[name=\"" + _0x155cb1 + "\"] > .badge[name=\"counter\"]")["text"](_0x37f19d) : this["container"].find("a[name=\"" + _0x155cb1 + '"]')["append"]('<span class="badge badge-pill" name="counter">' + _0x37f19d + "</span>"), this.container["find"]('a[name="' + _0x155cb1 + "\"] span[name=\"counter\"]")["removeClass"]("badge-danger badge-secondary badge-default badge-primary badge-success badge-warning badge-info badge-light badge-dark"), this["container"]["find"]("a[name=\"" + _0x155cb1 + "\"] span[name=\"counter\"]")["addClass"]("badge-" + _0x203928));
  }
  ["showButton"](_0x574a1d) {
    this["container"]["find"](".topbarButtons a[name=\"" + _0x574a1d + '"]')["show"]();
  }
  ["hideButton"](_0x289d93) {
    this["container"]["find"](".topbarButtons a[name=\"" + _0x289d93 + '"]')["hide"]();
  }
  ["enableButton"](_0x1a7c5c) {
    this.container.find(".topbarButtons a[name=\"" + _0x1a7c5c + '"]')["removeClass"]("disabledLink");
  }
  ["disableButton"](_0x1b00eb) {
    this["container"]["find"](".topbarButtons a[name=\"" + _0x1b00eb + '"]')["addClass"]("disabledLink");
  }
  ["pressButton"](_0x590e40, _0x546c74 = null) {
    $(this).triggerHandler(new buttonPressedEvent(_0x590e40, _0x546c74)["getEvent"]());
  }
  ["setText"](_0x9651f5, _0xba7d39, _0x1b084b = 0) {
    var _0x9651f5 = this["getCategoryBadge"](_0x9651f5);
    _0xba7d39 = _0x9651f5 + _0xba7d39, this.container.find("#headerTitle")["html"](_0xba7d39);
    if (_0x1b084b == 0) this["currentText"] = _0xba7d39; else {
      var _0x4d72dd = this;
      setTimeout(function () {
        _0x4d72dd["container"]["find"]("#headerTitle").html(_0x4d72dd["currentText"]);
      }, 1e3 * _0x1b084b);
    }
  }
  ["getCategoryBadge"](_0x285dcd) {
    if (_0x285dcd == "") return "";
    var _0x281ff0 = "msgCategory" + _0x285dcd;
    return '<div class="msgCategory ' + _0x281ff0 + '">' + textManager.getString("notifications.categories." + _0x285dcd) + "</div>";
  }
  ["show"]() {
    this.container["removeClass"]("invisible");
  }
  ["hide"]() {
    this["container"]["addClass"]("invisible");
  }
}
class Bottombar extends UIComponent {
  constructor(_0x224e8d) {
    super(_0x224e8d), this["colorBubbles"], this["container"].append("<nav class=\"navbar navbar-expand navbar-light p-0 m-0 bottomNavbar\">\n\t\t\t<div class=\"container full-width\">\n\t\t\t\t<ul class=\"navbar-nav bottombarButtons\" name=\"left\">\n\t\t\t\t\t<li class=\"nav-item\"><a name=\"scaleLink\" href=\"#\" class=\"txtScale nav-text\">100%</a></li>\n\t\t\t\t\t<li class=\"nav-item\"><a name=\"rotationLink\" href=\"#\" class=\"txtRotation nav-text\">0&ordm;</a></li>\n\t\t\t\t\t<li class=\"nav-item nav-separator beforeButtons\"></li>\n\t\t\t\t\t<li class=\"p-2 d-none d-lg-block\"><div id=\"colorbubbles\"></div></li>\n\t\t\t\t\t<li class=\"nav-item nav-separator d-none d-xl-block\"></li>\n\t\t\t\t</ul>\n\t\t\t\t\n\t\t\t\t<div class=\"m-0 p-0\">\n\t\t\t\t\t<div class=\"footerTitle d-none d-xl-block\"></div>\n\t\t\t\t</div>\n\t\t\t\t\n\t\t\t\t<ul class=\"navbar-nav bottombarButtons\" name=\"right\">\n\t\t\t\t\t<li class=\"nav-item nav-separator d-none d-lg-block\"></li>\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</nav>"), this["init"]();
  }
  ["init"]() {
    // Left side buttons
    this.addLeftButton("zoominButton", "fa-search-plus", "tooltip.lblZoomIn", false, true, "zoomin");
    this.addLeftButton("zoomoutButton", "fa-search-minus", "tooltip.lblZoomOut", false, true, "zoomout");
    this.addLeftButton("centerButton", "fa-bullseye", "tooltip.lblCenterBoard");
    this.addLeftButton("fitButton", "fa-expand-arrows-alt", "tooltip.lblFitScreen");
    this.addLeftButton("flipXButton", "fa-exchange-alt", "tooltip.lblFlipHorizontally", false, true, "viewflip");
    this.addLeftButton("toggleSmoothingButton", "fa-adjust", "tooltip.lblPixelSmoothing", false, true, "pixelsmoothing");
    this.addLeftButton("socketConnectButton", "fa-chain", "tooltip.lblSocketConnect", false, true, "socketconnect");
    this.addLeftButton("socketDisconnectButton", "fa-chain-broken", "tooltip.lblSocketDisconnect", false, true, "socketdisconnect");
    this.addLeftButton("commitUndoHistoryButton", "fa-check", "tooltip.lblCommitUndoHistory", false, true, "commitundohistory");
    this.addLeftButton("toggleUndoHistoryButton", "fa-history", "tooltip.lblToggleUndoHistory", false, true, "undohistory");
    this.addLeftButton("clearUndoHistoryButton", "fa-times", "tooltip.lblClearUndoHistory", false, true, "clearhistory");
    this.addLeftButton("executeUndoAction", "fa-reply", "tooltip.lblUndo", false, true, "undoactionmodded");
    this.addLeftButton("executeRedoAction", "fa-share", "tooltip.lblRedo", false, true, "redoactionmodded");
    this.addLeftButton("customBgColorButton", "fa-fill-drip", "Apply Custom Background Color", false, true, "custombgcolor");

    // Right side buttons
    this.addRightButton("modsButton", "fa-star", "tooltip.lblMods", false, true, "shortcut_display");
    // this.addRightButton("socketModButton", "fa-cloud", "tooltip.lblSocketMod", false, true, "socketmod");
    this.addRightButton("adminConsoleButton", "fa-toolbox", "tooltip.lblAdminConsole");
    this.addRightButton("registerButton", "fa-flag", "tooltip.lblRegisterRoom", true);
    this.addRightButton("roomManagerButton", "fa-wrench", "tooltip.lblRoomManager", false, true, "roommanager");
    this.addRightButton("undoButton", "fa-undo", "tooltip.lblUndo", false, true, "undo");
    this.addRightButton("messengerButton", "fa-envelope", "tooltip.lblMessenger", false, true, "messenger");
    this.addRightButton("uploadButton", "fa-image", "tooltip.lblUpload", false, true, "upload");
    this.addRightButton("saveButton", "fa-save", "tooltip.lblSave", false, true, "save");
    
    // Initial state configuration
    this.setText("");
    this.setScale(100);
    this.setRotation(0);
    this.colorBubbles = new ColorGrid("bottom", this.container.find("#colorbubbles"), 10, storage);
    
    var _0x8094e2 = this;
    $(this.colorBubbles).on("bubbleClicked", function (_0x579dfb) {
      if (_0x579dfb["etype"] == "load") room["myself"]["surface"]["setColor"](_0x579dfb["obj"]["color"]); else {
        if (_0x579dfb["etype"] == "save") {
          var _0x1d1978 = new ColorBubble(room["myself"]["surface"]["drawColor"]);
          _0x8094e2["colorBubbles"]["saveBubble"](_0x1d1978, _0x579dfb["number"]);
        }
      }
    }), this["container"]["find"](".bottombarButtons li a").on(UI["pointerEvent"]("click"), function (_0xea1cff) {
      _0xea1cff["preventDefault"](), _0x8094e2["pressButton"]($(this).attr("name"), $(this));
    });
  }
  ["addButton"](_0x2e58c6, _0x211184, _0x53d177, _0x4032f3, _0x4faf04 = false, _0x3cee81 = true, _0x69ede6 = null) {
    var _0x2db066 = new Icon(_0x53d177),
      _0x542a41 = "";
    _0x69ede6 ? _0x542a41 = "data-tooltipcallback=\"tooltipShortcut\" data-tooltipparam=\"" + _0x4032f3 + ";" + _0x69ede6 + '"' : _0x542a41 = 'data-tooltipcallback="tooltipText" data-tooltipparam="' + _0x4032f3 + '"', _0x2e58c6 == "left" ? $('<li class="nav-item"><a name="' + _0x211184 + "\" class=\"nav-link\" href=\"#\" " + _0x542a41 + ">" + _0x2db066.html() + "</a></li>").insertBefore(".bottombarButtons[name=" + _0x2e58c6 + "] li.beforeButtons") : this["container"].find(".bottombarButtons[name=\"" + _0x2e58c6 + '"]').append("<li class=\"nav-item\"><a name=\"" + _0x211184 + "\" class=\"nav-link\" href=\"#\" " + _0x542a41 + ">" + _0x2db066["html"]() + (_0x4faf04 ? ' <span class="d-none d-lg-inline-block">' + textManager.getString(_0x4032f3) + "</span>" : "") + "</a></li>"), !_0x3cee81 && this["hideButton"](_0x211184);
  }
  ["setCounter"](_0x4b5afe, _0x26eb7c, _0x46bf61 = false) {
    _0x26eb7c == 0 ? this["container"].find("a[name=\"" + _0x4b5afe + '"] > .badge[name="counter"]')["remove"]() : (this["container"].find("a[name=\"" + _0x4b5afe + "\"] > .badge[name=\"counter\"]")["length"] > 0 ? this["container"]["find"]("a[name=\"" + _0x4b5afe + '"] > .badge[name="counter"]').text(_0x26eb7c) : this.container.find("a[name=\"" + _0x4b5afe + '"]')["append"]("<span class=\"badge badge-pill\" name=\"counter\">" + _0x26eb7c + "</span>"), this["container"].find("a[name=\"" + _0x4b5afe + "\"] span[name=\"counter\"]").removeClass("badge-danger badge-secondary"), _0x46bf61 ? this["container"]["find"]('a[name="' + _0x4b5afe + "\"] span[name=\"counter\"]")["addClass"]("badge-secondary") : this["container"]["find"]("a[name=\"" + _0x4b5afe + "\"] span[name=\"counter\"]")["addClass"]("badge-danger"));
  }
  ["addLeftButton"](_0x7247bd, _0x21a66b, _0x1b46d4, _0x30b4f8 = false, _0xb5cb1 = true, _0x5be231 = null) {
    this["addButton"]("left", _0x7247bd, _0x21a66b, _0x1b46d4, _0x30b4f8, _0xb5cb1, _0x5be231);
  }
  ["addRightButton"](_0x547810, _0x49acfc, _0x5359f0, _0x180c34 = false, _0x4ea439 = true, _0x3dfff6 = null) {
    this.addButton("right", _0x547810, _0x49acfc, _0x5359f0, _0x180c34, _0x4ea439, _0x3dfff6);
  }
  ["showButton"](_0x4f354b) {
    this.container["find"](".bottombarButtons a[name=\"" + _0x4f354b + '"]')["show"]();
  }
  ["hideButton"](_0x181d98) {
    this["container"].find(".bottombarButtons a[name=\"" + _0x181d98 + '"]').hide();
  }
  ["enableButton"](_0x200724) {
    this["container"]["find"](".bottombarButtons a[name=\"" + _0x200724 + '"]')["removeClass"]("disabledLink");
  }
  ["disableButton"](_0x45ee3f) {
    this["container"].find('.bottombarButtons a[name="' + _0x45ee3f + '"]')["addClass"]("disabledLink");
  }
  ["selectButton"](_0x931348) {
    this["container"]["find"]('.bottombarButtons a[name="' + _0x931348 + '"]')["addClass"]("selected");
  }
  ["unselectButton"](_0x317d1c) {
    this["container"].find(".bottombarButtons a[name=\"" + _0x317d1c + '"]')["removeClass"]("selected");
  }
  ["pressButton"](_0xa1ed72, _0x250c6e = null) {
    $(this)["triggerHandler"](new buttonPressedEvent(_0xa1ed72, _0x250c6e)["getEvent"]());
  }
  ["setText"](_0x17f89e) {
    this["container"]["find"](".footerTitle").html(_0x17f89e);
  }
  ["setScale"](_0x186204) {
    this["container"]["find"](".txtScale").html(_0x186204 + "%");
  }
  ["setRotation"](_0x320899) {
    this.container["find"](".txtRotation")["html"](_0x320899 + "&ordm;"), _0x320899 == 0 ? this["container"].find(".txtRotation")["hide"]() : this["container"]["find"](".txtRotation")["show"]();
  }
  ["show"]() {
    this["container"]["removeClass"]("invisible");
  }
  ["hide"]() {
    this["container"]["addClass"]("invisible");
  }
}
class Sidebar extends UIComponent {
  constructor(_0x97a265) {
    super(_0x97a265), this.collapsed, this["fixed"], this["userList"], this["toolOptions"], this["toolbar"], this["colorBox"], this["presets"], this["layerPreview"], this["sortable"], this.containers = {}, this.init();
  }
  ["init"]() {
    var _0x5c057d = this;
    this["set"](true, false), this["containers"] = {}, this["containers"]["UserList"] = new SidebarContainer("UserList", this["container"]["find"]("#userlistBox"), textManager["getString"]("sidebar.lblUserList"), "fa-user-friends", 160, true, true, "boxBgContainer"), this["containers"]["ToolOptions"] = new SidebarContainer("ToolOptions", this["container"]["find"]("#options"), textManager["getString"]("sidebar.lblToolOptions"), "fa-paint-brush", 180, true, true, "boxBgContainer"), this["containers"].Animation = new SidebarContainer("Animation", this["container"]["find"]("#animationBox"), textManager.getString("sidebar.lblAnimation"), "fa-film", 200, true, true, "boxBgContainer"), this["containers"].Presets = new SidebarContainer("Presets", this["container"]["find"]("#presetsBox"), textManager["getString"]("sidebar.lblPresets"), "fa-cloud", 100, false, false), this["containers"]["ColorWheel"] = new SidebarContainer("ColorWheel", this["container"].find("#colorWheelBox"), textManager.getString("sidebar.lblColorWheel"), "fa-palette", 210, false, false), this["containers"].Layers = new SidebarContainer("Layers", this["container"]["find"]("#previewList"), textManager["getString"]("sidebar.lblLayers"), "fa-layer-group", 200, true), this["sortable"] = new SortableList(this["container"]["find"]('div[name="sidebarSortable"]')), this.userList = new UserList(this["container"].find("#userlist")), this["toolOptions"] = new ToolOptions(this["container"]["find"]("#options")), this["toolbar"] = new Toolbar(this["container"].find("#drawingTools")), this["colorWheel"] = new ColorWheel(this.container.find("#colorWheel")), this["layerPreview"] = new LayerPreview(this["container"]["find"]("#previewList")), this["colorBox"] = new ColorBox(this["container"].find("#colorBox"), "#000000", "#FFFFFF", storage), this["presets"] = new PresetGrid("sidebar", this["container"].find("#presets"), 18, storage), this.animationOptions = new AnimationOptions(this["container"]["find"]("#animationBox")), this["containers"]["Animation"]["hide"](), this["adaptToolbar"](), this["hideConfig"](), UI["userPreferences"]["preferences"]["sidebarOrder"] == undefined && (UI["userPreferences"].preferences["sidebarOrder"] = []), $.each(UI.userPreferences["preferences"]["sidebarOrder"], function (_0x574b3c, _0x276580) {
      _0x5c057d["container"].find("div[name=\"sidebarComponents\"]")["append"](_0x5c057d["containers"][_0x276580]["container"]);
    }), $["each"](this["containers"], function (_0x5ad3a4, _0xc8d56d) {
      UI["userPreferences"]["preferences"]["sidebarOrder"]["indexOf"](_0x5ad3a4) == -1 && _0x5c057d.container["find"]("div[name=\"sidebarComponents\"]")["append"](_0xc8d56d), _0x5ad3a4 in UI["userPreferences"]["preferences"]["sidebarComponentsCollapsed"] && UI["userPreferences"]["preferences"]["sidebarComponentsCollapsed"][_0x5ad3a4] && _0x5c057d["containers"][_0x5ad3a4]["collapse"](), _0x5ad3a4 in UI["userPreferences"].preferences["sidebarComponentsHeight"] && _0x5c057d.containers[_0x5ad3a4]["setHeight"](UI.userPreferences.preferences.sidebarComponentsHeight[_0x5ad3a4]), $(_0x5c057d["containers"][_0x5ad3a4]).on("elementCollapsed", function (_0x2f6c89) {
        UI["userPreferences"].setSidebarComponentCollapsed(_0x2f6c89.id, true);
      }), $(_0x5c057d["containers"][_0x5ad3a4]).on("elementUncollapsed", function (_0x2ae059) {
        UI["userPreferences"]["setSidebarComponentCollapsed"](_0x2ae059.id, false);
      }), $(_0x5c057d.containers[_0x5ad3a4]).on("elementHeightChanged", function (_0x22c98d) {
        UI["userPreferences"]["setSidebarComponentHeight"](_0x22c98d.id, _0x22c98d["height"]);
      });
    }), this["container"].on(UI.pointerEvent("dragstart"), function (_0x23183e) {
      _0x23183e.preventDefault();
    }), this["container"]["find"](".sidebarOptions").on(UI["pointerEvent"]("click"), 'a[name="options"]', function (_0x326d22) {
      _0x326d22["preventDefault"](), _0x5c057d.toggleConfig();
    }), this["container"]["find"](".sidebarOptions").on(UI.pointerEvent("click"), "a[name=\"confirm\"]", function (_0x296f80) {
      _0x296f80["preventDefault"]();
      var _0x234fc5 = new Array();
      $["each"](_0x5c057d.sortable["getOrder"](), function (_0x5d679d, _0x21a1ea) {
        _0x5c057d["container"]["find"]("div[name=\"sidebarComponents\"]").append(_0x5c057d.containers[_0x21a1ea]["container"]), _0x234fc5["push"](_0x21a1ea);
      }), UI.userPreferences["setSidebarOrder"](_0x234fc5), _0x5c057d["hideConfig"]();
    }), this["container"].find(".sidebarOptions").on(UI["pointerEvent"]("click"), "a[name=\"cancel\"]", function (_0x271f84) {
      _0x271f84["preventDefault"](), _0x5c057d["hideConfig"]();
    }), $(this["colorWheel"]).on("colorChanged", function (_0x326618) {
      UI["colorChange"](_0x326618.color);
    }), $(this["layerPreview"]).on("layerOptionClicked", function (_0x1ba8cb) {
      if (_0x1ba8cb.id == "toggle") !UI.layerIsVisible(_0x1ba8cb["layer"]) ? (_0x5c057d["layerPreview"].showLayer(_0x1ba8cb["layer"]), room["board"]["layers"][_0x1ba8cb["layer"]]["show"]()) : (_0x5c057d["layerPreview"]["hideLayer"](_0x1ba8cb["layer"]), room["board"]["layers"][_0x1ba8cb["layer"]]["hide"]()); else {
        if (_0x1ba8cb.id == "clear") room.myself["surface"]["layerRequestAction"]("Cl", _0x1ba8cb["layer"]); else {
          if (_0x1ba8cb.id == "fliph") room.myself.surface["layerRequestAction"]("Flh", _0x1ba8cb["layer"]); else {
            if (_0x1ba8cb.id == "flipv") room.myself.surface["layerRequestAction"]("Flv", _0x1ba8cb["layer"]); else {
              if (_0x1ba8cb.id == "locktoggle") !UI.layerIsLocked(_0x1ba8cb.layer) ? room["myself"]["surface"].layerRequestAction("Lkl", _0x1ba8cb["layer"]) : room.myself["surface"]["layerRequestAction"]("Ukl", _0x1ba8cb["layer"]); else {
                if (_0x1ba8cb.id == "merge") _0x1ba8cb["layer"] != _0x1ba8cb["parameters"]["target"] && room["myself"]["surface"]["layerRequestAction"]("Mgl", _0x1ba8cb["layer"], _0x1ba8cb["parameters"]["target"]); else {
                  if (_0x1ba8cb.id == "select") room["myself"]["surface"]["setCurrentLayer"](_0x1ba8cb.layer); else _0x1ba8cb.id == "save" && UI.saveDialog["show"]("full", _0x1ba8cb["layer"]);
                }
              }
            }
          }
        }
      }
    }), $(this.colorBox).on("colorChanged", function (_0x2758fb) {
      UI.colorChange(_0x2758fb["color"]);
    }), $(this.presets).on("bubbleClicked", function (_0x197c68) {
      if (_0x197c68["etype"] == "load") {
        var _0x133247 = _0x197c68["obj"];
        UI["userPreferences"]["getGroupOption"]("presetload", "color", true) && room["myself"]["surface"].setColor(_0x133247.color);
        var _0x51d0f5 = UI["sidebar"].toolbar["isToolAvailable"](_0x133247.brush);
        _0x51d0f5 && UI["userPreferences"]["getGroupOption"]("presetload", "brush", true) && (room["myself"]["surface"].setBrush(_0x133247["brush"]), _0x133247.brush == "custom" && (UI["hasSetCustomBrush"] = true), UI["sidebar"]["toolbar"]["highlight"](_0x133247.brush));
        var _0x7db025 = {};
        $["each"](_0x133247.options, function (_0x1c7806, _0x3808ef) {
          var _0x9cd2a8 = UI["optionToObject"](_0x1c7806);
          UI["userPreferences"]["getGroupOption"]("presetload", _0x1c7806, true) && _0x9cd2a8 && _0x9cd2a8["isCompatible"](room["type"], room["board"]["nLayers"]) && (_0x7db025[_0x1c7806] = _0x3808ef);
        }), room["myself"].surface.setBrushOptions(_0x7db025);
      } else {
        if (_0x197c68["etype"] == "save") {
          var _0x45b534 = room["myself"]["surface"].getCurrentBrush(),
            _0x508780 = room["myself"].surface.getBrushesOptions(),
            _0x1f150e = {};
          $["each"](_0x508780[_0x45b534], function (_0x57a19f, _0x31b0ec) {
            _0x5c057d["presets"]["saveableOptions"].indexOf(_0x57a19f) > -1 && _0x31b0ec != undefined && (_0x1f150e[_0x57a19f] = _0x31b0ec);
          });
          var _0x133247 = new PresetBox(room["myself"].surface["drawColor"], _0x45b534, _0x1f150e);
          _0x5c057d["presets"]["saveBubble"](_0x133247, _0x197c68["number"]);
        }
      }
    }), this["container"]["find"](".sidebarAdvanced").on(UI.pointerEvent("over"), function (_0x108d90) {
      _0x5c057d.collapsed && setTimeout(function (_0x54806c) {
        _0x5c057d["container"].find(".sidebarAdvanced").is(":hover") && _0x5c057d["uncollapse"]();
      }, 450);
    }), this["container"]["find"](".sidebarBlock").on(UI["pointerEvent"]("click"), function (_0x6ba1ea) {
      _0x6ba1ea["preventDefault"](), _0x5c057d["uncollapse"]();
    }), UI["drawingArea"].on(UI.pointerEvent("over"), function (_0x4b3670) {
      !_0x5c057d["collapsed"] && !_0x5c057d["fixed"] && _0x5c057d.collapse();
    }), UI["drawingArea"].on(UI.pointerEvent("click"), function (_0x4dc960) {
      _0x4dc960["preventDefault"](), !_0x5c057d["collapsed"] && !_0x5c057d["fixed"] && _0x5c057d["collapse"]();
    }), this["container"]["find"]("#sidebarCollapse").on(UI.pointerEvent("click"), function (_0x2b2838) {
      _0x2b2838["preventDefault"](), _0x5c057d.fixed ? (_0x5c057d["fixed"] = false, _0x5c057d.changeCollapseIcon("notfixed")) : !_0x5c057d.collapsed ? (_0x5c057d["fixed"] = true, _0x5c057d["changeCollapseIcon"]("fixed")) : _0x5c057d["toggleCollapse"]();
    }), this.scrollbar = this["container"]["find"](".sidebarAdvanced")["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    })["overlayScrollbars"]();
  }
  ["toggleConfig"]() {
    this.showingConfig ? this["hideConfig"]() : this["showConfig"]();
  }
  ["showConfig"]() {
    var _0x4e5a74 = this,
      _0xc0411d = [];
    $.each(Object["keys"](this["containers"]), function (_0x27ecbf, _0x5807a0) {
      let _0x2ec7d7 = _0x4e5a74["containers"][_0x5807a0];
      _0xc0411d[_0x2ec7d7["container"]["index"]()] = _0x5807a0;
    }), _0x4e5a74.sortable["removeElements"](), $["each"](_0xc0411d, function (_0x535dc7, _0x2f0a78) {
      let _0x4ef7da = _0x4e5a74["containers"][_0x2f0a78];
      _0x4e5a74["sortable"]["addElement"](_0x2f0a78, _0x4ef7da["container"]["find"](".containerTitle span")["html"]());
    }), this["container"]["find"]("div[name=\"sidebarSortable\"]")["show"](), this["container"].find("div[name=\"sidebarComponents\"]")["hide"](), this["container"]["find"](".sidebarOptions").html("<a style=\"margin-right: 10px;\" name=\"confirm\" href=\"#\">" + new Icon("fa-check")["html"]() + " <span data-i18n=\"sidebar.btnConfirm\">Confirm</span></a> <a name=\"cancel\" href=\"#\">" + new Icon("fa-times")["html"]() + " <span data-i18n=\"sidebar.btnCancel\">Cancel</span></a><p data-i18n=\"sidebar.lblDragAndDrop\">Drag and drop to the desired position.</p>"), textManager["updateElement"](this["container"].find(".sidebarOptions")), this["showingConfig"] = true;
  }
  ["hideConfig"]() {
    this["container"]["find"]("div[name=\"sidebarSortable\"]")["hide"](), this["container"].find("div[name=\"sidebarComponents\"]")["show"](), this["container"]["find"](".sidebarOptions")["html"]('<a name="options" href="#">' + new Icon("fa-cog").html() + ' <span data-i18n="sidebar.btnRearrange">Rearrange</span></a>'), textManager["updateElement"](this.container["find"](".sidebarOptions")), this.showingConfig = false;
  }
  ["changeCollapseIcon"](_0x20a0ff) {
    var _0x58e5db;
    if (_0x20a0ff == "fixed") _0x58e5db = new Icon("fa-caret-square-down"); else {
      if (_0x20a0ff == "notfixed") _0x58e5db = new Icon("fa-caret-square-down", "far"); else _0x20a0ff == "uncollapse" && (_0x58e5db = new Icon("fa-angle-double-left"));
    }
    this.container["find"]("#sidebarCollapse").html(_0x58e5db["html"]());
  }
  ["set"](_0x3f225a = true, _0x1d6e61 = false) {
    this["fixed"] = _0x3f225a, _0x1d6e61 ? this["collapse"]() : this.uncollapse(), _0x3f225a && !_0x1d6e61 && this["changeCollapseIcon"]("fixed");
  }
  ["toggleCollapse"]() {
    this.collapsed ? this["uncollapse"]() : this.collapse();
  }
  ["hideComponent"](_0x26bd34) {
    this["containers"][_0x26bd34]["hide"]();
  }
  ["showComponent"](_0x13188b) {
    this["containers"][_0x13188b].show();
  }
  ["collapse"]() {
    this.collapsed = true, this["container"]["find"](".sidebarAdvanced")["addClass"]("disabled"), UI["content"]["addClass"]("active"), this["container"]["addClass"]("active"), this.container["find"](".sidebarBlock")["show"](), this["changeCollapseIcon"]("uncollapse"), $(this)["triggerHandler"](new sidebarCollapsedEvent().getEvent());
  }
  ["uncollapse"]() {
    this["collapsed"] = false, this["container"]["find"](".sidebarAdvanced")["removeClass"]("disabled"), UI["content"].removeClass("active"), this["container"].removeClass("active"), this.container["find"](".sidebarBlock")["hide"](), this["changeCollapseIcon"]("notfixed"), $(this)["triggerHandler"](new sidebarUncollapsedEvent().getEvent());
  }
  ["adaptToolbar"]() {
    var _0x3a1219 = this["container"]["find"](".toolbar"),
      _0xb63ce3 = _0x3a1219.find("#drawingTools a"),
      _0x2a061d = _0x3a1219["find"]("#sidebarCollapse")["height"]() + 5,
      _0x3639b5 = Math["min"]((_0x3a1219.height() - _0x2a061d) / _0xb63ce3["length"], 50);
    _0xb63ce3["css"]({
      height: _0x3639b5 + "px",
      "line-height": _0x3639b5 + "px"
    });
  }
}
class EmojiSelector extends UIComponent {
  constructor(_0x3ac60e) {
    super(_0x3ac60e), this["container"]["html"]('<div class="background"></div><div class="emojilist"><div class="categories"></div><div class="emojis"></div></div>'), this.container["addClass"]("emojiContainer"), this.maxRecent = 48, this["recentlyUsed"] = [], this["scroll"] = null, this["categories"] = {}, this["categories"]["recent"] = "", this["categories"]["smileys"] = "", this["categories"].animals = "", this["categories"]["transport"] = "", this["categories"]["food"] = "", this["categories"]["sports"] = "", this["categories"]["misc"] = "", this.categories["signs"] = "", this["emojis"] = {}, this.emojis["smileys"] = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], this["emojis"]["animals"] = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], this["emojis"]["transport"] = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], this["emojis"]["food"] = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], this["emojis"]["sports"] = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], this["emojis"]["misc"] = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], this["emojis"]["signs"] = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], this["loadCategories"]();
    var _0xaa19a = this;
    this["container"]["find"](".categories").on(UI.pointerEvent("click"), "a", function (_0x282ad4) {
      _0x282ad4["preventDefault"](), _0xaa19a["selectCategory"]($(this)["attr"]("name"));
    }), this["container"]["find"](".emojis").on(UI["pointerEvent"]("click"), "a", function (_0x32c733) {
      _0x32c733["preventDefault"](), _0xaa19a.selectEmoji($(this)["html"]()), $(this)["blur"]();
    }), this["container"]["find"](".background").on(UI["pointerEvent"]("click"), function (_0x1aaaed) {
      _0x1aaaed["preventDefault"](), _0xaa19a.hide();
    });
  }
  ["loadCategories"]() {
    this["container"]["find"](".categories")["empty"]();
    var _0x554435 = this;
    $["each"](this["categories"], function (_0x3f35bb, _0x2cf511) {
      _0x554435["container"]["find"](".categories")["append"]("<a href=\"#\" name=\"" + _0x3f35bb + '"><span>' + _0x2cf511 + "</span></a>");
    });
  }
  ["selectCategory"](_0x88710) {
    this["container"]["find"](".categories a").removeClass("selected"), this["container"].find(".categories a[name=\"" + _0x88710 + '"]').addClass("selected");
    var _0x416f27 = _0x88710 == "recent" ? this["recentlyUsed"] : this.emojis[_0x88710],
      _0x20bb3e = this,
      _0x3e3cc4 = "";
    $(_0x416f27)["each"](function (_0x393759, _0x21a92d) {
      _0x3e3cc4 += "<a href=\"#\">" + _0x21a92d + "</a>";
    });
    this["scroll"] && this["scroll"]["destroy"]();
    var _0x4ff41f = this["container"]["find"](".emojis");
    _0x4ff41f["html"](_0x3e3cc4), this["scroll"] = _0x4ff41f.overlayScrollbars({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    })["overlayScrollbars"](), this.scroll.scroll({
      y: "0%"
    });
  }
  ["selectEmoji"](_0x4bd08b) {
    this.addRecent(_0x4bd08b), $(this)["triggerHandler"](new emojiSelectedEvent(_0x4bd08b)["getEvent"]());
  }
  ["addRecent"](_0x265686) {
    var _0x5859ae = [];
    _0x5859ae["push"](_0x265686);
    for (var _0x537ee9 = 0; _0x537ee9 < Math["min"](this["recentlyUsed"]["length"], this["maxRecent"]); _0x537ee9++) {
      let _0x4ff105 = this.recentlyUsed[_0x537ee9];
      _0x4ff105 != _0x265686 && _0x5859ae["push"](_0x4ff105);
    }
    this["recentlyUsed"] = _0x5859ae, UI["userPreferences"]["setProperty"]("recentemojis", this["recentlyUsed"]);
  }
  ["move"](_0xef2a42, _0x566006) {
    this["container"]["find"](".emojilist")["css"]({
      left: _0xef2a42 + "px",
      top: _0x566006 + "px"
    });
  }
  ["getEmojiList"]() {
    var _0x65e40e = [],
      _0x3808da = this;
    return $.each(Object["keys"](this["emojis"]), function (_0x121fe0, _0x386714) {
      $["each"](_0x3808da["emojis"][_0x386714], function (_0x48db27, _0x1fdc40) {
        _0x65e40e["push"](_0x1fdc40);
      });
    }), _0x65e40e;
  }
  ["width"]() {
    return this["container"]["find"](".emojilist").width();
  }
  ["height"]() {
    return this["container"]["find"](".emojilist")["height"]();
  }
  ["isVisible"]() {
    return this.container["find"](".emojilist").is(":visible");
  }
  ["showCategory"](_0x99a2f3) {
    this["container"].find(".categories a[name=\"" + _0x99a2f3 + '"]')["show"]();
  }
  ["hideCategory"](_0x2274e2) {
    this["container"]["find"](".categories a[name=\"" + _0x2274e2 + '"]').hide();
  }
  ["show"]() {
    !this["isVisible"]() && (this.recentlyUsed = UI.userPreferences["getProperty"]("recentemojis", []), this.recentlyUsed["length"] > 0 ? (this["showCategory"]("recent"), this["selectCategory"]("recent")) : (this["hideCategory"]("recent"), this["selectCategory"]("smileys")), this["container"]["show"](), $(this)["triggerHandler"](new dialogOpenedEvent("EmojiSelector")["getEvent"]()));
  }
  ["hide"]() {
    this["container"].hide(), $(this).triggerHandler(new dialogClosedEvent("EmojiSelector")["getEvent"]());
  }
}
class UserTag extends UIComponent {
  constructor(_0x520101) {
    super(_0x520101), this.hovering = false, this.container["html"]('<div class="usertagList"><div class="usertags"></div></div>'), this["container"].addClass("userTagContainer"), this["scroll"] = this["container"]["find"](".usertagList")["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    })["overlayScrollbars"](), this["currentFilter"] = null;
    var _0x58027a = this;
    this["container"].on("click", ".usertags a", function (_0x4b289b) {
      _0x4b289b["preventDefault"](), _0x58027a.select($(this)["data"]("id")), _0x58027a["accept"]();
    }), $(this["container"]).on(UI["pointerEvent"]("over"), function (_0xac8839) {
      _0x58027a["hovering"] = true;
    }), $(this["container"]).on(UI["pointerEvent"]("out"), function (_0x4583ec) {
      _0x58027a["hovering"] = false;
    }), this["hide"]();
  }
  ["isHovering"]() {
    return this["hovering"];
  }
  ["select"](_0xe03828) {
    this["container"]["find"]("a")["removeClass"]("selected"), this.container["find"]("a[data-id=\"" + _0xe03828 + '"]')["addClass"]("selected"), this["scroll"]["scroll"]({
      el: this["container"]["find"]("a.selected"),
      scroll: {
        y: "ifneeded",
        x: "never"
      }
    }, 100);
  }
  ["move"](_0x52f04e, _0x5c72e6) {
    this.container["find"](".usertagList").css({
      left: _0x52f04e + "px",
      bottom: _0x5c72e6 + "px",
      top: "unset"
    });
  }
  ["setHeight"](_0x15afe6) {
    this["container"].find(".usertagList").css("height", _0x15afe6);
  }
  ["setWidth"](_0x2bf825) {
    this.container.find(".usertagList")["css"]("width", _0x2bf825);
  }
  ["width"]() {
    return this["container"]["find"](".usertagList")["width"]();
  }
  ["height"]() {
    return this.container["find"](".usertagList")["height"]();
  }
  ["isVisible"]() {
    return this["container"].is(":visible");
  }
  ["up"]() {
    var _0x3dd82e = this["container"]["find"](".usertagList .selected"),
      _0x305582 = _0x3dd82e["prev"]();
    _0x305582["length"] == 0 && (_0x305582 = _0x3dd82e["siblings"](":last")), this["select"](_0x305582["data"]("id"));
  }
  ["down"]() {
    var _0x5ee2e4 = this["container"]["find"](".usertags .selected"),
      _0x30e273 = _0x5ee2e4["next"]();
    _0x30e273["length"] == 0 && (_0x30e273 = _0x5ee2e4["siblings"](":first")), this["select"](_0x30e273["data"]("id"));
  }
  ["accept"]() {
    var _0x324382 = this["container"].find(".usertags .selected")["data"]("id");
    _0x324382 && $(this)["triggerHandler"](new userTaggedEvent(_0x324382, this["currentFilter"]).getEvent());
  }
  ["filter"](_0x43f34f = "") {
    if (this["currentFilter"] != _0x43f34f) {
      this["currentFilter"] = _0x43f34f;
      var _0x4a6c6b = [];
      $["each"](room["users"], function (_0x1717ac, _0x48f94d) {
        _0x4a6c6b.push({
          username: _0x48f94d["username"],
          rank: _0x48f94d["rank"]
        });
      }), _0x4a6c6b.sort((_0x1057a9, _0x26f3b3) => _0x1057a9["username"]["localeCompare"](_0x26f3b3["username"])), this["container"].find(".usertags a")["remove"]();
      var _0x3fdbc1 = this;
      $["each"](_0x4a6c6b, function (_0x828729, _0x3a264a) {
        _0x3fdbc1["matches"](_0x43f34f, _0x3a264a.username) && _0x3fdbc1["container"]["find"](".usertags").append('<a class="' + UI["rankToStyle"](_0x3a264a["rank"]) + "\" data-id=\"" + _0x3a264a.username + "\" href=\"#\">" + _0x3a264a["username"] + "</a>");
      }), this["container"]["find"](".usertags a:first-child").addClass("selected"), this["setHeight"](_0x3fdbc1["container"].find(".usertags")["outerHeight"]() + 10);
    }
    this["container"]["find"](".usertags a")["length"] == 0 && this.hide();
  }
  ["userlistChanged"]() {
    this["currentFilter"] = null;
  }
  ["matches"](_0x1bd4d6, _0x44e4a5) {
    return _0x44e4a5.toLowerCase()["includes"](_0x1bd4d6.toLowerCase());
  }
  ["show"](_0x5027d7 = "") {
    !this["isVisible"]() && (this["container"].show(), this["filter"](_0x5027d7));
  }
  ["hide"]() {
    this.container["hide"]();
  }
}
class ProgressBar extends UIComponent {
  constructor(_0x3cd166) {
    super(_0x3cd166), this["bar"] = $("<div />"), this["bar"]["addClass"]("bar"), this["container"]["html"](this.bar), this["container"].addClass("fmProgressBar");
  }
  ["setProgress"](_0x1b2e73) {
    this.bar.css("width", _0x1b2e73 + "%");
  }
  ["show"]() {
    this.container["show"]();
  }
  ["hide"]() {
    this["container"].hide();
  }
}
class RadialMenu extends UIComponent {
  constructor(_0x47f185) {
    super(_0x47f185), this["position"] = new Point(0, 0), this["visible"] = true, this.pressedButton, this["menu"] = $("<ul />"), this.menu["addClass"]("radialmenu"), this["background"] = $("<ul />"), this["background"]["addClass"]("radialmenu radialbackground"), this["addCenter"]();
    var _0x3d9e63 = this;
    this.menu.on(UI["pointerEvent"]("click"), "li a", function (_0x1a4cbd) {
      _0x1a4cbd["preventDefault"](), $(_0x3d9e63)["triggerHandler"](new buttonPressedEvent($(this)["attr"]("name"), $(_0x1a4cbd["target"]))["getEvent"]());
    }), this["menu"].on(UI["pointerEvent"]("down"), "li a", function (_0x51fd76) {
      _0x51fd76.preventDefault(), _0x3d9e63.pressedButton = $(this)["attr"]("name");
    }), $(document).on(UI["pointerEvent"]("up"), function (_0xbc84c1) {
      _0x3d9e63["pressedButton"] && (_0x3d9e63["pressedButton"] = null);
    }), $(document).on(UI["pointerEvent"]("move", "radialMenu"), function (_0x4fd0fc) {
      if (_0x3d9e63["pressedButton"]) {
        var _0x5a6422 = UI["getInputPosition"](_0x4fd0fc);
        $(_0x3d9e63).triggerHandler(new penMoveEvent(_0x5a6422.x, _0x5a6422.y).getEvent());
      }
    }), this.container["empty"](), this["container"]["append"](this["background"]), this["container"].append(this["menu"]);
  }
  ["clearOptions"]() {
    this["menu"]["empty"]();
  }
  ["addCenter"]() {
    this["menu"].append("<li class=\"center\"></a></li>"), this["background"]["append"]('<li class="center"></a></li>');
  }
  ["addOption"](_0x141dfd, _0x4214ee) {
    this["menu"]["append"]('<li class="portion"><a href="#" name="' + _0x141dfd + "\"><span>" + _0x4214ee + "</span></a></li>"), this["background"]["append"]("<li class=\"portion\"><a href=\"#\" name=\"" + _0x141dfd + "\"></a></li>");
  }
  ["setSlider"](_0x301f48, _0x47a621) {
    var _0x1570cc = 535 - Math["max"](Math["min"](_0x47a621, 100), 0) / 100 * 285;
    this["background"]["find"]('a[name="' + _0x301f48 + '"]')["css"]({
      width: _0x1570cc + "px",
      height: _0x1570cc + "px"
    });
  }
  ["move"](_0x394964, _0x3baf93) {
    var _0x3f27c4 = this["menu"].width(),
      _0x18bf7d = this.menu["height"]();
    this["position"].x = _0x394964 - _0x3f27c4 / 2, this["position"].y = _0x3baf93 - _0x18bf7d / 2, this.container["css"]({
      left: this.position.x,
      top: this.position.y
    });
  }
  ["isVisible"]() {
    return this["container"].is(":visible");
  }
  ["show"]() {
    this["container"]["fadeIn"](100), this["visible"] = true;
    if (room && room.myself) {
      var _0x247f36 = this;
      $(room["myself"].surface).on("brushOptionChanged.radialMenu", function (_0x299b85) {
        _0x299b85.option == "size" && _0x247f36.visible && _0x247f36["setSlider"]("size", _0x299b85.value * 100 / room["myself"]["surface"]["maxSize"]);
      });
    }
  }
  ["hide"]() {
    this["container"].fadeOut(100), this["visible"] = false, room && room["myself"] && $(room["myself"]["surface"])["off"](".radialMenu");
  }
  ["toggle"]() {
    this["isVisible"]() ? this["hide"]() : this["show"]();
  }
}
class NumericInput extends UIComponent {
  constructor(_0x18db48, _0x3020f7 = 0, _0x538995 = null, _0x2b4544 = null, _0x383961 = null, _0x284a2f = "numericinput") {
    super(_0x18db48);
    !this["container"]["hasClass"]("fmNumericInput") && this["container"]["addClass"]("fmNumericInput");
    this["namespace"] = _0x284a2f, this.container["html"]("\n\t\t\t<div class=\"input-group\">\n\t\t\t\t<input type=\"text\" class=\"form-control big-input\" name=\"number\">" + (_0x383961 != null ? '<span class="input-group-text darkInput">' + _0x383961 + "</span>" : "") + "<button class=\"btn darkInput\" type=\"button\" name=\"increase\">+</button>\n\t\t\t\t<button class=\"btn darkInput\" type=\"button\" name=\"decrease\">-</button>\n\t\t\t</div>"), this["input"] = this["container"]["find"]("input"), this["input"]["val"](_0x3020f7), this.min = _0x538995, this["max"] = _0x2b4544;
    var _0x292c8e = this;
    this["input"].on(UI["pointerEvent"]("click", this["namespace"]), function (_0x19626c) {
      _0x19626c["preventDefault"](), UI["setFocusElement"](_0x292c8e);
    }), this["input"].on("focusout." + this["namespace"], function (_0xad8e26) {
      !$["isNumeric"](_0x292c8e.getValue()) ? _0x292c8e.change(_0x292c8e.min) : _0x292c8e["change"](_0x292c8e["getValue"]());
    }), this.input.on("keydown." + this["namespace"], function (_0x5103aa) {
      let _0x239a57 = _0x5103aa["which"] || _0x5103aa["keyCode"];
      if (!(_0x239a57 == 8 || _0x239a57 == 37 || _0x239a57 == 38 || _0x239a57 == 39 || _0x239a57 == 40) && (!(_0x239a57 >= 48 && _0x239a57 <= 57 || _0x239a57 >= 96 && _0x239a57 <= 105) || _0x292c8e["readOnly"])) return _0x5103aa.stopPropagation(), _0x5103aa.preventDefault(), false;
    }), this["input"].on("keyup." + this.namespace, function (_0x3bbf22) {
      if (!_0x292c8e.readOnly) {
        if ((_0x3bbf22.which || _0x3bbf22.keyCode) >= 48 && (_0x3bbf22.which || _0x3bbf22.keyCode) <= 57 || (_0x3bbf22.which || _0x3bbf22.keyCode) >= 96 && (_0x3bbf22.which || _0x3bbf22.keyCode) <= 105) {
          if (_0x292c8e["getValue"]() > _0x292c8e["max"]) _0x292c8e.change(_0x292c8e.max); else {
            if (_0x292c8e["getValue"]() < _0x292c8e["min"]) _0x292c8e["change"](_0x292c8e["min"]); else return true;
          }
        }
      }
      return false;
    }), this.container["find"]("button").on(UI["pointerEvent"]("click", this["namespace"]), function (_0xd65508) {
      _0xd65508["preventDefault"](), $(this).attr("name") == "increase" ? _0x292c8e["increase"]() : _0x292c8e["decrease"](), UI.setFocusElement(_0x292c8e);
    }), $(this).on("componentEnabled componentDisabled", function (_0x21e125) {
      _0x21e125["type"] == "componentDisabled" ? _0x292c8e["input"]["attr"]("disabled", "disabled") : _0x292c8e.input.removeAttr("disabled"), UI.setFocusElement(_0x292c8e);
    });
  }
  ["increase"]() {
    var _0x5a7261 = this["getValue"]();
    !$["isNumeric"](_0x5a7261) && (_0x5a7261 = this["min"]), (!this["max"] || _0x5a7261 + 1 <= this.max) && this["change"](_0x5a7261 + 1);
  }
  ["decrease"]() {
    var _0x3c3ff3 = this["getValue"]();
    !$["isNumeric"](_0x3c3ff3) && (_0x3c3ff3 = this.max), (!this.min || _0x3c3ff3 - 1 >= this.min) && this.change(_0x3c3ff3 - 1);
  }
  ["change"](_0x120d09) {
    !this["readOnly"] && this.setValue(_0x120d09);
  }
  ["setValue"](_0x1d5424) {
    this.input["val"](_0x1d5424);
  }
  ["getValue"]() {
    return parseInt(this["input"]["val"]());
  }
  ["keyPress"](_0x332822) {
    if (_0x332822 == 39 || _0x332822 == 38) this["increase"](); else (_0x332822 == 37 || _0x332822 == 40) && this["decrease"]();
  }
  ["destroy"]() {
    this.input["off"]("." + this["namespace"]), this.container["off"]("." + this.namespace), this["container"]["empty"]();
  }
  ["focus"]() {
    this.input.focus();
  }
}
class Selector extends UIComponent {
  constructor(_0x3c25d3, _0xb349d7, _0x286170, _0xccc2de = "selector") {
    super(_0x3c25d3);
    !this["container"]["hasClass"]("fmSelector") && this["container"]["addClass"]("fmSelector");
    this["namespace"] = _0xccc2de, this["list"] = _0xb349d7;
    var _0x41cbc1 = this;
    $["each"](Object["keys"](_0xb349d7), function (_0x26f43f, _0x543281) {
      let _0x53763f = _0xb349d7[_0x543281],
        _0x372200 = $("<a />");
      _0x372200["attr"]("href", "#"), _0x372200.attr("name", _0x543281), _0x372200["html"](_0x53763f), _0x372200.addClass("btn"), _0x372200["css"]("width", 100 / Object["keys"](_0xb349d7)["length"] + "%"), _0x41cbc1["container"]["append"](_0x372200);
    }), this["container"]["find"]("a").on(UI.pointerEvent("click", _0xccc2de), function (_0x38282d) {
      _0x38282d.preventDefault(), (!_0x38282d["which"] || _0x38282d.which == 1) && !_0x41cbc1["isReadOnly"] && (_0x41cbc1["select"]($(this)["attr"]("name")), UI["setFocusElement"](_0x41cbc1));
    }), this["select"](_0x286170);
  }
  ["select"](_0x1dff94) {
    this.container["find"]("a.selected")["removeClass"]("selected"), this["container"]["find"]('a[name="' + _0x1dff94 + '"]')["addClass"]("selected"), $(this)["triggerHandler"](new optionSelectedEvent(_0x1dff94)["getEvent"]());
  }
  ["getSelected"]() {
    return this.container["find"]("a.selected")["attr"]("name");
  }
  ["keyPress"](_0x424048) {
    if (_0x424048 == 39 || _0x424048 == 38) {
      let _0x25a6f2 = Object.keys(this["list"]),
        _0x4856aa = _0x25a6f2["indexOf"](this["getSelected"]()) + 1;
      _0x4856aa < _0x25a6f2.length && this["select"](_0x25a6f2[_0x4856aa]);
    } else {
      if (_0x424048 == 37 || _0x424048 == 40) {
        let _0x19a4af = Object["keys"](this["list"]),
          _0x1a6f62 = _0x19a4af["indexOf"](this["getSelected"]()) - 1;
        _0x1a6f62 >= 0 && this["select"](_0x19a4af[_0x1a6f62]);
      }
    }
  }
  ["destroy"]() {
    this["container"].off("." + this["namespace"]), this["container"].empty();
  }
  ["focus"]() {
    UI["setFocusElement"](this);
  }
}
class SortableList extends UIComponent {
  constructor(_0x1ac971, _0x472d37 = "sortablelist") {
    super(_0x1ac971), this["area"] = $("<div />"), this["area"]["addClass"]("sortableArea"), this["container"]["append"](this["area"]), this["elementCount"] = 0, this.isDraggingElement = false, this["movingElement"] = $("<div />"), this["movingElement"]["addClass"]("movingElement"), this["movingElement"]["hide"](), $(".appMain").append(this["movingElement"]);
    !this["container"]["hasClass"]("fmSortableList") && this["container"]["addClass"]("fmSortableList");
    var _0x1e30c7 = this;
    this.area.on(UI["pointerEvent"]("down"), ".sortableElement", function (_0x97337c) {
      if (!_0x97337c["which"] || _0x97337c.which == 1) {
        var _0x40821c = $(this);
        _0x40821c["addClass"]("selection");
        var _0x3543ef = UI["getInputPosition"](_0x97337c);
        _0x1e30c7["movingElement"]["html"](_0x40821c["html"]()), _0x1e30c7["movingElement"]["css"]({
          left: _0x3543ef.x,
          top: _0x3543ef.y,
          color: _0x40821c["css"]("color")
        }), _0x1e30c7["isDraggingElement"] = true, _0x1e30c7["movingElement"]["data"]("order", _0x40821c["data"]("order")), _0x1e30c7["movingElement"]["show"]();
        if (_0x40821c["data"]("order") != 0) {
          var _0x2b281f = _0x1e30c7["area"].find(".sortableElement:first"),
            _0x15b095 = $("<div />");
          _0x15b095.addClass("targetBlock"), _0x15b095.data("afterOrder", -1), _0x15b095["insertBefore"](_0x2b281f);
        }
        _0x1e30c7["area"]["addClass"]("isDragging"), _0x1e30c7["area"]["find"](".sortableElement")["each"](function (_0x137c0e, _0x5c8b40) {
          if ($(_0x5c8b40)["data"]("order") != _0x40821c["data"]("order") && $(_0x5c8b40)["data"]("order") != _0x40821c["data"]("order") - 1) {
            var _0xa25977 = $("<div />");
            _0xa25977["addClass"]("targetBlock"), _0xa25977["data"]("afterOrder", $(_0x5c8b40)["data"]("order")), _0xa25977["insertAfter"](_0x5c8b40);
          }
        });
      }
    }), $(document).on(UI["pointerEvent"]("move"), function (_0x25de48) {
      if (_0x1e30c7.isDraggingElement) {
        var _0x12b472 = UI["getInputPosition"](_0x25de48);
        _0x1e30c7["movingElement"].css({
          left: _0x12b472.x,
          top: _0x12b472.y
        });
      }
      var _0x2de020 = _0x1e30c7["area"].find(".targetBlock");
      $["each"](_0x2de020, function (_0x350860, _0x418d0a) {
        var _0x4a83c6 = $(_0x418d0a),
          _0x347cf1 = _0x4a83c6["offset"](),
          _0x44e823 = _0x4a83c6["height"](),
          _0x513c26 = _0x4a83c6["width"]();
        _0x12b472.y >= _0x347cf1["top"] && _0x12b472.y <= _0x347cf1["top"] + _0x44e823 && _0x12b472.x >= _0x347cf1.left && _0x12b472.y <= _0x347cf1["left"] + _0x513c26 && !_0x4a83c6["hasClass"]("active") && (_0x2de020.removeClass("active"), _0x4a83c6["addClass"]("active"));
      });
    }), $(document).on(UI.pointerEvent("up"), function (_0x162d9a) {
      if (_0x1e30c7["isDraggingElement"]) {
        var _0x229ebb = _0x1e30c7["area"]["find"](".targetBlock.active")["data"]("afterOrder");
        if (_0x229ebb !== undefined) {
          var _0x3bb4a1 = _0x1e30c7["area"]["find"](".sortableElement").filter(function () {
            return $(this)["data"]("order") == _0x1e30c7["movingElement"].data("order");
          });
          _0x1e30c7.move(_0x3bb4a1, _0x229ebb);
        }
        _0x1e30c7["isDraggingElement"] = false, _0x1e30c7["movingElement"]["hide"](), _0x1e30c7["area"]["removeClass"]("isDragging"), _0x1e30c7["area"]["find"](".selection")["removeClass"]("selection"), _0x1e30c7.area["find"](".targetBlock")["remove"]();
      }
    }), this["area"].on(UI["pointerEvent"]("over"), ".targetBlock", function (_0x33ede9) {
      $(this)["addClass"]("active");
    }), this["area"].on(UI["pointerEvent"]("out"), ".targetBlock", function (_0x4be96e) {
      $(this).removeClass("active");
    });
  }
  ["move"](_0x50a622, _0x17a443) {
    if (_0x17a443 == -1) {
      var _0x322f6a = this.area.find(".sortableElement")["filter"](function () {
        return $(this).data("order") == 0;
      });
      _0x50a622["insertBefore"](_0x322f6a);
    } else {
      var _0x322f6a = this["area"]["find"](".sortableElement").filter(function () {
        return $(this)["data"]("order") == _0x17a443;
      });
      _0x50a622["insertAfter"](_0x322f6a);
    }
    this["reorder"]();
  }
  ["reorder"]() {
    var _0x3145b5 = 0;
    this["area"]["find"](".sortableElement")["each"](function (_0x599315, _0x5a0744) {
      $(_0x5a0744)["data"]("order", _0x3145b5++);
    });
  }
  ["getOrder"]() {
    var _0x372f70 = [];
    return this["area"]["find"](".sortableElement")["each"](function (_0x2480b3, _0x506825) {
      _0x372f70[$(_0x506825).data("order")] = $(_0x506825)["data"]("id");
    }), _0x372f70;
  }
  ["addElement"](_0x1a616a, _0x21ea24) {
    var _0x52c46e = $("<div />");
    _0x52c46e["html"](_0x21ea24), _0x52c46e["addClass"]("sortableElement"), _0x52c46e["data"]("order", this["elementCount"]), _0x52c46e["data"]("id", _0x1a616a), this["elementCount"]++, this["area"]["append"](_0x52c46e);
  }
  ["removeElements"]() {
    this["elementCount"] = 0, this["area"]["empty"]();
  }
  ["destroy"]() {
    this["movingElement"]["remove"](), this["area"].empty();
  }
}
class Captcha extends UIComponent {
  constructor(_0x3a0c72) {
    super(_0x3a0c72), this["code"] = 0, this["canvas"] = $("<canvas />"), this["canvas"].attr("width", 200), this["canvas"]["attr"]("height", 35), this["newCode"]();
  }
  ["clear"]() {
    var _0x5c2ea8 = this.canvas[0]["getContext"]("2d");
    _0x5c2ea8["clearRect"](0, 0, _0x5c2ea8["canvas"]["width"], _0x5c2ea8.canvas.height);
  }
  ["newCode"]() {
    this.clear(), this.code = this.generate(6);
    var _0x421201 = this.canvas[0]["getContext"]("2d");
    _0x421201["textBaseline"] = "top", _0x421201["textAlign"] = "center", _0x421201.font = "30px Arial", _0x421201["fillStyle"] = "#069", _0x421201["fillText"](this["code"], _0x421201["canvas"]["width"] / 2 + Math["random"](-5, 5), Math["random"](2, 8));
  }
  ["generate"](_0xcf0f4 = 6) {
    var _0x3f8b13 = "",
      _0xa0c5da = "ABCDEFGHJKLMNPRSTWXYZ23456789",
      _0x1a57e1 = _0xa0c5da["length"];
    for (var _0x38c932 = 0; _0x38c932 < _0xcf0f4; _0x38c932++) {
      _0x3f8b13 += _0xa0c5da["charAt"](Math["floor"](Math.random() * _0x1a57e1));
    }
    return _0x3f8b13;
  }
  ["verify"](_0x54a972) {
    return _0x54a972.toUpperCase() == this["code"]["toUpperCase"]();
  }
}
class ColorSelector extends UIComponent {
  constructor(_0x2f7ea7, _0x4de2cd, _0x4c5bc5 = "colorselector") {
    super(_0x2f7ea7);
    !this["container"]["hasClass"]("fmColorSelector") && this["container"]["addClass"]("fmColorSelector");
    this["namespace"] = _0x4c5bc5, this["current"] = _0x4de2cd, this["preview"] = $("<div />"), this["preview"].addClass("w-100 p-0 m-0"), this.set(_0x4de2cd), this["container"]["html"](this.preview);
    var _0x570198 = this;
    this["preview"].on("click." + this["namespace"], function (_0x65bfcb) {
      $(UI.colorDialog).on("colorChanged.colorbox", function (_0x40ad72) {
        _0x570198["set"](_0x40ad72["color"]), $(UI["colorDialog"])["off"](".colorbox");
      }), $(UI["colorDialog"]).on("dialogClosed.colorbox", function (_0xe343de) {
        $(UI["colorDialog"])["off"](".colorbox");
      });
    });
  }
  ["set"](_0x513ec9) {
    this["preview"]["css"]("background-color", _0x513ec9), this["selected"](_0x513ec9);
  }
  ["selected"](_0x14bd04) {
    this["current"] = _0x14bd04, $(this).triggerHandler(new colorChangedEvent(_0x14bd04)["getEvent"]()), UI["setFocusElement"](this);
  }
  ["destroy"]() {
    this["preview"].off("." + this["namespace"]), this["container"]["empty"]();
  }
}
class AlertManager extends UIComponent {
  constructor(_0x431cb5) {
    super(_0x431cb5), this["leftSide"] = true, this["alertWidth"] = 300, this["alertMarginSide"] = 20, this.alertMarginTop = 20;
  }
  ["changeSide"](_0x56c887 = true) {
    this["leftSide"] = _0x56c887, _0x56c887 ? this["container"]["find"](".alertMessage").css({
      left: this["alertMarginSide"] + "px",
      right: "unset"
    }) : this["container"]["find"](".alertMessage")["css"]({
      right: this["alertMarginSide"] + "px",
      left: "unset"
    });
  }
  ["numberAlerts"]() {
    return this["container"]["find"](".alertMessage")["length"];
  }
  ["totalHeight"]() {
    var _0x29da80 = 0;
    return $["each"](this["container"]["find"](".alertMessage"), function (_0xfbc50b, _0x3a220f) {
      _0x29da80 += $(_0x3a220f)["height"]();
    }), _0x29da80;
  }
  ["showAlert"](_0x536129, _0x1fd63e = 4) {
    var _0xeebbde = this["numberAlerts"](),
      _0x242521 = this["totalHeight"](),
      _0x3e2a86 = $("<div class=\"alertMessage\"><div class=\"alertProgress\"></div><p></p></div></div>");
    this.container.append(_0x3e2a86), _0x3e2a86["find"]("p")["html"](_0x536129);
    var _0x47d465 = _0xeebbde * this["alertMarginTop"] + _0x242521;
    _0x3e2a86["css"]({
      top: _0x47d465 + "px",
      left: -this.alertWidth + "px",
      width: this["alertWidth"],
      opacity: "0"
    });
    !this.leftSide && _0x3e2a86["css"]({
      left: "unset",
      right: -this.alertWidth + "px"
    });
    _0x3e2a86["show"]();
    this["leftSide"] ? _0x3e2a86["animate"]({
      left: this.alertMarginSide,
      opacity: 1
    }, 500) : _0x3e2a86["animate"]({
      right: this["alertMarginSide"],
      opacity: 1
    }, 500);
    var _0x26e424 = Math["round"](new Date()["getTime"]() / 1e3);
    _0x3e2a86["data"]("alertOpenedSince", _0x26e424), _0x3e2a86["data"]("alertOpenUntil", _0x26e424 + _0x1fd63e * 1e3);
    var _0x4f2b95 = this;
    setTimeout(function (_0x77a3c4) {
      _0x4f2b95["progressAlert"](_0x3e2a86);
    }, 10);
  }
  ["progressAlert"](_0xf00c97) {
    var _0x136755 = Math["round"](new Date()["getTime"]() / 1e3),
      _0x2b319d = (_0xf00c97["data"]("alertOpenUntil") - parseInt(_0xf00c97["data"]("alertOpenedSince"))) / 1e3,
      _0x22b370 = _0x136755 - parseInt(_0xf00c97.data("alertOpenedSince")),
      _0xf9f4fa = _0x22b370 * 100 / _0x2b319d;
    _0xf00c97["find"](".alertProgress").css("width", _0xf9f4fa + "%");
    if (_0xf9f4fa <= 100) {
      var _0x100093 = this;
      setTimeout(function (_0x5054a0) {
        _0x100093["progressAlert"](_0xf00c97);
      }, 500);
    } else this["hideAlert"](_0xf00c97);
  }
  ["removeGaps"]() {
    var _0x371a47 = this,
      _0x29d035 = 0;
    $["each"](this["container"].find(".alertMessage"), function (_0x80d3e3, _0x74f812) {
      var _0x198970 = _0x80d3e3 * _0x371a47["alertMarginTop"] + _0x29d035;
      $(_0x74f812)["animate"]({
        top: _0x198970 + "px"
      }, 250), _0x29d035 += $(_0x74f812)["height"]();
    });
  }
  ["hideAlert"](_0x1dd359) {
    var _0x4199f6 = this;
    _0x1dd359["fadeOut"](250, function () {
      $(this)["remove"](), _0x4199f6["removeGaps"]();
    });
  }
}
class PIP extends UIComponent {
  constructor(_0x38ec9b) {
    super(_0x38ec9b), this["marker"] = $("<div />"), this["marker"]["addClass"]("pipMarker"), this["container"]["append"](this["marker"]);
  }
  ["show"](_0x11392b, _0x1dd984) {
    var _0x2ba50a = this;
    this["container"]["find"](".thumb")["remove"](), this["container"]["css"]("background-color", _0x1dd984), $.each(_0x11392b, function (_0x52c789, _0x1b14cd) {
      var _0x214ad0 = new Image();
      _0x214ad0["src"] = _0x1b14cd, $(_0x214ad0)["addClass"]("thumb"), _0x2ba50a["container"]["append"](_0x214ad0);
    }), this["container"]["show"]();
  }
  ["hide"]() {
    this["container"]["hide"]();
  }
  ["setView"](_0x44f3a8, _0x1ce03e, _0x3fb5f0, _0x3d2532, _0x4e8c58, _0x3b4a0a) {
    var _0x37c48f = room["board"].canvasHeight / 90;
    this["container"].css({
      scale: 1,
      width: room["board"]["canvasWidth"] / _0x37c48f,
      height: room["board"].canvasHeight / _0x37c48f
    }), this.marker["css"]({
      left: parseInt(_0x44f3a8 / _0x37c48f),
      top: parseInt(_0x1ce03e / _0x37c48f),
      width: parseInt(_0x3fb5f0 / _0x37c48f / _0x4e8c58),
      height: parseInt(_0x3d2532 / _0x37c48f / _0x4e8c58),
      transform: "rotate(" + -_0x3b4a0a + "deg)",
      "transform-origin": "top left"
    });
  }
  ["isVisible"]() {
    return this["container"].is(":visible");
  }
}
class DialogHandler {
  constructor(_0x855d21, _0x4df9fd, _0xc9832a) {
    this["block"] = null, this.container = _0x855d21, this.confirmationContainer = _0x4df9fd, this["alertManager"] = new AlertManager(_0xc9832a), this["alertOpenedSince"], this.alertOpenUntil, this["activeDialog"] = null, this["openedDialogs"] = 0, this["zindex"] = 10001, this["dialogs"] = {}, this["resizeBorder"] = $("<div />"), this["resizeBorder"]["addClass"]("resizeBorder"), this.container["append"](this["resizeBorder"]);
    var _0x5a6b74 = this;
    this["confirmationContainer"].contextmenu(function (_0x3dad11) {
      _0x3dad11["preventDefault"]();
    }), $(UI).on("windowResizingStarted", function (_0x5a48a9) {
      _0x5a6b74.activeDialog && _0x5a6b74["activeDialog"].onWindowResize(true);
    }), $(UI).on("windowResizingEnded", function (_0x4269a0) {
      _0x5a6b74.activeDialog && (_0x5a6b74["activeDialog"].onWindowResize(false), _0x5a6b74["activeDialog"].outOfBounds() && _0x5a6b74["activeDialog"]["center"]());
    });
  }
  ["blockBackground"](_0xa05fa9 = "blockdefault", _0x45e266 = 1) {
    this["block"] == null && (this["block"] = $("<div />"), this["block"].addClass("blockscreen fullscreen " + _0xa05fa9), this.block["contextmenu"](function (_0x31bd8d) {
      _0x31bd8d["preventDefault"]();
    }), this["block"]["css"]({
      opacity: _0x45e266,
      "z-index": -1
    }), this["container"]["prepend"](this.block));
  }
  ["unblockBackground"]() {
    this["block"] != null && (this["block"]["remove"](), this["block"] = null);
  }
  ["createDialog"](_0x145886) {
    var _0x47f1e4 = this,
      _0x6bbf75;
    if (_0x145886 == "login") _0x6bbf75 = new LoginDialog(this["container"], _0x145886); else {
      if (_0x145886 == "config") _0x6bbf75 = new ConfigDialog(this["container"], _0x145886); else {
        if (_0x145886 == "chat") _0x6bbf75 = new ChatDialog(this["container"], _0x145886); else {
          if (_0x145886 == "undo") _0x6bbf75 = new UndoDialog(this.container, _0x145886); else {
            if (_0x145886 == "roommanager") _0x6bbf75 = new RoomManagerDialog(this.container, _0x145886); else {
              if (_0x145886 == "save") _0x6bbf75 = new SaveDialog(this["container"], _0x145886); else {
                if (_0x145886 == "upload") _0x6bbf75 = new UploadDialog(this["container"], _0x145886); else {
                  if (_0x145886 == "brushdesigner") _0x6bbf75 = new BrushDesignerDialog(this["container"], _0x145886); else {
                    if (_0x145886 == "brushgallery") _0x6bbf75 = new BrushGalleryDialog(this.container, _0x145886); else {
                      if (_0x145886 == "debug") _0x6bbf75 = new DebugDialog(this.container, _0x145886); else {
                        if (_0x145886 == "profile") _0x6bbf75 = new ProfileDialog(this.container, _0x145886); else {
                          if (_0x145886 == "color") _0x6bbf75 = new ColorDialog(this["container"], _0x145886); else {
                            if (_0x145886 == "help") _0x6bbf75 = new HelpDialog(this.container, _0x145886); else {
                              if (_0x145886 == "mods") _0x6bbf75 = new ModsDialog(this.container, _0x145886); else {
                                // if (_0x145886 == "socketmod") _0x6bbf75 = new SocketModDialog(this.container, _0x145886); else {
                                  if (_0x145886 == "adminconsole") _0x6bbf75 = new AdminConsoleDialog(this["container"], _0x145886); else {
                                    if (_0x145886 == "feedback") _0x6bbf75 = new FeedbackDialog(this.container, _0x145886); else {
                                      if (_0x145886 == "animation") _0x6bbf75 = new AnimationDialog(this.container, _0x145886); else {
                                        if (_0x145886 == "messenger") _0x6bbf75 = new MessengerDialog(this["container"], _0x145886); else {
                                          if (_0x145886 == "galleryimage") _0x6bbf75 = new GalleryImageDialog(this["container"], _0x145886); else _0x145886 == "usergallery" && (_0x6bbf75 = new UserGalleryDialog(this["container"], _0x145886));
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    // }
    return this["dialogs"][_0x145886] = _0x6bbf75, _0x6bbf75.form["attr"]("name", _0x145886), $(_0x6bbf75).on("dialogOpened", function (_0x14e7cb) {
      _0x6bbf75["formHolder"]["css"]("z-index", ++_0x47f1e4["zindex"]), _0x47f1e4.openedDialogs++, this.blockBackground && _0x47f1e4.blockBackground(this["blockStyle"], this["blockOpacity"]), _0x47f1e4["activateDialog"](this), $(_0x47f1e4)["triggerHandler"](new dialogOpenedEvent(_0x6bbf75["name"]).getEvent());
    }), $(_0x6bbf75).on("dialogClosed", function (_0x2769f4) {
      _0x47f1e4["zindex"]--, _0x47f1e4["openedDialogs"]--, _0x47f1e4["deactivateDialogs"]();
      if (_0x47f1e4["openedDialogs"] <= 0) {
        if (this["blockBackground"]);
        {
          _0x47f1e4["unblockBackground"]();
        }
      } else _0x47f1e4["activateDialog"](_0x47f1e4["getNextVisibleDialog"]());
      $(_0x47f1e4).triggerHandler(new dialogClosedEvent(_0x6bbf75["name"])["getEvent"]());
    }), _0x6bbf75;
  }
  ["activateDialog"](_0x33db72) {
    this["activeDialog"] = _0x33db72, this["container"]["find"](".dialogFocus")["removeClass"]("dialogFocus"), _0x33db72["form"]["addClass"]("dialogFocus");
  }
  ["deactivateDialogs"]() {
    this["container"]["find"](".dialogFocus")["removeClass"]("dialogFocus"), this["activeDialog"] = null;
  }
  ["getNextVisibleDialog"]() {
    var _0x2c90bb = 0,
      _0x5e9642 = null;
    $["each"](this["container"]["find"](".dialogVisible"), function (_0x289689, _0x3a1ca8) {
      parseInt($(this)["parents"](".dialogHolder")["css"]("z-index")) > _0x2c90bb && (_0x2c90bb = parseInt($(this)["parents"](".dialogHolder")["css"]("z-index")), _0x5e9642 = $(this)["attr"]("name"));
    });
    var _0x7d76ba = null;
    return _0x2c90bb > 0 && $["each"](this["dialogs"], function (_0x56ab0b, _0x34367c) {
      _0x56ab0b == _0x5e9642 && (_0x7d76ba = _0x34367c);
    }), _0x7d76ba;
  }
  ["draggingDialog"]() {
    if (this["activeDialog"]) return this.activeDialog["dragging"];
    return false;
  }
  ["resizingDialog"]() {
    if (this["activeDialog"]) return this.activeDialog["resizing"];
    return false;
  }
  ["mouseMove"](_0x1d3960, _0x4e6c57) {
    this["activeDialog"] && this["activeDialog"]["mouseMove"](_0x1d3960, _0x4e6c57);
  }
  ["mouseUp"](_0x3732c4, _0xb07606) {
    this.activeDialog && this["activeDialog"]["mouseUp"](_0x3732c4, _0xb07606);
  }
  ["resized"]() {
    this["activeDialog"] && this["activeDialog"].resized();
  }
  ["createConfirmation"](_0x462a42, _0x23ebf9 = null) {
    this["destroyConfirmation"]();
    _0x23ebf9 == null && (_0x23ebf9 = [], _0x23ebf9["push"](new ButtonType("ok", textManager["getString"]("messages.btnYes"), "btn-success", "fa-check")), _0x23ebf9["push"](new ButtonType("cancel", textManager["getString"]("messages.btnNo"), "btn-danger", "fa-times")));
    var _0x5b8da4 = "";
    $["each"](_0x23ebf9, function (_0x25aded, _0x281aa8) {
      _0x5b8da4 += "<a href=\"#\" name=\"" + _0x281aa8["name"] + "\" class=\"btn btn-sm " + _0x281aa8.style + ' m-2">' + new Icon(_0x281aa8.icon).html() + " " + _0x281aa8["caption"] + "</a>";
    });
    var _0xa40bed = $("<div class=\"confirmContent\"><p>" + _0x462a42 + "</p>" + _0x5b8da4 + "</div>");
    return this["confirmationContainer"]["append"](_0xa40bed), this["confirmationContainer"]["addClass"]("blockConfirmation bgConfirmation"), _0xa40bed["find"]("a").on(UI["pointerEvent"]("click", "confirmation"), function (_0x1e831a) {
      _0x1e831a["preventDefault"]();
      var _0x38d399 = $(this).attr("name");
      $(_0xa40bed)["triggerHandler"](new confirmationClosedEvent(_0x38d399)["getEvent"]());
    }), _0xa40bed;
  }
  ["destroyConfirmation"]() {
    this["confirmationContainer"]["empty"](), this.confirmationContainer["removeClass"]("blockConfirmation bgConfirmation");
  }
  ["showAlert"](_0x30b6f2, _0x46123b = undefined) {
    this.alertManager.showAlert(_0x30b6f2, _0x46123b);
  }
  ["getActiveDialogName"]() {
    if (this["activeDialog"]) return this["activeDialog"]["constructor"]["name"];
    return null;
  }
  ["getDialog"](_0x509c1a) {
    return $["each"](this["dialogs"], function (_0x3b4234, _0xbc8321) {
      if (_0x3b4234 == _0x509c1a) return _0xbc8321;
    }), null;
  }
  ["showDialog"](_0x5cb818, _0x319874 = undefined) {
    $["each"](this["dialogs"], function (_0x515372, _0x5e329d) {
      _0x515372 == _0x5cb818 && _0x5e329d["show"](_0x319874);
    });
  }
  ["hideDialog"](_0x2eac78) {
    $["each"](this["dialogs"], function (_0x2cf261, _0x3a0074) {
      _0x2cf261 == _0x2eac78 && _0x3a0074["hide"]();
    });
  }
  ["toggleDialog"](_0x829958) {
    if (this["activeDialog"] && this["activeDialog"] == this["dialogs"][_0x829958]) this["activeDialog"]["closable"] && this["activeDialog"].hide(); else {
      var _0x587f91 = true;
      this["activeDialog"] && (this["activeDialog"].closable ? this["activeDialog"]["hide"]() : _0x587f91 = false), _0x587f91 && this.showDialog(_0x829958);
    }
  }
  ["hideAll"]() {
    $["each"](this.dialogs, function (_0x4258df, _0x332af1) {
      _0x332af1["hide"]();
    });
  }
  ["show"]() {
    this["dialogContainer"]["show"](), this["activeDialog"] && this.activeDialog["show"]();
  }
  ["hide"]() {
    this.dialogContainer["hide"]();
  }
}
class Dialog {
  constructor(_0x3a2b19, _0x1204b3) {
    this["active"] = false, this.maximizable = true, this["closable"] = true, this.draggable = true, this["resizable"] = true, this["languageSelector"] = false, this.helpLink = null, this["name"] = _0x1204b3, this.icon = "fa-city", this["caption"] = "", this.titlebar = true, this["isModal"] = true, this["blockBackground"] = false, this["blockStyle"] = null, this.blockOpacity = null, this["formPreferences"] = {}, this["initializing"] = true, this["forcedMaximized"] = false, this["maximized"] = false, this["resizing"] = false, this["resizingFrom"] = null, this["resizeRect"] = null, this["resizePoint"] = null, this.dragging = false, this["dragPoint"] = null, this["formHolder"] = $("<div/>"), this["formHolder"]["addClass"]("dialogHolder fullscreen"), this["formHolder"]["hide"](), this["form"] = $("<div/>"), this["form"]["addClass"]("dialog dialogInvisible"), this["parent"] = _0x3a2b19, this["previousFocus"] = null, this["title"] = $("<div/>"), this.content = $("<div/>"), this["form"]["append"](this.title), this["form"]["append"](this["content"]), this.formHolder.append(this["form"]), _0x3a2b19.append(this["formHolder"]), this["createResizingEdge"](), this["setResize"](this["resizable"]), this["createTitlebar"](), this.setDrag(this["draggable"]), this["hideContentResizing"] = false, this["width"] = 850, this["height"] = 550, this.minWidth = 400, this["minHeight"] = 400, this.windowWidth, this["windowHeight"], this["sizeType"] = "lg", this.modal = $("<div />"), this["modal"].addClass("submodal"), this["resizeBorder"] = _0x3a2b19["find"](".resizeBorder"), this["resizeBorderWidth"] = 1, this["previousRect"], this["wasMaximized"] = false;
    var _0x483f6f = this;
    this["formHolder"]["contextmenu"](function (_0x3fe1e2) {
      _0x3fe1e2["preventDefault"]();
    }), this["formHolder"].on(UI["pointerEvent"]("dragstart"), function (_0x2a019e) {
      _0x2a019e.preventDefault();
    }), this["title"]["contextmenu"](function (_0x5ad36d) {
      _0x5ad36d["preventDefault"]();
    }), this.title.on(UI.pointerEvent("down"), function (_0x1dcc37) {
      if (!UI["onFocus"]) return;
      if (!_0x1dcc37["which"] || _0x1dcc37["which"] == 1) {
        if (_0x483f6f["draggable"] && !_0x483f6f["maximized"] && !($(_0x1dcc37["target"]).hasClass("titleButton") || $(_0x1dcc37["target"])["hasClass"]("btn"))) {
          var _0x1e847d = UI["getInputPosition"](_0x1dcc37),
            _0x561119 = _0x483f6f.form["offset"]();
          _0x483f6f["dragPoint"] = new Point(_0x1e847d.x - _0x561119["left"], _0x1e847d.y - _0x561119.top), !_0x483f6f.dragging && (_0x483f6f["dragging"] = true, $(_0x483f6f)["triggerHandler"](new dialogDraggingStartedEvent()["getEvent"]())), _0x483f6f["mouseMove"](_0x1e847d.x, _0x1e847d.y);
        }
      }
    }), this["title"].on(UI["pointerEvent"]("dblclick"), function (_0x306df3) {
      _0x306df3["preventDefault"](), _0x483f6f["maximizable"] && _0x483f6f["toggleMaximize"]();
    }), this["form"].on(UI["pointerEvent"]("down"), ".dialogSize", function (_0x5329c6) {
      _0x5329c6.preventDefault();
      if (!_0x5329c6.which || _0x5329c6["which"] == 1) {
        if (_0x483f6f["resizable"] && !_0x483f6f["maximized"]) {
          var _0xf36325 = UI["getInputPosition"](_0x5329c6),
            _0x55ac2d = _0x483f6f["form"]["offset"]();
          _0x483f6f["resizePoint"] = new Point(_0xf36325.x - _0x55ac2d.left, _0xf36325.y - _0x55ac2d["top"]), _0x483f6f["resizeRect"] = new Rect(_0x55ac2d["left"], _0x55ac2d["top"], _0x483f6f["form"]["width"](), _0x483f6f["form"].height());
          !_0x483f6f.resizing && (_0x483f6f["resizing"] = true, $(_0x483f6f)["triggerHandler"](new dialogResizingStartedEvent()["getEvent"]()));
          if ($(_0x5329c6["target"])["hasClass"]("sbLeft")) _0x483f6f["resizingFrom"] = "W"; else {
            if ($(_0x5329c6["target"]).hasClass("sbRight")) _0x483f6f["resizingFrom"] = "E"; else {
              if ($(_0x5329c6["target"])["hasClass"]("sbTop")) _0x483f6f.resizingFrom = "N"; else {
                if ($(_0x5329c6["target"])["hasClass"]("sbBottom")) _0x483f6f["resizingFrom"] = "S"; else {
                  if ($(_0x5329c6["target"]).hasClass("sbTopLeft")) _0x483f6f["resizingFrom"] = "NW"; else {
                    if ($(_0x5329c6["target"]).hasClass("sbTopRight")) _0x483f6f["resizingFrom"] = "NE"; else {
                      if ($(_0x5329c6.target)["hasClass"]("sbBottomLeft")) _0x483f6f["resizingFrom"] = "SW"; else $(_0x5329c6["target"])["hasClass"]("sbBottomRight") && (_0x483f6f.resizingFrom = "SE");
                    }
                  }
                }
              }
            }
          }
          _0x483f6f["mouseMove"](_0xf36325.x, _0xf36325.y);
        }
      }
    }), this["content"].on(UI.pointerEvent("click"), ".subcloseButton", function (_0x4d2c3d) {
      _0x4d2c3d.preventDefault(), _0x483f6f["disableModal"]();
    }), this["title"].on("change", 'select[name="languagebutton"]', function (_0x5b41be) {
      _0x5b41be["preventDefault"]();
      let _0x195681 = _0x483f6f.title["find"]('select[name="languagebutton"]')["val"]();
      UI.userPreferences["setProperty"]("language", _0x195681), textManager["changeLocale"](_0x195681), textManager.updateElement($("body"));
    }), this["title"].on(UI["pointerEvent"]("click"), ".maximizeButton", function (_0x4a1e01) {
      _0x4a1e01["preventDefault"](), _0x483f6f["maximizable"] && _0x483f6f["toggleMaximize"]();
    }), this["title"].on(UI["pointerEvent"]("click"), ".helpButton", function (_0x15d5e9) {
      _0x15d5e9["preventDefault"](), _0x483f6f["helpLink"] && UI["helpDialog"]["show"](_0x483f6f.helpLink);
    }), this["title"].on(UI.pointerEvent("click"), ".closeButton", function (_0xfcde) {
      _0xfcde.preventDefault(), _0x483f6f.closable && _0x483f6f["hide"]();
    }), $(this).on("dialogResizingStarted dialogDraggingStarted", function (_0x5a2c7e) {
      _0x483f6f["hideContentResizing"] && _0x483f6f.content["fadeOut"](250), _0x483f6f["form"]["addClass"]("noMouseInteraction");
    }), $(this).on("dialogResizingEnded dialogDraggingEnded", function (_0x4af6d2) {
      _0x483f6f["hideContentResizing"] && _0x483f6f["content"]["fadeIn"](250), _0x483f6f["form"]["removeClass"]("noMouseInteraction");
    }), $(this).on("dialogResizingStarted", function (_0x6c71a4) {
      _0x6c71a4["resizeType"] == "Dialog" && _0x483f6f["resizeBorder"]["show"]();
    }), $(this).on("dialogResizingEnded", function (_0x1fb493) {
      var _0xfbf29c = _0x483f6f["resizeBorder"]["offset"]();
      _0x483f6f["setPosition"](_0xfbf29c["left"], _0xfbf29c["top"]), _0x483f6f["setSize"](_0x483f6f["resizeBorder"]["width"]() + _0x483f6f["resizeBorderWidth"] * 2, _0x483f6f["resizeBorder"]["height"]() + _0x483f6f["resizeBorderWidth"] * 2), _0x483f6f["resizeBorder"]["hide"]();
    }), $(this).on("dialogSizeTypeChanged", function (_0x2fe0e6) {
      _0x483f6f["processSizeType"](_0x2fe0e6["current"]);
    }), $(this).on("dialogModalEnabled", function (_0x54af9b) {
      _0x483f6f["processSizeType"](_0x483f6f.sizeType);
    }), $(this).on("dialogResizingEnded dialogMaximized dialogRestored dialogContentChanged", function (_0x598c11) {
      _0x483f6f["content"]["find"]("[data-anchortarget]")["each"](function (_0x37599b, _0x452dff) {
        var _0x5f070b = $(_0x452dff)["data"]("anchortarget") ? $(_0x452dff)["data"]("anchortarget") : "",
          _0x515092 = $(_0x452dff)["data"]("anchorpoints") ? $(_0x452dff)["data"]("anchorpoints") : "",
          _0x6a7e6b = $(_0x452dff)["data"]("anchormargin") ? $(_0x452dff).data("anchormargin") : 0;
        if (_0x515092 != "" && _0x5f070b != "") {
          var _0xac542e = _0x483f6f["content"]["find"](_0x5f070b);
          if (_0xac542e) {
            var _0x24a8b3 = _0xac542e["offset"](),
              _0x50ee65 = $(_0x452dff)["offset"]();
            if (_0x24a8b3 && _0x50ee65) {
              var _0x406c47 = new Rect(_0x24a8b3["left"], _0x24a8b3["top"], _0xac542e.width(), _0xac542e["height"]()),
                _0x412dda = new Rect(0, 0, _0xac542e["outerWidth"](true), _0xac542e["outerHeight"](true)),
                _0x37cef4 = (_0x412dda.width - _0x406c47["width"]) / 2,
                _0x3cc89d = (_0x412dda["height"] - _0x406c47.height) / 2;
              _0x515092["includes"]("b") && _0x515092["includes"]("t") && $(_0x452dff).css("height", _0x406c47["height"] - (_0x50ee65.top - _0x406c47.y) - _0x6a7e6b + _0x3cc89d - 1), _0x515092.includes("l") && _0x515092.includes("r") && $(_0x452dff)["css"]("width", _0x406c47["width"] - (_0x50ee65.left - _0x406c47.x) - _0x6a7e6b + _0x37cef4 - 1);
            }
          }
        }
      }), _0x483f6f["alignModal"](), _0x483f6f.calculateSizeType(this["form"]["width"](), this["form"]["height"]()), _0x483f6f["onResize"]();
    }), $(UI).on("windowFocused", function (_0x457196) {
      _0x483f6f.title["find"](".dialogTitlebar").removeClass("inactive"), _0x483f6f.onFocus();
    }), $(UI).on("windowBlurred", function (_0x4ba005) {
      _0x483f6f.title["find"](".dialogTitlebar").addClass("inactive"), _0x483f6f["onBlur"]();
    });
  }
  ["setResize"](_0x930a56) {
    this.form["find"](".dialogSize")["removeClass"]("noResize"), !_0x930a56 && this["form"]["find"](".dialogSize")["addClass"]("noResize");
  }
  ["setDrag"](_0x4a6f27) {
    this["form"].find(".dialogTitlebar")["removeClass"]("movable"), _0x4a6f27 && this.form["find"](".dialogTitlebar")["addClass"]("movable");
  }
  ["setPreference"](_0x322ed5, _0xfe9645) {
    this["formPreferences"][_0x322ed5] = _0xfe9645;
  }
  ["getPreference"](_0x1c5f51) {
    if (_0x1c5f51 in this.formPreferences) return this.formPreferences[_0x1c5f51];
    return undefined;
  }
  ["createResizingEdge"]() {
    var _0xd05442 = $("<div/>");
    _0xd05442.addClass("dialogSize dsBar sbTop"), this["form"]["append"](_0xd05442);
    var _0x15239 = $("<div/>");
    _0x15239["addClass"]("dialogSize dsBar sbBottom"), this.form["append"](_0x15239);
    var _0x3cbe4f = $("<div/>");
    _0x3cbe4f["addClass"]("dialogSize dsBar sbLeft"), this["form"].append(_0x3cbe4f);
    var _0x1de518 = $("<div/>");
    _0x1de518["addClass"]("dialogSize dsBar sbRight"), this["form"]["append"](_0x1de518);
    var _0x294f44 = $("<div/>");
    _0x294f44["addClass"]("dialogSize dsCorner sbTopLeft"), this["form"]["append"](_0x294f44);
    var _0x2ad22b = $("<div/>");
    _0x2ad22b["addClass"]("dialogSize dsCorner sbTopRight"), this["form"].append(_0x2ad22b);
    var _0x4c13d3 = $("<div/>");
    _0x4c13d3.addClass("dialogSize dsCorner sbBottomLeft"), this["form"]["append"](_0x4c13d3);
    var _0xd7514a = $("<div/>");
    _0xd7514a["addClass"]("dialogSize dsCorner sbBottomRight"), this["form"].append(_0xd7514a);
  }
  ["createTitlebar"]() {
    var _0x4e7bd2 = "";
    $["each"](textManager["getSupportedLanguages"](), function (_0x275392, _0x26618d) {
      _0x4e7bd2 += "<option value=\"" + _0x275392 + '">' + _0x26618d + "</option>";
    });
    var _0x1860f2 = "";
    this["titlebar"] && (_0x1860f2 = '<div class="dialogTitlebar' + (this.draggable ? " movable" : "") + "\"><div class=\"dialogTitle\"><div class=\"pull-left\">" + new Icon(this["icon"]).html() + " " + this["caption"] + "</div> <div class=\"dialogTitleButtons\"><div style=\"text-align: right;\"><select name=\"languagebutton\" href=\"#\" class=\"btn btn-sm btn-transparent\">" + _0x4e7bd2 + "</select>" + (this.helpLink ? "<a href=\"#\" class=\"btn btn-md helpButton\" data-tooltip=\"" + textManager["getString"]("tooltip.lblHelp", null, false) + '">' + new Icon("fa-circle-question", "fas", "titleButton")["html"]() + "</a>" : "") + (this["maximizable"] ? "<a href=\"#\" class=\"btn btn-md maximizeButton\" data-tooltipcallback=\"tooltipShortcut\" data-tooltipparam=\"" + textManager.getString("tooltip.lblMaximize", null, false) + ";maximizedialog\">" + new Icon(this["maximized"] ? "fa-window-restore" : "fa-window-maximize", "fas", "titleButton")["html"]() + "</a>" : "") + (this["closable"] ? "<a href=\"#\" class=\"btn btn-md closeButton\" data-tooltipcallback=\"tooltipShortcut\" data-tooltipparam=\"" + textManager.getString("tooltip.lblClose", null, false) + ";closedialog\">" + new Icon("fa-window-close", "fas", "titleButton")["html"]() + "</a>" : "") + "</div></div></div></div>"), this.title["html"](_0x1860f2);
  }
  ["loadFile"](_0x1d42c5, _0x19d312 = true) {
    var _0x5610a3 = "";
    return $["ajax"]({
      type: "GET",
      cache: true,
      async: false,
      url: UI.baseDir + _0x1d42c5 + (_0x19d312 ? "?v=" + UI.version : "")
    })["done"](function (_0x44348d) {
      _0x5610a3 = _0x44348d;
    })["fail"](function (_0x4de848, _0x5bb53a, _0x2e2f03) {
      _0x5610a3 = "<h1 class=\"text-center pt-2\">" + new Icon("fa-exclamation-triangle")["html"]() + "<br />Error</h1>";
    }), _0x5610a3;
  }
  ["mouseMove"](_0x4a3d11, _0x38fc93) {
    if (!this["maximized"]) {
      if (this["dragging"] && this["dragPoint"]) {
        var _0x2f163c = new Point(_0x4a3d11 - this.dragPoint.x, _0x38fc93 - this["dragPoint"].y),
          _0x4ac350 = this["parent"].offset();
        _0x2f163c.x < _0x4ac350["left"] && (_0x2f163c.x = _0x4ac350["left"]), _0x2f163c.y < _0x4ac350["top"] && (_0x2f163c.y = _0x4ac350["top"]), _0x2f163c.x + this["form"]["width"]() > this.parent["width"]() && (_0x2f163c.x = this["parent"]["width"]() - this["form"].width()), _0x2f163c.y + this["form"].height() > this["parent"]["height"]() && (_0x2f163c.y = this["parent"]["height"]() - this["form"]["height"]()), this["setPosition"](_0x2f163c.x, _0x2f163c.y);
      } else {
        if (this["resizing"] && this["resizePoint"]) {
          var _0xb9fb1f = this["form"]["offset"](),
            _0x498306 = new Rect(_0xb9fb1f.left, _0xb9fb1f.top, this.form["width"](), this["form"]["height"]());
          for (var _0x20e7c0 = 0; _0x20e7c0 < this.resizingFrom["length"]; _0x20e7c0++) {
            var _0x459b00 = this["resizingFrom"][_0x20e7c0];
            if (_0x459b00 == "N") _0x498306.y = _0x38fc93, _0x498306["height"] = this["resizeRect"]["height"] - (_0x38fc93 - this["resizeRect"].y), _0x498306["height"] < this["minHeight"] && (_0x498306.y -= this["minHeight"] - _0x498306["height"], _0x498306["height"] = this["minHeight"]); else {
              if (_0x459b00 == "S") _0x498306.height = _0x38fc93 - _0x498306.y, _0x498306["height"] < this.minHeight && (_0x498306["height"] = this.minHeight); else {
                if (_0x459b00 == "W") _0x498306.x = _0x4a3d11, _0x498306["width"] = this["resizeRect"]["width"] - (_0x4a3d11 - this["resizeRect"].x), _0x498306["width"] < this.minWidth && (_0x498306.x -= this["minWidth"] - _0x498306["width"], _0x498306.width = this["minWidth"]); else _0x459b00 == "E" && (_0x498306["width"] = _0x4a3d11 - _0x498306.x, _0x498306.width < this["minWidth"] && (_0x498306["width"] = this["minWidth"]));
              }
            }
          }
          this.setResizeBorder(_0x498306.x, _0x498306.y, _0x498306["width"], _0x498306["height"]);
        }
      }
    }
  }
  ["setPosition"](_0x462d88, _0x39cb2c) {
    this["form"]["css"]({
      top: _0x39cb2c,
      left: _0x462d88
    });
  }
  ["setSize"](_0x57f571, _0x39a091) {
    this["form"]["css"]({
      width: _0x57f571,
      height: _0x39a091
    });
  }
  ["setResizeBorder"](_0x57c536, _0x316233, _0x5a398e, _0x2a538c) {
    this["resizeBorder"]["css"]({
      top: _0x316233,
      left: _0x57c536,
      width: _0x5a398e,
      height: _0x2a538c
    });
  }
  ["setLimit"](_0x197863, _0x569dae) {
    this["form"]["css"]({
      "min-width": _0x197863,
      "min-height": _0x569dae
    });
  }
  ["calculateSizeType"](_0x2e31f4, _0x17df61) {
    var _0x2c72ab;
    if (_0x2e31f4 >= 0 && _0x2e31f4 < 577) _0x2c72ab = "xs"; else {
      if (_0x2e31f4 >= 577 && _0x2e31f4 < 768) _0x2c72ab = "sm"; else {
        if (_0x2e31f4 >= 768 && _0x2e31f4 < 992) _0x2c72ab = "md"; else {
          if (_0x2e31f4 >= 992 && _0x2e31f4 < 1200) _0x2c72ab = "lg"; else {
            if (_0x2e31f4 >= 1200 && _0x2e31f4 < 1400) _0x2c72ab = "xl"; else _0x2e31f4 >= 1400 && (_0x2c72ab = "xxl");
          }
        }
      }
    }
    var _0x4b8c7a = this["sizeType"];
    _0x2c72ab != _0x4b8c7a && (this.sizeType = _0x2c72ab, $(this)["triggerHandler"](new dialogSizeTypeChangedEvent(_0x2c72ab, _0x4b8c7a)["getEvent"]()));
  }
  ["processSizeType"](_0x8b86e6) {
    try {
      this.content["find"]("[data-size]").each(function (_0x528849, _0x4eeffd) {
        var _0x2bffb2 = $(_0x4eeffd)["data"]("size")["split"](" "),
          _0x3d64fe = {};
        $["each"](_0x2bffb2, function (_0x45be95, _0x47a574) {
          var _0x5f5562 = _0x47a574["match"](/col\-([A-z]{2})\-([0-9]+)/i);
          _0x5f5562 && (_0x3d64fe[_0x5f5562[1]] = parseInt(_0x5f5562[2]));
        }), _0x3d64fe = processSizes(_0x3d64fe), $.each(_0x4eeffd["classList"], function (_0x1cea86, _0x4d447b) {
          _0x4d447b && _0x4d447b["startsWith"]("col-") && $(_0x4eeffd).removeClass(_0x4d447b);
        }), $(_0x4eeffd)["addClass"]("col-" + _0x3d64fe[_0x8b86e6]);
      });
    } catch (_0x1b34a8) { }
    try {
      this["content"]["find"]("[data-display]")["each"](function (_0x4c7e29, _0x7cb462) {
        var _0x585b4c = $(_0x7cb462)["data"]("display")["split"](" "),
          _0x731625 = {};
        $["each"](_0x585b4c, function (_0x24d9a3, _0x20372d) {
          var _0x453a6d = _0x20372d.match(/d\-([A-z]{2})\-(block|inline|none)/i);
          _0x453a6d && (_0x731625[_0x453a6d[1]] = _0x453a6d[2]);
        }), _0x731625 = processSizes(_0x731625), $.each(_0x7cb462["classList"], function (_0x51a6bb, _0x1dbbeb) {
          _0x1dbbeb && _0x1dbbeb["startsWith"]("d-") && (_0x1dbbeb.endsWith("-block") || _0x1dbbeb["endsWith"]("-inline") || _0x1dbbeb["endsWith"]("-none")) && $(_0x7cb462)["removeClass"](_0x1dbbeb);
        }), $(_0x7cb462).addClass("d-" + _0x731625[_0x8b86e6]);
      });
    } catch (_0x2775d2) { }
    try {
      this["content"]["find"]("[data-css]")["each"](function (_0x5856f8, _0x2c8b81) {
        var _0x47cf73 = $(_0x2c8b81)["data"]("css").split(" "),
          _0xb4f4e6 = {};
        $["each"](_0x47cf73, function (_0x8fb45b, _0x1d40c1) {
          var _0x401f15 = _0x1d40c1["match"](/d\-([A-z]{2})\[(.+)\]$/i);
          _0x401f15 && (_0xb4f4e6[_0x401f15[1]] = _0x401f15[2]);
        }), _0xb4f4e6 = processSizes(_0xb4f4e6), $.each(_0xb4f4e6, function (_0x552989, _0x50f449) {
          var _0xac9eb4 = _0x50f449.split(" ");
          $["each"](_0xac9eb4, function (_0x32ae09, _0x552f0a) {
            $(_0x2c8b81)["removeClass"](_0x552f0a);
          });
        });
        var _0x2faa97 = _0xb4f4e6[_0x8b86e6]["split"](" ");
        $["each"](_0x2faa97, function (_0x4a2b1b, _0x3e8b40) {
          $(_0x2c8b81).addClass(_0x3e8b40);
        });
      });
    } catch (_0x27808f) { }
  }
  ["forceMaximize"]() {
    this["forcedMaximized"] = true, this.title.find("a.maximizeButton")["addClass"]("disabled"), this["wasMaximized"] = this["maximized"], this.maximize();
  }
  ["unforceMaximize"]() {
    this["forcedMaximized"] = false, this["title"]["find"]("a.maximizeButton").removeClass("disabled"), !this["wasMaximized"] && (this["restore"](), this["form"]["removeClass"]("noMouseInteraction"));
  }
  ["maximize"]() {
    if (!this.maximized) {
      var _0x3cf151 = this["form"]["offset"]();
      this["previousRect"] = new Rect(_0x3cf151["left"], _0x3cf151["top"], this["form"]["width"](), this.form["height"]()), this["maximized"] = true, this["form"]["find"](".dialogSize").addClass("noMouseInteraction"), this["form"]["addClass"]("dialogMaximized"), this.title["find"]("a.maximizeButton")["html"](new Icon("fa-window-restore")["html"]()), $(this)["triggerHandler"](new dialogMaximizedEvent().getEvent());
    }
  }
  ["restore"]() {
    this["maximized"] && (this["maximized"] = false, this["form"]["removeClass"]("dialogMaximized"), this["form"]["find"](".dialogSize")["removeClass"]("noMouseInteraction"), this["title"].find("a.maximizeButton")["html"](new Icon("fa-window-maximize")["html"]()), this.setSize(this["previousRect"].width, this["previousRect"].height), this["setPosition"](this["previousRect"].x, this.previousRect.y), this["setLimit"](this["minWidth"], this["minHeight"]), $(this)["triggerHandler"](new dialogRestoredEvent()["getEvent"]()));
  }
  ["toggleMaximize"]() {
    this["maximized"] ? !this.forcedMaximized && this["restore"]() : this["maximize"]();
  }
  ["mouseUp"](_0x3cd0b8, _0x21c4ed) {
    this["dragging"] && (this["dragging"] = false, this["dragPoint"] = null, $(this).triggerHandler(new dialogDraggingEndedEvent()["getEvent"]())), this["resizing"] && this["endResize"]();
  }
  ["endResize"]() {
    this["resizing"] = false, this.resizeRect = null, this["resizePoint"] = null, $(this)["triggerHandler"](new dialogResizingEndedEvent()["getEvent"]());
  }
  ["resized"]() {
    this.calculateSizeType(this.form.width(), this.form["height"]());
  }
  ["center"]() {
    var _0x4e7f25 = new Point(this["form"]["parent"]()["outerWidth"]() / 2 - this["form"]["outerWidth"]() / 2, this["form"]["parent"]()["outerHeight"]() / 2 - this["form"]["outerHeight"]() / 2);
    this["setPosition"](_0x4e7f25.x, _0x4e7f25.y);
  }
  ["show"]() {
    this["initializing"] && (this["initializing"] = false, this["setSize"](this.width, this["height"]), this["setLimit"](this["minWidth"], this["minHeight"]), this["center"]());
    var _0x3a6952 = this["title"].height() || 37;
    this["content"]["css"]({
      height: "calc(100% - " + _0x3a6952 + "px)",
      position: "relative",
      overflow: "hidden"
    }), this["helpLink"] != null ? this["title"]["find"](".helpButton").show() : this["title"].find(".helpButton")["hide"](), !this.active && (this["active"] = true, this["isModal"] ? this["formHolder"]["addClass"]("dialogModal") : this.formHolder["removeClass"]("dialogModal"), this["formHolder"]["fadeIn"](200), this["form"]["removeClass"]("dialogInvisible")["addClass"]("dialogVisible"), $(this).triggerHandler(new dialogOpenedEvent(this["name"])["getEvent"]()), this["createTitlebar"](), this.disableModal(), this["previousFocus"] = UI["getFocusElement"](), UI["setFocusElement"](null), this.loading(false), this["title"]["find"]("select[name=\"languagebutton\"]").val(textManager["getLocale"]()), this["title"]["find"]("select[name=\"languagebutton\"]")["toggle"](this["languageSelector"]), this["onShow"].apply(this, arguments), this["checkSizeRequirements"]() && this["outOfBounds"]() && this["resizeToFit"](), this["dragging"] = false, this["dragPoint"] = null);
  }
  ["hide"]() {
    this.active && (this.active = false, this.formHolder["fadeOut"](200), this["form"]["removeClass"]("dialogVisible")["addClass"]("dialogInvisible"), window["getSelection"] && window["getSelection"]()["removeAllRanges"](), this["resizing"] && this["endResize"](), $(this)["triggerHandler"](new dialogClosedEvent(this["name"])["getEvent"]()), this["onHide"](), UI["setFocusElement"](this["previousFocus"]));
  }
  ["changed"]() {
    textManager["updateElement"](this["form"]), $(this)["triggerHandler"](new dialogContentChangedEvent()["getEvent"]());
  }
  ["loading"](_0x163f5c) {
    if (_0x163f5c) {
      if (this["content"].find(".dialogLoader")["length"] == 0) {
        var _0x2d20d3 = $("<div />");
        _0x2d20d3["addClass"]("dialogLoader loadingSpinner"), _0x2d20d3["append"]("<p class=\"progressText\"><span class=\"icon\">" + new Icon("fa-spinner", "fas", "fa-spin")["html"]() + "</span></div>"), this.content["append"](_0x2d20d3);
      }
    } else this["content"]["find"](".dialogLoader")["remove"]();
  }
  ["alignModal"]() {
    if (this["modal"].is(":visible")) {
      var _0x201b53 = this["modal"]["find"](".subcontent");
      _0x201b53 && (_0x201b53["height"]() > this["modal"].height() ? (_0x201b53["removeClass"]("verticalAlign modalBorder"), this["modal"]["css"]("overflow", "auto")) : (!_0x201b53["hasClass"]("verticalAlign") && _0x201b53.addClass("verticalAlign modalBorder"), this["modal"].css("overflow", "hidden")));
    }
  }
  ["enableModal"](_0x3ebe67) {
    this["modal"].html(_0x3ebe67), this["content"]["append"](this["modal"]), this.modal.fadeIn(250), this.alignModal(), textManager["updateElement"](this["modal"]), $(this)["triggerHandler"](new dialogModalEnabledEvent()["getEvent"]());
  }
  ["disableModal"]() {
    this["modal"]["hide"](), this["content"]["remove"](this["modal"]), $(this)["triggerHandler"](new dialogModalDisabledEvent()["getEvent"]());
  }
  ["onWindowResize"](_0x43011d) {
    this["windowWidth"] = $(window)["width"](), this["windowHeight"] = $(window)["height"](), this["maximized"] && (_0x43011d ? $(this).triggerHandler(new dialogResizingStartedEvent("Screen")["getEvent"]()) : $(this)["triggerHandler"](new dialogResizingEndedEvent("Screen")["getEvent"]())), this["checkSizeRequirements"]() && this["outOfBounds"]() && this.resizeToFit();
  }
  ["checkSizeRequirements"]() {
    var _0x1f37c5 = this["windowWidth"] < this.minWidth || this["windowHeight"] < this["minHeight"];
    if (_0x1f37c5) return !this["forcedMaximized"] && this["forceMaximize"](), false; else this["forcedMaximized"] && this.unforceMaximize();
    return true;
  }
  ["outOfBounds"]() {
    var _0x311d22 = this.form["offset"]();
    return _0x311d22["left"] < 0 || this["windowWidth"] > _0x311d22.left || _0x311d22["top"] < 0 || this["windowHeight"] > _0x311d22["top"];
  }
  ["resizeToFit"]() {
    this.setSize(Math["min"](this["form"]["width"](), this.windowWidth || $(window).width()), Math["min"](this["form"]["height"](), this["windowHeight"] || $(window).height())), this["center"](), this["changed"]();
  }
  ["getFormWidth"]() {
    return this["form"]["width"]() + this.resizeBorderWidth * 2;
  }
  ["getFormHeight"]() {
    return this["form"].height() + this["resizeBorderWidth"] * 2;
  }
  ["hasModal"]() {
    return this["modal"].is(":visible");
  }
  ["onFocus"]() { }
  ["onBlur"]() { }
  ["onShow"]() { }
  ["onHide"]() { }
  ["onResize"]() { }
}
class SubDialog {
  constructor(_0x19a476, _0x268692 = null) {
    this.dialog = _0x19a476, _0x268692 == null && (_0x268692 = $("<div />"), _0x268692["addClass"]("h-100")), this.subContent = _0x268692;
  }
  ["load"]() { }
  ["unload"]() { }
}
class ConfigDialog extends Dialog {
  constructor(_0x1f7d54) {
    super(_0x1f7d54), this.icon = "fa-cog", this["caption"] = textManager["getString"]("config.title"), this["helpLink"] = "https://flockmod.com/help/tools/config/", this["loadContent"](this["loadFile"]("forms/config.main.html")), this["table"], this["elementCB"], this["changingPrimary"] = true;
    var _0x26c3eb = this;
    this["content"].on(UI.pointerEvent("click"), ".subcontentOption", function (_0x327b47) {
      _0x327b47["preventDefault"]();
      var _0x564200 = $(this).data("subcontent");
      _0x26c3eb["loadPage"](_0x564200);
    }), this["content"].on(UI.pointerEvent("click"), "#editShortcut", function (_0x5f2718) {
      _0x5f2718["preventDefault"](), _0x26c3eb["editShortcut"]();
    }), this["content"].on(UI["pointerEvent"]("click"), "#loadDefaults", function (_0x1510c3) {
      _0x1510c3["preventDefault"](), UI.shortcutManager.loadDefaults(), _0x26c3eb["loadPage"]("shortcuts");
    }), this["content"].on(UI["pointerEvent"]("click"), "#changeButton, #changeButton2", function (_0x344232) {
      _0x344232.preventDefault(), _0x26c3eb["content"].find("#changeButton")["html"](textManager["getString"]("config.btnChange")), _0x26c3eb["content"].find("#changeButton2")["html"](textManager["getString"]("config.btnChange")), UI.shortcutManager["setupMode"] ? UI["shortcutManager"]["setupMode"] = false : (UI["shortcutManager"]["setupMode"] = true, _0x26c3eb["changingPrimary"] = $(_0x344232["target"])["attr"]("id") == "changeButton", $(_0x344232["target"]).html(textManager["getString"]("config.lblListening")));
    }), this["content"].on(UI["pointerEvent"]("click"), "#clearButton, #clearButton2", function (_0x5076fb) {
      _0x5076fb.preventDefault(), _0x26c3eb["setShortcut"]("", $(_0x5076fb.target)["attr"]("id") == "clearButton");
    }), this["content"].on(UI["pointerEvent"]("click"), "#applyShortcut", function (_0x40182d) {
      _0x40182d["preventDefault"]();
      var _0x5b961e = _0x26c3eb.table["getSelected"](),
        _0x1f1e95 = _0x26c3eb["content"]["find"]("input[name=\"shortcut\"]").val(),
        _0x50cba6 = _0x26c3eb["content"].find("input[name=\"shortcut2\"]").val();
      if (!UI["shortcutManager"]["shortcutExists"](_0x1f1e95, _0x5b961e[0].ID) && !UI["shortcutManager"]["shortcutExists"](_0x50cba6, _0x5b961e[0].ID)) {
        if (!UI["shortcutManager"]["shortcutReserved"](_0x1f1e95) && !UI["shortcutManager"].shortcutReserved(_0x50cba6)) {
          if (UI.shortcutManager["changeShortcut"](_0x5b961e[0].ID, _0x1f1e95, true)) {
            var _0x1c0231 = {};
            _0x1c0231[_0x26c3eb["table"]["getColumnId"]("Shortcut")] = _0x1f1e95, _0x1c0231[_0x26c3eb.table["getColumnId"]("Hotkey")] = shortcutToKeys(_0x1f1e95), _0x26c3eb.table.updateRow(_0x5b961e[0]["rowId"], _0x1c0231);
          }
          if (UI["shortcutManager"]["changeShortcut"](_0x5b961e[0].ID, _0x50cba6, false)) {
            var _0x1c0231 = {};
            _0x1c0231[_0x26c3eb["table"]["getColumnId"]("Shortcut2")] = _0x50cba6, _0x1c0231[_0x26c3eb["table"]["getColumnId"]("Hotkey 2")] = shortcutToKeys(_0x50cba6), _0x26c3eb["table"]["updateRow"](_0x5b961e[0]["rowId"], _0x1c0231);
          }
          _0x26c3eb["disableModal"]();
        } else UI["dialogHandler"]["showAlert"](textManager["getString"]("alerts.txtReservedHotkey"));
      } else UI.dialogHandler["showAlert"](textManager["getString"]("alerts.txtHotkeyInUse"));
    }), $(this).on("dialogResizingEnded dialogMaximized dialogRestored", function (_0x45a556) {
      _0x26c3eb["table"] && _0x26c3eb["table"]["updated"]();
    }), $(this).on("dialogModalDisabled", function (_0x1282c0) {
      UI.shortcutManager["setupMode"] = false;
    });
  }
  ["loadContent"](_0x31af06) {
    this["content"].html(_0x31af06), $(this["content"])["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    });
  }
  ["loadSubcontent"](_0x5b6afb) {
    this.content.find(".dynamicDialogArea").html(_0x5b6afb);
  }
  ["loadPage"](_0x4f3c20) {
    var _0x1b75b3 = this;
    if (_0x4f3c20 !== undefined) {
      this["form"]["find"](".subcontentOption")["removeClass"]("selected"), this.form.find(".subcontentOption[data-subcontent=" + _0x4f3c20 + "]")["addClass"]("selected"), this.loading(true);
      if (_0x4f3c20 == "settings") {
        this.loadSubcontent(this["loadFile"]("forms/config.settings.html")), $["each"](textManager["getSupportedLanguages"](), function (_0x204d6f, _0x17f9b6) {
          _0x1b75b3["content"].find("select[name=\"language\"]")["append"](new Option(_0x17f9b6, _0x204d6f));
        }), this["sidebarSelector"] = new Selector(this["content"]["find"]("div[name=\"sidebar\"]"), {
          left: textManager["getString"]("config.optLeft"),
          right: textManager["getString"]("config.optRight")
        }), this.volumeSlider = new Slider(this["content"].find("div[name=\"volume\"]"), 0, 1, 0.01, zeroToOnePercentage), this["volumeSlider"].setValue(UI["userPreferences"]["getProperty"]("soundvolume", 1)), this["sidebarSelector"].select(UI.toolbarSide), this["content"]["find"]("select[name=\"language\"]")["val"](textManager["getLocale"]()), this.content["find"]("select[name=\"theme\"]")["val"](UI["userPreferences"]["getProperty"]("theme", "dark")), this["content"].find('select[name="strokequality"]')["val"](UI["userPreferences"].getProperty("strokequality", "high")), this["elementCB"] = [], this["content"]["find"](".check")["each"](function (_0xf4d5ab, _0x3b7b1c) {
          _0x3b7b1c = $(_0x3b7b1c), _0x3b7b1c.addClass("smallCheckbox");
          var _0x68c161 = _0x3b7b1c["attr"]("name"),
            _0x6871c0 = _0x3b7b1c["data"]("caption-i18n") ? textManager.getString(_0x3b7b1c["data"]("caption-i18n")) : _0x3b7b1c.data("caption"),
            _0x865dcf = _0x3b7b1c.data("group"),
            _0x51f93f = _0x3b7b1c["data"]("value") ? _0x3b7b1c["data"]("value") == "1" : false,
            _0x51c234 = new Checkbox(_0x3b7b1c, _0x6871c0);
          _0x51c234["setValue"](UI["userPreferences"]["getGroupOption"](_0x865dcf, _0x68c161, _0x51f93f)), _0x1b75b3["elementCB"]["push"](_0x51c234);
        }), this["content"]["find"]("#uploadConfig").on("change", function (_0x4b927a) {
          var _0x1bd1b6 = _0x4b927a["target"].files,
            _0x57aad3 = _0x1bd1b6[0];
          if (getExtension(_0x57aad3["name"]) == "FMC") {
            var _0xa7365b = new FileReader();
            _0xa7365b.onload = function (_0x15dc30) {
              let _0x14a8da = JSON["parse"](atob(_0x15dc30.target["result"]));
              _0x14a8da && typeof _0x14a8da === "object" && (storage["data"] = _0x14a8da, storage["saveData"](), UI["reloadStorage"](), _0x1b75b3["loadPage"]("settings"), _0x1b75b3["applySettings"](true));
            }, _0xa7365b["readAsText"](_0x57aad3);
          } else UI["dialogHandler"]["showAlert"](textManager["getString"]("alerts.txtIncorrectFileType"));
        }), this["content"]["find"]("#importSettings").on(UI.pointerEvent("click"), function (_0x4b8d64) {
          _0x4b8d64["preventDefault"](), _0x1b75b3["content"]["find"]("#uploadConfig").click();
        }), this["content"]["find"]("#exportSettings").on(UI.pointerEvent("click"), function (_0x3c0a64) {
          _0x3c0a64["preventDefault"](), storage["exportData"]();
        }), this["content"].find("#applySettings").on(UI.pointerEvent("click"), function (_0x1cf445) {
          _0x1cf445.preventDefault(), _0x1b75b3["applySettings"](), UI["dialogHandler"].showAlert(textManager["getString"]("alerts.txtSaved"));
        });
        var _0x4d53c3 = this["content"].find(".dialogContentArea")["overlayScrollbars"]({
          className: "os-theme-light",
          overflowBehavior: {
            x: "hidden"
          }
        })["overlayScrollbars"]();
        _0x4d53c3.addExt("fmExtension"), this["changed"](), this["loading"](false);
      } else {
        if (_0x4f3c20 == "shortcuts") this["loadSubcontent"](this["loadFile"]("forms/config.shortcuts.html")), this.shortcutList(), this["changed"](), this["table"]["updated"](), this.content["find"]("#editShortcut").addClass("disabled"), this["loading"](false); else {
          if (_0x4f3c20 == "aboutus") {
            this["loadSubcontent"](this.loadFile("forms/config.aboutus.html")), this.content["find"]("div[name=\"build\"]")["text"]("Build: " + UI["version"]), this["content"]["find"](".btn.usefulLink").on(UI["pointerEvent"]("click"), function (_0x50eda1) {
              _0x50eda1["preventDefault"]();
              let _0x1e978e = $(_0x50eda1["target"])["attr"]("name");
              if (_0x1e978e == "gallery") window["open"]("https://flockmod.com/gallery/", "_blank"); else {
                if (_0x1e978e == "news") UI["helpDialog"]["show"]("https://flockmod.com/news/"); else {
                  if (_0x1e978e == "feedback") UI["feedbackDialog"]["show"](); else {
                    if (_0x1e978e == "ideas") window["open"]("http://ideas.flockmod.com", "_blank"); else _0x1e978e == "help" && window.open("https://flockmod.com/help/", "_blank");
                  }
                }
              }
            });
            var _0x2c1e46 = new Table(this["content"]["find"]("#specialThanks"), null, "thanksTable", "fmTable");
            _0x2c1e46["rowsPerPage"] = 20, _0x2c1e46["selectable"] = false, _0x2c1e46.setFilterable(false), _0x2c1e46["setTitle"](textManager["getString"]("config.lblSpecialThanks")), _0x2c1e46["clear"](), _0x2c1e46["setHeader"](["Name"]), _0x2c1e46.headerCaption(1, textManager.getString("config.rowThanksName"));
            var _0x156ccd = ["Josh", "Maka", "TnT"];
            $["each"](_0x156ccd, function (_0x5e6e9e, _0x120e5d) {
              _0x2c1e46["addRow"]([_0x120e5d], false);
            }), _0x2c1e46["updated"](), _0x2c1e46["sort"](1), this.changed(), this.loading(false);
          }
        }
      }
      this.processSizeType(this.sizeType);
    }
  }
  ["applySettings"](_0x2bfb5a = false) {
    var _0x2d6980 = {};
    $["each"](this["elementCB"], function (_0x13c733, _0x4b2666) {
      !(_0x4b2666["container"].data("group") in _0x2d6980) && (_0x2d6980[_0x4b2666["container"]["data"]("group")] = {}), _0x2d6980[_0x4b2666["container"].data("group")][_0x4b2666["container"]["attr"]("name")] = _0x4b2666["checked"];
    }), $["each"](_0x2d6980, function (_0x3024f3, _0xf9cde7) {
      UI.userPreferences["setGroupOptions"](_0x3024f3, _0xf9cde7);
    });
    var _0x3b82cf = this["content"]["find"]("select[name=\"language\"]").val();
    _0x3b82cf != textManager.getLocale() && (textManager["changeLocale"](_0x3b82cf), textManager["updateElement"]($("body")));
    var _0x5ca105 = this["content"]["find"]("select[name=\"theme\"]")["val"]();
    (_0x5ca105 != UI["userPreferences"]["getProperty"]("theme", "dark") || _0x2bfb5a) && UI["loadTheme"](_0x5ca105);
    UI.userPreferences.setProperty("language", _0x3b82cf), UI["userPreferences"]["setProperty"]("theme", _0x5ca105), UI["userPreferences"]["setProperty"]("strokequality", this["content"]["find"]("select[name=\"strokequality\"]").val()), UI["userPreferences"]["setProperty"]("soundvolume", this["volumeSlider"]["value"]);
    var _0x151a9e = this["sidebarSelector"].getSelected();
    UI.moveSidebar(_0x151a9e), UI["userPreferences"].setProperty("toolbarside", _0x151a9e), UI.userPreferences["getGroupOption"]("graphics", "showusername", true) ? room["myself"]["surface"]["cursor"]["showUsername"]() : room["myself"]["surface"]["cursor"]["hideUsername"]();
  }
  ["shortcutPressed"](_0x1ac25e) {
    var _0x35c4b4 = this["table"]["getSelected"](),
      _0x294cbb = UI["shortcutManager"]["shortcutExists"](_0x1ac25e, _0x35c4b4[0].ID),
      _0x10ff18 = UI["shortcutManager"]["shortcutReserved"](_0x1ac25e);
    this["setShortcut"](_0x1ac25e, this.changingPrimary, !_0x294cbb && !_0x10ff18);
  }
  ["setShortcut"](_0x22f8ef = "", _0x4ed9aa = true, _0x4d53af = true) {
    _0x4ed9aa ? (this.content["find"]('input[name="shortcut"]')["val"](_0x22f8ef), this["content"].find("div[name=\"shortcutKeys\"]")["html"](shortcutToKeys(_0x22f8ef)), _0x4d53af ? this["content"]["find"]("div[name=\"shortcutKeys\"]").removeClass("prohibitedShortcut") : this["content"]["find"]("div[name=\"shortcutKeys\"]").addClass("prohibitedShortcut")) : (this["content"]["find"]('input[name="shortcut2"]')["val"](_0x22f8ef), this.content["find"]('div[name="shortcutKeys2"]').html(shortcutToKeys(_0x22f8ef)), _0x4d53af ? this.content["find"]("div[name=\"shortcutKeys2\"]").removeClass("prohibitedShortcut") : this.content["find"]("div[name=\"shortcutKeys2\"]")["addClass"]("prohibitedShortcut"));
  }
  ["shortcutList"]() {
    var _0x4b93a3 = new Table(this["content"]["find"]("#configShurtcuts"), null, "shortcutsTable", "fmTable");
    _0x4b93a3["rowsPerPage"] = 40, _0x4b93a3["selectable"] = true, _0x4b93a3.setFilterable(true), _0x4b93a3["setTitle"](textManager["getString"]("config.lblHotkeys")), _0x4b93a3["clear"](), _0x4b93a3.setHeader(["ID", "Description", "Shortcut", "Shortcut2", "Hotkey", "Hotkey 2"]), _0x4b93a3["headerCaption"](2, textManager.getString("config.rowDescription")), _0x4b93a3["headerCaption"](5, textManager["getString"]("config.rowHotkey")), _0x4b93a3["headerCaption"](6, textManager["getString"]("config.rowHotkey2"));
    var _0x3a0aa1 = this;
    $["each"](UI["shortcutManager"]["shortcuts"], function (_0x1da69f, _0x562d0d) {
      _0x4b93a3["addRow"]([_0x562d0d.id, textManager["getString"]("config.sc." + _0x562d0d.id + "." + _0x562d0d.stype, _0x562d0d.description), _0x562d0d.shortcut, _0x562d0d["shortcut2"], shortcutToKeys(_0x562d0d.shortcut), shortcutToKeys(_0x562d0d["shortcut2"])], false);
    }), $(_0x4b93a3).on("tableRowDoubleClick", function (_0xfe7d80) {
      _0x3a0aa1["editShortcut"]();
    }), $(_0x4b93a3).on("tableRowSelected tableRowUnselected", function (_0x5db8d1) {
      _0x5db8d1["type"] == "tableRowSelected" ? _0x3a0aa1["content"]["find"]("#editShortcut")["removeClass"]("disabled") : _0x3a0aa1["content"].find("#editShortcut")["addClass"]("disabled");
    }), _0x4b93a3["hideColumns"]([1, 3, 4]), _0x4b93a3["updated"](), this["table"] = _0x4b93a3;
  }
  ["editShortcut"]() {
    var _0x569962 = this["table"]["getSelected"]();
    this["enableModal"](this.loadFile("forms/config.modal.editshortcut.html")), this["content"]["find"]("input[name=\"description\"]")["val"](_0x569962[0]["Description"]), this["setShortcut"](_0x569962[0].Shortcut, true), this["setShortcut"](_0x569962[0].Shortcut2, false);
  }
  ["clearSubcontent"]() {
    this["content"].find(".dynamicDialogArea")["empty"]();
  }
  ["onShow"]() {
    this["loadPage"]("settings");
  }
  ["onHide"]() {
    this["clearSubcontent"](), this.table && this.table.reset();
  }
}
class LoginDialog extends Dialog {
  constructor(_0x5202d4) {
    super(_0x5202d4), this["icon"] = "fa-university", this["caption"] = textManager["getString"]("login.title"), this.closable = false, this["maximizable"] = true, this["languageSelector"] = true, this["helpLink"] = "https://flockmod.com/help/", this["isModal"] = false, this["blockBackground"] = true, this["blockStyle"] = "blockwelcome", this["blockOpacity"] = 1, this["rooms"] = {}, this["table"], this["width"] = 650, this["height"] = 550, this["defaultUsername"] = "Anonymous", this.defaultRoom = "fallback", this["requestedRoom"] = null, this["confirmedAccount"] = false, this.loadContent(this["loadFile"]("forms/login.main.html")), this.table = new Table(this["content"].find("#roomList"), null, "roomTable", "fmTable"), this["table"]["selectable"] = true, this["content"]["find"](".modal-body")["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    });
    var _0x3017c7 = this;
    $(this["table"]).on("tableRowSelected", function (_0x1c5441) {
      var _0x1a602a = _0x1c5441["selection"][0];
      _0x3017c7["content"]["find"]("#loginRoom")["val"](_0x1a602a["Room"]), _0x3017c7.content["find"](".thumbBox")["empty"](), _0x3017c7["content"]["find"](".thumbBox")["css"]("background-color", _0x1a602a["Background"]);
      var _0x19600e = _0x1a602a["Password"] == "" ? "" : new Icon("fa-lock").html() + " ";
      _0x3017c7.content["find"](".nameBox").html(_0x19600e + " #" + _0x1a602a.Room), _0x3017c7["content"]["find"](".typeBox")["html"](_0x1a602a["Size"]), _0x3017c7["content"].find(".descriptionBox")["html"](nl2br(parseURL(escapeHTML(_0x1a602a["Description"]))));
      var _0x5ab250 = {};
      _0x5ab250.command = "OFFROOM", _0x5ab250["option"] = "GETTHUMB", _0x5ab250.room = _0x1a602a["Room"], socket["send"](_0x5ab250, true);
    }), $(this).on("dialogResizingEnded dialogMaximized dialogRestored", function (_0x5758cc) {
      _0x3017c7["table"] && _0x3017c7.table["updated"]();
    }), $(UI["account"]).on("usernameChanged", function (_0x33d818) {
      _0x3017c7["content"]["find"]('a[name="accountbutton"]').html(new Icon("fa-user")["html"]() + " " + _0x33d818["newname"]);
    });
  }
  ["loadContent"](_0x3e1c43) {
    var _0x403ac1 = this;
    this["content"]["html"](_0x3e1c43), this["content"].on(UI["pointerEvent"]("click"), "button[name=\"okaccount\"]", function (_0x161420) {
      _0x161420["preventDefault"]();
      let _0x3e9274 = _0x403ac1["content"]["find"]("input[name=\"loginUsername\"]").val();
      UI.account.change(_0x3e9274 == "" ? "Anonymous" : _0x3e9274, _0x403ac1.content["find"]('input[name="loginPassword"]')["val"]()), _0x403ac1["content"]["find"]('input[name="loginUsername"]')["val"](""), _0x403ac1["content"]["find"]('input[name="loginPassword"]')["val"](""), _0x403ac1["disableModal"](), _0x403ac1.confirmedAccount = true, _0x403ac1["content"].find("#loginRoom")["focus"](), _0x403ac1["content"]["find"]("form[name=\"loginForm\"]")["submit"](function (_0x58db17) {
        _0x58db17["preventDefault"]();
      }), $(this)["hasClass"]("joinRoom") && _0x403ac1.doLogin();
    }), this["content"].on(UI["pointerEvent"]("click"), "button[name=\"newaccount\"]", function (_0x2e5006) {
      _0x2e5006["preventDefault"]();
      if (_0x403ac1["content"].find("input[name=\"registerUsername\"]")["val"]().length >= 3) {
        if (/(\p{Emoji_Presentation}|\p{Extended_Pictographic})/u.test(_0x403ac1.content["find"]("input[name=\"registerUsername\"]")["val"]())) UI["dialogHandler"]["showAlert"](textManager["getString"]("alerts.txtUsernameContainsEmojis")); else {
          if (_0x403ac1["content"]["find"]("input[name=\"registerPassword\"]")["val"]()["length"] >= 5) {
            if (_0x403ac1.content["find"]("input[name=\"registerQuestion\"]")["val"]() != "" && _0x403ac1["content"]["find"]("input[name=\"registerAnswer\"]").val() != "") {
              if (_0x403ac1["content"]["find"]("input[name=\"registerQuestion\"]")["val"]() != _0x403ac1["content"].find('input[name="registerAnswer"]')["val"]()) {
                if (_0x403ac1.content["find"]("input[name=\"registerPassword\"]")["val"]() == _0x403ac1.content.find("input[name=\"registerPassword2\"]")["val"]()) {
                  var _0x1a912b = {};
                  _0x1a912b.command = "OFFROOM", _0x1a912b["option"] = "ACCOUNTCREATE", _0x1a912b["username"] = _0x403ac1["content"]["find"]("input[name=\"registerUsername\"]").val(), _0x1a912b["password"] = _0x403ac1.content["find"]('input[name="registerPassword"]')["val"](), _0x1a912b.email = _0x403ac1.content["find"]("input[name=\"registerEmail\"]").val(), _0x1a912b["question"] = _0x403ac1["content"]["find"]('input[name="registerQuestion"]')["val"](), _0x1a912b.answer = _0x403ac1.content.find("input[name=\"registerAnswer\"]")["val"](), socket["send"](_0x1a912b, true), _0x403ac1["loading"](true);
                } else UI["dialogHandler"].showAlert(textManager.getString("alerts.txtPasswordDontMatch"));
              } else UI["dialogHandler"]["showAlert"](textManager.getString("alerts.txtSecretsMatch"));
            } else UI["dialogHandler"]["showAlert"](textManager["getString"]("alerts.txtFillSecrets"));
          } else UI["dialogHandler"]["showAlert"](textManager["getString"]("alerts.txtPasswordTooShort"));
        }
      } else UI["dialogHandler"]["showAlert"](textManager["getString"]("alerts.txtUsernameTooShort"));
    }), this["content"].on("keydown", ".usernameAccount, .roomName", function (_0x22c354) {
      let _0x15abca = _0x22c354["which"] || _0x22c354["keyCode"],
        _0x3e1816 = _0x22c354.key,
        _0x1dc0ab = _0x15abca == 32;
      if (_0x1dc0ab || _0x15abca > 32 && (_0x3e1816 == "<" || _0x3e1816 == ">" || _0x3e1816 == "'" || _0x3e1816 == '"' || _0x3e1816 == "/" || _0x3e1816 == "\\" || _0x3e1816 == "@")) return _0x22c354["stopPropagation"](), _0x22c354["preventDefault"](), false;
    }), this.content.find("a[name=\"loginbutton\"]").on(UI.pointerEvent("click"), function (_0x3ef794) {
      _0x3ef794.preventDefault(), _0x403ac1.attemptJoin();
    }), this["content"].find("a[name=\"refreshbutton\"]").on(UI["pointerEvent"]("click"), function (_0x165b81) {
      _0x165b81.preventDefault(), _0x403ac1["refresh"]();
    }), this.content["find"]("#loginRoom").on("keydown", function (_0x468f19) {
      _0x468f19.which == 13 && (_0x468f19["preventDefault"](), _0x403ac1["attemptJoin"]());
    }), this.content.on(UI["pointerEvent"]("click"), "button[name=\"enterRoom\"]", function (_0x348a4d) {
      _0x348a4d["preventDefault"](), _0x403ac1["attemptJoin"]();
    }), this["content"].on(UI["pointerEvent"]("click"), "a[name=\"forgotPassword\"]", function (_0x2d718a) {
      _0x2d718a["preventDefault"](), UI["dialogHandler"]["showAlert"](textManager.getString("alerts.txtNotAvailableYet"));
    }), this.content.on(UI.pointerEvent("click"), '[name="accountRegister"]', function (_0x420858) {
      _0x420858.preventDefault(), _0x403ac1["enableModal"](_0x403ac1["loadFile"]("forms/login.modal.registeraccount.html")), _0x403ac1["content"]["find"]("input.usernameAccount")["focus"]();
    }), this["content"]["find"]("a[name=\"accountbutton\"]").on(UI["pointerEvent"]("click"), function (_0x12121e) {
      _0x12121e["preventDefault"](), _0x403ac1["loading"](true), _0x403ac1["enableModal"](_0x403ac1["loadFile"]("forms/login.modal.username.html")), _0x403ac1.content["find"]("input[name=\"loginUsername\"]")["focus"](), _0x403ac1["content"]["find"]("button[name=\"okaccount\"]:not(.joinRoom)").show(), _0x403ac1["content"]["find"]('button[name="okaccount"].joinRoom').hide(), _0x403ac1["loading"](false);
    });
  }
  ["attemptJoin"]() {
    this["doLogin"](this["content"]["find"]("input[name=\"roompassword\"]")["val"]());
  }
  ["roomThumb"](_0xaf35ac, _0x5602e9) {
    if (_0x5602e9) {
      var _0x3a1330 = this;
      $["each"](_0x5602e9, function (_0x34fdfd, _0x451878) {
        var _0x580c87 = new Image();
        _0x580c87["src"] = _0x451878, $(_0x580c87)["addClass"]("thumb"), _0x3a1330["content"].find(".thumbBox")["append"](_0x580c87);
      });
    }
  }
  ["registerResponse"](_0x4ab7fe) {
    _0x4ab7fe == "OK" ? (UI["account"].change(this["content"]["find"]("input[name=\"registerUsername\"]")["val"](), this["content"]["find"]("input[name=\"registerPassword\"]")["val"]()), this["confirmedAccount"] = true, this.disableModal()) : UI["dialogHandler"]["showAlert"](_0x4ab7fe), this.loading(false);
  }
  ["roomPassword"]() {
    this["loading"](false), this.enableModal(this.loadFile("forms/login.modal.roompassword.html")), this["content"]["find"]("form[name=\"loginForm\"]")["submit"](function (_0xd384df) {
      _0xd384df["preventDefault"]();
    });
    var _0x553bd7 = this;
    this["content"].find("input[name=\"roompassword\"]").on("keydown", function (_0xc8e4a9) {
      _0xc8e4a9["which"] == 13 && (_0xc8e4a9["preventDefault"](), _0x553bd7.attemptJoin());
    }), this["content"].find('input[name="roompassword"]').focus();
  }
  ["roomList"](_0x2e5e6f) {
    this["table"]["reset"](), this.table["setHeader"](["Room", "Roomname", "Type", "Background", "Size", "Password", new Icon("fa-users")["html"](), "Description", "Users", "Size"]), this["table"]["hideColumns"]([1, 3, 4, 5, 6, 8, 9, 10]), this.table["headerCaption"](2, textManager["getString"]("login.rowRoomName")), this["table"]["columnAlignment"](7, "right");
    var _0x5612d4 = 0,
      _0x48837f = 0,
      _0x458b21 = null,
      _0x2dd484 = this;
    $["each"](_0x2e5e6f.rooms, function (_0x586497, _0xb8ae30) {
      _0x2dd484.requestedRoom != null && _0xb8ae30["name"] == _0x2dd484["requestedRoom"] && (_0x458b21 = _0x5612d4);
      _0xb8ae30.name == _0x2dd484["defaultRoom"] && (_0x48837f = _0x5612d4);
      _0x5612d4++;
      var _0x32388c = _0xb8ae30["password"] ? " " + new Icon("fa-lock")["html"]() : "";
      _0x2dd484["table"]["addRow"]([_0xb8ae30.name, _0xb8ae30["name"] + _0x32388c, _0xb8ae30.type, _0xb8ae30["background"], _0xb8ae30["size"], _0xb8ae30["password"], _0xb8ae30["usercount"], escapeHTML(_0xb8ae30["description"]), _0xb8ae30["users"], _0xb8ae30["size"]], false);
    }), _0x2e5e6f["rooms"]["length"] > 0 && this["content"]["find"]("#loginRoom")["val"]() == "" && (this["requestedRoom"] == null ? this["table"].select(_0x48837f) : _0x458b21 != null && this["table"]["select"](_0x458b21)), this["loading"](false), this.changed(), this["table"]["updated"](), this["table"]["sort"](7, false), this["processSizeType"](this.sizeType);
  }
  ["doLogin"](_0x56689c = "") {
    this.loading(true);
    if (!this["confirmedAccount"]) this["enableModal"](this["loadFile"]("forms/login.modal.username.html")), this["content"].find("button[name=\"okaccount\"].joinRoom")["show"](), this["content"]["find"]("button[name=\"okaccount\"]:not(.joinRoom)")["hide"](), this["content"]["find"]("input[name=\"loginUsername\"]")["focus"](), this["loading"](false); else {
      var _0x45d75b = {};
      _0x45d75b["command"] = "OFFROOM", _0x45d75b.option = "ENTER", _0x45d75b["room"] = this["content"]["find"]("#loginRoom")["val"]() != "" ? this["content"]["find"]("#loginRoom").val() : this.defaultRoom, _0x45d75b["username"] = UI["account"]["username"] != "" ? UI["account"]["username"] : this["defaultUsername"], _0x45d75b["password"] = UI["account"]["password"], _0x56689c != "" && (_0x45d75b["roompwd"] = _0x56689c), socket["send"](_0x45d75b, true);
    }
  }
  ["refresh"]() {
    var _0x453f19 = {};
    _0x453f19.command = "OFFROOM", _0x453f19.option = "ROOMS", socket["send"](_0x453f19, true);
  }
  ["onShow"]() {
    if (room && room["connected"]) {
      var _0x2b0524 = {};
      _0x2b0524.command = "USERFUNCTIONS", _0x2b0524["option"] = "LEAVE", socket.send(_0x2b0524, true);
    }
    this["loading"](false), this["content"].find('a[name="accountbutton"]')["html"](new Icon("fa-user")["html"]() + " " + (UI["account"]["username"] == "" ? "Anonymous" : UI.account["username"])), this["changed"](), this.table["updated"](), this["content"].find("#loginRoom")["focus"]();
    let _0x588829 = getRoomFromURL("r");
    this["requestedRoom"] = _0x588829, _0x588829 != null && (this.content["find"]("#loginRoom")["val"](this["requestedRoom"]), this["attemptJoin"]());
  }
  ["onResize"]() {
    this["getFormHeight"]() < this.minHeight ? this.hidePreview() : this["showPreview"]();
  }
  ["showPreview"]() {
    !this["content"].find(".previewThumb").is(":visible") && (this["content"]["find"](".previewThumb")["show"](), this["changed"]());
  }
  ["hidePreview"]() {
    this["content"]["find"](".previewThumb").is(":visible") && (this["content"]["find"](".previewThumb")["hide"](), this.changed());
  }
  ["forceJoin"](_0x16b186, _0x152216 = "") {
    this["content"]["find"]("#loginRoom")["val"](_0x16b186), this["doLogin"](_0x152216);
  }
}
class ChatDialog extends Dialog {
  constructor(_0x478345) {
    super(_0x478345), this["currentChannel"] = null, this["channels"] = {}, this["icon"] = "fa-comment", this["caption"] = textManager.getString("chat.title"), this["helpLink"] = "https://flockmod.com/help/tools/social/", this["fontSize"] = 13, this["spamLimit"] = 25, this["loadContent"](this.loadFile("forms/chat.main.html")), this.sidebarScroll = this.content["find"](".chatBar")["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    })["overlayScrollbars"](), this["sidebarScroll"]["addExt"]("fmExtension"), this["scroll"] = this.content["find"](".chatBox")["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    })["overlayScrollbars"](), this["scroll"]["addExt"]("fmExtension"), this["content"]["find"](".sidebarElements")["empty"](), this["content"]["find"]("a[name=\"newPM\"]")["hide"](), this["addChannel"]("public", "room"), this["addChannel"]("staff", "room"), this["selectChannel"]("public", "room"), this["changeFontSize"](this.fontSize), this["previews"] = new ImagePreview(), this["emojiList"] = new EmojiSelector(this["content"]["find"](".emojiContainer")), this["userTag"] = new UserTag(this["content"]["find"](".userTagContainer"));
    var _0x3c18d9 = this;
    $(this.emojiList).on("dialogClosed", function (_0x1356ba) {
      _0x3c18d9["content"]["find"]("input[name=\"text\"]")["focus"]();
    }), $(this.userTag).on("userTagged", function (_0x4f983a) {
      _0x3c18d9["content"]["find"]("input[name=\"text\"]")["focus"](), _0x3c18d9.acceptTag(_0x4f983a["username"], _0x4f983a["filter"]), _0x3c18d9.userTag["hide"]();
    }), $["contextMenu"]({
      selector: ".chatBox",
      build: function (_0x4ec8b5) {
        var _0x37dc5a = {
          callback: function (_0xb9907f, _0x2ac854) {
            if (_0xb9907f == "clear") {
              var _0x15a529 = _0x3c18d9["getChannelString"](_0x3c18d9["channels"][_0x3c18d9["currentChannel"]].name, _0x3c18d9["channels"][_0x3c18d9["currentChannel"]]["type"]);
              _0x3c18d9.content["find"](".channelMessages[name=\"" + _0x15a529 + '"]')["empty"]();
            } else {
              if (_0xb9907f == "copy") document["execCommand"]("copy", false, null); else {
                if (_0xb9907f == "select") try {
                  var _0x13d5dd = document["createRange"]();
                  _0x13d5dd.selectNode(document["getElementById"]("chatMessages")), window["getSelection"]()["removeAllRanges"](), window.getSelection()["addRange"](_0x13d5dd);
                } catch (_0x467606) { }
              }
            }
          },
          items: {
            copy: {
              name: "Copy text",
              icon: "fa-copy"
            },
            select: {
              name: "Select all",
              icon: "fa-i-cursor"
            },
            "-": {
              type: "cm_separator"
            },
            clear: {
              name: "Clear text",
              icon: "fa-broom"
            }
          }
        };
        return $["each"](_0x37dc5a["items"], function (_0x53e384, _0x1fe8fb) {
          _0x37dc5a.items[_0x53e384]["name"] && (_0x37dc5a["items"][_0x53e384]["name"] = function () {
            return textManager["getString"]("menu.textbox." + _0x53e384, null, false);
          });
        }), _0x37dc5a;
      }
    }), $["contextMenu"]({
      selector: ".chatBox a",
      build: function (_0x5f1fa6) {
        var _0x13a79e = {
          callback: function (_0x4d2859, _0x599f83) {
            if (_0x4d2859 == "copylink") {
              var _0x393eb2 = _0x599f83["$trigger"];
              navigator.clipboard["writeText"](_0x393eb2["attr"]("href"));
            } else {
              if (_0x4d2859 == "openlink") {
                var _0x393eb2 = _0x599f83["$trigger"];
                window.open(_0x393eb2["attr"]("href"), "_blank");
              }
            }
          },
          items: {
            copylink: {
              name: "Copy link",
              icon: "fa-copy"
            },
            openlink: {
              name: "Open link",
              icon: "fa-arrow-up-right-from-square"
            }
          }
        };
        return $.each(_0x13a79e["items"], function (_0x5c232c, _0xac530a) {
          _0x13a79e["items"][_0x5c232c].name && (_0x13a79e["items"][_0x5c232c]["name"] = function () {
            return textManager["getString"]("menu.textbox." + _0x5c232c, null, false);
          });
        }), _0x13a79e;
      }
    }), $(this.emojiList).on("emojiSelected", function (_0x26c31e) {
      _0x3c18d9["content"].find("input[name=\"text\"]").val(_0x3c18d9["content"]["find"]("input[name=\"text\"]")["val"]() + _0x26c31e["emoji"]);
    }), this["content"].find("button[name=\"submit\"]").on(UI.pointerEvent("click"), function (_0x4e5a3c) {
      _0x4e5a3c["preventDefault"](), _0x3c18d9["sendMessage"](), _0x3c18d9["content"]["find"]('input[name="text"]').focus();
    }), this["content"]["find"](".chatBox").on("copy", function (_0x2949c3) {
      // Only hide msgTime if fixCopyAction is NOT true
      if (localStorage.getItem("fixCopyAction") !== "true") {
        _0x3c18d9["content"]["find"](".msgTime")["hide"]();
        setTimeout(function () {
          _0x3c18d9["content"]["find"](".msgTime")["show"]();
        }, 100);
      }
    }), this["content"].find("input[name=\"text\"]").on("blur", function (_0x1875c9) {
      !_0x3c18d9.userTag["isHovering"]() && setTimeout(function () {
        _0x3c18d9.userTag["hide"]();
      }, 250);
    }), this["content"].find("input[name=\"text\"]").on("focus", function (_0x36880c) {
      var _0xf3b9be = _0x3c18d9["currentWord"](this),
        _0x3d8d3f = _0xf3b9be["word"];
      _0x3d8d3f[0] == "@" && _0x3c18d9["showUserTag"](_0x3d8d3f["slice"](1));
    }), this["content"].find("input[name=\"text\"]").on("click", function (_0x2b7b32) {
      var _0x19debb = _0x3c18d9["currentWord"](this),
        _0x50b60c = _0x19debb["word"];
      _0x50b60c[0] == "@" ? _0x3c18d9["showUserTag"](_0x50b60c["slice"](1)) : _0x3c18d9["userTag"]["hide"]();
    }), this["content"].find("input[name=\"text\"]").on("keydown", function (_0x4f4210) {
      if (_0x3c18d9.userTag["isVisible"]()) {
        var _0x51b7bf = ["ArrowUp", "ArrowDown", "Enter"];
        if (_0x51b7bf["indexOf"](_0x4f4210["key"]) > -1) {
          _0x4f4210.preventDefault();
          if (_0x4f4210["key"] == "ArrowUp") _0x3c18d9["userTag"].up(); else _0x4f4210.key == "ArrowDown" && _0x3c18d9.userTag["down"]();
          return;
        }
      }
      _0x4f4210["which"] == 13 && (_0x4f4210["preventDefault"](), _0x3c18d9.sendMessage());
    }), this["content"].find("input[name=\"text\"]").on("keyup", function (_0x552e20) {
      var _0x79dfaf = _0x3c18d9.currentWord(this),
        _0x5ddf8e = _0x79dfaf.word;
      _0x5ddf8e[0] == "@" ? (_0x3c18d9["showUserTag"](_0x5ddf8e.slice(1)), _0x552e20["key"] == "Enter" && _0x3c18d9["userTag"].accept()) : _0x3c18d9["userTag"].hide();
    }), this["content"].on(UI["pointerEvent"]("click"), ".closePM", function (_0x1b7a66) {
      _0x1b7a66.preventDefault(), _0x1b7a66["stopPropagation"]();
      var _0x49d42d = _0x3c18d9.getChannelObject($(this)["attr"]("name"));
      _0x3c18d9["closeChannel"](_0x49d42d["name"], _0x49d42d["type"]);
    }), this["content"]["find"](".fontIncrease").on(UI["pointerEvent"]("click"), function (_0x50c90d) {
      _0x50c90d["preventDefault"](), _0x3c18d9["fontIncrease"]();
    }), this["content"].find(".fontDecrease").on(UI["pointerEvent"]("click"), function (_0x1289c1) {
      _0x1289c1.preventDefault(), _0x3c18d9["fontDecrease"]();
    }), this["content"].find("a[name=\"newPM\"]").on(UI["pointerEvent"]("click"), function (_0x2067f2) {
      _0x2067f2["preventDefault"]();
      var _0xcd1dc0 = 0;
      $.each(room.users, function (_0x352b6f, _0x5cd95c) {
        !_0x3c18d9.existsChannel(_0x5cd95c["username"], "user") && _0xcd1dc0++;
      });
      if (_0xcd1dc0 > 0) {
        _0x3c18d9["enableModal"](_0x3c18d9["loadFile"]("forms/chat.modal.newpm.html")), _0x3c18d9["content"]["find"]("select[name=\"userspm\"]")["focus"]();
        var _0x44bc7b = _0x3c18d9["content"]["find"]("select[name=\"userspm\"]");
        _0x3c18d9["content"]["find"]("a[name=\"addPM\"]").on(UI.pointerEvent("click"), function (_0x8e7cb2) {
          _0x8e7cb2["preventDefault"](), !_0x3c18d9["existsChannel"](_0x44bc7b["val"](), "user") && (_0x3c18d9.addChannel(_0x44bc7b.val(), "user"), _0x3c18d9["selectChannel"](_0x44bc7b["val"](), "user"), _0x3c18d9["disableModal"]());
        }), $["each"](room["users"], function (_0x46d8bd, _0x5008d0) {
          !_0x3c18d9["existsChannel"](_0x5008d0["username"], "user") && _0x44bc7b["append"](new Option(_0x5008d0["username"], _0x5008d0["username"]));
        });
      } else UI["dialogHandler"]["showAlert"](textManager.getString("alerts.txtNoMoreUsers"));
    }), this["content"].on(UI["pointerEvent"]("up"), ".channelTitle", function (_0x374780) {
      _0x374780["preventDefault"]();
      var _0x12e1d0 = $(this)["attr"]("name"),
        _0x19573e = _0x3c18d9["getChannelObject"](_0x12e1d0);
      _0x374780["which"] && _0x374780["which"] == 2 ? _0x3c18d9["closeChannel"](_0x19573e.name, _0x19573e["type"]) : _0x3c18d9["selectChannel"](_0x19573e["name"], _0x19573e.type);
    }), this["content"].on(UI["pointerEvent"]("click"), 'button[name="emoji"]', function (_0x44a1b9) {
      _0x44a1b9["preventDefault"](), _0x3c18d9["showEmojiSelector"]();
    }), $(this).on("dialogResizingEnded dialogMaximized dialogRestored", function (_0x1d89f8) {
      _0x3c18d9.scroll["scroll"]({
        y: "100%"
      }), _0x3c18d9["emojiList"]["isVisible"]() && _0x3c18d9.showEmojiSelector(), _0x3c18d9["userTag"]["isVisible"]() && _0x3c18d9.showUserTag();
    }), this["content"].on(UI.pointerEvent("click"), 'a[data-thumb-service="fmgallery"]', function (_0x1fc851) {
      _0x1fc851["preventDefault"](), UI["galleryImageDialog"].show($(this)["data"]("thumb-id"));
    }), this["content"].on(UI["pointerEvent"]("click"), 'a[data-thumb-service="fmgalleryuser"]', function (_0x187c69) {
      _0x187c69["preventDefault"](), UI["userGalleryDialog"]["show"]({
        uid: $(this)["data"]("thumb-id")
      });
    });
  }
  ["closeChannel"](_0x358b0b, _0x56efdb) {
    var _0x448749 = this.getChannelString(_0x358b0b, _0x56efdb);
    this["existsChannel"](_0x358b0b, _0x56efdb) && this["channels"][_0x448749]["closable"] && (this["deleteChannel"](_0x358b0b, _0x56efdb), this["currentChannel"] == _0x448749 && this["selectChannel"]("public", "room"));
  }
  ["isVisible"]() {
    return this["content"].is(":visible");
  }
  ["acceptTag"](_0x50751b, _0x27eab2 = "") {
    var _0x16aa25 = this.content["find"]("input[name=\"text\"]"),
      _0x2a5e3b = _0x16aa25.val(),
      _0x2af666 = this["currentWord"](_0x16aa25[0]),
      _0x1e1b8e = _0x2a5e3b["substring"](0, _0x2af666.start),
      _0x2c2b54 = _0x2a5e3b["substring"](_0x2af666["end"]),
      _0x35d599 = _0x1e1b8e + "@" + _0x50751b + (_0x2c2b54 == "" ? " " : _0x2c2b54),
      _0x25b695 = (_0x1e1b8e + "@" + _0x50751b).length + 1;
    _0x16aa25["val"](_0x35d599), setCaretPosition(_0x16aa25[0], _0x25b695);
  }
  ["getWordLimits"](_0x2d42d0, _0x585f94) {
    var _0xe05ad8 = _0x585f94,
      _0x387436 = _0x585f94,
      _0x247195 = _0x585f94,
      _0x229ce4 = _0x2d42d0.substring(0, _0x585f94),
      _0x12819e = "";
    if (_0x229ce4["indexOf"](" ") > 0) {
      let _0x221023 = _0x229ce4["split"](" ");
      _0x12819e = _0x221023[_0x221023["length"] - 1];
    } else _0x12819e = _0x229ce4;
    var _0x5b7dcb = "",
      _0x58bb74 = "";
    if (_0x2d42d0["length"] > _0x585f94 && _0x2d42d0[_0x585f94] != " ") {
      _0x5b7dcb = _0x2d42d0["substring"](_0x585f94);
      if (_0x5b7dcb["indexOf"](" ") > 0) {
        let _0xa495ba = _0x5b7dcb["split"](" ");
        _0x58bb74 = _0xa495ba[0];
      } else _0x58bb74 = _0x5b7dcb;
    }
    return {
      word: _0x12819e + _0x58bb74,
      start: _0x585f94 - _0x12819e["length"],
      end: _0x585f94 + _0x58bb74["length"],
      caret: _0x585f94
    };
  }
  ["currentWord"](_0x43e847) {
    var _0x24b0e3 = getCaretPosition(_0x43e847);
    return this["getWordLimits"](_0x43e847.value, _0x24b0e3);
  }
  ["showEmojiSelector"]() {
    var _0x1da018 = this.content["offset"](),
      _0x59bc53 = this["content"]["find"]("button[name=\"emoji\"]")["offset"]();
    this["emojiList"]["move"](_0x59bc53["left"] - _0x1da018.left, _0x59bc53.top - _0x1da018["top"] - this.emojiList["height"]()), this.emojiList["show"]();
  }
  ["showUserTag"](_0x360007 = "") {
    var _0x38237d = this["content"]["offset"](),
      _0x2bfa4a = this["content"]["find"](".chatText .chatTextGroup")["offset"](),
      _0x4c379e = this.content["find"](".chatText .chatTextGroup").width();
    this["userTag"].setWidth(_0x4c379e), this.userTag.move(_0x2bfa4a["left"] - _0x38237d["left"], this["content"]["find"](".chatText")["outerHeight"]() + 10), this["userTag"]["show"](), this["userTag"]["filter"](_0x360007);
  }
  ["updateWarnings"]() {
    if (room) {
      this["content"].find("div[name=\"channelWarnings\"]").text("");
      var _0x3cbf2d = this["getChannelObject"](this["currentChannel"]);
      if (_0x3cbf2d["type"] == "room") {
        if (!room["connected"]) this["content"]["find"]("div[name=\"channelWarnings\"]")["text"]("NOT CONNECTED"); else room["myself"].silenced && this["content"]["find"]("div[name=\"channelWarnings\"]").text("SILENCED");
      } else {
        if (_0x3cbf2d["name"] in room["users"]) {
          let _0x5cf1e3 = room["users"][_0x3cbf2d["name"]];
          _0x5cf1e3["ignored"] && this.content.find("div[name=\"channelWarnings\"]")["text"]("IGNORED");
        } else this["content"]["find"]("div[name=\"channelWarnings\"]")["text"]("OFFLINE");
      }
      this["changed"]();
    }
  }
  ["bindRoomEvents"]() {
    this["setChannelProperty"]("public", "room", "closable", false), this["setChannelProperty"]("staff", "room", "closable", false), this["setChannelProperty"]("public", "room", "silenced", room["myself"].silenced), this["setChannelProperty"]("staff", "room", "locked", !room.can("modmessageuse"));
    var _0x4a7a89 = this;
    $(room).on("userRenamed.chatevents", function (_0x54f726) {
      _0x4a7a89.updateWarnings();
    }), $(room).on("userIgnored.chatevents userUnignored.chatevents", function (_0x31d112) {
      _0x31d112["type"] == "userIgnored" ? _0x4a7a89["registerEvent"](textManager["getString"]("events.txtIgnore", _0x31d112["username"], false)) : _0x4a7a89.registerEvent(textManager["getString"]("events.txtUnignore", _0x31d112["username"], false)), _0x4a7a89["existsChannel"](_0x31d112["username"], "user") && (_0x4a7a89["setChannelProperty"](_0x31d112["username"], "user", "ignored", _0x31d112["type"] == "userIgnored"), _0x4a7a89.updateWarnings());
    }), $(room).on("roomPrivilegesChanged", function (_0x2ba20d) {
      var _0x3cbe85 = room["can"]("modmessageuse");
      _0x4a7a89["setChannelProperty"]("staff", "room", "locked", !_0x3cbe85);
    }), $(room).on("userLeft.chatevents userJoined.chatevents", function (_0x360a51) {
      let _0x193aeb = Object.keys(room["users"]).length;
      _0x193aeb > 0 ? _0x4a7a89["content"]["find"]('a[name="newPM"]')["show"]() : _0x4a7a89["content"]["find"]('a[name="newPM"]')["hide"](), _0x4a7a89["existsChannel"](_0x360a51["username"], "user") && _0x4a7a89.setChannelProperty(_0x360a51.username, "user", "offline", _0x360a51["type"] == "userLeft"), _0x4a7a89["userTag"]["userlistChanged"](), _0x4a7a89["updateWarnings"]();
    }), $(room).on("usernameChanged.chatevents", function (_0x45a976) {
      _0x4a7a89["existsChannel"](_0x45a976["oldname"], "user") && _0x4a7a89["setChannelProperty"](_0x45a976["oldname"], "user", "offline", true), _0x4a7a89["existsChannel"](_0x45a976["newname"], "user") && _0x4a7a89["setChannelProperty"](_0x45a976["newname"], "user", "offline", false), _0x4a7a89["userTag"]["userlistChanged"](), _0x4a7a89["updateWarnings"]();
    }), $(room["myself"]).on("silenceChanged.chatevents", function (_0x5d3f64) {
      _0x4a7a89["setChannelProperty"]("public", "room", "silenced", _0x5d3f64["status"]), _0x4a7a89["updateWarnings"]();
    });
  }
  ["unbindRoomEvents"]() {
    $(room)["off"](".chatevents"), $(room["myself"])["off"](".chatevents");
  }
  ["addChannel"](_0x2cbb42, _0x2a5e66) {
    var _0x2e76d1 = this["getChannelString"](_0x2cbb42, _0x2a5e66);
    this["channels"][_0x2e76d1] = new ChatChannel(_0x2cbb42, _0x2a5e66);
    var _0x463e18 = this;
    $(this["channels"][_0x2e76d1]).on("chatChannelPropertyChanged", function (_0x223269) {
      if (_0x223269["prop"] == "closable") _0x223269["value"] ? _0x463e18.content["find"](".sidebarElements .channelTitle[name=\"" + _0x2e76d1 + "\"] .channelClose")["show"]() : _0x463e18["content"]["find"]('.sidebarElements .channelTitle[name="' + _0x2e76d1 + "\"] .channelClose").hide(); else {
        if (_0x223269.prop == "locked") _0x223269["value"] ? !_0x463e18["channelHasIcon"](_0x2cbb42, _0x2a5e66, "fa-lock") && (_0x463e18["content"].find('.sidebarElements .channelTitle[name="' + _0x2e76d1 + "\"] .channelIcons")["append"](new Icon("fa-lock")["html"]()), _0x463e18["content"]["find"]('.sidebarElements .channelTitle[name="' + _0x2e76d1 + '"]')["addClass"]("locked")) : (_0x463e18.content.find(".sidebarElements .channelTitle[name=\"" + _0x2e76d1 + "\"] .channelIcons > .fa-lock")["remove"](), _0x463e18["content"]["find"](".sidebarElements .channelTitle[name=\"" + _0x2e76d1 + '"]')["removeClass"]("locked")); else {
          if (_0x223269["prop"] == "silenced" || _0x223269["prop"] == "ignored") _0x223269["value"] ? !_0x463e18.channelHasIcon(_0x2cbb42, _0x2a5e66, "fa-comment-slash") && _0x463e18["content"]["find"](".sidebarElements .channelTitle[name=\"" + _0x2e76d1 + '"] .channelIcons')["append"](new Icon("fa-comment-slash").html()) : _0x463e18["content"]["find"](".sidebarElements .channelTitle[name=\"" + _0x2e76d1 + "\"] .channelIcons > .fa-comment-slash").remove(); else _0x223269.prop == "offline" && _0x463e18["currentChannel"] == _0x2e76d1 && (_0x223269["value"] ? _0x463e18["lockMessageBar"]() : _0x463e18["unlockMessageBar"]());
        }
      }
    }), $(this["channels"][_0x2e76d1]).on("unreadMessages", function (_0x16dd92) {
      _0x16dd92["messages"] > 0 ? _0x463e18.content["find"](".sidebarElements .channelTitle[name=\"" + _0x2e76d1 + '"] .channelIcons > .badge')["length"] > 0 ? _0x463e18["content"]["find"](".sidebarElements .channelTitle[name=\"" + _0x2e76d1 + "\"] .channelIcons > .badge")["html"](_0x16dd92["messages"]) : _0x463e18["content"]["find"](".sidebarElements .channelTitle[name=\"" + _0x2e76d1 + '"] .channelIcons')["append"]("<span class=\"badge badge-danger\">" + _0x16dd92["messages"] + "</span>") : _0x463e18.content.find(".sidebarElements .channelTitle[name=\"" + _0x2e76d1 + "\"] .channelIcons > .badge")["remove"]();
    });
    var _0x229739 = "channelTypeRoom",
      _0x188148 = "#";
    let _0x27659 = _0x2cbb42;
    _0x2a5e66 == "user" ? (_0x229739 = "channelTypeUser", _0x188148 = "@") : _0x27659 = textManager["getString"]("chat.room." + _0x2cbb42);
    this["content"]["find"](".sidebarElements")["append"]("<div name=\"" + _0x188148 + _0x2cbb42 + "\" data-type=\"" + _0x2a5e66 + "\" data-name=\"" + _0x2cbb42 + "\" class=\"channelTitle " + _0x229739 + "\"><div class=\"channelCaption\">" + _0x188148 + _0x27659 + "</div><div class=\"channelClose\"><a href=\"#\" name=\"" + _0x188148 + _0x2cbb42 + '" class="closePM"><i class="fas fa-times"></i></a></div><div class="channelIcons"></div></div>'), this["content"]["find"]("#chatMessages")["append"]('<div class="channelMessages" name="' + _0x188148 + _0x2cbb42 + '"></div>'), this["content"]["find"]("#chatMessages div.channelMessages[name=\"" + _0x188148 + _0x2cbb42 + '"]')["hide"]();
    if (room) {
      if (_0x2a5e66 == "room") this["setChannelProperty"](_0x2cbb42, _0x2a5e66, "closable", false), this["setChannelProperty"](_0x2cbb42, _0x2a5e66, "silenced", room && room.myself ? room["myself"]["silenced"] : false), _0x2cbb42 == "staff" && this.setChannelProperty(_0x2cbb42, _0x2a5e66, "locked", !room["can"]("modmessageuse")); else _0x2a5e66 == "user" && (this.setChannelProperty(_0x2cbb42, _0x2a5e66, "closable", true), this["setChannelProperty"](_0x2cbb42, _0x2a5e66, "ignored", room["users"][_0x2cbb42]["ignored"]));
    }
  }
  ["setChannelProperty"](_0x25bc6b, _0x3d63a2, _0x59d72, _0x197de0) {
    var _0xd5f31c = this["getChannelString"](_0x25bc6b, _0x3d63a2);
    this["channels"][_0xd5f31c]["setProperty"](_0x59d72, _0x197de0);
  }
  ["channelHasIcon"](_0x4abeec, _0x2bc8e0, _0x2b23c2) {
    var _0x251e49 = this["getChannelString"](_0x4abeec, _0x2bc8e0);
    return this["content"]["find"](".sidebarElements .channelTitle[name=\"" + _0x251e49 + '"] .channelIcons > .' + _0x2b23c2)["length"] > 0;
  }
  ["deleteChannel"](_0x1e8180, _0x2a3c52) {
    var _0x45fc6f = this["getChannelString"](_0x1e8180, _0x2a3c52);
    this.content["find"](".sidebarElements .channelTitle[name=\"" + _0x45fc6f + '"]')["remove"](), this["content"]["find"]("#chatMessages div.channelMessages[name=\"" + _0x45fc6f + '"]')["remove"](), delete this.channels[_0x45fc6f];
  }
  ["selectChannel"](_0x5806b2, _0x3b345f) {
    var _0x1f5de4 = this["getChannelString"](_0x5806b2, _0x3b345f);
    if (this.currentChannel != _0x1f5de4) {
      if (this["existsChannel"](_0x5806b2, _0x3b345f)) {
        if (!this["channelHasIcon"](_0x5806b2, _0x3b345f, "fa-lock")) {
          this["content"]["find"]("#chatMessages div.channelMessages")["hide"](), this["content"]["find"]("#chatMessages div.channelMessages[name=\"" + _0x1f5de4 + '"]').show(), this["content"]["find"](".sidebarElements .channelTitle")["removeClass"]("selected"), this["content"]["find"](".sidebarElements .channelTitle[name=\"" + _0x1f5de4 + '"]').addClass("selected");
          if (_0x3b345f == "room") {
            let _0x5e0acf = this.getChannelObject(_0x1f5de4);
            this["content"]["find"]("#chatTitle .title").html(_0x5e0acf.prefix + textManager["getString"]("chat.room." + _0x5806b2));
          } else this["content"]["find"]("#chatTitle .title")["text"](_0x1f5de4);
          this["scroll"]["scroll"]({
            y: "100%"
          }), this["currentChannel"] && this["currentChannel"] in this["channels"] && (this.channels[this["currentChannel"]].input = this["content"]["find"]("input[name=\"text\"]")["val"]()), this["content"]["find"]("input[name=\"text\"]").val(this.channels[_0x1f5de4]["input"]), this["currentChannel"] = _0x1f5de4, this["setUnreadMessages"](_0x5806b2, _0x3b345f, 0), this["channels"][this["currentChannel"]]["offline"] ? this["lockMessageBar"]() : this["unlockMessageBar"](), this["content"]["find"]("input[name=\"text\"]")["focus"](), this["updateWarnings"]();
        }
      }
    }
  }
  ["existsChannel"](_0x411f1a, _0x39dee5) {
    var _0x737d7 = this["getChannelString"](_0x411f1a, _0x39dee5);
    return _0x737d7 in this.channels;
  }
  ["getChannelString"](_0x5f03f5, _0x5c6412) {
    let _0x2f588d = "#";
    return _0x5c6412 == "user" && (_0x2f588d = "@"), _0x2f588d + _0x5f03f5;
  }
  ["getChannelObject"](_0x16bafe) {
    var _0x31b26b = _0x16bafe[0],
      _0x16bafe = _0x16bafe["substring"](1),
      _0x34a796 = _0x31b26b == "@" ? "user" : "room";
    return {
      prefix: _0x31b26b,
      name: _0x16bafe,
      type: _0x34a796
    };
  }
  ["composeHTML"](_0x4c0c28, _0x36ae82, _0x137f60 = null) {
    var _0x28b003 = {},
      _0xe944f4 = dateToObj(),
      _0x5487f6 = _0xe944f4["hours"] + ":" + _0xe944f4["minutes"];
    if (_0x4c0c28 == "MYMSG" || _0x4c0c28 == "MSG") {
      var _0x228cf4 = room["myself"];
      _0x4c0c28 == "MSG" && (_0x228cf4 = room["users"][_0x137f60]), _0x28b003["block"] = "<div class=\"chatBlock messageBlock\" data-type=\"" + _0x4c0c28 + "\" data-username=\"" + _0x228cf4.username + "\"><div class=\"msgTime\" data-timestamp = \"" + _0x5487f6 + '">' + _0x5487f6 + "</div><div data-timestamp=\"" + _0x5487f6 + "\" class=\"msgUsername " + UI["rankToStyle"](_0x228cf4.rank) + '">' + _0x228cf4["username"] + "</div><div class=\"msgContent\"></div></div>";
    } else {
      if (_0x4c0c28 == "EVENT") _0x28b003["block"] = "<div class=\"chatBlock eventBlock\"><div class=\"msgTime\" data-timestamp = \"" + _0x5487f6 + '">' + _0x5487f6 + "</div><div class=\"msgContent\"></div></div>"; else {
        if (_0x4c0c28 == "MOTD") _0x28b003["block"] = "<div class=\"chatBlock motdBlock\"><div class=\"msgTime\" data-timestamp = \"" + _0x5487f6 + '">' + _0x5487f6 + "</div><div class=\"msgContent\"></div></div>"; else _0x4c0c28 == "GM" && (_0x28b003.block = "<div class=\"chatBlock gmBlock\"><div class=\"msgTime\" data-timestamp = \"" + _0x5487f6 + '">' + _0x5487f6 + '</div><div class="msgContent"></div></div>');
      }
    }
    return _0x28b003["text"] = "<div class=\"msgLine\"><div class=\"msgTime\" data-timestamp = \"" + _0x5487f6 + "\"></div><div class=\"msgText\">" + _0x36ae82 + "</div></div>", _0x28b003;
  }
  ["createMessage"](_0x58faa0, _0x30c6e2, _0x4add1e, _0x4534bd, _0xacf0f3 = null) {
    var _0x2164c2 = null,
      _0x5373dd = false;
    if (_0x4add1e == "MYMSG") _0x2164c2 = room["myself"]; else {
      if (_0xacf0f3 != null) {
        _0x2164c2 = room["users"][_0xacf0f3];
        var _0x575c3d = parseInt(new Date()["getTime"]() / 1e3);
        !_0x2164c2["ignored"] && _0x2164c2.lastMessage >= _0x575c3d - 30 ? _0x2164c2["chatMessages"]++ : (_0x2164c2.lastMessage = _0x575c3d, _0x2164c2["chatMessages"] = 1), _0x2164c2["chatMessages"] >= this["spamLimit"] && (this.registerEvent(textManager["getString"]("events.txtAutoIgnore", _0x2164c2.username, false)), room["ignoreUser"](_0x2164c2["username"]));
      }
    }
    _0x2164c2 != null && (_0x4534bd = escapeHTML(_0x4534bd), _0x5373dd = _0x2164c2.ignored);
    if (!_0x5373dd) {
      var _0x10cc15 = null;
      UI["userPreferences"]["getGroupOption"]("graphics", "chatpreviews", false) && (_0x10cc15 = this["previews"]["containsImage"](_0x4534bd));
      _0x10cc15 != null && (_0x4534bd = "<div class=\"chatThumb unloaded\" name=\"" + _0x10cc15["service"] + ":" + _0x10cc15["value"] + "\"></div> " + _0x4534bd);
      var _0x37c097 = [],
        _0x3814fd,
        _0x7b11b8 = false;
      const _0x26d145 = /(?:^|\s?)@([^\s]+?)([,\.\!\?'"\:\;]*?)(?:$|\s)/g;
      _0x4534bd = _0x4534bd["replace"](_0x26d145, function (_0x5939c2, _0x337760, _0x56ac54) {
        let _0x43ca11 = "";
        if (room.myself["username"] == _0x337760) _0x7b11b8 = true, _0x43ca11 = " chatTagYou"; else !room["userExists"](_0x337760) && (_0x43ca11 = " chatTagUnknown");
        return _0x37c097.push(_0x337760), " <span class=\"chatTag" + _0x43ca11 + '">@' + _0x337760 + "</span>" + _0x56ac54 + " ";
      }), _0x4534bd = _0x4534bd["replace"](/(\p{Emoji_Presentation}|\p{Extended_Pictographic})(?![^<]*>|[^<>]*<\/)/gu, "<span class=\"chatEmoji\">$&</span>");
      var _0x4fe1e8 = this["composeHTML"](_0x4add1e, nl2br(parseURL(_0x4534bd)), _0xacf0f3),
        _0xa73837 = $(_0x4fe1e8.block);
      _0xa73837.find(".msgContent")["append"](_0x4fe1e8.text);
      var _0x20f4a2 = this["lastMessage"](_0x58faa0, _0x30c6e2);
      if (_0x20f4a2.type == _0x4add1e && _0x2164c2 && _0x20f4a2["username"] == _0x2164c2.username) {
        var _0x3984ef = $(_0x4fe1e8["text"]);
        _0x20f4a2["timestamp"] != _0x3984ef.find(".msgTime")["data"]("timestamp") && _0x3984ef["find"](".msgTime").text(_0x3984ef["find"](".msgTime")["data"]("timestamp")), this.addLine(_0x58faa0, _0x30c6e2, _0x4add1e, _0x3984ef, _0x7b11b8, true);
      } else this.addLine(_0x58faa0, _0x30c6e2, _0x4add1e, _0xa73837, _0x7b11b8);
      if (!this["isVisible"]()) {
        var _0x2f045f;
        _0xacf0f3 ? _0x2f045f = '<span class="notify' + _0x4add1e + "_" + _0x30c6e2 + "\"><span class=\"" + UI["rankToStyle"](room["users"][_0xacf0f3]["rank"]) + '">' + room["users"][_0xacf0f3]["username"] + "</span>:&nbsp;" + $(_0x4fe1e8["text"]).find(".msgText")["html"]() + "</span>" : _0x2f045f = _0x4fe1e8["text"];
        var _0x23243e = _0x4add1e;
        if (_0x4add1e == "MSG") {
          if (_0x30c6e2 == "room") _0x58faa0 == "public" ? _0x23243e = "PUBLICROOM" : _0x23243e = "STAFFROOM"; else _0x30c6e2 == "user" && (_0x23243e = "PM");
        }
        this["showNotification"](_0x23243e, _0x2f045f, 5);
      }
      _0x10cc15 != null && this["requestThumb"](_0x10cc15);
    }
  }
  ["showNotification"](_0x591356, _0x3b4275, _0x3675da) {
    UI["topbar"].setText(_0x591356, _0x3b4275, _0x3675da);
  }
  ["requestThumb"](_0x5e7bee) {
    var _0x455064 = this;
    this.previews["getThumb"](_0x5e7bee).then(function (_0x520e0a) {
      _0x455064["embedImage"](_0x520e0a);
    });
  }
  ["embedImage"](_0x41dbe1) {
    var _0x239825 = this,
      _0x4cb47e = this["content"]["find"]("div.chatThumb.unloaded[name=\"" + _0x41dbe1["service"] + ":" + _0x41dbe1.id + '"]');
    if (_0x4cb47e["length"] > 0) {
      _0x4cb47e["removeClass"]("unloaded");
      var _0x3aa3f9 = new Image();
      _0x3aa3f9["onload"] = function () {
        var _0x341f8a = _0x239825["scroll"].scroll(),
          _0x2f1666 = parseInt(_0x341f8a["ratio"].y * 100) >= 97 || _0x341f8a["max"].y === 0;
        _0x4cb47e["append"]("<a data-thumb-service=\"" + _0x41dbe1["service"] + "\" data-thumb-id=\"" + _0x41dbe1.id + "\" href=\"" + _0x41dbe1["url"] + "\" target=\"_blank\"></a>").find("a").append(this), _0x2f1666 && setTimeout(function (_0x3233e3) {
          _0x239825["scroll"]["scroll"]({
            y: "100%"
          });
        }, 250);
      }, _0x3aa3f9["src"] = _0x41dbe1.image;
    }
  }
  ["sendMessage"]() {
    var _0x14d612 = this["content"].find("input[name=\"text\"]")["val"]()["slice"](0, 250);
    if (_0x14d612 != "") {
      var _0x58b151 = this["getChannelObject"](this["currentChannel"]);
      this.createMessage(_0x58b151["name"], _0x58b151.type, "MYMSG", _0x14d612), this["content"]["find"]("input[name=\"text\"]")["val"]("");
      var _0x3a5da0 = {};
      _0x3a5da0["command"] = "USERFUNCTIONS", _0x3a5da0["option"] = "CHAT", _0x3a5da0.chattype = _0x58b151.type, _0x3a5da0["chatname"] = _0x58b151["name"], _0x3a5da0["message"] = _0x14d612, socket["send"](_0x3a5da0, true);
    }
    this["scroll"]["scroll"]({
      y: "100%"
    });
  }
  ["lastMessage"](_0x5743e4, _0x1ad67b) {
    var _0x4ff3e7 = this.getChannelString(_0x5743e4, _0x1ad67b),
      _0x2b2e7d = this.content.find("#chatMessages div.channelMessages[name=\"" + _0x4ff3e7 + "\"] .chatBlock:last"),
      _0x3184ee = _0x2b2e7d["find"](".msgContent .msgLine:last");
    if (_0x2b2e7d) return {
      type: _0x2b2e7d.data("type"),
      username: _0x2b2e7d["data"]("username"),
      timestamp: _0x3184ee["find"](".msgTime").data("timestamp")
    };
    return null;
  }
  ["addLine"](_0x440501, _0x10aa35, _0x425a8e, _0x589cdd, _0x2f242f = false, _0x5c11f3 = false) {
    !this["existsChannel"](_0x440501, _0x10aa35) && this.addChannel(_0x440501, _0x10aa35);
    var _0x175755 = this["scroll"].scroll(),
      _0x2a7e37 = parseInt(_0x175755.ratio.y * 100) >= (localStorage.getItem("fixAutoScroll") === "true" ? 99.9 : 97) || _0x175755["max"].y === 0,
      _0x1cbfac = this["getChannelString"](_0x440501, _0x10aa35);
      _0x1cbfac = this["getChannelString"](_0x440501, _0x10aa35);
    _0x5c11f3 ? this.content["find"]("#chatMessages div.channelMessages[name=\"" + _0x1cbfac + "\"] .messageBlock:last .msgContent")["append"](_0x589cdd) : this["content"]["find"]("#chatMessages div.channelMessages[name=\"" + _0x1cbfac + '"]')["append"](_0x589cdd);
    if (_0x2a7e37) {
      var _0x1896a1 = this;
      setTimeout(function (_0xf1f4f7) {
        _0x1896a1.scroll["scroll"]({
          y: "100%"
        });
      }, 250);
    }
    _0x425a8e != "EVENT" && (!this["active"] || this["currentChannel"] != _0x1cbfac) && this["setUnreadMessages"](_0x440501, _0x10aa35, this.channels[_0x1cbfac]["unread"] + 1);
    if (!this["active"]) {
      if (_0x425a8e != "EVENT" && _0x425a8e != "MOTD") {
        if (_0x10aa35 == "user" || _0x2f242f) UI["playSound"]("pm"); else _0x10aa35 == "room" && (_0x440501 == "staff" ? UI.playSound("staff") : UI.playSound("chat"));
      }
    }
  }
  ["lockMessageBar"]() {
    this["content"]["find"]("input[name=\"text\"]")["attr"]("disabled", "disabled"), this["content"]["find"]("button[name=\"submit\"]").attr("disabled", "disabled"), this["content"]["find"]("button[name=\"emoji\"]").attr("disabled", "disabled"), this["content"]["find"]("input[name=\"text\"]").addClass("disabled"), this["content"]["find"]("button[name=\"submit\"]")["addClass"]("disabled"), this["content"].find("button[name=\"emoji\"]")["addClass"]("disabled");
  }
  ["unlockMessageBar"]() {
    this["content"]["find"]("input[name=\"text\"]")["removeAttr"]("disabled"), this["content"].find("button[name=\"submit\"]")["removeAttr"]("disabled"), this["content"].find("button[name=\"emoji\"]")["removeAttr"]("disabled"), this["content"]["find"]("input[name=\"text\"]")["removeClass"]("disabled"), this["content"]["find"]('button[name="submit"]').removeClass("disabled"), this["content"]["find"]("button[name=\"emoji\"]")["removeClass"]("disabled");
  }
  ["fontIncrease"]() {
    this["changeFontSize"](this["fontSize"] + 1);
  }
  ["fontDecrease"]() {
    this.changeFontSize(this["fontSize"] - 1);
  }
  ["changeFontSize"](_0x20f5d8) {
    let _0x311727 = 10,
      _0x54485f = 20;
    this["fontSize"] = Math["min"](Math["max"](_0x20f5d8, _0x311727), _0x54485f), this["content"]["find"]("#chatMessages")["css"]("font-size", this["fontSize"] + "px");
  }
  ["loadContent"](_0x47a6e8) {
    this["content"]["html"](_0x47a6e8);
  }
  ["reset"]() {
    this["content"]["find"]("#chatMessages div.channelMessages").empty(), this["setUnreadMessages"]("public", "room", 0), this.setUnreadMessages("staff", "room", 0), this.selectChannel("public", "room");
    var _0x20925a = this;
    Object["keys"](this["channels"])["forEach"](function (_0x32d0b5) {
      var _0xfca6e7 = _0x20925a["channels"][_0x32d0b5];
      _0xfca6e7.type == "user" && _0x20925a["deleteChannel"](_0xfca6e7["name"], _0xfca6e7["type"]);
    });
  }
  ["onShow"]() {
    this["changed"]();
    var _0x1fc4d3 = this;
    setTimeout(function (_0x85cf39) {
      _0x1fc4d3["scroll"]["scroll"]({
        y: "100%"
      });
    }, 250);
    var _0x3e520c = _0x1fc4d3["getChannelObject"](this["currentChannel"]);
    this["setUnreadMessages"](_0x3e520c.name, _0x3e520c["type"], 0), this["content"]["find"]("input[name=\"text\"]")["focus"](), this.updateWarnings();
  }
  ["setUnreadMessages"](_0x1008fa, _0xf5ca9c, _0x50739e) {
    var _0x5c1d19 = this["getChannelString"](_0x1008fa, _0xf5ca9c);
    _0x5c1d19 in this.channels && this.channels[_0x5c1d19]["setUnread"](_0x50739e);
    var _0x365d2b = 0,
      _0x59768f = false,
      _0x626f9e = this;
    Object["keys"](this["channels"]).forEach(function (_0x369b8d) {
      _0x365d2b += _0x626f9e["channels"][_0x369b8d].unread, _0x626f9e.channels[_0x369b8d]["type"] == "user" && _0x626f9e["channels"][_0x369b8d]["unread"] > 0 && _0x59768f++;
    });
    var _0x5a280e = "msg";
    _0x59768f > 0 && (_0x5a280e = "pm"), $(this).triggerHandler(new unreadMessagesEvent(_0x365d2b, _0x5a280e).getEvent());
  }
  ["registerEvent"](_0x48728f) {
    this["createMessage"]("public", "room", "EVENT", _0x48728f);
  }
  ["registerGlobalMessage"](_0x2598f1) {
    this["createMessage"]("public", "room", "GM", _0x2598f1);
  }
  ["onFocus"]() {
    this["scroll"]["scroll"]({
      y: "100%"
    });
  }
  ["disableModal"]() {
    this["emojiList"]["hide"](), this["modal"]["hide"](), this.content["remove"](this["modal"]), $(this)["triggerHandler"](new dialogModalDisabledEvent()["getEvent"]());
  }
  ["hasModal"]() {
    return this["modal"].is(":visible") || this.emojiList["isVisible"]();
  }
}
class ChatChannel {
  constructor(_0x2dce94, _0x37e4b8) {
    this["name"] = _0x2dce94, this["type"] = _0x37e4b8, this.unread = 0, this["closable"] = false, this["silenced"] = false, this["locked"] = false, this.offline = false, this["input"] = "";
  }
  ["setUnread"](_0x5a1fc0) {
    this["unread"] = _0x5a1fc0, $(this)["triggerHandler"](new unreadMessagesEvent(_0x5a1fc0).getEvent());
  }
  ["setProperty"](_0x48f835, _0x4c419e) {
    this[_0x48f835] = _0x4c419e, $(this).triggerHandler(new chatChannelPropertyChangedEvent(_0x48f835, _0x4c419e)["getEvent"]());
  }
}
class UndoDialog extends Dialog {
  constructor(_0x336cfa) {
    super(_0x336cfa), this["icon"] = "fa-undo", this["caption"] = textManager.getString("undo.title"), this["helpLink"] = "https://flockmod.com/help/basics/drawing/", this.width = 770, this.height = 600, this["enabled"] = false, this["defaultInterval"] = 5, this["defaultMax"] = 20, this["roomName"] = null, this.intervalInput, this["maxInput"], this.boards = new Array(), this["maxBoards"], this["secInterval"], this["slider"] = null, this["layers"] = null, this.layersCheckbox = null, this["undoInterval"] = null, this["lastSaveTime"] = null, this["selection"], this["currentTool"] = "rectangle", this.selectionPrevious = null, this["selectionInitial"] = null, this.loadContent(this.loadFile("forms/undo.main.html"));
    var _0x374491 = this;
    this["content"].on(UI.pointerEvent("click"), ".subcontentOption", function (_0xd2df42) {
      _0xd2df42["preventDefault"]();
      var _0x103131 = $(this).data("subcontent");
      _0x374491["loadPage"](_0x103131);
    });
  }
  ["undoCurrentCanvasFromConsole"](specificLayers = null) {
  
  if (!room || !room.board) {
    console.error("Room or board not available");
    return false;
  }
  
  // Standard checks
  if (socket && socket.isTransferInProgress) {
    console.error("Cannot perform undo while board transfer is in progress");
    return false;
  }
  if (UI.undoHistoryEnabled) {
    console.error("Cannot perform undo while step back is enabled");
    return false;
  }
  if (UI.uploader && UI.uploader.isVisible()) {
    console.error("Cannot perform undo while image transform is in progress");
    return false;
  }
  if (room.board.isProcessingCommit) {
    console.error("Cannot perform undo while stroke commits are in progress");
    return false;
  }
  
  try {
    // Get selection mask if selection tool is active
    let selectionMask = null;
    let selectionBounds = null;
    let isLassoSelection = false;
    const selectionBrush = room.myself.surface.brushHandler.brushes.selection;
    
    if (selectionBrush && selectionBrush.isUsingSlate()) {
      // Get selection points/coordinates
      selectionMask = selectionBrush.getCoords();
      
      // Check if the mask is valid
      if (!selectionMask || selectionMask.length < 3) {
        console.warn("Invalid selection mask, using full canvas");
        selectionMask = null;
      } else {
        // Check if this is a lasso selection (more than 4 points suggests non-rectangular)
        isLassoSelection = selectionBrush.currentTool === "lasso" || selectionMask.length > 4;

        // Calculate selection bounds for both rectangle and lasso
        let minX = Number.MAX_VALUE, minY = Number.MAX_VALUE;
        let maxX = 0, maxY = 0;
        
        for (let i = 0; i < selectionMask.length; i++) {
          const point = selectionMask[i];
          minX = Math.min(minX, point.x);
          minY = Math.min(minY, point.y);
          maxX = Math.max(maxX, point.x);
          maxY = Math.max(maxY, point.y);
        }
        
        // Use exact bounds without padding
        minX = Math.max(0, Math.floor(minX));
        minY = Math.max(0, Math.floor(minY));
        maxX = Math.min(room.board.canvasWidth, Math.ceil(maxX));
        maxY = Math.min(room.board.canvasHeight, Math.ceil(maxY));
        
        selectionBounds = {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
        
      }
    } else {
    }
    
    // Determine which layers to process
    var layersToUndo = specificLayers || Array.from({length: room.board.nLayers}, (_, i) => i);
    
    // Create a transfer - IMPORTANT: The 5th parameter (true) sets firstPart flag
    var transfer = new Transfer("BROADCAST", null, "undo", new Date().getTime(), true);
    
    // Add mask if available - use addMask method
    if (selectionMask && selectionMask.length > 0) {
      transfer.addMask(selectionMask);
    }
    
    // Add event handlers
    $(transfer).on("transferStart", function() {
    });
    $(transfer).on("transferChunkReady", function() {
    });
    $(transfer).on("transferStart transferChunkReady", sendChunk);
    
    // Process each selected layer
    for (var layer of layersToUndo) {
      if (layer >= 0 && layer < room.board.nLayers) {
        
        if (selectionBounds) {
          // Get the layer canvas and context
          var layerCanvas = room.board.layers[layer].advCanvas.canvas[0];
          var layerContext = layerCanvas.getContext('2d');
          
          // Create a temporary canvas to handle the selection
          var tempCanvas = document.createElement('canvas');
          tempCanvas.width = selectionBounds.width;
          tempCanvas.height = selectionBounds.height;
          var tempCtx = tempCanvas.getContext('2d');
          
          if (isLassoSelection) {
            // For lasso/free-form selection, use a clipping path
            tempCtx.save();
            
            // Draw the selection path
            tempCtx.beginPath();
            for (let i = 0; i < selectionMask.length; i++) {
              const point = selectionMask[i];
              const x = point.x - selectionBounds.x;
              const y = point.y - selectionBounds.y;
              
              if (i === 0) {
                tempCtx.moveTo(x, y);
              } else {
                tempCtx.lineTo(x, y);
              }
            }
            tempCtx.closePath();
            
            // Use the path as a clipping region
            tempCtx.clip();
            
            // Draw the image data inside the clipped region
            tempCtx.drawImage(
              layerCanvas, 
              selectionBounds.x, 
              selectionBounds.y, 
              selectionBounds.width, 
              selectionBounds.height,
              0, 
              0, 
              selectionBounds.width, 
              selectionBounds.height
            );
            
            tempCtx.restore();
          } else {
            // For rectangular selection, just get the image data directly
            var imageData = layerContext.getImageData(
              selectionBounds.x, 
              selectionBounds.y, 
              selectionBounds.width, 
              selectionBounds.height
            );
            tempCtx.putImageData(imageData, 0, 0);
          }
          
          // Add data to transfer with the selection bounds coordinates
          transfer.addData(
            layer,                   // layer number
            selectionBounds.x,       // x position (corner of selection)
            selectionBounds.y,       // y position (corner of selection)
            selectionBounds.width,   // width of selection area
            selectionBounds.height,  // height of selection area
            0,                       // rotation
            btoa(tempCanvas.toDataURL()) // Encode just the selected area
          );
        } else {
          // Get full layer data for full canvas undo
          var layerData = room.board.layers[layer].getData();
          
          // Add data to transfer
          transfer.addData(
            layer,                     // layer number
            0,                         // x position
            0,                         // y position
            room.board.canvasWidth,    // width
            room.board.canvasHeight,   // height
            0,                         // rotation
            btoa(layerData)            // Encode the entire data URL
          );
        }
      }
    }
    
    // Send the transfer
    transfer.send();
    room.addTransfer(transfer);
    return true;
  } catch (error) {
    console.error("Error in undo operation:", error);
    return false;
  }
}
  ["loadContent"](_0x557220) {
    this["content"]["html"](_0x557220);
  }
  ["loadSubcontent"](_0x535d33) {
    this["content"]["find"](".dynamicDialogArea").html(_0x535d33);
  }
  ["loadPage"](_0x509fd8) {
    var _0x183e07 = this;
    if (_0x509fd8 !== undefined) {
      this["form"]["find"](".subcontentOption")["removeClass"]("selected"), this["form"].find(".subcontentOption[data-subcontent=" + _0x509fd8 + "]")["addClass"]("selected"), this["loading"](true);
      if (_0x509fd8 == "preview") {
        this["loadSubcontent"](this["loadFile"]("forms/undo.preview.html")), $(this["content"]).overlayScrollbars({
          className: "os-theme-light",
          overflowBehavior: {
            x: "hidden"
          }
        }), this["slider"] = new Slider(this["content"].find("#undoPosition"), 0, 1, 1, function (_0x117b30) {
          return isNaN(_0x117b30) ? "" : _0x117b30 + 1;
        }), this["slider"]["setValue"](0), this["slider"]["focus"](), $(this.slider).on("sliderMoved", function (_0x29e3d8) {
          _0x183e07["boards"][_0x29e3d8["value"]] && _0x183e07["preview"](_0x29e3d8["value"]);
        });
        !this["enabled"] && (this["content"]["find"]("#undoNow")["addClass"]("disabled"), this["slider"]["setReadOnly"](true));
        this["content"]["find"]("#undoNow").on(UI.pointerEvent("click"), function (_0x5ed8f9) {
          _0x5ed8f9["preventDefault"]();
          
          // Check for conditions that prevent undo
          if (socket && socket.isTransferInProgress) {
            UI.dialogHandler.showAlert("Cannot perform undo while board transfer is in progress. Please wait for all transfers to complete.");
          } else if (UI.undoHistoryEnabled) {
            UI.dialogHandler.showAlert("Cannot perform undo while step back is enabled. Please disable step back first.");
          } else if (UI.uploader && UI.uploader.isVisible()) {
            UI.dialogHandler.showAlert("Cannot perform undo while image transform is in progress. Please confirm or cancel the image operation first.");
          } else if (room && room.board && (room.board.isProcessingCommit)) {
            UI.dialogHandler.showAlert("Cannot perform undo while stroke commits are in progress. Please wait for all strokes to finish processing.");
          } else {
            _0x183e07["doUndo"](_0x183e07.slider["getValue"]());
          }
        }), $(this.content.find(".dialogContentArea"))["overlayScrollbars"]({
          className: "os-theme-light",
          overflowBehavior: {
            x: "hidden"
          }
        }), this["content"].find("#undoBox")["css"]("background-color", room["backgroundColor"]), this["content"].find("#undoPreview")["css"]({
          width: room["board"]["canvasWidth"] + "px",
          height: room["board"]["canvasHeight"] + "px"
        }), this.content["find"]("#undoLayers").empty(), this["layers"] = new Array(), this["layersCheckbox"] = new Array();
        for (var _0x367262 = 0; _0x367262 < room["board"]["nLayers"]; _0x367262++) {
          var _0x23263e = new Layer(_0x367262, room["board"]["canvasWidth"], room["board"].canvasHeight);
          _0x23263e["advCanvas"]["canvas"]["attr"]("name", _0x367262), this["layers"]["push"](_0x23263e), this["content"]["find"]("#undoPreview")["append"](_0x23263e["advCanvas"]["canvas"]);
          var _0x13ba8b = $("<div />");
          _0x13ba8b.css({
            float: "left",
            width: 100 / room["board"]["nLayers"] + "%"
          }), _0x13ba8b["addClass"]("smallCheckbox"), _0x13ba8b["attr"]("name", _0x367262), this["content"].find("#undoLayers").prepend(_0x13ba8b);
          var _0x515921 = new Checkbox(_0x13ba8b, textManager["getString"]("undo.preview.lblLayer", _0x367262 + 1, false));
          _0x515921["setValue"](true), this["layersCheckbox"]["push"](_0x515921), $(_0x515921).on("checkboxChanged", function (_0x18d039) {
            _0x183e07.preview(_0x183e07["slider"]["getValue"]());
          });
        }
        this["selection"] = new SelectionTool(this["content"].find("#undoPreview"), room["board"]["canvasWidth"], room["board"].canvasHeight), this.selectionTool = new Switch(this["content"]["find"]("#selectionTool"), lassoRectFunction), $(this.selectionTool).on("checkboxChanged", function (_0x2f020a) {
          _0x183e07["selection"]["currentTool"] = _0x2f020a["checked"] ? "lasso" : "rectangle", _0x183e07["selection"]["clear"](), _0x183e07["currentTool"] = _0x183e07.selection["currentTool"];
        }), this["changePartialSelection"](this.currentTool), $["contextMenu"]({
          selector: "#undoPreview",
          build: function (_0x559830) {
            var _0x434650 = {
              callback: function (_0x39bec8, _0x5c608f) {
                if (_0x39bec8 == "save") {
                  var _0x5cc64f = new Array();
                  for (var _0x270c80 = 0; _0x270c80 < room["board"].nLayers; _0x270c80++) {
                    _0x183e07["layersCheckbox"][_0x270c80]["getValue"]() && _0x5cc64f["push"](_0x183e07["boards"][_0x183e07["slider"]["getValue"]()][_0x270c80]);
                  }
                  UI.saveDialog["show"]("custom", _0x5cc64f);
                }
              },
              items: {
                save: {
                  name: "Save selected layers",
                  icon: "fa-floppy-disk"
                }
              }
            };
            return $["each"](_0x434650["items"], function (_0x25db86, _0x5702fc) {
              _0x434650.items[_0x25db86]["name"] && (_0x434650["items"][_0x25db86]["name"] = function () {
                return textManager.getString("menu.undoPreview." + _0x25db86, null, false);
              });
            }), _0x434650;
          }
        }), this.content.find("#undoPreview").on(UI.pointerEvent("down"), function (_0x569b60) {
          _0x569b60["which"] && _0x569b60["which"] == 2 && (_0x569b60["preventDefault"](), _0x183e07["selection"]["currentTool"] = _0x183e07["selection"]["currentTool"] == "rectangle" ? "lasso" : "rectangle", _0x183e07["selectionTool"]["setValue"](!_0x183e07["selectionTool"]["checked"]));
        }), this["slider"]["setup"](0, this["boards"].length - 1, 1), this["slider"]["setValue"](this["slider"].max), this["preview"](this.slider["getValue"]()), this["changed"](), this.loading(false);
      } else _0x509fd8 == "settings" && (this["loadSubcontent"](this.loadFile("forms/undo.settings.html")), this["intervalInput"] = new NumericInput(this["content"]["find"]("div[name=\"intervalinput\"]"), this["secInterval"], 3, 999, textManager.getString("undo.settings.lblSeconds")), this.maxInput = new NumericInput(this.content.find('div[name="maxinput"]'), this["maxBoards"], 1, 50, textManager["getString"]("undo.settings.lblSavedBoards")), this["enableUndo"] = new Switch(this.content["find"]("#enableUndo"), function (_0x25e8ff) {
        return _0x25e8ff ? textManager["getString"]("global.enabled") : textManager["getString"]("global.disabled");
      }), this["enableUndo"].setValue(this["enabled"]), this.intervalInput.focus(), this["content"]["find"]("#applyUndoSettings").on(UI["pointerEvent"]("click"), function (_0x1c6a5d) {
        _0x1c6a5d["preventDefault"]();
        var _0x3cfe15 = _0x183e07["enableUndo"]["getValue"]();
        _0x183e07["enabled"] != _0x3cfe15 && (_0x3cfe15 ? _0x183e07.enable() : _0x183e07["disable"]()), _0x183e07["secInterval"] = _0x183e07["intervalInput"]["getValue"](), _0x183e07.maxBoards = _0x183e07.maxInput["getValue"](), UI["userPreferences"]["setProperty"]("undoInterval", _0x183e07["secInterval"]), UI["userPreferences"]["setProperty"]("undoMax", _0x183e07.maxBoards), UI["dialogHandler"]["showAlert"](textManager["getString"]("alerts.txtSaved"));
      }), this.content["find"]("#defaultUndoSettings").on(UI["pointerEvent"]("click"), function (_0x27b84f) {
        _0x27b84f["preventDefault"](), _0x183e07["intervalInput"]["setValue"](_0x183e07["defaultInterval"]), _0x183e07["maxInput"]["setValue"](_0x183e07["defaultMax"]);
      }), this["scroll"] = this.content.find(".dialogContentArea")["overlayScrollbars"]({
        className: "os-theme-light",
        overflowBehavior: {
          x: "hidden"
        }
      })["overlayScrollbars"](), this["scroll"].addExt("fmExtension"), this["changed"](), this["loading"](false));
      this["processSizeType"](this.sizeType);
    }
  }
  ["enable"](_0x28d3bf = "") {
    this["enabled"] = true, this.secInterval = UI["userPreferences"].getProperty("undoInterval", this["defaultInterval"]), this["maxBoards"] = UI["userPreferences"]["getProperty"]("undoMax", this["defaultMax"]);
    if (!this["undoInterval"]) {
      var _0x593c2c = this;
      this["roomName"] != _0x28d3bf && (this["boards"] = new Array()), this["roomName"] = _0x28d3bf, this["undoInterval"] = window["setInterval"](function () {
        if (room["board"] && room["connected"]) {
          if (_0x593c2c["lastSaveTime"] == null || room.board["lastChangeTime"]["getTime"]() > _0x593c2c["lastSaveTime"]["getTime"]()) {
            var _0x454587 = new Array();
            for (var _0x4f4c79 = 0; _0x4f4c79 < room["board"]["nLayers"]; _0x4f4c79++) {
              var _0x3ce6b8 = room["board"]["layers"][_0x4f4c79].getContext();
              _0x454587[_0x4f4c79] = _0x3ce6b8["getImageData"](0, 0, room["board"]["canvasWidth"], room["board"]["canvasHeight"]);
            }
            _0x593c2c["pushBoards"](_0x454587), _0x593c2c["slider"] && _0x593c2c["slider"]["setup"](0, _0x593c2c.boards["length"] - 1, 1);
          }
        }
      }, _0x593c2c.secInterval * 1e3);
    }
  }
  ["pause"]() {
    this["enabled"] = false, this.undoInterval && (clearInterval(this["undoInterval"]), this.undoInterval = null);
  }
  ["disable"]() {
    this["pause"](), this["boards"] = new Array();
  }
  ["reset"]() {
    this["enabled"] && (this.disable(), this["enable"]());
  }
  ["pushBoards"](_0x58b443) {
    if (this["enabled"]) {
      var _0x12a3e3 = 0;
      this["slider"] != null && (_0x12a3e3 = this["slider"]["value"]), this["boards"].length >= this["maxBoards"] && (this["boards"].shift(), _0x12a3e3--), this["boards"]["push"](_0x58b443), this.lastSaveTime = new Date(), this["slider"] != null && this["active"] && this["slider"]["setValue"](_0x12a3e3 >= 0 ? _0x12a3e3 : 0, true);
    }
  }
  ["preview"](_0x182eb2) {
    if (this["boards"]["length"] > 0) {
      var _0x15d671 = this["boards"][_0x182eb2]["length"];
      for (var _0x5f3bd0 = 0; _0x5f3bd0 < _0x15d671; _0x5f3bd0++) {
        this["layers"][_0x5f3bd0]["clear"]();
        if (this["layersCheckbox"][_0x5f3bd0].getValue()) {
          var _0x39d9c2 = this["content"]["find"]("#undoPreview canvas[name=\"" + _0x5f3bd0 + '"]');
          if (_0x39d9c2["length"] > 0) {
            var _0x12f5dc = _0x39d9c2[0]["getContext"]("2d");
            _0x12f5dc["putImageData"](this["boards"][_0x182eb2][_0x5f3bd0], 0, 0);
          }
        }
      }
    }
  }
  ["doUndo"](_0x5d71d4) {
    if (_0x5d71d4 in this["boards"]) {
      var _0x2a9d2b = 0;
      for (var _0x5447c1 = 0; _0x5447c1 < room["board"].nLayers; _0x5447c1++) {
        _0x2a9d2b += this["layersCheckbox"][_0x5447c1]["getValue"]() ? 1 : 0;
      }
      if (_0x2a9d2b > 0) {
        var _0x56eebc = new Transfer("BROADCAST", null, "undo", new Date()["getTime"](), true);
        $(_0x56eebc).on("transferStart transferChunkReady", sendChunk);
        if (this.selection.hasSelection()) {
          var _0x2c08dc = 0,
            _0xaa0fe1 = this;
          for (var _0x5447c1 = 0; _0x5447c1 < room["board"].nLayers; _0x5447c1++) {
            var _0x3a3be2 = _0xaa0fe1["getSelectedImage"](_0x5d71d4, _0x5447c1);
            _0x3a3be2["then"](function (_0x1256c6) {
              _0xaa0fe1["layersCheckbox"][_0x1256c6["layer"]].getValue() && (_0x56eebc.addData(_0x1256c6.layer, _0x1256c6.position.x, _0x1256c6["position"].y, _0x1256c6.position["width"], _0x1256c6["position"].height, 0, btoa(_0x1256c6["img"])), ++_0x2c08dc >= _0x2a9d2b && (_0x1256c6["mask"]["length"] > 0 && _0x56eebc["addMask"](_0x1256c6["mask"]), _0x56eebc["send"](), room["addTransfer"](_0x56eebc), _0xaa0fe1.hide()));
            });
          }
        } else {
          for (var _0x5447c1 = 0; _0x5447c1 < room["board"].nLayers; _0x5447c1++) {
            this["layersCheckbox"][_0x5447c1]["getValue"]() && _0x56eebc["addData"](_0x5447c1, 0, 0, room["board"].canvasWidth, room["board"]["canvasHeight"], 0, btoa(this["layers"][_0x5447c1]["getData"]()));
          }
          _0x56eebc["send"](), room["addTransfer"](_0x56eebc), this["hide"]();
        }
      } else UI["dialogHandler"]["showAlert"](textManager["getString"]("alerts.txtSelectOneLayer"));
    }
  }
  ["getSelectedImage"](_0x4fd71a, _0x107049) {
    var _0x43abf5 = this;
    return new Promise(function (_0xb0154c, _0x47d8d5) {
      var _0x1fa4ca = new AdvancedCanvas(room["board"]["canvasWidth"], room["board"].canvasHeight);
      _0x1fa4ca["putImageData"](_0x43abf5["boards"][_0x4fd71a][_0x107049]);
      var _0x21aa4c = _0x43abf5.selection.getContext(),
        _0x5b3d61,
        _0xd80cf5;
      _0x43abf5["selection"]["currentTool"] == "lasso" ? (_0x5b3d61 = getLimits(_0x43abf5.selection.clickX), _0xd80cf5 = getLimits(_0x43abf5.selection["clickY"])) : (_0x5b3d61 = getLimits(new Array(_0x43abf5["selection"]["initialPosition"].x, _0x43abf5["selection"]["clickX"][0])), _0xd80cf5 = getLimits(new Array(_0x43abf5["selection"].initialPosition.y, _0x43abf5.selection.clickY[0])));
      var _0x24793d = new Rect(_0x5b3d61.x, _0xd80cf5.x, _0x5b3d61.y, _0xd80cf5.y),
        _0x17d6c3 = new Image();
      _0x17d6c3["onload"] = function () {
        _0x21aa4c["save"](), _0x43abf5["selection"]["redraw"](false, false), _0x21aa4c["closePath"](), _0x21aa4c["clip"](), _0x43abf5["selection"]["layer"]["advCanvas"]["drawImage"](_0x17d6c3, 0, 0), _0x21aa4c["restore"]();
        var _0x152896 = new Image();
        _0x152896["onload"] = function (_0x3fdb74) {
          var _0x163b7d = {};
          _0x163b7d["position"] = _0x24793d, _0x163b7d["img"] = cropImage(this, _0x24793d.x, _0x24793d.y, _0x24793d["width"] - _0x24793d.x, _0x24793d.height - _0x24793d.y), _0x163b7d.layer = _0x107049, _0x163b7d["mask"] = _0x43abf5["selection"]["getMask"](), _0xb0154c(_0x163b7d);
        }, _0x152896["src"] = _0x43abf5["selection"]["getData"]();
      }, _0x17d6c3.src = _0x1fa4ca["getData"](), _0x1fa4ca.remove();
    });
  }
  ["onResize"]() {
    var _0x2645b2 = this["content"].find("#undoBox")["width"](),
      _0x14e25f = this["content"]["find"]("#undoPreview")["width"](),
      _0x43af05 = this.content.find("#undoPreview")["height"](),
      _0x143755 = this["content"]["find"]("#undoContent").width(),
      _0x507a99 = this.content["find"]("#undoContent")["height"](),
      _0x2c1e7d = calculateAspectRatioFit(room["board"]["canvasWidth"], room["board"].canvasHeight, _0x143755, _0x507a99),
      _0x4087fd = _0x2c1e7d["width"] / room.board["canvasWidth"];
    this["content"]["find"]("#undoPreview")["css"]("transform", "scale(" + _0x4087fd + ")"), this["content"].find("#undoBox")["css"]({
      width: _0x2c1e7d["width"],
      height: _0x2c1e7d.height
    }), this.selection["setScale"](_0x4087fd);
  }
  ["clearSubcontent"]() {
    this["content"].find(".dynamicDialogArea")["empty"]();
  }
  ["changePartialSelection"](_0x57280b) {
    this["selectionTool"]["setValue"](_0x57280b == "lasso");
  }
  ["onShow"]() {
    this["loadPage"]("preview");
    if (this.selectionPrevious) try {
      this["selection"]["setClicks"](this.selectionPrevious), this["selection"]["initialPosition"] = this.selectionInitial, (this.currentTool == "lasso" || this["currentTool"] == "rectangle" && this.selection["initialPosition"] != null) && this["selection"]["redraw"]();
    } catch (_0xc7c2bd) { }
    $(this.content["find"](".sidebar"))["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    });
  }
  ["onHide"]() {
    this["selectionPrevious"] = this.selection.getClicks(), this.selectionInitial = this.selection["initialPosition"], this["selection"]["remove"](), this["layers"] = null, this["layersCheckbox"] = null, this["clearSubcontent"]();
  }
}
class RoomManagerDialog extends Dialog {
  constructor(_0x5da791) {
    super(_0x5da791), this["icon"] = "fa-wrench", this["caption"] = textManager.getString("roommanager.title"), this.helpLink = "https://flockmod.com/help/room/", this["banLengths"] = [0, 900, 1800, 3600, 10800, 21600, 43200, 86400, 259200, 604800, 1209600, 2592e3, 7776e3, 15552e3, 23328e3, 31536e3], this["muteLengths"] = [300, 900, 1800, 3600, 7200, 10800, 14400, 18e3, 21600, 43200, 86400, 259200, 345600, 432e3, 518400, 604800], this.loadContent(this["loadFile"]("forms/roommanager.main.html")), $(this["content"]["find"](".sidebar"))["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    }), this["currentSubDialog"] = null, this["settingsSubDialog"] = new RoomManagerSettingsSubDialog(this), this["staffSubDialog"] = new RoomManagerStaffSubDialog(this), this["privilegesSubDialog"] = new RoomManagerPrivilegesSubDialog(this), this["toolsSubDialog"] = new RoomManagerToolsSubDialog(this), this["bansSubDialog"] = new RoomManagerBansSubDialog(this);
    var _0x4823d3 = this;
    this.content.on(UI.pointerEvent("click"), ".subcontentOption", function (_0x4f22e8) {
      _0x4f22e8.preventDefault();
      var _0x2a6f69 = $(this)["data"]("subcontent");
      _0x4823d3.loadPage(_0x2a6f69);
    });
  }
  ["loadContent"](_0x3a34a3) {
    this["content"]["html"](_0x3a34a3);
  }
  ["loadSubcontent"](_0x26aa0a) {
    this.content["find"](".dynamicDialogArea")["html"](_0x26aa0a);
  }
  ["clearSubcontent"]() {
    this.content["find"](".dynamicDialogArea")["empty"]();
  }
  ["loadSubDialog"](_0x28309d) {
    var _0x24bb3f = this["content"]["find"](".dynamicDialogArea");
    _0x24bb3f.empty(), _0x24bb3f["hide"]();
    this["currentSubDialog"] && this["currentSubDialog"]["unload"]();
    if (_0x28309d == "settings") this.settingsSubDialog["load"](), _0x24bb3f.append(this.settingsSubDialog.subContent), this["currentSubDialog"] = this["settingsSubDialog"]; else {
      if (_0x28309d == "staff") this["staffSubDialog"]["load"](), _0x24bb3f["append"](this["staffSubDialog"]["subContent"]), this["currentSubDialog"] = this["staffSubDialog"]; else {
        if (_0x28309d == "privileges") this.privilegesSubDialog.load(), _0x24bb3f["append"](this["privilegesSubDialog"].subContent), this["currentSubDialog"] = this["privilegesSubDialog"]; else {
          if (_0x28309d == "tools") this["toolsSubDialog"].load(), _0x24bb3f.append(this["toolsSubDialog"]["subContent"]), this.currentSubDialog = this["toolsSubDialog"]; else _0x28309d == "bans" && (this["bansSubDialog"]["load"](), _0x24bb3f["append"](this.bansSubDialog.subContent), this.currentSubDialog = this["bansSubDialog"]);
        }
      }
    }
    this.changed(), _0x24bb3f["fadeIn"](500);
  }
  ["loadPage"](_0x3399e8) {
    var _0x1ebcf3 = this;
    _0x3399e8 !== undefined && (this["content"]["find"](".subcontentOption.selected")["removeClass"]("selected"), this["content"]["find"](".subcontentOption[data-subcontent=" + _0x3399e8 + "]")["addClass"]("selected"), this["loadSubDialog"](_0x3399e8), this.processSizeType(this.sizeType));
  }
  ["unloadPage"]() {
    this["currentSubDialog"] && this["currentSubDialog"]["unload"]();
  }
  ["roomSettings"]() {
    this["settingsSubDialog"]["data"]();
  }
  ["staffList"](_0x27ef86) {
    this["staffSubDialog"]["data"](_0x27ef86);
  }
  ["privilegeList"](_0x36d334, _0x2010d2) {
    this["privilegesSubDialog"].data(_0x36d334, _0x2010d2);
  }
  ["toolList"](_0x31209e, _0x30aa6c) {
    this["toolsSubDialog"]["data"](_0x31209e, _0x30aa6c);
  }
  ["banList"](_0x2e5943) {
    this["bansSubDialog"]["data"](_0x2e5943);
  }
  ["gotResponse"](_0x1e9d31) {
    if (_0x1e9d31["action"] == "RoomBans") this["bansSubDialog"].gotResponse(_0x1e9d31); else {
      if (_0x1e9d31.action == "RoomStaff") this["staffSubDialog"].gotResponse(_0x1e9d31); else {
        if (_0x1e9d31.action == "RoomPrivileges") this["privilegesSubDialog"]["gotResponse"](_0x1e9d31); else _0x1e9d31["action"] == "RoomTools" && this["toolsSubDialog"].gotResponse(_0x1e9d31);
      }
    }
  }
  ["onShow"]() {
    this.loadPage("settings");
  }
  ["onHide"]() {
    this["clearSubcontent"](), this["unloadPage"]();
  }
}
class RoomManagerSettingsSubDialog extends SubDialog {
  constructor(_0x5d4c1e, _0x17ccb5) {
    super(_0x5d4c1e, _0x17ccb5), this.privateCheckbox, this["backgroundSelector"], this.layersNumericInput, this.capacityNumericInput;
  }
  ["load"]() {
    this.dialog.loading(true), this["subContent"]["html"](this.dialog["loadFile"]("forms/roommanager.settings.html"));
    !room["can"]("unregisterroom") && this.subContent["find"]("#unregRoom").hide();
    !room.can("roommanager") && this.subContent.find("#applySettings").addClass("disabled");
    this.privateCheckbox = new Switch(this.subContent.find("#privateRoom"), function (_0x42d77f) {
      return _0x42d77f ? textManager.getString("roommanager.settings.optPrivateRoom") : textManager["getString"]("roommanager.settings.optPublicRoom");
    }), this.backgroundSelector = new Selector(this["subContent"]["find"]("div[name=\"background\"]"), {
      "#FFFFFF": textManager["getString"]("roommanager.settings.optWhite"),
      "#4A4A4A": textManager["getString"]("roommanager.settings.optGray"),
      "#000000": textManager["getString"]("roommanager.settings.optBlack")
    }), this["bottomtransparencySelector"] = new Selector(this.subContent["find"]("div[name=\"bottomtransparency\"]"), {
      1: textManager.getString("roommanager.settings.optTransparent"),
      0: textManager.getString("roommanager.settings.optOpaque")
    }), this["layersNumericInput"] = new NumericInput(this["subContent"]["find"]("div[name=\"numlayers\"]"), 3, 1, 5), this["rowsNumericInput"] = new NumericInput(this["subContent"].find("div[name=\"animrows\"]"), 3, 2, 8), this.colsNumericInput = new NumericInput(this.subContent["find"]("div[name=\"animcols\"]"), 3, 2, 8), this["capacityNumericInput"] = new NumericInput(this["subContent"]["find"]('div[name="capacity"]'), 45, 1, 45, textManager.getString("roommanager.settings.lblUsers"));
    var _0x1e13be = this;
    this["scroll"] = this["subContent"]["find"](".dialogContentArea")["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    })["overlayScrollbars"](), this.scroll.addExt("fmExtension"), this["subContent"]["find"]("select[name=\"roomtype\"]").on("change", function (_0x253fd7) {
      _0x1e13be["animationMode"]($(_0x253fd7["target"]).val() == "A");
    }), this.subContent["find"]("#applySettings").on(UI.pointerEvent("click", "settingsSubdialog"), function (_0x3e005e) {
      _0x3e005e["preventDefault"]();
      var _0x4ecb65 = {};
      _0x4ecb65["description"] = _0x1e13be.subContent["find"]("textarea[name=\"description\"]").val(), _0x4ecb65["roomtype"] = _0x1e13be["subContent"]["find"]('select[name="roomtype"]').val(), _0x4ecb65.size = _0x1e13be["subContent"]["find"]("select[name=\"canvassize\"]")["val"](), _0x4ecb65["mute"] = _0x1e13be["subContent"].find("select[name=\"mute\"]")["val"](), _0x4ecb65.knownproxy = _0x1e13be.subContent["find"]("select[name=\"knownproxy\"]")["val"](), _0x4ecb65.mutetime = _0x1e13be["subContent"]["find"]("select[name=\"mutetime\"]")["val"](), _0x4ecb65["bantime"] = _0x1e13be["subContent"]["find"]("select[name=\"bantime\"]")["val"](), _0x4ecb65.password = _0x1e13be.subContent["find"]("input[name=\"password\"]").val(), _0x4ecb65["hidden"] = _0x1e13be["privateCheckbox"].checked, _0x4ecb65["background"] = _0x1e13be["backgroundSelector"].getSelected(), _0x4ecb65["bottomtransparency"] = _0x1e13be["bottomtransparencySelector"]["getSelected"]() == "1", _0x4ecb65["numlayers"] = _0x1e13be["layersNumericInput"]["getValue"](), _0x4ecb65["animrows"] = _0x1e13be["rowsNumericInput"]["getValue"](), _0x4ecb65["animcols"] = _0x1e13be["colsNumericInput"].getValue(), _0x4ecb65["capacity"] = _0x1e13be["capacityNumericInput"].getValue();
      var _0x68e682 = {};
      _0x68e682["command"] = "ROOMCHANGE", _0x68e682["action"] = "RoomSettings", _0x68e682["options"] = _0x4ecb65, socket.send(_0x68e682, true), UI["dialogHandler"]["showAlert"](textManager["getString"]("alerts.txtSaved"));
    }), this["subContent"].find("#unregRoom").on(UI["pointerEvent"]("click", "settingsSubdialog"), function (_0x3c2f34) {
      _0x3c2f34.preventDefault();
      var _0x31fcae = UI["dialogHandler"]["createConfirmation"](textManager.getString("messages.lblUnregisterRoom"));
      _0x31fcae.on("confirmationClosed", function (_0x807e74) {
        if (_0x807e74["response"] == "ok") {
          var _0x28f421 = {};
          _0x28f421.command = "ROOMREQUEST", _0x28f421.action = "Unregister", socket["send"](_0x28f421, true), _0x1e13be.dialog["hide"]();
        }
        UI["dialogHandler"]["destroyConfirmation"]();
      });
    });
    var _0x2ff8aa = {};
    _0x2ff8aa["command"] = "ROOMREQUEST", _0x2ff8aa["action"] = "RoomSettings", socket["send"](_0x2ff8aa, true);
  }
  ["animationMode"](_0x30b7a2) {
    _0x30b7a2 ? (this.rowsNumericInput["setReadOnly"](false), this.colsNumericInput["setReadOnly"](false)) : (this.rowsNumericInput["setReadOnly"](true), this["colsNumericInput"]["setReadOnly"](true));
  }
  ["unload"]() {
    this.dialog.modal["off"](".settingsSubdialog"), this.subContent.find("input[name=\"password\"]").val("");
  }
  ["data"]() {
    var _0xd17ec3 = this["subContent"]["find"]("select[name=\"bantime\"]");
    _0xd17ec3["empty"](), $["each"](this.dialog["banLengths"], function (_0x4efcef, _0x1ec5f3) {
      let _0x2b031c = getLengthDescription(_0x1ec5f3);
      _0xd17ec3["append"](new Option(_0x2b031c, _0x1ec5f3));
    }), _0xd17ec3.val(room["bantime"]);
    var _0x45d2c0 = this.subContent["find"]("select[name=\"mutetime\"]");
    _0x45d2c0.empty(), $["each"](this["dialog"]["muteLengths"], function (_0x5538bf, _0x4bbbe1) {
      let _0x2409fb = getLengthDescription(_0x4bbbe1);
      _0x45d2c0["append"](new Option(_0x2409fb, _0x4bbbe1));
    }), _0x45d2c0["val"](room["mutetime"]), this["subContent"]["find"]("textarea[name=\"description\"]")["val"](room["description"]), this.subContent["find"]("select[name=\"roomtype\"]")["val"](room["type"]), this["subContent"]["find"]('select[name="canvassize"]')["val"](room["size"]), this["subContent"]["find"]("select[name=\"mute\"]")["val"](room["mute"]), this["subContent"]["find"]("select[name=\"knownproxy\"]").val(room["knownproxy"]), this["subContent"]["find"]("input[name=\"password\"]")["val"](room["password"]), this["privateCheckbox"]["setValue"](room.hidden), this.backgroundSelector.select(room.backgroundColor), this["bottomtransparencySelector"]["select"](room["bottomTransparency"] ? "1" : "0"), this.capacityNumericInput.setValue(room["capacity"]), this["layersNumericInput"]["setValue"](room["numLayers"]), this["colsNumericInput"].setValue(room["animCols"]), this["rowsNumericInput"]["setValue"](room["animRows"]), this.animationMode(room["type"] == "A"), this["dialog"]["changed"](), this["dialog"]["loading"](false);
  }
}
class RoomManagerStaffSubDialog extends SubDialog {
  constructor(_0x2680b8, _0x162122) {
    super(_0x2680b8, _0x162122), this.table;
  }
  ["load"]() {
    this.dialog.loading(true), this.subContent["html"](this.dialog["loadFile"]("forms/roommanager.staff.html"));
    !room["can"]("addmod") && this["subContent"]["find"]("#addUser")["addClass"]("disabled");
    this["subContent"]["find"]("#removeUser")["addClass"]("disabled"), this.subContent["find"]("#editUser")["addClass"]("disabled"), this["table"] = new Table(this["subContent"]["find"]("#staffTable"), null, "staffTable", "fmTable"), this["table"].selectable = true, this["table"]["setFilterable"](true), this["table"]["setTitle"](textManager["getString"]("roommanager.staff.lblStaff")), this["table"]["setHeader"](["UID", "Username", "Code", "Rank", "Promoted by", "PromoterUsername", "Timestamp", "Date"]), this["table"]["hideColumns"]([1, 3, 6, 7]), this.table.headerCaption(2, textManager["getString"]("roommanager.staff.rowUsername")), this["table"]["headerCaption"](4, textManager["getString"]("roommanager.staff.rowRank")), this["table"]["headerCaption"](5, textManager["getString"]("roommanager.staff.rowPromotedBy")), this.table["headerCaption"](8, textManager["getString"]("roommanager.staff.rowDate")), this["table"].columnLink(5, 6), this["table"].columnLink(8, 7);
    var _0x5c40d2 = this;
    $(this["dialog"]).on("dialogResizingEnded.settingsSubdialog dialogMaximized.settingsSubdialog dialogRestored.settingsSubdialog", function (_0x1656e6) {
      _0x5c40d2["table"] && _0x5c40d2["table"]["updated"]();
    }), this["subContent"].on(UI["pointerEvent"]("click", "settingsSubdialog"), "#addUser", function (_0x4ef4c1) {
      _0x4ef4c1.preventDefault(), _0x5c40d2["dialog"]["enableModal"](_0x5c40d2["dialog"]["loadFile"]("forms/roommanager.modal.adduser.html")), _0x5c40d2["dialog"]["modal"]["find"]("input[name=\"username\"]")["focus"](), _0x5c40d2["dialog"]["modal"]["find"]("select[name=\"rank\"]").empty();
      for (var _0x519a36 = UI.rankToIndex("TU"); _0x519a36 <= UI.rankToIndex("CO"); _0x519a36++) {
        _0x519a36 < UI["rankToIndex"](room["myself"]["rank"]) && _0x5c40d2["dialog"].modal.find('select[name="rank"]').append(new Option(UI["userRank"](UI.indexToRank(_0x519a36), false), UI["indexToRank"](_0x519a36)));
      }
    }), this["subContent"].on(UI["pointerEvent"]("click", "settingsSubdialog"), "#editUser", function (_0x5db161) {
      _0x5db161["preventDefault"](), _0x5c40d2.editStaff();
    }), this["subContent"].on(UI.pointerEvent("click", "settingsSubdialog"), "#removeUser", function (_0x360495) {
      _0x360495["preventDefault"]();
      var _0x415727 = _0x5c40d2["table"]["getSelected"]();
      if (_0x415727) {
        _0x5c40d2["dialog"]["loading"](true);
        var _0x18f73b = {};
        _0x18f73b.command = "ROOMCHANGE", _0x18f73b["action"] = "RoomStaff", _0x18f73b["perform"] = "delete", _0x18f73b["uid"] = _0x415727[0]["UID"], _0x18f73b["username"] = _0x415727[0]["Username"], _0x18f73b["rank"] = _0x415727[0]["Code"], socket["send"](_0x18f73b, true);
      }
    }), this.dialog.modal.on(UI["pointerEvent"]("click", "settingsSubdialog"), "#updateStaff", function (_0x45fa06) {
      _0x45fa06["preventDefault"]();
      var _0x9c3a14 = {};
      _0x9c3a14["command"] = "ROOMCHANGE", _0x9c3a14["action"] = "RoomStaff", _0x9c3a14["perform"] = "update", _0x9c3a14["username"] = _0x5c40d2["dialog"]["modal"]["find"]('input[name="username"]')["val"](), _0x9c3a14.rank = _0x5c40d2.dialog.modal["find"]("select[name=\"rank\"]").val(), socket["send"](_0x9c3a14, true), _0x5c40d2["dialog"]["loading"](true);
    });
    var _0x1cd7e7 = {};
    _0x1cd7e7["command"] = "ROOMREQUEST", _0x1cd7e7["action"] = "RoomStaff", socket.send(_0x1cd7e7, true);
  }
  ["unload"]() {
    this["dialog"]["modal"]["off"](".staffSubdialog"), this["table"]["reset"]();
  }
  ["editStaff"]() {
    this["dialog"]["enableModal"](this.dialog.loadFile("forms/roommanager.modal.edituser.html")), this["dialog"].modal.find('input[name="username"]')["focus"](), this["dialog"]["modal"]["find"]('select[name="rank"]')["empty"]();
    for (var _0x4e9e2f = UI.rankToIndex("TU"); _0x4e9e2f <= UI["rankToIndex"]("CO"); _0x4e9e2f++) {
      _0x4e9e2f < UI["rankToIndex"](room["myself"].rank) && this.dialog["modal"].find("select[name=\"rank\"]")["append"](new Option(UI["userRank"](UI["indexToRank"](_0x4e9e2f), false), UI["indexToRank"](_0x4e9e2f)));
    }
    var _0x4e32da = this.table["getSelected"]();
    this["dialog"].modal["find"]("input[name=\"username\"]")["val"](_0x4e32da[0]["Username"]), this.dialog["modal"].find("select[name=\"rank\"]")["val"](_0x4e32da[0]["Code"]);
  }
  ["data"](_0x47d898) {
    this["table"]["clear"]();
    var _0x33c455 = this;
    $.each(_0x47d898, function (_0x2a8670, _0x542008) {
      var _0x57e48e = _0x542008["date"] == 0 ? textManager["getString"]("global.lblUnknown") : formatTimestamp(_0x542008.date),
        _0x14a9f7;
      _0x542008.promoterUid == 0 ? _0x14a9f7 = textManager["getString"]("global.lblUnknown") : _0x14a9f7 = "<span class=\"" + UI["rankToStyle"](_0x542008["promoterRank"]) + '">' + (_0x542008.promoterUsername || textManager.getString("global.lblUnknown")) + "</span>", _0x33c455["table"]["addRow"]([_0x542008["uid"], _0x542008["username"], _0x542008.rank, '<span class="' + UI["rankToStyle"](_0x542008["rank"]) + "\"> " + UI["userRank"](_0x542008.rank) + "</span>", _0x14a9f7, _0x542008["promoterUsername"], _0x542008["date"], _0x57e48e], false);
    }), $(this["table"]).on("tableRowDoubleClick", function (_0x55f713) {
      !_0x33c455["subContent"]["find"]("#editUser")["hasClass"]("disabled") && _0x33c455["editStaff"]();
    }), $(this["table"]).on("tableRowSelected.banSubdialog tableRowUnselected.banSubdialog", function (_0x2eac14) {
      var _0x7bf585 = _0x33c455["table"]["getSelected"](),
        _0x5e12e6 = false;
      room["can"]("addmod") && _0x2eac14["type"] == "tableRowSelected" && (_0x5e12e6 = _0x7bf585[0]["Code"] != "RO" && UI.rankToIndex(_0x7bf585[0]["Code"]) < UI["rankToIndex"](room.myself["rank"])), _0x5e12e6 ? (_0x33c455.subContent["find"]("#removeUser")["removeClass"]("disabled"), _0x33c455.subContent["find"]("#editUser")["removeClass"]("disabled")) : (_0x33c455["subContent"]["find"]("#removeUser")["addClass"]("disabled"), _0x33c455["subContent"]["find"]("#editUser")["addClass"]("disabled"));
    }), this.dialog["changed"](), this["table"]["updated"](), this["table"]["sort"](7), this["dialog"]["loading"](false);
  }
  ["gotResponse"](_0x1bff61) {
    if (_0x1bff61["option"] == "Rsc") {
      if (_0x1bff61.perform == "update") {
        if (_0x1bff61["code"] == "OK") {
          this["dialog"]["disableModal"]();
          var _0x4b7e05 = this.table.find(this["table"]["getColumnId"]("UID"), _0x1bff61["user"].uid),
            _0x19d2f8 = _0x1bff61.date == 0 ? textManager.getString("global.lblUnknown") : formatTimestamp(_0x1bff61["date"]);
          if (_0x4b7e05 != null) {
            var _0x43464b = {};
            _0x43464b[this["table"]["getColumnId"]("Code")] = _0x1bff61.user["rank"], _0x43464b[this["table"]["getColumnId"]("Rank")] = '<span class="' + UI.rankToStyle(_0x1bff61["user"].rank) + '">' + UI["userRank"](_0x1bff61.user["rank"]) + "</span>", _0x43464b[this["table"]["getColumnId"]("PromoterUsername")] = _0x1bff61["promoter"]["username"], _0x43464b[this["table"].getColumnId("Promoted by")] = "<span class=\"" + UI["rankToStyle"](_0x1bff61["promoter"]["rank"]) + '">' + _0x1bff61["promoter"].username + "</span>", _0x43464b[this["table"]["getColumnId"]("Timestamp")] = _0x1bff61["date"], _0x43464b[this["table"]["getColumnId"]("Date")] = _0x19d2f8, this["table"]["updateRow"](_0x4b7e05, _0x43464b);
          } else {
            var _0x34dd7e = "<span class=\"" + UI["rankToStyle"](_0x1bff61.promoter["rank"]) + '">' + (_0x1bff61["promoter"].username || textManager["getString"]("global.lblUnknown")) + "</span>";
            _0x4b7e05 = this["table"]["addRow"]([_0x1bff61["user"]["uid"], _0x1bff61["user"]["username"], _0x1bff61["user"]["rank"], '<span class="' + UI["rankToStyle"](_0x1bff61["user"]["rank"]) + '">' + UI["userRank"](_0x1bff61["user"]["rank"]) + "</span>", _0x34dd7e, _0x1bff61.promoter["username"], _0x1bff61["date"], _0x19d2f8], false);
          }
          this["table"].locate(_0x4b7e05), UI["dialogHandler"].showAlert(textManager["getString"]("alerts.txtSuccess"));
        } else UI["dialogHandler"]["showAlert"]("Error: " + _0x1bff61["code"]);
        this["table"]["updated"](), this["dialog"]["loading"](false);
      } else {
        if (_0x1bff61["perform"] == "delete") {
          if (_0x1bff61["code"] == "OK") {
            var _0x4b7e05 = this["table"]["find"](this["table"]["getColumnId"]("UID"), _0x1bff61.user.uid);
            this["table"]["deleteRow"](_0x4b7e05), this["load"](), UI.dialogHandler.showAlert(textManager.getString("alerts.txtSuccess"));
          } else UI["dialogHandler"]["showAlert"]("Error: " + _0x1bff61["code"]);
        }
      }
    }
  }
}
class RoomManagerPrivilegesSubDialog extends SubDialog {
  constructor(_0x4160e0, _0x5c0bb5) {
    super(_0x4160e0, _0x5c0bb5), this["table"];
  }
  ["load"]() {
    this["dialog"]["loading"](true), this["subContent"]["html"](this["dialog"].loadFile("forms/roommanager.privileges.html"));
    !room["can"]("changeprivileges") && (this.subContent.find("#applyPrivileges")["addClass"]("disabled"), this["subContent"]["find"]("#defaultPrivileges")["addClass"]("disabled"));
    this["table"] = new Table(this["subContent"]["find"]("#privilegeContent"), null, "privilegesTable", "fmTable"), this.table["selectable"] = false;
    var _0x49bb28 = this;
    $(this.dialog).on("dialogResizingEnded.privSubdialog dialogMaximized.privSubdialog dialogRestored.privSubdialog", function (_0x17696a) {
      _0x49bb28["table"] && _0x49bb28["table"]["updated"]();
    }), this.subContent["find"]("#defaultPrivileges").on(UI.pointerEvent("click", "privSubdialog"), function (_0x14c3d5) {
      _0x14c3d5["preventDefault"]();
      var _0x2a9b95 = {};
      _0x2a9b95["command"] = "ROOMREQUEST", _0x2a9b95["action"] = "RoomPrivileges", _0x2a9b95["perform"] = "default", socket.send(_0x2a9b95, true), _0x49bb28["dialog"].loading(true);
    }), this.subContent["find"]("#applyPrivileges").on(UI["pointerEvent"]("click", "privSubdialog"), function (_0x4bb9ed) {
      _0x4bb9ed["preventDefault"]();
      var _0x5cf881 = _0x49bb28["table"]["getColumnId"]("ID"),
        _0x8ff77d = UI["rankToIndex"](room["myself"]["rank"]),
        _0x4252dd = _0x49bb28["table"].headerFields["length"] - 1,
        _0x4d2ede = {};
      for (var _0x8f5434 = 2; _0x8f5434 <= _0x4252dd; _0x8f5434++) {
        var _0xacc26c = _0x49bb28.table["headerFields"][_0x8f5434];
        UI["rankToIndex"](_0xacc26c) < _0x8ff77d && (_0x4d2ede[_0xacc26c] = {});
      }
      for (var _0x3087be = 0; _0x3087be < _0x49bb28["table"]["rowCount"]; _0x3087be++) {
        for (var _0x8f5434 = 2; _0x8f5434 <= _0x4252dd; _0x8f5434++) {
          var _0x38b174 = _0x49bb28["table"]["rows"][_0x3087be][_0x8f5434],
            _0xacc26c = _0x49bb28["table"].headerFields[_0x8f5434];
          UI["rankToIndex"](_0xacc26c) < _0x8ff77d && (_0x4d2ede[_0xacc26c][_0x49bb28["table"]["rows"][_0x3087be][_0x5cf881]] = _0x38b174["checked"]);
        }
      }
      var _0x2c9160 = {};
      _0x2c9160["command"] = "ROOMCHANGE", _0x2c9160.action = "RoomPrivileges", _0x2c9160["privileges"] = _0x4d2ede, socket["send"](_0x2c9160, true), UI["dialogHandler"]["showAlert"](textManager.getString("alerts.txtSaved"));
    });
    var _0x2b4fb4 = {};
    _0x2b4fb4["command"] = "ROOMREQUEST", _0x2b4fb4["action"] = "RoomPrivileges", _0x2b4fb4["perform"] = "get", socket.send(_0x2b4fb4, true);
  }
  ["unload"]() {
    this["dialog"]["modal"]["off"](".privSubdialog"), this["table"]["reset"]();
  }
  ["gotResponse"](_0x3c0e52) {
    _0x3c0e52["option"] == "Rpc" && this.dialog["loading"](false);
  }
  ["data"](_0x3850ac, _0x237c2a) {
    var _0x102350 = UI.rankToIndex(room["myself"]["rank"]);
    this.table["reset"]();
    var _0x37bf49 = ["ID", "Privilege"],
      _0x5c8d2a = _0x37bf49["length"] + 1;
    $["each"](_0x3850ac, function (_0x4950e9, _0x2fc352) {
      _0x37bf49["push"](_0x2fc352);
    }), this["table"]["setHeader"](_0x37bf49), this.table["headerCaption"](2, textManager["getString"]("roommanager.privileges.rowPrivilege"));
    var _0x2a1a4f = this;
    $["each"](_0x3850ac, function (_0x3426dd, _0x35cd59) {
      _0x2a1a4f["table"]["headerClass"](_0x3426dd + _0x5c8d2a, UI["rankToStyle"](_0x35cd59)), _0x2a1a4f["table"].headerTooltip(_0x3426dd + _0x5c8d2a, UI.userRank(_0x35cd59)), _0x2a1a4f["table"].headerCaption(_0x3426dd + _0x5c8d2a, textManager["getString"]("global.shortRank." + _0x35cd59));
    }), $["each"](_0x237c2a, function (_0x348cd6, _0x38c07c) {
      var _0x2896be = [_0x348cd6, UI.userPrivilege(_0x348cd6)];
      $["each"](_0x38c07c, function (_0x284c5a, _0x6dc44d) {
        var _0x2b5be3 = $("<div />");
        _0x2b5be3["addClass"]("smallCheckbox");
        var _0x222619 = new Checkbox(_0x2b5be3);
        _0x222619["setValue"](_0x6dc44d), UI.rankToIndex(_0x284c5a) >= _0x102350 && _0x222619["setReadOnly"](true), _0x2896be["push"](_0x222619);
      }), _0x2a1a4f["table"]["addRow"](_0x2896be, false);
    }), this.table["hideColumn"](1), this["dialog"].changed(), this["table"]["updated"](), this["dialog"]["loading"](false);
  }
}
class RoomManagerToolsSubDialog extends SubDialog {
  constructor(_0x3ee547, _0x50254c) {
    super(_0x3ee547, _0x50254c), this["table"];
  }
  ["load"]() {
    this["dialog"]["loading"](true), this["subContent"]["html"](this["dialog"]["loadFile"]("forms/roommanager.tools.html"));
    !room["can"]("changetools") && (this.subContent["find"]("#applyChanged")["addClass"]("disabled"), this.subContent["find"]("#defaultTools")["addClass"]("disabled"));
    this["table"] = new Table(this["subContent"]["find"]("#toolsContent"), null, "roomTable", "fmTable"), this["table"]["selectable"] = false;
    var _0x3804a8 = this;
    $(this["dialog"]).on("dialogResizingEnded.toolsSubdialog dialogMaximized.toolsSubdialog dialogRestored.toolsSubdialog", function (_0x288072) {
      _0x3804a8["table"] && _0x3804a8["table"].updated();
    }), this["subContent"]["find"]("#defaultTools").on(UI["pointerEvent"]("click", "toolsSubdialog"), function (_0x3b56b1) {
      _0x3b56b1["preventDefault"](), _0x3804a8["dialog"]["loading"](true);
      var _0x470fa6 = {};
      _0x470fa6["command"] = "ROOMREQUEST", _0x470fa6["action"] = "RoomTools", _0x470fa6["perform"] = "default", socket["send"](_0x470fa6, true), _0x3804a8["dialog"]["loading"](true);
    }), this["subContent"]["find"]("#applyChanges").on(UI["pointerEvent"]("click", "toolsSubdialog"), function (_0x401e52) {
      _0x401e52["preventDefault"](), _0x3804a8["dialog"].loading(true);
      var _0x2ed90d = _0x3804a8["table"]["getColumnId"]("ID"),
        _0x367266 = UI["rankToIndex"](room["myself"].rank),
        _0xf55eb8 = _0x3804a8.table["headerFields"]["length"] - 1,
        _0x297cd3 = {};
      for (var _0xc5aa3f = 2; _0xc5aa3f <= _0xf55eb8; _0xc5aa3f++) {
        var _0x3e60ec = _0x3804a8["table"]["headerFields"][_0xc5aa3f];
        UI.rankToIndex(_0x3e60ec) < _0x367266 && (_0x297cd3[_0x3e60ec] = {});
      }
      for (var _0x243d4b = 0; _0x243d4b < _0x3804a8["table"]["rowCount"]; _0x243d4b++) {
        for (var _0xc5aa3f = 2; _0xc5aa3f <= _0xf55eb8; _0xc5aa3f++) {
          var _0x5a6478 = _0x3804a8["table"]["rows"][_0x243d4b][_0xc5aa3f],
            _0x3e60ec = _0x3804a8.table["headerFields"][_0xc5aa3f];
          UI.rankToIndex(_0x3e60ec) < _0x367266 && (_0x297cd3[_0x3e60ec][_0x3804a8["table"]["rows"][_0x243d4b][_0x2ed90d]] = _0x5a6478["checked"]);
        }
      }
      var _0x482683 = {};
      _0x482683["command"] = "ROOMCHANGE", _0x482683["action"] = "RoomTools", _0x482683["tools"] = _0x297cd3, socket.send(_0x482683, true), UI["dialogHandler"]["showAlert"](textManager.getString("alerts.txtSaved"));
    });
    var _0x56aa70 = {};
    _0x56aa70["command"] = "ROOMREQUEST", _0x56aa70["action"] = "RoomTools", _0x56aa70.perform = "get", socket["send"](_0x56aa70, true);
  }
  ["unload"]() {
    this["dialog"]["modal"].off(".toolsSubdialog"), this["table"]["reset"]();
  }
  ["gotResponse"](_0x1be22b) {
    _0x1be22b["option"] == "Rtc" && this["dialog"]["loading"](false);
  }
  ["data"](_0x411798, _0x1d51ee) {
    var _0x45248e = UI["rankToIndex"](room["myself"]["rank"]);
    this.table["reset"]();
    var _0xdac174 = ["ID", "Tool"],
      _0x4473d6 = _0xdac174["length"] + 1;
    $.each(_0x411798, function (_0x2d02ba, _0x46879e) {
      _0xdac174.push(_0x46879e);
    }), this["table"]["setHeader"](_0xdac174), this["table"].headerCaption(2, textManager["getString"]("roommanager.tools.rowTool"));
    var _0x17b117 = this;
    $.each(_0x411798, function (_0x400dbc, _0x4c32a0) {
      _0x17b117["table"]["headerClass"](_0x400dbc + _0x4473d6, UI["rankToStyle"](_0x4c32a0)), _0x17b117["table"]["headerTooltip"](_0x400dbc + _0x4473d6, UI.userRank(_0x4c32a0)), _0x17b117["table"]["headerCaption"](_0x400dbc + _0x4473d6, textManager["getString"]("global.shortRank." + _0x4c32a0));
    }), $.each(_0x1d51ee, function (_0x3618f6, _0x183e04) {
      var _0x2aa574 = [_0x3618f6, UI["brushToIcon"](_0x3618f6)["html"]() + " " + UI["brushToName"](_0x3618f6)];
      $["each"](_0x183e04, function (_0x52cf1d, _0x1c8735) {
        var _0x53bd4b = $("<div />");
        _0x53bd4b["addClass"]("smallCheckbox");
        var _0x3e2d58 = new Checkbox(_0x53bd4b);
        _0x3e2d58["setValue"](_0x1c8735), (UI["rankToIndex"](_0x52cf1d) >= _0x45248e || _0x3618f6 == UI["defaultBrush"]) && _0x3e2d58.setReadOnly(true), _0x2aa574["push"](_0x3e2d58);
      }), _0x17b117["table"]["addRow"](_0x2aa574, false);
    }), this["table"].hideColumn(1), this.table["columnLink"](2, 1), this.dialog["changed"](), this["table"]["updated"](), this["dialog"]["loading"](false);
  }
}
class RoomManagerBansSubDialog extends SubDialog {
  constructor(_0x550a84, _0x35ea7b) {
    super(_0x550a84, _0x35ea7b), this["table"];
  }
  ["load"]() {
    this.dialog["loading"](true), this["subContent"]["html"](this["dialog"]["loadFile"]("forms/roommanager.bans.html"));
    !room["can"]("ban") && this["subContent"]["find"]("#addBan")["addClass"]("disabled");
    this.subContent["find"]("#removeBan")["addClass"]("disabled"), this["subContent"]["find"]("#editBan")["addClass"]("disabled"), this["table"] = new Table(this.subContent["find"]("#banContent"), null, "banManagerTable", "fmTable"), this["table"].setFilterable(true), this["table"]["setTitle"](textManager["getString"]("roommanager.bans.lblBans")), this.table["setHeader"](["ID", "Address", "Username", "Timestamp", "Staffname", "Staffrank", "Staffuid", "IP", "Banned by", "Length"]), this["table"]["hideColumns"]([1, 2, 3, 4, 5, 6, 7]), this["table"]["columnLink"](9, 5), this["table"]["columnLink"](10, 4), this.table["headerCaption"](8, textManager["getString"]("roommanager.bans.rowIP")), this["table"]["headerCaption"](9, textManager.getString("roommanager.bans.rowBannedBy")), this["table"]["headerCaption"](10, textManager["getString"]("roommanager.bans.rowLength"));
    var _0x1faf74 = this;
    $(this["dialog"]).on("dialogResizingEnded.banSubdialog dialogMaximized.banSubdialog dialogRestored.banSubdialog", function (_0xa93d6d) {
      _0x1faf74.table && _0x1faf74["table"].updated();
    }), this["subContent"].on(UI["pointerEvent"]("click", "banSubdialog"), "#addBan", function (_0x478cbd) {
      _0x478cbd["preventDefault"](), _0x1faf74["dialog"]["enableModal"](_0x1faf74["dialog"].loadFile("forms/roommanager.modal.addban.html")), _0x1faf74["dialog"]["modal"]["find"]("input[name=\"address\"]")["focus"]();
      var _0x533169 = _0x1faf74["dialog"]["modal"].find("select[name=\"banLength\"]");
      _0x533169["empty"](), $.each(_0x1faf74["dialog"]["banLengths"], function (_0x13c1ae, _0x540c9c) {
        let _0x4d1043 = getLengthDescription(_0x540c9c);
        _0x533169.append(new Option(_0x4d1043, _0x540c9c));
      }), _0x533169.val(room.bantime);
    }), this["subContent"].on(UI["pointerEvent"]("click", "banSubdialog"), "#editBan", function (_0x296a42) {
      _0x296a42["preventDefault"](), _0x1faf74["editBan"]();
    }), this.subContent.on(UI["pointerEvent"]("click", "banSubdialog"), "#removeBan", function (_0xa48d1b) {
      _0xa48d1b["preventDefault"]();
      var _0xf13098 = _0x1faf74.table["getSelected"]();
      if (_0xf13098) {
        _0x1faf74["dialog"].loading(true);
        var _0x1e871f = {};
        _0x1e871f["command"] = "ROOMCHANGE", _0x1e871f.action = "RoomBans", _0x1e871f.perform = "delete", _0x1e871f["banid"] = _0xf13098[0].ID, socket["send"](_0x1e871f, true);
      }
    }), this["dialog"]["modal"].on(UI["pointerEvent"]("click", "banSubdialog"), "#insertBan", function (_0x3668d9) {
      _0x3668d9["preventDefault"]();
      let _0x41c582 = _0x1faf74["dialog"]["modal"]["find"]("input[name=\"address\"]").val();
      if (isValidIP(_0x41c582)) {
        var _0x442d3e = {};
        _0x442d3e["command"] = "ROOMCHANGE", _0x442d3e["action"] = "RoomBans", _0x442d3e["perform"] = "update", _0x442d3e["username"] = _0x1faf74["dialog"]["modal"]["find"]("input[name=\"username\"]")["val"](), _0x442d3e.ip = _0x41c582, _0x442d3e["expires"] = _0x1faf74["dialog"]["modal"]["find"]("select[name=\"banLength\"]")["val"](), socket["send"](_0x442d3e, true), _0x1faf74["dialog"].loading(true);
      } else UI["dialogHandler"].showAlert(textManager["getString"]("alerts.txtInvalidIP"));
    }), this.dialog["modal"].on(UI.pointerEvent("click", "banSubdialog"), "#updateBan", function (_0x3a767d) {
      _0x3a767d["preventDefault"]();
      let _0x176db0 = _0x1faf74["dialog"]["modal"].find('input[name="address"]')["val"]();
      if (isValidIP(_0x176db0)) {
        var _0x3db856 = {};
        _0x3db856["command"] = "ROOMCHANGE", _0x3db856["action"] = "RoomBans", _0x3db856["perform"] = "update", _0x3db856["banid"] = _0x1faf74["dialog"]["modal"].find("input[name=\"banid\"]")["val"](), _0x3db856["username"] = _0x1faf74["dialog"]["modal"]["find"]('input[name="username"]')["val"](), _0x3db856.ip = _0x176db0, _0x3db856["expires"] = _0x1faf74.dialog["modal"]["find"]("select[name=\"banLength\"]")["val"](), socket.send(_0x3db856, true), _0x1faf74["dialog"]["loading"](true);
      } else UI["dialogHandler"]["showAlert"](textManager.getString("alerts.txtInvalidIP"));
    });
    var _0xb123c5 = {};
    _0xb123c5["command"] = "ROOMREQUEST", _0xb123c5["action"] = "RoomBans", socket["send"](_0xb123c5, true);
  }
  ["unload"]() {
    this["dialog"]["modal"]["off"](".banSubdialog"), this["table"].reset();
  }
  ["data"](_0x6f4f96) {
    var _0x33879d = this;
    $["each"](_0x6f4f96, function (_0x17b370, _0x5c3809) {
      _0x33879d["addBanRow"](_0x5c3809.id, _0x5c3809.ip, _0x5c3809.username, _0x5c3809["expires"], _0x5c3809["staffname"], _0x5c3809["staffrank"], _0x5c3809["uid"]);
    }), $(this["table"]).on("tableRowDoubleClick.banSubdialog", function (_0xbc4133) {
      _0x33879d.editBan();
    }), $(this["table"]).on("tableRowSelected.banSubdialog tableRowUnselected.banSubdialog", function (_0x5971f0) {
      var _0x404d58 = false;
      if (_0x5971f0["type"] == "tableRowSelected") {
        var _0x1a0203 = _0x33879d["table"]["getSelected"]();
        (_0x1a0203[0].Staffuid == room.myself["uid"] || room["can"]("unbanothers")) && (_0x404d58 = true);
      }
      _0x404d58 ? (_0x33879d["subContent"].find("#removeBan")["removeClass"]("disabled"), _0x33879d["subContent"].find("#editBan").removeClass("disabled")) : (_0x33879d["subContent"]["find"]("#removeBan")["addClass"]("disabled"), _0x33879d["subContent"]["find"]("#editBan")["addClass"]("disabled"));
    }), this["dialog"]["changed"](), this.table["updated"](), this["table"]["sort"](4), this["dialog"]["loading"](false);
  }
  ["editBan"]() {
    this.dialog["enableModal"](this["dialog"]["loadFile"]("forms/roommanager.modal.editban.html")), this.dialog.modal["find"]("input[name=\"address\"]")["focus"]();
    var _0x534e1a = this["table"]["getSelected"](),
      _0x5ca804 = this.dialog["modal"].find('select[name="banLength"]');
    _0x5ca804["empty"](), _0x5ca804.append(new Option(_0x534e1a[0]["Length"], -1)), $.each(this.dialog["banLengths"], function (_0x4f9317, _0x396a31) {
      let _0x5c9f69 = getLengthDescription(_0x396a31);
      _0x5ca804["append"](new Option(_0x5c9f69, _0x396a31));
    }), _0x5ca804["val"](-1), this["dialog"]["modal"].find('input[name="banid"]').val(_0x534e1a[0].ID), this["dialog"].modal["find"]("input[name=\"address\"]")["val"](_0x534e1a[0]["Address"]), this["dialog"]["modal"].find("input[name=\"username\"]")["val"](_0x534e1a[0]["Username"]);
  }
  ["addBanRow"](_0x4a6971, _0x4a962d, _0x7667de, _0x2580da, _0x126d5e, _0x1b2865, _0x395448) {
    var _0x46fe96;
    _0x2580da >= 2e9 ? _0x46fe96 = textManager["getString"]("global.lengths.lblPermanent") : _0x46fe96 = formatTimestamp(_0x2580da - UI["timeDiff"]);
    var _0xaf9d33 = _0x4a962d + "<br /><span class=\"smallDate\">" + _0x7667de + "</span>",
      _0x138786 = "<span class=\"" + UI["rankToStyle"](_0x1b2865) + '">' + _0x126d5e + "</span>";
    return this["table"]["addRow"]([_0x4a6971, _0x4a962d, _0x7667de, _0x2580da, _0x126d5e, _0x1b2865, _0x395448, _0xaf9d33, _0x138786, _0x46fe96], false);
  }
  ["updateBanRow"](_0x821e4d, _0xfccd98, _0x2dfb8a, _0xba6d1d, _0x24db33, _0xe95518, _0x57511b) {
    var _0x3e485a = this["table"]["find"](this.table.getColumnId("ID"), _0x821e4d);
    if (_0x3e485a != null) {
      var _0x4a6db3;
      _0xba6d1d >= 2e9 ? _0x4a6db3 = textManager["getString"]("global.lengths.lblPermanent") : _0x4a6db3 = formatTimestamp(_0xba6d1d - UI["timeDiff"]);
      var _0x2acd49 = _0xfccd98 + "<br /><span class=\"smallDate\">" + _0x2dfb8a + "</span>",
        _0x4aa905 = "<span class=\"" + UI["rankToStyle"](_0xe95518) + '">' + _0x24db33 + "</span>",
        _0x4860f0 = {};
      _0x4860f0[this.table.getColumnId("Address")] = _0xfccd98, _0x4860f0[this.table["getColumnId"]("Username")] = _0x2dfb8a, _0x4860f0[this["table"]["getColumnId"]("Timestamp")] = _0xba6d1d, _0x4860f0[this["table"].getColumnId("IP")] = _0x2acd49, _0x4860f0[this["table"]["getColumnId"]("Staffname")] = _0x24db33, _0x4860f0[this.table["getColumnId"]("Staffrank")] = _0xe95518, _0x4860f0[this["table"]["getColumnId"]("Staffuid")] = _0x57511b, _0x4860f0[this["table"]["getColumnId"]("Banned by")] = _0x4aa905, _0x4860f0[this["table"].getColumnId("Length")] = _0x4a6db3, this.table["updateRow"](_0x3e485a, _0x4860f0);
    }
  }
  ["gotResponse"](_0x286ab7) {
    if (_0x286ab7["option"] == "Rba") {
      if (_0x286ab7["code"] == "OK") {
        this["dialog"]["disableModal"]();
        var _0x221875 = this["addBanRow"](_0x286ab7["ban"].id, _0x286ab7["ban"].ip, _0x286ab7["ban"]["username"], _0x286ab7["ban"]["time"], _0x286ab7.ban["staffname"], _0x286ab7["ban"].staffrank, _0x286ab7["ban"]["staffuid"]),
          _0x221875 = this["table"]["find"](this["table"]["getColumnId"]("ID"), _0x286ab7.ban.id);
        _0x221875 != null && this.table["locate"](_0x221875);
      } else UI["dialogHandler"].showAlert("Error: " + _0x286ab7["code"]);
      this["table"]["updated"]();
    } else {
      if (_0x286ab7["option"] == "Rbu") {
        if (_0x286ab7.code == "OK") {
          this.dialog.disableModal(), this["updateBanRow"](_0x286ab7["ban"].id, _0x286ab7["ban"].ip, _0x286ab7.ban["username"], _0x286ab7.ban.time, _0x286ab7["ban"]["staffname"], _0x286ab7["ban"]["staffrank"]);
          var _0x221875 = this["table"]["find"](this.table["getColumnId"]("ID"), _0x286ab7["ban"].id);
          _0x221875 != null && this.table["locate"](_0x221875);
        } else UI["dialogHandler"]["showAlert"]("Error: " + _0x286ab7["code"]);
      } else {
        if (_0x286ab7["option"] == "Rbd") {
          if (_0x286ab7["code"] == "OK") {
            var _0x221875 = this["table"].find(this["table"]["getColumnId"]("ID"), _0x286ab7["ban"].id);
            _0x221875 != null && this["table"]["deleteRow"](_0x221875);
          } else UI["dialogHandler"]["showAlert"]("Error: " + _0x286ab7["code"]);
        }
      }
    }
    this["dialog"].loading(false);
  }
}
class SaveDialog extends Dialog {
  constructor(_0xb478db) {
    super(_0xb478db), this["icon"] = "fa-image", this.caption = textManager["getString"]("save.title"), this["width"] = 705, this["height"] = 590, this.canvasWidth, this["canvasHeight"], this.selectionPrevious = null, this["selectionInitial"] = null, this["gallerySaves"] = 0, this.galleryLimit = 10, this["loadContent"](this["loadFile"]("forms/save.main.html")), this["canvas"] = new AdvancedCanvas(1, 1), this.content["find"]("#savePreview")["append"](this.canvas["canvas"]), $(this.content).overlayScrollbars({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    });
    var _0x18eb07 = this;
    this["content"]["find"]("a[name=\"saveGallery\"]").on(UI["pointerEvent"]("click"), function (_0x5e315e) {
      _0x5e315e["preventDefault"](), _0x18eb07["selection"]["hasSelection"]() ? (_0x18eb07.selectionPrevious = _0x18eb07["selection"]["getClicks"](), _0x18eb07.selectionInitial = _0x18eb07["selection"]["initialPosition"]) : (_0x18eb07.selectionPrevious = null, _0x18eb07.selectionInitial = null), _0x18eb07["save"]("gallery"), _0x18eb07["content"]["find"]('input[name="url"]')["focus"]();
    }), this["content"]["find"]('a[name="saveFile"]').on(UI["pointerEvent"]("click"), function (_0x131b96) {
      _0x131b96["preventDefault"](), _0x18eb07["selection"].hasSelection() ? (_0x18eb07["selectionPrevious"] = _0x18eb07["selection"]["getClicks"](), _0x18eb07["selectionInitial"] = _0x18eb07.selection["initialPosition"]) : (_0x18eb07["selectionPrevious"] = null, _0x18eb07["selectionInitial"] = null), _0x18eb07.save("disk");
    }), this["selection"] = new SelectionTool(this.content["find"]("#savePreview"), 0, 0), this["background"] = new Switch(this["content"].find("#saveBackground"), function (_0x126d6a) {
      return _0x126d6a ? textManager["getString"]("global.transparent") : textManager.getString("global.opaque");
    }), $(this["background"]).on("checkboxChanged", function (_0x4902b3) {
      _0x18eb07["content"]["find"]("#savePreview").css("background", _0x4902b3["checked"] ? "" : room["board"]["backgroundColor"]), _0x18eb07["setPreference"]("background", _0x4902b3["checked"]);
    }), this["selectionTool"] = new Switch(this["content"]["find"]("#selectionTool"), lassoRectFunction), this["currentTool"] = "rectangle", $(this["selectionTool"]).on("checkboxChanged", function (_0x14bdba) {
      _0x18eb07["selection"]["currentTool"] = _0x14bdba["checked"] ? "lasso" : "rectangle", _0x18eb07.selection.clear(), _0x18eb07["currentTool"] = _0x18eb07["selection"].currentTool, _0x18eb07["setPreference"]("tool", _0x14bdba["checked"]);
    }), this["content"]["find"]("#savePreview")["contextmenu"](function (_0x38e2c6) {
      _0x38e2c6["preventDefault"]();
    }), this["content"]["find"]("#savePreview").on(UI["pointerEvent"]("down"), function (_0x73ad3a) {
      _0x73ad3a["which"] && _0x73ad3a.which == 2 && (_0x73ad3a["preventDefault"](), !_0x18eb07.selectionTool["readOnly"] && (_0x18eb07["selection"]["currentTool"] = _0x18eb07.selection["currentTool"] == "rectangle" ? "lasso" : "rectangle", _0x18eb07["selectionTool"]["setValue"](!_0x18eb07["selectionTool"]["checked"]), _0x18eb07["currentTool"] = _0x18eb07["selection"]["currentTool"]));
    }), this["content"].find("button[name=\"visitImage\"]").on(UI["pointerEvent"]("click"), function (_0x550880) {
      _0x550880["preventDefault"]();
      var _0x5f2fa7 = _0x18eb07["content"]["find"]('input[name="url"]').val();
      _0x5f2fa7 != "" && window["open"](_0x5f2fa7, "_blank");
    });
  }
  ["loadContent"](_0x153f16) {
    this.content["html"](_0x153f16);
  }
  ["saveToGallery"](_0x3b9710 = false) {
    var _0xcb3cc4 = this;
    if (this["gallerySaves"] >= this["galleryLimit"] && !_0x3b9710) {
      this["enableModal"](this["loadFile"]("forms/system.captcha.html"));
      var _0x44a37f = new Captcha();
      this["modal"].find("form[name=\"captchaForm\"]").submit(function (_0x115cad) {
        _0x115cad.preventDefault(), _0x44a37f["verify"](_0x334e7c.val()) ? (_0xcb3cc4["saveToGallery"](true), _0xcb3cc4["disableModal"](), _0xcb3cc4.gallerySaves = 0) : (_0x44a37f["newCode"](), UI["dialogHandler"].showAlert(textManager["getString"]("alerts.txtCaptchaFailed"))), _0x334e7c["val"]("");
      }), this["modal"]["find"](".captchaContainer p").append(_0x44a37f["canvas"]);
      var _0x334e7c = this["modal"]["find"]("input[name=\"code\"]");
      _0x334e7c["focus"](), this["modal"]["find"]("#confirmCaptcha").on(UI["pointerEvent"]("down"), function (_0x215c56) {
        _0x215c56.preventDefault(), _0xcb3cc4.modal["find"]('form[name="captchaForm"]')["submit"]();
      }), _0x334e7c.on("keydown", function (_0x40c5c4) {
        _0x40c5c4.which == 13 && (_0x40c5c4["preventDefault"](), _0xcb3cc4["modal"].find("form[name=\"captchaForm\"]").submit());
      });
    } else {
      this["loading"](true);
      var _0x53dac4 = this["getDataURL"](),
        _0x4ae672 = new FormData(),
        _0x1951fe = this["getExtension"]();
      _0x4ae672.append("file", canvas2blob(_0x53dac4), "whiteboard." + _0x1951fe), _0x4ae672["append"]("tags", _0x1951fe == "gif" ? "animation" : ""), _0x4ae672.append("filename", "whiteboard." + _0x1951fe), _0x4ae672["append"]("extension", _0x1951fe), _0x4ae672["append"]("username", UI["account"]["username"]), _0x4ae672["append"]("password", UI["account"].password), $.ajax({
        type: "POST",
        enctype: "multipart/form-data",
        url: "https://flockmod.com/gallery/index.php?q=/upload",
        data: _0x4ae672,
        processData: false,
        contentType: false,
        cache: false,
        timeout: 6e5
      })["done"](function (_0x563b7a) {
        var _0x2d88e8 = /(to \.\/index\.php\?q\=\/post\/view\/([0-9]*)?)/g,
          _0x368665 = _0x2d88e8["exec"](_0x563b7a);
        if (_0x368665) {
          var _0x67388e = _0x368665[2];
          _0xcb3cc4.content["find"]("input[name=\"url\"]")["val"]("https://flockmod.com/img/?" + _0x67388e), _0xcb3cc4["content"]["find"]("input[name=\"url\"]")["focus"]();
        }
        $(_0xcb3cc4).triggerHandler(new processFinishedEvent()["getEvent"]()), _0xcb3cc4.gallerySaves++, _0xcb3cc4["loading"](false);
      })["fail"](function (_0x149fd0) {
        UI.dialogHandler["showAlert"](textManager.getString("alerts.txtGallerySaveFailed")), _0xcb3cc4.loading(false);
      });
    }
  }
  ["saveToDisk"]() {
    this.loading(true), UI["warnExit"] = false;
    var _0x32366d = formatDateString(new Date()),
      _0x2bf6fa = $("<a />");
    _0x2bf6fa.addClass("invisible"), _0x2bf6fa["attr"]("download", "savedfile_" + _0x32366d + "." + this.getExtension()), _0x2bf6fa["attr"]("href", this.makeDownloadable(this.getDataURL())), this["content"]["append"](_0x2bf6fa), _0x2bf6fa[0].click(), _0x2bf6fa.remove(), UI["warnExit"] = true, $(this).triggerHandler(new processFinishedEvent()["getEvent"]()), this.loading(false);
  }
  ["getExtension"]() {
    return this["content"]["find"]("#savePreview canvas:visible")["length"] > 0 ? "png" : "gif";
  }
  ["makeDownloadable"](_0xf88738) {
    return _0xf88738["replace"]("image/png", "image/octet-stream").replace("image/gif", "image/octet-stream");
  }
  ["getDataURL"]() {
    return this["content"]["find"]("#savePreview canvas:visible")["length"] > 0 ? this["canvas"]["getData"]() : this["content"].find("#savePreview img").attr("src");
  }
  ["save"](_0x15c4a3) {
    if (this.selection["hasSelection"]()) this["saveSelection"](_0x15c4a3); else {
      if (!this.background["checked"]) {
        var _0x3b80b5 = this["canvas"]["getImageData"](),
          _0x479345 = this,
          _0x418738 = new Image();
        _0x418738["onload"] = function () {
          _0x479345["canvas"]["clear"](room["board"]["backgroundColor"]), _0x479345["canvas"].drawImage(_0x418738, 0, 0), _0x479345["doSave"](_0x15c4a3);
        }, _0x418738["src"] = this["canvas"]["getData"](), $(_0x479345).on("processFinished.savedialog", function (_0x110993) {
          _0x479345.canvas["putImageData"](_0x3b80b5), $(_0x479345).off(".savedialog");
        });
      } else this["doSave"](_0x15c4a3);
    }
  }
  ["doSave"](_0x3f24c5) {
    _0x3f24c5 == "disk" ? this.saveToDisk() : this["saveToGallery"]();
  }
  ["saveSelection"](_0x40bb30) {
    if (this.selection.hasSelection()) {
      var _0x23b9b2 = this,
        _0x187f1d = this["getSelectedImage"]();
      _0x187f1d.then(function (_0x2f6731) {
        var _0xfc7a92 = parseInt(_0x2f6731["position"]["width"] - _0x2f6731["position"].x),
          _0x2335f3 = parseInt(_0x2f6731["position"]["height"] - _0x2f6731["position"].y);
        _0x23b9b2["canvasWidth"] = _0xfc7a92, _0x23b9b2.canvasHeight = _0x2335f3, _0x23b9b2["content"]["find"]("#saveBox")["css"]({
          width: _0x23b9b2.canvasWidth / 2 + "px",
          height: _0x23b9b2["canvasHeight"] / 2 + "px"
        }), _0x23b9b2["content"].find("#savePreview")["css"]({
          width: _0x23b9b2["canvasWidth"] + "px",
          height: _0x23b9b2["canvasHeight"] + "px"
        }), _0x23b9b2.resizeCanvas(_0xfc7a92, _0x2335f3), _0x23b9b2.canvas["clear"](), _0x23b9b2["selection"]["clear"]();
        var _0xc3e143 = new Image();
        _0xc3e143["onload"] = function () {
          _0x23b9b2["canvas"]["drawImage"](_0xc3e143, 0, 0), _0x23b9b2["save"](_0x40bb30);
        }, _0xc3e143["src"] = _0x2f6731["img"];
      });
    }
  }
  ["getSelectedImage"]() {
    var _0x5b9f5a = this;
    return new Promise(function (_0x35cbcd, _0x42d857) {
      var _0x37f1ae = _0x5b9f5a["selection"]["layer"].advCanvas["getContext"](),
        _0x139d6e,
        _0x21ffa6;
      _0x5b9f5a.selection["currentTool"] == "lasso" ? (_0x139d6e = getLimits(_0x5b9f5a["selection"]["clickX"]), _0x21ffa6 = getLimits(_0x5b9f5a.selection["clickY"])) : (_0x139d6e = getLimits(new Array(_0x5b9f5a["selection"].initialPosition.x, _0x5b9f5a.selection["clickX"][0])), _0x21ffa6 = getLimits(new Array(_0x5b9f5a["selection"]["initialPosition"].y, _0x5b9f5a["selection"].clickY[0])));
      var _0x244363 = new Rect(_0x139d6e.x, _0x21ffa6.x, _0x139d6e.y, _0x21ffa6.y),
        _0x599818 = new Image();
      _0x599818["onload"] = function () {
        _0x37f1ae["save"](), _0x5b9f5a["selection"]["redraw"](false, false), _0x37f1ae.closePath(), _0x37f1ae["clip"](), _0x37f1ae["drawImage"](_0x599818, 0, 0), _0x37f1ae["restore"]();
        var _0x31cd13 = new Image();
        _0x31cd13["onload"] = function (_0x54a651) {
          var _0x57b044 = {};
          _0x57b044["position"] = _0x244363, _0x57b044["img"] = cropImage(this, _0x244363.x, _0x244363.y, _0x244363["width"] - _0x244363.x, _0x244363.height - _0x244363.y), _0x35cbcd(_0x57b044);
        }, _0x31cd13["src"] = _0x5b9f5a["selection"]["layer"]["advCanvas"]["getData"]();
      }, _0x599818["src"] = _0x5b9f5a["canvas"]["getData"]();
    });
  }
  ["getBrushSelection"](_0x6c157c = null) {
    var _0x561787 = room["myself"].surface["brushHandler"].brush,
      _0x3edc48 = _0x561787["getBounds"]();
    this["resizeCanvas"](_0x3edc48["width"] - _0x3edc48.x, _0x3edc48.height - _0x3edc48.y), this.canvas.clear();
    var _0x2b3f51 = this,
      _0x4fd6f3 = new Array();
    if (_0x561787.getOption("multilayer")) for (var _0x33f5b5 = 0; _0x33f5b5 < room["board"].nLayers; _0x33f5b5++) {
      UI.layerIsVisible(_0x33f5b5) && (_0x6c157c == null || _0x6c157c == _0x33f5b5) && _0x4fd6f3["push"](_0x33f5b5);
    } else _0x4fd6f3["push"](_0x6c157c == null ? room["myself"]["surface"]["currentLayer"] : _0x6c157c);
    var _0x3c38eb = _0x4fd6f3["length"],
      _0x5eac71 = {},
      _0x52d22d = 0;
    $["each"](_0x4fd6f3, function (_0x594a53, _0x55a8cb) {
      var _0x2fcf26 = _0x561787.getSelectedImage(_0x55a8cb);
      _0x2fcf26["then"](function (_0x207bb1) {
        _0x5eac71[_0x207bb1["layer"]] = _0x207bb1;
        if (++_0x52d22d == _0x3c38eb) {
          for (var _0x5990c1 = 0; _0x5990c1 < room.board["nLayers"]; _0x5990c1++) {
            _0x5990c1 in _0x5eac71 && UI["layerIsVisible"](_0x5990c1) && (_0x2b3f51["canvas"]["drawImage"](_0x5eac71[_0x5990c1]["img"], 0, 0), room.myself.surface["brushParameter"]({
              action: "save"
            }));
          }
          $(_0x2b3f51)["triggerHandler"](new imageLoadedEvent()["getEvent"]());
        }
      });
    });
  }
  ["gif"](_0x59dde8) {
    $(_0x59dde8)["addClass"]("noMouseInteraction"), this["simpleMode"](true), this["content"]["find"]("#savePreview")["append"](_0x59dde8), this["canvasWidth"] = $(_0x59dde8)["width"](), this["canvasHeight"] = $(_0x59dde8)["height"](), $(this)["triggerHandler"](new imageLoadedEvent().getEvent());
  }
  ["simpleMode"](_0x5e72e6) {
    _0x5e72e6 ? (this["content"]["find"]("#savePreview canvas")["hide"](), this.selectionTool["setReadOnly"](true), this.background["setReadOnly"](true)) : (this.content["find"]("#savePreview canvas").show(), this.selectionTool["setReadOnly"](false), this.background["setReadOnly"](false));
  }
  ["custom"](_0x4db591) {
    var _0x319cee = this;
    $["each"](_0x4db591, function (_0x1ca477, _0x3e7d00) {
      _0x1ca477 == 0 && (_0x319cee["resizeCanvas"](_0x3e7d00["width"], _0x3e7d00["height"]), _0x319cee["canvas"].clear());
      var _0x1f2a7a = new AdvancedCanvas(_0x3e7d00["width"], _0x3e7d00["height"]);
      _0x1f2a7a["putImageData"](_0x3e7d00);
      var _0x448589 = new Image();
      _0x448589["onload"] = function () {
        _0x319cee.canvas["drawImage"](_0x448589, 0, 0);
      }, _0x448589["src"] = _0x1f2a7a["getData"](), _0x1f2a7a["remove"]();
    }), $(this).triggerHandler(new imageLoadedEvent()["getEvent"]());
  }
  ["getFullBoard"](_0x5a2fc7 = null) {
    this["resizeCanvas"](room["board"]["canvasWidth"], room["board"]["canvasHeight"]), this["canvas"]["clear"]();
    var _0x401250 = this,
      _0xe1599b = _0x5a2fc7 == null ? room["board"].getAllLayers(0, 0, this["canvasWidth"], this.canvasHeight) : room["board"]["getImgLayers"]({}, 0, 0, this["canvasWidth"], this.canvasHeight, _0x5a2fc7 - 1);
    _0xe1599b["then"](function (_0x1f21fc) {
      var _0x32b892 = Object.keys(_0x1f21fc).length,
        _0x11ff6d = {},
        _0x2bb8e5 = 0;
      $["each"](_0x1f21fc, function (_0x55bfbe, _0x226c81) {
        var _0x5e13a0 = new Image();
        _0x11ff6d[_0x55bfbe] = _0x5e13a0, _0x5e13a0["onload"] = function () {
          if (++_0x2bb8e5 == _0x32b892) {
            for (var _0x5876bc = 0; _0x5876bc < room["board"]["nLayers"]; _0x5876bc++) {
              _0x5876bc in _0x11ff6d && UI["layerIsVisible"](_0x5876bc) && (_0x5a2fc7 == null || _0x5a2fc7 == _0x5876bc) && _0x401250["canvas"]["drawImage"](_0x11ff6d[_0x5876bc], 0, 0);
            }
            $(_0x401250)["triggerHandler"](new imageLoadedEvent().getEvent());
          }
        }, _0x5e13a0["src"] = _0x226c81;
      });
    });
  }
  ["preview"](_0x11348d = "full", _0x433e4f = null) {
    if (_0x11348d == "full") this["getFullBoard"](_0x433e4f); else {
      if (_0x11348d == "selection") this["getBrushSelection"](_0x433e4f); else {
        if (_0x11348d == "custom") this["custom"](_0x433e4f); else _0x11348d == "gif" && this.gif(_0x433e4f);
      }
    }
  }
  ["onResize"]() {
    var _0x4f8e11 = this["content"]["find"]("#saveBox")["width"](),
      _0x42d8e5 = this["content"]["find"]("#savePreview")["width"](),
      _0x3a741a = this["content"]["find"]("#savePreview")["height"](),
      _0x554cae = this["content"]["find"]("#previewDiv")["width"](),
      _0x1287d4 = this["content"]["find"]("#previewDiv")["height"](),
      _0x1c27d3 = calculateAspectRatioFit(this.canvasWidth, this.canvasHeight, _0x554cae, _0x1287d4),
      _0x10361c = _0x1c27d3["width"] / this.canvasWidth;
    this["content"]["find"]("#savePreview")["css"]("transform", "scale(" + _0x10361c + ")"), this["content"]["find"]("#saveBox")["css"]({
      width: _0x1c27d3["width"],
      height: _0x1c27d3["height"]
    }), this["selection"]["setScale"](_0x10361c);
  }
  ["onShow"](_0x2c062b = "full", _0x4a4ec5 = null) {
    var _0x3c32fc = this;
    this.loading(true), this["simpleMode"](false), $(this).on("imageLoaded", function (_0x261855) {
      _0x3c32fc["loading"](false), _0x3c32fc["changed"]();
    }), this["preview"](_0x2c062b, _0x4a4ec5), this["selectionPrevious"] && (this["selection"]["setClicks"](this["selectionPrevious"]), this["selection"].initialPosition = this["selectionInitial"], this["selection"].redraw()), this["content"]["find"]("input[name=\"url\"]").val(""), this["getPreference"]("background") !== undefined ? this["background"].setValue(this.getPreference("background")) : (this["background"]["setValue"](false), this["content"]["find"]("#savePreview").css("background", room["board"]["backgroundColor"])), this.getPreference("tool") !== undefined && this["selectionTool"]["setValue"](this["getPreference"]("tool")), this.changed();
  }
  ["onHide"]() {
    this["layers"] = null, this.layersCheckbox = null, this["resizeCanvas"](1, 1), this.content["find"]("#savePreview img").remove();
  }
  ["resizeCanvas"](_0x3a661a, _0x557be4) {
    this["canvasWidth"] = _0x3a661a, this["canvasHeight"] = _0x557be4, this["content"]["find"]("#savePreview")["css"]({
      width: this["canvasWidth"] + "px",
      height: this.canvasHeight + "px"
    }), this["canvas"]["changeSize"](this["canvasWidth"], this.canvasHeight), this.selection["changeSize"](this["canvasWidth"], this["canvasHeight"]), this["onResize"]();
  }
}
class UploadDialog extends Dialog {
  constructor(_0x51a84a) {
    super(_0x51a84a), this["icon"] = "fa-image", this["caption"] = textManager["getString"]("upload.title"), this["width"] = 705, this["height"] = 450, this["loadContent"](this["loadFile"]("forms/upload.main.html"));
    var _0x31bab7 = this;
    this["content"]["find"]("#dropArea").on("dragover dragenter", function (_0x32e25c) {
      _0x31bab7["active"] && (_0x32e25c["preventDefault"](), $(this)["css"]("border", "3px solid red"));
    }), this.content["find"]("#dropArea").on("dragleave", function (_0xf6a489) {
      _0x31bab7["active"] && (_0xf6a489["preventDefault"](), $(this)["css"]("border", "3px solid #505050"));
    }), this["content"]["find"]("#dropArea").on("drop", function (_0x29846f) {
      _0x31bab7["active"] && (_0x29846f["preventDefault"](), $(this).css("border", "3px solid #505050"), UI["uploader"]["uploadFile"](_0x29846f["originalEvent"]["dataTransfer"]["files"]), _0x31bab7["hide"]());
    }), this["content"]["find"]("#dropArea").on("click", function (_0x4a928c) {
      _0x31bab7.active && (_0x4a928c["preventDefault"](), $("#uploadFile")["click"](), _0x31bab7["hide"]());
    }), this["content"]["find"]('a[name="uploadFile"]').on("click", function (_0x502a6f) {
      _0x502a6f.preventDefault(), $("#uploadFile")["click"](), _0x31bab7["hide"]();
    });
  }
  ["onShow"]() {
    this["changed"]();
  }
  ["loadContent"](_0x2ef8db) {
    this["content"]["html"](_0x2ef8db);
  }
}
class BrushDesignerDialog extends Dialog {
  constructor(_0x1a7a29) {
    super(_0x1a7a29), this["icon"] = "fa-paint-brush", this["caption"] = textManager["getString"]("brushdesigner.title"), this["canvasSize"] = 140, this["brushSize"] = 10, this.brushAlpha = 1, this["brushType"], this.brushColor = "#000000", this["designerScale"] = 2.5, this["width"] = 740, this["height"] = 520, this.minWidth = 440, this["colorSelector"], this["sliderSize"], this["sliderAlpha"], this["from"], this.brush = new AdvancedCanvas(this["canvasSize"], this["canvasSize"]), this.brush.canvas.addClass("pixelArt noPixelSmoothing transparentBG noMouseInteraction"), this["slate"] = new AdvancedCanvas(this["canvasSize"], this["canvasSize"]), this["slate"]["canvas"]["addClass"]("pixelArt noPixelSmoothing"), this["slate"]["canvas"]["css"]({
      "z-index": 999
    }), this["loadContent"](this["loadFile"]("forms/brushdesigner.main.html")), this["drawing"] = false, this["clicks"] = new Array(), this.selectBrush("pen"), this["cursorPos"] = new Point(0, 0), this["cursor"] = $("<div />"), this["cursor"]["addClass"]("cursor designerPointer"), this["cursor"]["css"]({
      width: this["brushSize"],
      height: this["brushSize"]
    }), this["content"].find(".brushPreview")["append"](this["cursor"]);
    var _0x1c0c0f = this;
    this["content"]["find"]("div[name=\"dropBrush\"]").on("dragover dragenter", function (_0xf8f7ce) {
      _0xf8f7ce.preventDefault(), _0xf8f7ce.stopPropagation(), $(this)["css"]("border", "2px solid red");
    }), this["content"].find("div[name=\"dropBrush\"]").on("dragleave", function (_0x507055) {
      _0x507055["preventDefault"](), _0x507055["stopPropagation"](), $(this)["css"]("border", "2px solid #505050");
    }), this["content"].find("div[name=\"dropBrush\"]").on("drop", function (_0x2211c9) {
      _0x2211c9.preventDefault(), _0x2211c9["stopPropagation"](), $(this)["css"]("border", "2px solid #505050"), _0x1c0c0f["upload"](_0x2211c9["originalEvent"]["dataTransfer"]["files"][0]);
    });
  }
  ["upload"](_0xc3678d) {
    var _0x3bc155 = this,
      _0x2e2a4a = _0xc3678d,
      _0x1fa181 = new FileReader();
    _0x1fa181.onloadend = function (_0x3a149f) {
      _0x3bc155.brush["clear"](), _0x3bc155["brush"].putData(_0x3a149f["target"]["result"], 0, 0, _0x3bc155["canvasSize"], _0x3bc155["canvasSize"]);
    }, _0x2e2a4a && _0x1fa181["readAsDataURL"](_0x2e2a4a);
  }
  ["loadContent"](_0x3e7add) {
    var _0x386e33 = this;
    this["content"].html(_0x3e7add), $(this.content)["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    }), this.content["find"](".brushPreview")["append"](this["slate"]["canvas"]).append(this.brush["canvas"]);
    var _0x26b6dd = this["brush"].getContext(),
      _0xc8bff9 = this.slate.getContext();
    this["sliderSize"] = new Slider(this["content"]["find"]("#designerSize"), 1, 40, 1), this["sliderSize"]["setValue"](5), $(this.sliderSize).on("sliderChanged", function (_0x21bba4) {
      _0x386e33["brushSize"] = _0x21bba4.value, _0x386e33.cursor["css"]({
        width: _0x386e33["brushSize"],
        height: _0x386e33.brushSize
      });
    }), this.sliderAlpha = new Slider(this["content"].find("#designerAlpha"), 0, 1, 0.1, zeroToOnePercentage), this.sliderAlpha["setValue"](1), $(this["sliderAlpha"]).on("sliderChanged", function (_0x43255c) {
      _0x386e33["brushAlpha"] = _0x43255c["value"];
    }), this["colorSelector"] = new ColorSelector(this["content"]["find"]("#designerColor"), "#000000"), $(this.colorSelector).on("colorChanged", function (_0x2b7fed) {
      _0x386e33["brushColor"] = _0x2b7fed["color"];
    }), this["content"]["find"]("#designerColor").on("click", function (_0x465671) {
      _0x465671["preventDefault"](), UI["colorDialog"]["show"](_0x386e33["brushColor"]);
    }), this["changeScale"](this.designerScale), this["content"]["find"](".brushPreview").on("wheel", function (_0x1bbfac) {
      _0x1bbfac["preventDefault"](), _0x1bbfac["originalEvent"]["deltaY"] < 0 ? _0x386e33["sliderSize"]["increase"]() : _0x386e33.sliderSize["decrease"]();
    }), this["content"]["find"](".designerBrush").on(UI.pointerEvent("click"), function (_0x13b006) {
      _0x13b006.preventDefault(), _0x386e33["selectBrush"]($(this)["attr"]("name"));
    }), this["content"]["find"](".designerOption").on(UI["pointerEvent"]("click"), function (_0x59ec20) {
      _0x59ec20.preventDefault();
      var _0x251b1a = $(this)["attr"]("name");
      if (_0x251b1a == "clear") _0x386e33["brush"]["clear"](); else {
        if (_0x251b1a == "load") _0x386e33["form"]["find"]("input[name=\"uploadBrush\"]").click(); else {
          if (_0x251b1a == "save") _0x386e33["save"](); else {
            if (_0x251b1a == "zoomin") _0x386e33["changeScale"](_0x386e33["designerScale"] + 0.1); else {
              if (_0x251b1a == "zoomout") _0x386e33["changeScale"](_0x386e33["designerScale"] - 0.1); else _0x251b1a == "center" && _0x386e33["centerCanvas"]();
            }
          }
        }
      }
      $(_0x59ec20.target)["blur"]();
    }), $(document).on(UI.pointerEvent("up"), function (_0x5a3da8) {
      if (_0x386e33["brushType"] == "picker") {
        var _0x30bcc9 = _0x386e33["brush"]["getContext"](),
          _0x399501 = _0x30bcc9["getImageData"](_0x386e33["cursorPos"].x, _0x386e33["cursorPos"].y, 1, 1)["data"];
        _0x386e33["colorSelector"].set(rgb2hex("rgba(" + _0x399501[0] + "," + _0x399501[1] + "," + _0x399501[2] + "," + _0x399501[3] / 255 + ")")), _0x386e33["cancelStroke"]();
      } else _0x386e33["drawing"] && (_0x386e33.drawing = false, _0x386e33["drawStroke"]());
      _0x386e33["canvasDragPoint"] = null;
    }), $(document).on(UI["pointerEvent"]("move"), function (_0xe1b70d) {
      var _0x40ae4c = UI["getInputPosition"](_0xe1b70d),
        _0x246acc = _0x386e33["content"]["find"](".brushPreview")["offset"]();
      if (_0x386e33["drawing"]) {
        var _0x200aa1 = $(_0x386e33["brush"].canvas).offset(),
          _0x3a5164 = new Point((_0x40ae4c.x - _0x200aa1["left"]) / _0x386e33.designerScale, (_0x40ae4c.y - _0x200aa1["top"]) / _0x386e33["designerScale"]);
        _0x386e33["clicks"]["push"](_0x3a5164);
        if (_0x386e33.brushType == "eraser") _0x386e33["clicks"]["push"](_0x386e33.from), _0x386e33["drawStroke"](); else _0x386e33.brushType == "picker" ? _0x386e33["cursorPos"] = new Point(_0x3a5164.x, _0x3a5164.y) : (_0xc8bff9.lineTo(_0x3a5164.x, _0x3a5164.y), _0xc8bff9.stroke());
        _0x386e33["from"] = _0x3a5164;
      } else _0x386e33["canvasDragPoint"] && _0x386e33.moveCanvas((_0x40ae4c.x - _0x246acc.left) / _0x386e33["designerScale"] - _0x386e33["canvasDragPoint"].x, (_0x40ae4c.y - _0x246acc["top"]) / _0x386e33["designerScale"] - _0x386e33["canvasDragPoint"].y);
      var _0x3a5164 = new Point((_0x40ae4c.x - _0x246acc["left"]) / _0x386e33["designerScale"], (_0x40ae4c.y - _0x246acc["top"]) / _0x386e33.designerScale);
      _0x386e33["cursor"]["css"]({
        top: _0x3a5164.y,
        left: _0x3a5164.x
      });
    }), $(this["slate"]["canvas"]).contextmenu(function (_0x372075) {
      _0x372075["preventDefault"](), _0x386e33["cancelStroke"]();
    }), $(this["slate"]["canvas"]).on(UI["pointerEvent"]("down"), function (_0x366b66) {
      if (!_0x366b66["which"] || _0x366b66["which"] == 1) {
        var _0x1d595d = $(_0x386e33["brush"]["canvas"])["offset"](),
          _0x54dad3 = UI["getInputPosition"](_0x366b66);
        if (_0x386e33.brushType == "drag") {
          var _0x3713b6 = _0x386e33.brush["canvas"][0].getBoundingClientRect();
          _0x386e33.canvasDragPoint = new Point((_0x54dad3.x - _0x3713b6.left) / _0x386e33["designerScale"], (_0x54dad3.y - _0x3713b6["top"]) / _0x386e33["designerScale"]);
        } else {
          _0x386e33["drawing"] = true, _0x386e33["from"] = new Point((_0x54dad3.x - _0x1d595d["left"]) / _0x386e33.designerScale, (_0x54dad3.y - _0x1d595d.top) / _0x386e33.designerScale), _0x386e33["clicks"]["push"](_0x386e33["from"]);
          if (_0x386e33.brushType == "eraser") _0x386e33["drawStroke"](); else _0x386e33.brushType == "picker" ? _0x386e33.cursorPos = _0x386e33["from"] : (_0x386e33["slate"].setCanvasProperties({
            linejoin: "round",
            linecap: "round",
            linewidth: _0x386e33["brushSize"],
            strokestyle: _0x386e33["brushColor"],
            alpha: 1,
            blendmode: "normal",
            blur: 0,
            linedash: []
          }), _0x386e33.slate.setCSSProperties({
            alpha: _0x386e33["brushAlpha"]
          }), _0xc8bff9["beginPath"](), _0xc8bff9.moveTo(_0x386e33["from"].x, _0x386e33["from"].y));
        }
      }
    }), this["form"]["find"]("a[name=\"ok\"]").on(UI["pointerEvent"]("click"), function (_0x1dfb1e) {
      _0x1dfb1e["preventDefault"]();
      var _0x3349ba = UI["brushDesignerDialog"]["brush"]["getData"]();
      UI["setCustomBrush"](_0x3349ba), _0x386e33["hide"]();
    }), this["form"].find("a[name=\"cancel\"]").on(UI["pointerEvent"]("click"), function (_0x2b4e5f) {
      _0x2b4e5f["preventDefault"](), _0x386e33["hide"]();
    }), this.form["find"]("input[name=\"uploadBrush\"]").on("change", function (_0x2502fb) {
      _0x386e33["upload"](_0x2502fb["target"].files[0]), _0x386e33["form"].find("input[name=\"uploadBrush\"]")["val"]("");
    });
  }
  ["selectBrush"](_0x27f3fc) {
    this["brushType"] = _0x27f3fc, this["content"]["find"](".selected").removeClass("selected"), this["content"]["find"]("a.designerBrush[name=\"" + _0x27f3fc + '"]')["addClass"]("selected");
    var _0x5dc4d9 = this["content"]["find"](".brushPreview");
    if (_0x27f3fc == "drag") _0x5dc4d9.css("cursor", "grab"), _0x5dc4d9.find(".cursor")["hide"](); else _0x27f3fc == "picker" ? (_0x5dc4d9["css"]("cursor", "crosshair"), _0x5dc4d9["find"](".cursor")["hide"]()) : (_0x5dc4d9.css("cursor", "none"), _0x5dc4d9.find(".cursor").show());
  }
  ["cancelStroke"]() {
    this["drawing"] = false, this["slate"]["clear"](), this.clicks = new Array();
  }
  ["drawStroke"]() {
    if (this["clicks"]["length"] > 0) {
      var _0x38e478 = this["brush"]["getContext"]();
      this["slate"]["clear"](), this["brush"]["setCanvasProperties"]({
        linejoin: "round",
        linecap: "round",
        linewidth: this["brushSize"],
        strokestyle: this["brushColor"],
        alpha: this["brushAlpha"],
        blendmode: this["brushType"] == "eraser" ? "destination-out" : "normal",
        blur: 0,
        linedash: []
      }), _0x38e478.beginPath(), _0x38e478["moveTo"](this.clicks[0].x, this["clicks"][0].y);
      for (var _0x506042 = 0; _0x506042 < this.clicks["length"]; _0x506042++) {
        _0x38e478["lineTo"](this["clicks"][_0x506042].x, this.clicks[_0x506042].y);
      }
      _0x38e478["stroke"](), this.clicks = new Array();
    }
  }
  ["moveCanvas"](_0x4b5cf5, _0x578c54) {
    this["content"]["find"](".brushPreview canvas")["css"]({
      left: _0x4b5cf5 + "px",
      top: _0x578c54 + "px"
    });
  }
  ["changeScale"](_0x3d0fca) {
    this["designerScale"] = _0x3d0fca, this.content["find"](".brushPreview")["css"]({
      transform: "translateZ(0) scale(" + _0x3d0fca + ", " + _0x3d0fca + ")",
      "transform-origin": "top left"
    }), this["content"]["find"]("span[name=\"zoom\"]")["text"](parseInt(100 * _0x3d0fca) + "%"), this["centerCanvas"]();
  }
  ["save"]() {
    var _0x4ac530 = this["brush"]["getContext"](),
      _0x30ef7e = _0x4ac530["getImageData"](0, 0, _0x4ac530["canvas"].width, _0x4ac530["canvas"]["height"]);
    UI.saveDialog.show("custom", [_0x30ef7e]);
  }
  ["centerCanvas"]() {
    let _0x7613da = this["content"]["find"](".brushPreview")["parent"]()["width"](),
      _0x3a4a98 = this["content"]["find"](".brushPreview")["parent"]()["height"]();
    this["moveCanvas"]((_0x7613da / 2 - this["canvasSize"] * this.designerScale / 2) / this["designerScale"], (_0x3a4a98 / 2 - this["canvasSize"] * this["designerScale"] / 2) / this["designerScale"]);
  }
  ["setImage"](_0x40ed38) {
    _0x40ed38 != null && (this["brush"]["clear"](), this["brush"]["putData"](_0x40ed38));
  }
  ["previewCanvas"](_0x506e59) {
    this.brush["clear"](), this["brush"]["drawImage"](_0x506e59, 0, 0, this["canvasSize"], this["canvasSize"]);
  }
  ["onShow"]() {
    this["changed"](), this.centerCanvas();
  }
  ["onResize"]() {
    this["centerCanvas"]();
  }
}
class BrushGalleryDialog extends Dialog {
  constructor(_0x38a621) {
    super(_0x38a621), this["icon"] = "fa-th-list", this["caption"] = textManager["getString"]("brushgallery.title"), this["canvasScale"] = 80, this["canvasSize"] = 140, this.brushesDir = "brushes/custom/", this["width"] = 690, this["loadContent"](this.loadFile("forms/brushgallery.main.html"));
    var _0x361be4 = this;
    this["content"].on(UI["pointerEvent"]("click"), ".brush a", function (_0x4dbdce) {
      _0x4dbdce["preventDefault"](), _0x361be4.content["find"](".brush.selected").removeClass("selected"), $(this)["parent"]()["addClass"]("selected");
    }), this["content"].on(UI["pointerEvent"]("dblclick"), ".brush a", function (_0x2e68f4) {
      _0x2e68f4["preventDefault"](), _0x361be4["loadBrush"](), _0x361be4["hide"]();
    }), this["form"].find('a[name="ok"]').on(UI.pointerEvent("click"), function (_0x3c37a1) {
      _0x3c37a1["preventDefault"](), _0x361be4["loadBrush"](), _0x361be4["hide"]();
    }), this["form"]["find"]('a[name="cancel"]').on(UI["pointerEvent"]("click"), function (_0x1bbce0) {
      _0x1bbce0["preventDefault"](), _0x361be4.hide();
    });
  }
  ["initialize"]() {
    this["initialized"] = true, this.brushes = this["loadFile"](this["brushesDir"] + "brushes.json");
    var _0x1c4d6b = this;
    this["scroll"] && this["scroll"]["destroy"](), this["content"].find("div.brushGalleryArea").empty(), $["each"](this["brushes"], function (_0x5849d4, _0x3b0554) {
      _0x1c4d6b.content["find"]("div.brushGalleryArea")["append"]('<div class="brush" data-tooltip="<strong>' + _0x3b0554["description"] + "</strong><br />" + textManager["getString"]("brushgallery.lblBy", _0x3b0554["author"], false) + '"><a href="#"><img style="width: ' + _0x1c4d6b["canvasSize"] * _0x1c4d6b["canvasScale"] / 100 + "px; height: " + _0x1c4d6b["canvasSize"] * _0x1c4d6b["canvasScale"] / 100 + "px;\" class=\"transparentBG\" loading=\"lazy\" src=\"" + UI["baseDir"] + _0x1c4d6b["brushesDir"] + _0x3b0554.file + "\" /></a></div>");
    }), this["scroll"] = this["content"]["find"](".brushGalleryArea")["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    })["overlayScrollbars"]();
  }
  ["loadBrush"]() {
    if (this["content"]["find"](".brush.selected")["length"] == 1) {
      var _0x23d200 = new AdvancedCanvas(this["canvasSize"], this["canvasSize"]);
      _0x23d200["drawImage"](this["content"].find(".brush.selected a img")[0]), UI["setCustomBrush"](_0x23d200["getData"]()), _0x23d200["remove"]();
    }
  }
  ["loadContent"](_0x5416f0) {
    this["content"]["html"](_0x5416f0);
  }
  ["onShow"]() {
    !this["initialized"] && this["initialize"](), this["changed"]();
  }
}
class DebugDialog extends Dialog {
  constructor(_0x9bcf67) {
    super(_0x9bcf67), this["name"], this["width"] = 620, this["icon"] = "fa-bug", this["caption"] = textManager["getString"]("debug.title"), this["loadContent"](this.loadFile("forms/debug.main.html")), this["table"] = new Table(this["content"]["find"]("#debugTable"), null, "debugTable", "fmTable"), this["table"]["setFilterable"](true), this["table"]["setHeader"](["Parameter", "Value"]), this["table"]["selectable"] = false, this["table"]["headerCaption"](1, textManager.getString("debug.rowParameter")), this.table["headerCaption"](2, textManager.getString("debug.rowValue"));
    var _0x346eb0 = this;
    $(this).on("dialogResizingEnded dialogMaximized dialogRestored", function (_0x4593b7) {
      _0x346eb0["table"] && _0x346eb0.table["updated"]();
    });
  }
  ["loadContent"](_0x2ce764) {
    this["content"].html(_0x2ce764), $(this["content"]).overlayScrollbars({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    });
  }
  ["onShow"]() {
    this["changed"](), this["table"]["updated"]();
  }
  ["onHide"]() {
    this["table"]["reset"](), this["table"].setHeader(["Parameter", "Value"]);
  }
}
class UserGalleryDialog extends Dialog {
  constructor(_0x4f405d) {
    super(_0x4f405d), this["name"], this["width"] = 770, this["target"], this.pagination, this["scroll"], this["icon"] = "fa-image", this["caption"] = textManager["getString"]("usergallery.title"), this["loadContent"](this.loadFile("forms/usergallery.main.html"));
  }
  ["loadContent"](_0x5730a1) {
    this["content"]["html"](_0x5730a1), this["content"]["find"]("#profileGallery").on(UI["pointerEvent"]("click"), "img", function (_0x1295bb) {
      _0x1295bb.preventDefault(), UI["galleryImageDialog"]["show"]($(_0x1295bb.target).attr("name"));
    }), this["pagination"] = new Pagination(this["content"].find("#galleryPages")), this["content"]["find"]("#galleryPages")["hide"]();
    var _0x3719c9 = this;
    $(this["pagination"]).on("pageSelected", function (_0x437f8c) {
      _0x3719c9["requestGalleryPage"](_0x437f8c["page"]);
    }), this["scroll"] = this["content"]["find"]("#profileGallery").overlayScrollbars({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    })["overlayScrollbars"](), this.scroll["addExt"]("fmExtension"), this["requestGalleryPage"](1);
  }
  ["galleryImages"](_0x18b4c6, _0x4880e2, _0x105fa4) {
    this["target"] = _0x18b4c6, this.content["find"]("h4.galleryTitle")["text"](textManager["getString"]("usergallery.lblGalleryTitle", this["target"]["username"], false)), this["content"]["find"]("#profileGallery div[name=\"images\"]").empty(), this["pagination"]["update"](_0x4880e2);
    _0x4880e2 > 1 && this.content.find("#galleryPages")["fadeIn"](800);
    var _0x1fcd03 = this;
    $(_0x105fa4).each(function (_0x36b518, _0x5b36f6) {
      var _0x595032 = new Image();
      _0x595032["src"] = _0x5b36f6["thumb"];
      var _0x54058a = Math.round(_0x5b36f6.width * 100 / _0x5b36f6.height);
      $(_0x595032)["css"]({
        width: _0x54058a + "px"
      }), $(_0x595032).attr("name", _0x5b36f6.id), _0x1fcd03["content"]["find"]("#profileGallery div[name=\"images\"]").append(_0x595032);
    }), this.scroll["scroll"]({
      y: 0
    }), this["loading"](false), this["changed"]();
  }
  ["requestGalleryPage"](_0x1b91fb) {
    if (this["target"]) {
      this["loading"](true);
      var _0x12a58 = {};
      _0x12a58.command = "USERREQUEST", _0x12a58.action = "UserGallery", this["target"]["uid"] ? _0x12a58.uid = this["target"]["uid"] : _0x12a58["username"] = this["target"]["username"], _0x12a58.page = _0x1b91fb, socket["send"](_0x12a58, true);
    }
  }
  ["onShow"](_0x3dd44a) {
    this["target"] = _0x3dd44a, this["requestGalleryPage"](1);
  }
  ["onHide"]() {
    this["content"]["find"]("h4.galleryTitle")["text"](""), this["content"].find("#profileGallery div[name=\"images\"]")["empty"](), this["pagination"].setPage(1);
  }
}
class ProfileDialog extends Dialog {
  constructor(_0x39495d) {
    super(_0x39495d), this["width"] = 850, this["table"], this["icon"] = "fa-user-tie", this["caption"] = textManager["getString"]("profile.title"), this["loadContent"](this["loadFile"]("forms/profile.main.html"));
    var _0x1b379f = this;
    this["content"].on(UI.pointerEvent("click"), ".subcontentOption", function (_0x2e76f4) {
      _0x2e76f4["preventDefault"]();
      var _0x27635 = $(this)["data"]("subcontent");
      _0x1b379f["loadPage"](_0x27635);
    }), $(this).on("dialogResizingEnded dialogMaximized dialogRestored", function (_0x335461) {
      _0x1b379f["table"] && _0x1b379f.table["updated"]();
    }), this["content"].on(UI["pointerEvent"]("click"), "#confirmUsername", function (_0x58c8f0) {
      _0x58c8f0["preventDefault"](), _0x1b379f["changeAccount"]();
    }), this["content"].on("keydown", "input[type=\"text\"], input[type=\"password\"]", function (_0x3f3eb0) {
      _0x3f3eb0.which == 13 && _0x1b379f["modal"].is(":visible") && (_0x3f3eb0.preventDefault(), _0x1b379f.changeAccount());
    }), this["content"].on("keydown", ".usernameAccount", function (_0x399d83) {
      let _0x989cfb = _0x399d83["which"] || _0x399d83["keyCode"],
        _0x87014e = String["fromCharCode"](_0x989cfb);
      if (_0x989cfb == 32 || _0x87014e == "<" || _0x87014e == ">" || _0x87014e == "'" || _0x87014e == '"' || _0x87014e == "/") return _0x399d83["stopPropagation"](), _0x399d83["preventDefault"](), false;
    });
  }
  ["loadContent"](_0x1b2828) {
    this["content"]["html"](_0x1b2828);
  }
  ["loadSubcontent"](_0x5dea70) {
    this.content.find(".dynamicDialogArea").html(_0x5dea70);
  }
  ["loadPage"](_0x417f66) {
    var _0x3bd136 = this;
    if (_0x417f66 !== undefined) {
      this["content"]["find"](".subcontentOption.selected")["removeClass"]("selected"), this.content.find(".subcontentOption[data-subcontent=" + _0x417f66 + "]")["addClass"]("selected"), this["loading"](true);
      if (_0x417f66 == "info") this["loadSubcontent"](this["loadFile"]("forms/profile.info.html")), this["content"]["find"]("input[name=\"username\"]")["val"](room["myself"]["username"]), this.content["find"]('input[name="status"]')["val"](room["myself"].status), this["content"]["find"]("input[name=\"status\"]")["focus"](), this.content["find"]("#applyProfile").on(UI["pointerEvent"]("click"), function (_0x592930) {
        _0x592930["preventDefault"](), room["myself"]["changeStatus"](_0x3bd136["content"]["find"]('input[name="status"]').val());
      }), this["content"].on(UI["pointerEvent"]("click"), "#clearStatus", function (_0x33a29b) {
        _0x33a29b.preventDefault(), _0x3bd136["content"]["find"]("input[name=\"status\"]").val("");
      }), this["content"].on(UI.pointerEvent("click"), "#changeUsername", function (_0x1ff783) {
        _0x1ff783["preventDefault"](), _0x3bd136["enableModal"](_0x3bd136["loadFile"]("forms/profile.modal.changeusername.html")), _0x3bd136.content.find("input[name=\"newUsername\"]")["focus"](), _0x3bd136["content"].find("input[name=\"newUsername\"]").val(UI["account"].username), _0x3bd136["content"]["find"]("input[name=\"newPassword\"]")["val"](UI["account"].password);
      }), this["scroll"] = this["content"]["find"](".dialogContentArea")["overlayScrollbars"]({
        className: "os-theme-light",
        overflowBehavior: {
          x: "hidden"
        }
      })["overlayScrollbars"](), this.scroll["addExt"]("fmExtension"), this["loading"](false), this.changed(); else {
        if (_0x417f66 == "rooms") {
          this["loadSubcontent"](this["loadFile"]("forms/profile.rooms.html")), this["loading"](true);
          var _0x1b575e = {};
          _0x1b575e["command"] = "USERREQUEST", _0x1b575e["action"] = "OwnedRooms", socket["send"](_0x1b575e, true);
        } else {
          if (_0x417f66 == "ranks") {
            this.loadSubcontent(this["loadFile"]("forms/profile.ranks.html")), this["loading"](true);
            var _0x1b575e = {};
            _0x1b575e.command = "USERREQUEST", _0x1b575e["action"] = "RoomRanks", socket["send"](_0x1b575e, true);
          }
        }
      }
      this["processSizeType"](this.sizeType);
    }
  }
  ["changeAccount"]() {
    var _0x64bf01 = {};
    _0x64bf01["command"] = "USERFUNCTIONS", _0x64bf01.option = "RELOG", _0x64bf01["username"] = this["content"]["find"]("input[name=\"newUsername\"]")["val"](), _0x64bf01["password"] = this.content.find("input[name=\"newPassword\"]")["val"](), socket["send"](_0x64bf01, true), this["content"]["find"]("input[name=\"username\"]").val(this["content"].find("input[name=\"newUsername\"]").val()), UI["account"].change(_0x64bf01["username"], _0x64bf01["password"]), this["content"]["find"]("input[name=\"newUsername\"]")["val"](""), this["content"]["find"]('input[name="newPassword"]')["val"](""), this["disableModal"]();
  }
  ["ownedRoomsList"](_0x451498) {
    var _0x546c6c = this.content["find"]("#ownedRoomsContent");
    _0x546c6c["empty"]();
    var _0x2b0bc3 = new Table(_0x546c6c, null, "profileRoomsTable", "fmTable");
    _0x2b0bc3.selectable = false, _0x2b0bc3["clear"](), _0x2b0bc3["setHeader"](["Room"]), _0x2b0bc3["headerCaption"](1, textManager["getString"]("profile.rooms.rowRoom"));
    var _0x5f5dbb = this;
    $["each"](_0x451498, function (_0x24f679, _0x62ee0c) {
      _0x2b0bc3.addRow([_0x62ee0c], false);
    }), this["loading"](false), this["changed"](), _0x2b0bc3["updated"](), this["table"] = _0x2b0bc3;
  }
  ["roomRankList"](_0x394882) {
    var _0x588223 = this.content.find("#roomRanksContent");
    _0x588223["empty"]();
    var _0x2da4f3 = new Table(_0x588223, null, "profileRanksTable", "fmTable");
    _0x2da4f3["selectable"] = false, _0x2da4f3["clear"](), _0x2da4f3["setHeader"](["Room", "Rank"]), _0x2da4f3.headerCaption(1, textManager["getString"]("profile.ranks.rowRoom")), _0x2da4f3.headerCaption(2, textManager["getString"]("profile.ranks.rowRank"));
    var _0x41000e = this;
    $["each"](_0x394882, function (_0x3f98d5, _0x14995f) {
      var _0x461db8 = "<span class=\"" + UI["rankToStyle"](_0x14995f["rank"]) + '">' + UI.userRank(_0x14995f["rank"]) + "</span>";
      _0x2da4f3["addRow"]([_0x14995f["name"], _0x461db8], false);
    }), this["loading"](false), this["changed"](), _0x2da4f3.updated(), this.table = _0x2da4f3;
  }
  ["clearSubcontent"]() {
    this["content"].find(".dynamicDialogArea").empty();
  }
  ["checkAccountType"]() {
    room.myself.rank == "UU" ? (this["content"]["find"]("a.subcontentOption[data-subcontent=\"rooms\"]").parent()["hide"](), this["content"]["find"]("a.subcontentOption[data-subcontent=\"ranks\"]").parent()["hide"]()) : (this.content.find("a.subcontentOption[data-subcontent=\"rooms\"]")["parent"]()["show"](), this.content.find("a.subcontentOption[data-subcontent=\"ranks\"]")["parent"]()["show"]());
  }
  ["onShow"]() {
    this.loadPage("info"), this["content"]["find"](".sidebar")["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    }), this["checkAccountType"]();
  }
  ["onHide"]() {
    this.clearSubcontent(), this["table"] && this["table"]["reset"]();
  }
}
class ColorDialog extends Dialog {
  constructor(_0xffbdbc) {
    super(_0xffbdbc), this.icon = "fa-palette", this["caption"] = textManager["getString"]("color.title"), this["width"] = 800, this["height"] = 485, this["loadContent"](this["loadFile"]("forms/color.main.html")), this["color"], this["setupMode"] = false, this["colorR"] = new Slider(this["content"]["find"]("div[name=\"cred\"]"), 0, 255, 1), this["colorG"] = new Slider(this["content"]["find"]("div[name=\"cgreen\"]"), 0, 255, 1), this["colorB"] = new Slider(this["content"]["find"]("div[name=\"cblue\"]"), 0, 255, 1), this["colorH"] = new Slider(this["content"]["find"]('div[name="chue"]'), 0, 360, 1), this["colorS"] = new Slider(this.content["find"]("div[name=\"csaturation\"]"), 0, 100, 1), this["colorV"] = new Slider(this["content"].find("div[name=\"cvalue\"]"), 0, 100, 1), this["colorBubbles"] = new ColorGrid("colordialog", this["content"]["find"](".colorBubbles"), 84, storage);
    var _0x2de098 = this;
    this["colorWheel"] = new ColorWheel(this["content"]["find"](".newColorWheel"), false), $(this["colorWheel"]).on("colorChanged", function (_0x1ed14a) {
      _0x2de098.changeColor(_0x1ed14a["color"]);
    }), $(this["colorBubbles"]).on("bubbleClicked", function (_0x3dedf5) {
      if (_0x3dedf5["etype"] == "load") _0x2de098["changeColor"](_0x3dedf5["obj"]["color"]); else {
        if (_0x3dedf5["etype"] == "save") {
          var _0x2ffb18 = new ColorBubble(_0x2de098["color"]);
          _0x2de098.colorBubbles["saveBubble"](_0x2ffb18, _0x3dedf5.number);
        }
      }
      _0x2de098["content"]["find"]('input[name="hex"]').focus();
    }), this["content"].find("a[name=\"okButton\"]").on(UI["pointerEvent"]("click"), function (_0x1b6c12) {
      _0x1b6c12["preventDefault"](), _0x2de098["confirm"](), _0x2de098["hide"]();
    }), this["content"]["find"]("input[name=\"hex\"]").on("keyup", function (_0x16341d) {
      !_0x2de098["setupMode"] && isHexColor($(this).val()) && _0x2de098["changeColor"]("#" + $(this).val());
    }), this["content"].find('input[name="hex"]').on("keydown", function (_0x430c6a) {
      _0x430c6a["which"] == 13 && (_0x430c6a["preventDefault"](), _0x2de098.confirm(), _0x2de098["hide"]());
    }), $(this["colorR"]).on("sliderMoved", function (_0x2ff3a6) {
      !_0x2de098["setupMode"] && _0x2de098["rgbSlidersChanged"](_0x2ff3a6["value"], null, null);
    }), $(this["colorG"]).on("sliderMoved", function (_0x489e0c) {
      !_0x2de098["setupMode"] && _0x2de098["rgbSlidersChanged"](null, _0x489e0c["value"], null);
    }), $(this["colorB"]).on("sliderMoved", function (_0x1ff7c8) {
      !_0x2de098["setupMode"] && _0x2de098["rgbSlidersChanged"](null, null, _0x1ff7c8["value"]);
    }), $(this.colorR).on("sliderChanged", function (_0x247906) {
      !_0x2de098["setupMode"] && _0x2de098["rgbSlidersChanged"]();
    }), $(this["colorG"]).on("sliderChanged", function (_0x745603) {
      !_0x2de098["setupMode"] && _0x2de098["rgbSlidersChanged"]();
    }), $(this["colorB"]).on("sliderChanged", function (_0xd041d4) {
      !_0x2de098.setupMode && _0x2de098.rgbSlidersChanged();
    }), $(this.colorH).on("sliderMoved", function (_0xd08c6e) {
      !_0x2de098.setupMode && _0x2de098["hsvSlidersChanged"](_0xd08c6e["value"], null, null);
    }), $(this.colorS).on("sliderMoved", function (_0x3f39dc) {
      !_0x2de098["setupMode"] && _0x2de098.hsvSlidersChanged(null, _0x3f39dc["value"], null);
    }), $(this["colorV"]).on("sliderMoved", function (_0x5a23e9) {
      !_0x2de098["setupMode"] && _0x2de098.hsvSlidersChanged(null, null, _0x5a23e9["value"]);
    }), $(this["colorH"]).on("sliderChanged", function (_0x1719de) {
      !_0x2de098["setupMode"] && _0x2de098.hsvSlidersChanged();
    }), $(this["colorS"]).on("sliderChanged", function (_0x81238) {
      !_0x2de098["setupMode"] && _0x2de098["hsvSlidersChanged"]();
    }), $(this["colorV"]).on("sliderChanged", function (_0x46da9e) {
      !_0x2de098["setupMode"] && _0x2de098["hsvSlidersChanged"]();
    });
  }
  ["loadContent"](_0x505133) {
    this.content["html"](_0x505133), $(this["content"]["find"](".rightSide")).overlayScrollbars({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    });
  }
  ["rgbSlidersChanged"](_0x2eabef = null, _0x5147f4 = null, _0x257249 = null) {
    var _0x270d23 = _0x2eabef == null ? this["colorR"]["getValue"]() : _0x2eabef,
      _0x53f93f = _0x5147f4 == null ? this["colorG"]["getValue"]() : _0x5147f4,
      _0x1781e2 = _0x257249 == null ? this["colorB"]["getValue"]() : _0x257249;
    this["setColor"]("rgb(" + _0x270d23 + "," + _0x53f93f + "," + _0x1781e2 + ")");
    var _0x4c6675 = rgb2hsv(_0x270d23, _0x53f93f, _0x1781e2);
    this.setupMode = true, this["colorH"]["setValue"](parseInt(_0x4c6675.h)), this.colorS.setValue(parseInt(_0x4c6675.s)), this["colorV"].setValue(parseInt(_0x4c6675.v)), this["setupMode"] = false;
  }
  ["hsvSlidersChanged"](_0x2ce626 = null, _0x5dd6a4 = null, _0x6965f6 = null) {
    var _0x29d7eb = _0x2ce626 == null ? this["colorH"].getValue() : _0x2ce626,
      _0x5de419 = _0x5dd6a4 == null ? this["colorS"]["getValue"]() : _0x5dd6a4,
      _0x21d1fd = _0x6965f6 == null ? this["colorV"]["getValue"]() : _0x6965f6,
      _0xc915a9 = hsv2rgb(_0x29d7eb, _0x5de419, _0x21d1fd);
    this["setColor"]("rgb(" + _0xc915a9.r + "," + _0xc915a9.g + "," + _0xc915a9.b + ")"), this["setupMode"] = true, this["colorR"].setValue(_0xc915a9.r), this["colorG"]["setValue"](_0xc915a9.g), this["colorB"]["setValue"](_0xc915a9.b), this.setupMode = false;
  }
  ["changeColor"](_0x2204b8) {
    this["setupMode"] = true;
    var _0x546b78;
    _0x2204b8[0] == "#" ? _0x546b78 = hex2rgb(_0x2204b8) : _0x546b78 = rgb2obj(_0x2204b8);
    this["setColor"]("rgb(" + _0x546b78.r + "," + _0x546b78.g + "," + _0x546b78.b + ")");
    if (_0x546b78) {
      this["colorR"]["setValue"](_0x546b78.r), this.colorG["setValue"](_0x546b78.g), this.colorB["setValue"](_0x546b78.b);
      var _0x5677db = rgb2hsv(_0x546b78.r, _0x546b78.g, _0x546b78.b);
      _0x5677db && (this["colorH"].setValue(parseInt(_0x5677db.h)), this["colorS"]["setValue"](parseInt(_0x5677db.s)), this["colorV"]["setValue"](parseInt(_0x5677db.v)));
    }
    this["setupMode"] = false;
  }
  ["setColor"](_0x3f1a95) {
    this["color"] = _0x3f1a95, this.content["find"]("div[name=\"currentColor\"]")["css"]("background-color", _0x3f1a95), _0x3f1a95[0] != "#" && (_0x3f1a95 = rgb2hex(_0x3f1a95)), this["content"]["find"]("input[name=\"hex\"]")["val"](_0x3f1a95["substr"](1)), this["colorWheel"].setColor(_0x3f1a95);
  }
  ["confirm"]() {
    $(this)["triggerHandler"](new colorChangedEvent(this["color"])["getEvent"]());
  }
  ["onShow"](_0x2f985c = null) {
    _0x2f985c && this["changeColor"](_0x2f985c), this.content["find"]("input[name=\"hex\"]").focus();
  }
}
const config = {
  dialog: {
      icon: "fa-cogs",
      caption: "Mods",
      width: 650,
      height: 650,
  },
  timers: {
      roomUpdateInterval: 1000,
      drawingCheckInterval: 100,
  },
  defaultValues: {
      room: "Lobby Browser",
  },
  localStorageKeys: {
      roomTimeData: "roomTimeData",
      drawingTimeData: "drawingTimeData",
      blockedUsers: "blockedUsers",
      enableSmoothing: "enableSmoothing",
      mouseWheelMode: "mouseWheelMode",
      enable1000PressureLevels: "enable1000PressureLevels",
      maxOpacitySize: "maxOpacitySize",
      opacityChangeThreshold: "opacityChangeThreshold",
      bypassDenied101: "bypassDenied101",
      mirroredText: "mirroredText",
      positionAwareMirroring: "positionAwareMirroring",
      positionAwareRotation: "positionAwareRotation",
      resetPressureRelease: "resetPressureRelease",
      rmbActionFix: "rmbActionFix",
      smartOpacityCap: "smartOpacityCap",
      mouseModeEnabled: "mouseModeEnabled",
      persistentBoardSync: "persistentBoardSync",
      holdToPickColor: "holdToPickColor",
      reconnectAwareSync: "reconnectAwareSync",
      fixSelectionOptionsStuck: "fixSelectionOptionsStuck",
      fixResizingShift: "fixResizingShift",
      resizeRotationBugFix: "resizeRotationBugFix",
      instantReconnect: "instantReconnect",
      quickLaunch: "quickLaunch",
      unlimitedReconnect: "unlimitedReconnect",
      detectTrolling: "detectTrolling",
      trollSound: "trollSound",
      blurControl: "blurControl",
      keepTabAlive: "keepTabAlive",
      disableBlur: "disableBlur",
      preAntsResizing: "preAntsResizing",
      extendedBoardByDefault: "extendedBoardByDefault",
      smallerZoomStep: "smallerZoomStep",
      preciseZoomDisplay: "preciseZoomDisplay",
      skipSyncing: "skipSyncing",
      fixAutoScroll: "fixAutoScroll",
      fixCopyAction: "fixCopyAction",
      quickOpacityHotkeys: "quickOpacityHotkeys",
      csCursor: "csCursor",
      paintWithinSelection: "paintWithinSelection",
      lineInterpolation: "lineInterpolation",
      lineSnappingShift: "lineSnappingShift",
      brushCustomPressure: "brushCustomPressure",
      option20: "option20",
      option21: "option21",
      option22: "option22",
      option23: "option23",
      option24: "option24",
      option25: "option25",
      option26: "option26",
      option27: "option27",
      option28: "option28",
      option29: "option29",
      option30: "option30",
      // FlockModCoin currency system keys
      fmcBalance: "fmcBalance",
      fmcInitialDrawingTimeProcessed: "fmcInitialDrawingTimeProcessed",
      // Stock market keys
      fmcStockPortfolio: "fmcStockPortfolio",
      fmcStockTransactions: "fmcStockTransactions",
      dismissedIPTrackerInfo: "dismissedIPTrackerInfo",
      backgroundColor: "fmTweak_backgroundColor",
      backgroundColorEnabled: "fmTweak_backgroundColorEnabled"
  },
};
// StockMarketDB Helper - standalone IndexedDB implementation for stock market
const StockMarketDB = {
  dbName: 'StockMarketDatabase',
  version: 1,
  db: null,
  stores: {
    portfolio: 'portfolio',
    transactions: 'transactions',
    balance: 'balance'
  },
  
  async init() {
    if (this.db) return this.db;
    
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        // Create portfolio store if needed
        if (!db.objectStoreNames.contains(this.stores.portfolio)) {
          db.createObjectStore(this.stores.portfolio);
        }
        
        // Create transactions store with indices if needed
        if (!db.objectStoreNames.contains(this.stores.transactions)) {
          // Note: Using auto-increment with keyPath 'id'
          const txStore = db.createObjectStore(this.stores.transactions, { 
            keyPath: 'id', 
            autoIncrement: true 
          });
          txStore.createIndex('timestamp', 'timestamp', { unique: false });
          txStore.createIndex('symbol', 'symbol', { unique: false });
          txStore.createIndex('type', 'type', { unique: false });
          
          console.log('Created transactions store with schema');
        }
        
        // Create balance store if needed
        if (!db.objectStoreNames.contains(this.stores.balance)) {
          db.createObjectStore(this.stores.balance);
        }
      };
      
      request.onsuccess = (event) => {
        this.db = event.target.result;
        resolve(this.db);
      };
      
      request.onerror = (event) => {
        console.error('Error opening StockMarketDB:', event.target.error);
        reject(event.target.error);
      };
    });
  },
  
  // Portfolio operations
  async getPortfolio() {
    await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.stores.portfolio], 'readonly');
      const store = transaction.objectStore(this.stores.portfolio);
      const request = store.get('holdings');
      
      request.onsuccess = () => resolve(request.result || {});
      request.onerror = (event) => reject(event.target.error);
    });
  },
  
  async updatePortfolio(portfolio) {
    await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.stores.portfolio], 'readwrite');
      const store = transaction.objectStore(this.stores.portfolio);
      const request = store.put(portfolio, 'holdings');
      
      request.onsuccess = () => resolve();
      request.onerror = (event) => reject(event.target.error);
    });
  },
  
  // Balance operations
  async getBalance() {
    await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.stores.balance], 'readonly');
      const store = transaction.objectStore(this.stores.balance);
      const request = store.get('fmc');
      
      request.onsuccess = () => resolve(request.result || 0);
      request.onerror = (event) => reject(event.target.error);
    });
  },
  
  async updateBalance(amount) {
    await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.stores.balance], 'readwrite');
      const store = transaction.objectStore(this.stores.balance);
      const request = store.put(amount, 'fmc');
      
      request.onsuccess = () => resolve();
      request.onerror = (event) => reject(event.target.error);
    });
  },
  
  // Transaction operations
// Replace the StockMarketDB.addTransaction method with this version
async addTransaction(transaction) {
  await this.init();
  
  // Ensure timestamp is set
  if (!transaction.timestamp) {
    transaction.timestamp = Date.now();
  }
  
  return new Promise((resolve, reject) => {
    // Make sure we're using the correct store name
    const tx = this.db.transaction([this.stores.transactions], 'readwrite');
    const store = tx.objectStore(this.stores.transactions);
    
    // Add the transaction
    const request = store.add(transaction);
    
    request.onsuccess = () => resolve(request.result);
    
    request.onerror = (event) => {
      console.error('Error adding transaction:', event.target.error);
      console.error('Transaction data:', JSON.stringify(transaction));
      reject(event.target.error);
    };
    
    // Add transaction complete handler to catch any errors
    tx.oncomplete = () => console.log('Transaction added successfully');
    tx.onerror = (event) => {
      console.error('Transaction error:', event.target.error);
      reject(event.target.error);
    };
  });
},
  
// Replace the StockMarketDB.getTransactions method
async getTransactions() {
  await this.init();
  
  return new Promise((resolve, reject) => {
    try {
      const tx = this.db.transaction([this.stores.transactions], 'readonly');
      const store = tx.objectStore(this.stores.transactions);
      
      // Get all transactions
      const request = store.getAll();
      
      request.onsuccess = () => {
        const transactions = request.result || [];
        console.log(`Retrieved ${transactions.length} transactions`);
        resolve(transactions);
      };
      
      request.onerror = (event) => {
        console.error('Error retrieving transactions:', event.target.error);
        reject(event.target.error);
      };
    } catch (error) {
      console.error('Exception in getTransactions:', error);
      reject(error);
    }
  });
},
  
  async deleteTransaction(id) {
    await this.init();
    
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.stores.transactions], 'readwrite');
      const store = transaction.objectStore(this.stores.transactions);
      const request = store.delete(id);
      
      request.onsuccess = () => resolve();
      request.onerror = (event) => reject(event.target.error);
    });
  },
  
  // Data migration helper
  async migrateFromLocalStorage(keys) {
    await this.init();
    const migrated = localStorage.getItem('stockMarketDBMigrated');
    
    if (migrated === 'true') return;
    
    try {
      // Migrate portfolio data
      const portfolioStr = localStorage.getItem(keys.stockPortfolio);
      if (portfolioStr) {
        const portfolio = JSON.parse(portfolioStr);
        await this.updatePortfolio(portfolio);
      }
      
      // Migrate balance data
      const balanceStr = localStorage.getItem(keys.fmcBalance);
      if (balanceStr && !isNaN(parseFloat(balanceStr))) {
        const balance = parseFloat(balanceStr);
        await this.updateBalance(balance);
      }
      
      // Migrate transaction history
      const transactionsStr = localStorage.getItem(keys.stockTransactions);
      if (transactionsStr) {
        const transactions = JSON.parse(transactionsStr);
        for (const tx of transactions) {
          await this.addTransaction(tx);
        }
      }
      
      // Mark migration as complete
      localStorage.setItem('stockMarketDBMigrated', 'true');
      console.log('Stock market data successfully migrated from localStorage to IndexedDB');
    } catch (error) {
      console.error('Error migrating stock market data:', error);
    }
  }
};

// Then initialize it early to have it ready
StockMarketDB.init().catch(error => {
  console.error('Failed to initialize StockMarketDB:', error);
});

const IDBHelper = {
  dbName: 'IPStatsDatabase',
  storeName: 'KeyValueStore',
  dbVersion: 2,  // Updated from 1 to 2
  db: null,

  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName);
        }
      };
      request.onsuccess = (event) => {
        this.db = event.target.result;
        resolve();
      };
      request.onerror = (event) => reject(event);
    });
  },

  async setItem(key, value) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.put(value, key);
      request.onsuccess = () => resolve();
      request.onerror = (event) => reject(event);
    });
  },

  async getItem(key) {
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.get(key);
      request.onsuccess = () => resolve(request.result);
      request.onerror = (event) => reject(event);
    });
  }
};

// Modified IPTracker with performance improvements
const IPTracker = {
  statsKey: 'hierarchicalIPStats',
  // Tracking cache to reduce database reads/writes
  _statsCache: null,
  _lastWrite: 0,
  _writeInterval: 5000, // Write to DB every 5 seconds instead of every update

  async init() {
    await IDBHelper.init();
    this._statsCache = await this.initializeHierarchicalStructure();
    this.startTracking();
  },

  async _saveCurrentMonthToDb(year, month) {
    const now = Date.now();
    if (now - this._lastWrite < this._writeInterval) return; // Throttle
    
    this._lastWrite = now;
    const stats = this._statsCache;
    if (!stats || !stats.years[year] || !stats.years[year].months[month]) {
      return;
    }
  
    // Log structure size before saving
    const monthData = stats.years[year].months[month];
    const uniqueIPsCount = monthData.uniqueIPs.size;
    const daysCount = Object.keys(monthData.days || {}).length;
    
    const currentDay = new Date().getDate();
    const currentHour = new Date().getHours();
    
    // Check if today exists and has data
    if (monthData.days[currentDay]) {
      const todayIPsCount = monthData.days[currentDay].uniqueIPs.size;
      
      // Check current hour
      if (monthData.days[currentDay].hours[currentHour]) {
        const hourIPsCount = monthData.days[currentDay].hours[currentHour].uniqueIPs.size;
      } else {
      }
    } else {
    }
  
    // Convert only the relevant month's data
    const convertedMonth = JSON.parse(JSON.stringify(
      stats.years[year].months[month],
      (key, value) => value instanceof Set ? [...value] : value
    ));
  
    const key = `ipStats_${year}_${month}`;
    await IDBHelper.setItem(key, convertedMonth);
    
    // Debug: Log what was actually saved
  },
  
  _convertArraysToSetsMonth(monthData) {
    
    // Rebuild Sets in monthData
    monthData.uniqueIPs = new Set(monthData.uniqueIPs || []);
    Object.values(monthData.days || {}).forEach(dayData => {
      dayData.uniqueIPs = new Set(dayData.uniqueIPs || []);
      Object.values(dayData.hours || {}).forEach(hourData => {
        hourData.uniqueIPs = new Set(hourData.uniqueIPs || []);
      });
    });
    return monthData;
  },
  async initializeHierarchicalStructure() {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth() + 1;
    const day = now.getDate();
    const hour = now.getHours();
  
    // Build a minimal stats skeleton
    const stats = {
      years: {},
      current: { year, month, day, hour }
    };
    stats.years[year] = { months: {}, uniqueIPs: new Set(), peak: 0 };
  
    // Attempt to load the current month
    const key = `ipStats_${year}_${month}`;
    const existingMonth = await IDBHelper.getItem(key);
  
    if (existingMonth) {
      
      // Rebuild Sets
      const monthData = this._convertArraysToSetsMonth(existingMonth);
      stats.years[year].months[month] = monthData;
      
      // Ensure current day and hour structures exist
      if (!monthData.days[day]) {
        monthData.days[day] = { hours: {}, uniqueIPs: new Set(), peak: 0 };
      }
      
      if (!monthData.days[day].hours[hour]) {
        monthData.days[day].hours[hour] = { uniqueIPs: new Set(), count: 0, peak: 0 };
      }
      
    } else {
      
      // Initialize an empty structure for this month with current day and hour
      stats.years[year].months[month] = { days: {}, uniqueIPs: new Set(), peak: 0 };
      stats.years[year].months[month].days[day] = { hours: {}, uniqueIPs: new Set(), peak: 0 };
      stats.years[year].months[month].days[day].hours[hour] = { uniqueIPs: new Set(), count: 0, peak: 0 };
    }
    
    return stats;
  },

  // Helper to convert arrays to Sets when loading from DB
  _convertArraysToSets(stats) {
    if (!stats || !stats.years) return;
    
    Object.values(stats.years).forEach(yearData => {
      yearData.uniqueIPs = new Set(yearData.uniqueIPs || []);
      
      Object.values(yearData.months || {}).forEach(monthData => {
        monthData.uniqueIPs = new Set(monthData.uniqueIPs || []);
        
        Object.values(monthData.days || {}).forEach(dayData => {
          dayData.uniqueIPs = new Set(dayData.uniqueIPs || []);
          
          Object.values(dayData.hours || {}).forEach(hourData => {
            hourData.uniqueIPs = new Set(hourData.uniqueIPs || []);
          });
        });
      });
    });
  },

  // Helper to convert Sets to arrays for database storage
  _convertSetsToArrays(stats) {
    const convertedStats = JSON.parse(JSON.stringify(stats, (key, value) => {
      if (value instanceof Set) {
        return [...value];
      }
      return value;
    }));
    return convertedStats;
  },



  async updateHierarchicalStats(ip) {
    if (!ip) return;
    const stats = this._statsCache || await this.initializeHierarchicalStructure();
    const currentDate = new Date();
    const year = currentDate.getFullYear();
    const month = currentDate.getMonth() + 1;
    const day = currentDate.getDate();
    const hour = currentDate.getHours();
    
    // Check if the date values have changed since last update
    const dateChanged = (
      stats.current.year !== year ||
      stats.current.month !== month ||
      stats.current.day !== day ||
      stats.current.hour !== hour
    );
    
    if (dateChanged) {
    }
  
    stats.current = { year, month, day, hour };
    
    // Ensure data structures exist in memory
    if (!stats.years[year]) {
      stats.years[year] = { months: {}, uniqueIPs: new Set(), peak: 0 };
    }
    
    if (!stats.years[year].months[month]) {
      stats.years[year].months[month] = { days: {}, uniqueIPs: new Set(), peak: 0 };
    }
    
    if (!stats.years[year].months[month].days[day]) {
      stats.years[year].months[month].days[day] = { hours: {}, uniqueIPs: new Set(), peak: 0 };
    }
    
    if (!stats.years[year].months[month].days[day].hours[hour]) {
      stats.years[year].months[month].days[day].hours[hour] = { uniqueIPs: new Set(), count: 0, peak: 0 };
    }
  
    // Update memory
    const before = {
      year: stats.years[year].uniqueIPs.size,
      month: stats.years[year].months[month].uniqueIPs.size,
      day: stats.years[year].months[month].days[day].uniqueIPs.size,
      hour: stats.years[year].months[month].days[day].hours[hour].uniqueIPs.size
    };
    
    stats.years[year].uniqueIPs.add(ip);
    stats.years[year].months[month].uniqueIPs.add(ip);
    stats.years[year].months[month].days[day].uniqueIPs.add(ip);
    stats.years[year].months[month].days[day].hours[hour].uniqueIPs.add(ip);
    
    const after = {
      year: stats.years[year].uniqueIPs.size,
      month: stats.years[year].months[month].uniqueIPs.size,
      day: stats.years[year].months[month].days[day].uniqueIPs.size,
      hour: stats.years[year].months[month].days[day].hours[hour].uniqueIPs.size
    };
    
    const changed = (
      before.year !== after.year ||
      before.month !== after.month ||
      before.day !== after.day ||
      before.hour !== after.hour
    );
    
    if (changed) {
    } else {
    }
  
    // Save only the current month
    await this._saveCurrentMonthToDb(year, month);
  },

  async addIP(ip) {
    if (!ip) return;
    await this.updateHierarchicalStats(ip);
  },

  startTracking() {
    
    // Use a single Set to batch process IPs
    const pendingIPs = new Set();
    
    // Process IPs in batch
    const processIPs = async () => {
      if (pendingIPs.size === 0) return;
      for (const ip of pendingIPs) {
        await this.addIP(ip);
      }
      pendingIPs.clear();
    };
    
    // Schedule batch processing
    setInterval(processIPs, 2000);
    
    // Collect IPs and update counts
    setInterval(async () => {
      if (!room || !room.users) return;
      
      const currentDate = new Date();
      const year = currentDate.getFullYear();
      const month = currentDate.getMonth() + 1;
      const day = currentDate.getDate();
      const hour = currentDate.getHours();
      
      // Check if month changed since last run
      const stats = this._statsCache;
      if (stats && (stats.current.year !== year || stats.current.month !== month)) {
        
        // Force reload of cache for new month
        this._statsCache = await this.initializeHierarchicalStructure();
      }
      
      const userList = Object.values(room.users);
      const totalOnline = userList.length + 1;
      
      // Log how many users and IPs we're tracking
      const userIPs = userList.map(user => user.ip).filter(Boolean);
      
      // Queue IPs for batch processing
      for (const user of userList) {
        if (user.ip) pendingIPs.add(user.ip);
      }
    
      if (!stats) return;
    
      // Make sure all structures exist
      if (!stats.years[year]) {
        stats.years[year] = { months: {}, uniqueIPs: new Set(), peak: 0 };
      }
      
      if (!stats.years[year].months[month]) {
        stats.years[year].months[month] = { days: {}, uniqueIPs: new Set(), peak: 0 };
      }
      
      if (!stats.years[year].months[month].days[day]) {
        stats.years[year].months[month].days[day] = { hours: {}, uniqueIPs: new Set(), peak: 0 };
      }
      
      if (!stats.years[year].months[month].days[day].hours[hour]) {
        stats.years[year].months[month].days[day].hours[hour] = { uniqueIPs: new Set(), count: 0, peak: 0 };
      }
    
      // Add IPs directly here too for redundancy
      for (const user of userList) {
        if (user.ip) {
          stats.years[year].uniqueIPs.add(user.ip);
          stats.years[year].months[month].uniqueIPs.add(user.ip);
          stats.years[year].months[month].days[day].uniqueIPs.add(user.ip);
          stats.years[year].months[month].days[day].hours[hour].uniqueIPs.add(user.ip);
        }
      }
      
      // Log current IP counts
      
      // Update counts and peaks at all levels
      stats.years[year].months[month].days[day].hours[hour].count = totalOnline;
      
      // Update peak values
      if (totalOnline > stats.years[year].months[month].days[day].hours[hour].peak) {
        stats.years[year].months[month].days[day].hours[hour].peak = totalOnline;
      }
      
      if (totalOnline > stats.years[year].months[month].days[day].peak) {
        stats.years[year].months[month].days[day].peak = totalOnline;
      }
      
      if (totalOnline > stats.years[year].months[month].peak) {
        stats.years[year].months[month].peak = totalOnline;
      }
      
      if (totalOnline > stats.years[year].peak) {
        stats.years[year].peak = totalOnline;
      }
      
      // Add this line to save the updated counts and peaks to IndexedDB
      await this._saveCurrentMonthToDb(year, month);
      
    }, 1000);
  },

  async getHierarchicalStats(year, month, day) {
    // Use cached stats if available
    let stats = this._statsCache;
    if (!stats) {
      stats = await IDBHelper.getItem(this.statsKey);
      this._convertArraysToSets(stats);
      this._statsCache = stats;
    }
    
    // Convert Sets to arrays for the returned data
    const convertCopy = (obj) => {
      if (!obj) return null;
      
      // Create a deep copy with Sets converted to arrays
      return JSON.parse(JSON.stringify(obj, (key, value) => {
        if (value instanceof Set) {
          return [...value];
        }
        return value;
      }));
    };
    
    if (year && month && day) {
      if (stats.years[year]?.months[month]?.days[day]) {
        return convertCopy(stats.years[year].months[month].days[day]);
      }
      return null;
    }
    
    if (year && month) {
      if (stats.years[year]?.months[month]) {
        return convertCopy(stats.years[year].months[month]);
      }
      return null;
    }
    
    if (year) {
      if (stats.years[year]) {
        return convertCopy(stats.years[year]);
      }
      return null;
    }
    
    return convertCopy(stats);
  },

  // Updated for Sets
// Updated for Sets with complete hierarchical time series data
async getExtendedStats() {
  // Initialize structure for combined stats
  const stats = {
    years: {},
    current: { 
      year: new Date().getFullYear(), 
      month: new Date().getMonth() + 1,
      day: new Date().getDate(),
      hour: new Date().getHours() 
    }
  };

  try {
    // Get a list of all keys in the database to find our month entries
    const allKeys = await this.getAllKeys();
    const monthKeyPattern = /^ipStats_(\d+)_(\d+)$/;
    const monthKeys = allKeys.filter(key => monthKeyPattern.test(key));
    
    // Process each month key
    for (const key of monthKeys) {
      const match = key.match(monthKeyPattern);
      if (!match) continue;
      
      const year = match[1];
      const month = match[2];
      
      // Load month data
      const monthData = await IDBHelper.getItem(key);
      if (!monthData) continue;
      
      // Initialize year if needed
      if (!stats.years[year]) {
        stats.years[year] = { 
          months: {}, 
          uniqueIPs: new Set(),
          peak: 0 
        };
      }
      
      // Convert arrays in the month data back to Sets
      const monthWithSets = this._convertArraysToSetsMonth(monthData);
      
      // Add to the combined structure
      stats.years[year].months[month] = monthWithSets;
      
      // Update year-level uniqueIPs and peak
      for (const ip of monthWithSets.uniqueIPs) {
        stats.years[year].uniqueIPs.add(ip);
      }
      
      if (monthWithSets.peak > stats.years[year].peak) {
        stats.years[year].peak = monthWithSets.peak;
      }
    }
  } catch (error) {
  }

  // Use the current cache for the current month if available
  const currentYear = new Date().getFullYear();
  const currentMonth = new Date().getMonth() + 1;
  const currentDay = new Date().getDate();
  
  if (this._statsCache?.years?.[currentYear]?.months?.[currentMonth]) {
    // Replace current month with cache data which might be more up-to-date
    if (!stats.years[currentYear]) {
      stats.years[currentYear] = { months: {}, uniqueIPs: new Set(), peak: 0 };
    }
    
    stats.years[currentYear].months[currentMonth] = this._statsCache.years[currentYear].months[currentMonth];
    
    // Update year uniqueIPs with current month data
    for (const ip of this._statsCache.years[currentYear].months[currentMonth].uniqueIPs) {
      stats.years[currentYear].uniqueIPs.add(ip);
    }
    
    // Update year peak
    if (this._statsCache.years[currentYear].months[currentMonth].peak > stats.years[currentYear].peak) {
      stats.years[currentYear].peak = this._statsCache.years[currentYear].months[currentMonth].peak;
    }
  }

  // Create time series arrays for chart visualization
  const hourlyData = [];
  const dailyData = [];
  const monthlyData = [];

  const extendedStats = {
    today: null,
    week: null,
    month: null,
    year: {},
    yearMonthly: {},
    // Add time series arrays for charts
    hourly: hourlyData,
    daily: dailyData,
    monthly: monthlyData
  };

  // Process all years, months, days, and hours to build time series data
  const years = Object.keys(stats.years || {}).sort((a, b) => Number(a) - Number(b));
  
  for (const year of years) {
    const yearData = stats.years[year];
    
    // Store year data
    extendedStats.year[year] = [...yearData.uniqueIPs];
    extendedStats.yearMonthly[year] = {};
    
    // Process months
    const months = Object.keys(yearData.months || {}).sort((a, b) => Number(a) - Number(b));
    
    for (const month of months) {
      const monthData = yearData.months[month];
      
      // Add to yearMonthly structure
      extendedStats.yearMonthly[year][month] = {
        peak: monthData.peak || 0,
        uniqueIPs: [...monthData.uniqueIPs]
      };
      
      // Add to monthly time series
      monthlyData.push({
        x: new Date(Number(year), Number(month) - 1, 1),
        uniqueIPs: monthData.uniqueIPs.size,
        peakUsers: monthData.peak || 0
      });
      
      // Process days
      const days = Object.keys(monthData.days || {}).sort((a, b) => Number(a) - Number(b));
      
      for (const day of days) {
        const dayData = monthData.days[day];
        
        // Add to daily time series
        dailyData.push({
          x: new Date(Number(year), Number(month) - 1, Number(day)),
          uniqueIPs: dayData.uniqueIPs.size,
          peakUsers: dayData.peak || 0
        });
        
        // Process hours
        const hours = Object.keys(dayData.hours || {}).sort((a, b) => Number(a) - Number(b));
        
        for (const hour of hours) {
          const hourData = dayData.hours[hour];
          
          // Add to hourly time series
          hourlyData.push({
            x: new Date(Number(year), Number(month) - 1, Number(day), Number(hour)),
            uniqueIPs: hourData.uniqueIPs.size,
            peakUsers: hourData.peak || 0
          });
        }
      }
    }
  }

  // Today's data with Sets converted to arrays
  if (stats.years[currentYear]?.months[currentMonth]?.days[currentDay]) {
    const todayData = stats.years[currentYear].months[currentMonth].days[currentDay];
    extendedStats.today = {
      date: `${currentYear}-${currentMonth}-${currentDay}`,
      uniqueIPs: [...todayData.uniqueIPs],
      hours: {},
      online: {}
    };

    // Get hourly data
    Object.entries(todayData.hours || {}).forEach(([hour, hourData]) => {
      extendedStats.today.hours[hour] = [...hourData.uniqueIPs];
      extendedStats.today.online[hour] = hourData.count || 0;
    });
  }

  // Week data with merged Sets
  const weekIPs = new Set();
  const weekData = {
    yearWeek: this.getYearWeek(),
    uniqueIPs: [],
    days: {}
  };

  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  
  for (let i = 0; i < 7; i++) {
    const date = new Date();
    date.setDate(date.getDate() - i);
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const dayName = dayNames[date.getDay()];
    
    if (stats.years[year]?.months[month]?.days[day]) {
      const dayData = stats.years[year].months[month].days[day];
      
      // Union the Sets efficiently
      for (const ip of dayData.uniqueIPs) {
        weekIPs.add(ip);
      }
      
      weekData.days[dayName] = {
        uniqueIPs: [...dayData.uniqueIPs],
        peak: dayData.peak || 0
      };
    }
  }
  
  weekData.uniqueIPs = [...weekIPs];
  extendedStats.week = weekData;

  // Month data
  if (stats.years[currentYear]?.months[currentMonth]) {
    const monthData = stats.years[currentYear].months[currentMonth];
    extendedStats.month = {
      yearMonth: this.getYearMonth(),
      uniqueIPs: [...monthData.uniqueIPs],
      days: {}
    };
    
    // Get daily data for the month
    Object.entries(monthData.days || {}).forEach(([day, dayData]) => {
      extendedStats.month.days[day] = {
        uniqueIPs: [...dayData.uniqueIPs],
        peak: dayData.peak || 0
      };
    });
  }

  // Sort time series data by date
  extendedStats.hourly.sort((a, b) => a.x - b.x);
  extendedStats.daily.sort((a, b) => a.x - b.x);
  extendedStats.monthly.sort((a, b) => a.x - b.x);

  return extendedStats;
},

// Helper method to get all keys from IndexedDB
async getAllKeys() {
  return new Promise((resolve, reject) => {
    if (!IDBHelper.db) {
      return reject(new Error("Database not initialized"));
    }
    
    const transaction = IDBHelper.db.transaction([IDBHelper.storeName], "readonly");
    const store = transaction.objectStore(IDBHelper.storeName);
    const request = store.getAllKeys();
    
    request.onsuccess = () => {
      resolve(request.result);
    };
    
    request.onerror = (event) => {
      reject(event);
    };
  });
},

  // Keep original helper methods
  getDateString() {
    const d = new Date();
    return `${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}`;
  },

  getYearWeek() {
    const d = new Date();
    const year = d.getFullYear();
    const jan1 = new Date(d.getFullYear(), 0, 1);
    const days = Math.floor((d - jan1) / 86400000);
    const weekNum = Math.ceil((days + jan1.getDay() + 1) / 7);
    return `${year}-W${weekNum}`;
  },

  getYearMonth() {
    const d = new Date();
    return `${d.getFullYear()}-${d.getMonth() + 1}`;
  },

  async getStats(days = 1) {
    try {
      // Try to get data from the hierarchical structure
      const extendedStats = await this.getExtendedStats();
      
      if (!extendedStats) {
        return {
          total: 0,
          recent: 0,
          period: `${days} day(s)`
        };
      }
      
      // Extract all unique IPs across all years
      const allIPs = new Set();
      
      // Extract all year data
      Object.values(extendedStats.year || {}).forEach(ips => {
        if (Array.isArray(ips)) {
          ips.forEach(ip => allIPs.add(ip));
        }
      });
      
      // Calculate cutoff date for recent IPs
      const cutoff = Date.now() - days * 24 * 60 * 60 * 1000;
      const cutoffDate = new Date(cutoff);
      
      // Use daily data for recent IPs
      const recentIPs = new Set();
      extendedStats.daily.forEach(dayData => {
        if (dayData.x >= cutoffDate && Array.isArray(dayData.ips)) {
          dayData.ips.forEach(ip => recentIPs.add(ip));
        }
      });
      
      // If we don't have specific IPs per day in the daily data,
      // use the week data which should be available
      if (recentIPs.size === 0 && extendedStats.week && extendedStats.week.uniqueIPs) {
        extendedStats.week.uniqueIPs.forEach(ip => recentIPs.add(ip));
      }
      
      return {
        total: allIPs.size,
        recent: recentIPs.size || allIPs.size, // Fall back to total if recent isn't available
        period: `${days} day(s)`
      };
    } catch (error) {
      return {
        total: 0,
        recent: 0,
        period: `${days} day(s)`,
        error: error.message
      };
    }
  }
};

(async () => {
  // Check if IP tracking is enabled in localStorage
  const enableIPTracker = localStorage.getItem("enableIPTracker") === "true"; // Default to true if not set
  
  if (enableIPTracker) {
    await IPTracker.init();
  }
})();


// class SocketMod {
//   constructor() {
//     this.ws = null;
//     this.serverAddress = localStorage.getItem('socketMod_serverAddress') || 'wss://SERVER.com';
//     this.connected = false;
//     this.username = localStorage.getItem('socketMod_username') || '';
//     this.userColors = {};
//     this.currentRoom = null;
//     this.preferences = { color: 'rgb(255, 255, 255)' };
//     this.autoConnect = localStorage.getItem('socketMod_autoConnect') === 'true';
    
//     this.lastSetColor = null;
//     this.profileMap = {}; 

//     this.listeners = {
//       connect: [],
//       disconnect: [],
//       error: []
//     };

    
//     this.initChatObserver();
    
    
//     this._setupDocumentEventListeners();

    
//     if (this.autoConnect && this.username) {
//       setTimeout(() => this.connect(), 1000);
//     }

    
//     this.pingInterval = null;
//     this.on('connect', () => this.startPingInterval());
//     this.on('disconnect', () => this.stopPingInterval());
    
//     console.log(`SocketMod: Initialized with username: ${this.username}`);
//   }
  
//   initChatObserver() {
//     this.chatObserver = new MutationObserver(mutations => {
//       mutations.forEach(mutation => {
//         mutation.addedNodes.forEach(node => {
//           if (node.nodeType === 1 && node.classList && node.classList.contains('chatBlock')) {
//             const username = node.getAttribute('data-username');
//             if (username && this.userColors[username]) {
//               const usernameElement = node.querySelector('.msgUsername');
//               if (usernameElement) {
//                 usernameElement.style.color = this.userColors[username];
//               }
//             }
//           }
//         });
//       });
//     });

    
//     setTimeout(() => {
//       const chatContainer = document.querySelector('#chatMessages');
//       if (chatContainer) {
//         this.chatObserver.observe(chatContainer, { childList: true, subtree: true });
//         console.log("SocketMod: Chat color observer started");
//       }
//     }, 2000);
//   }

//   startPingInterval() {
//     this.stopPingInterval();
//     this.pingInterval = setInterval(() => this.sendPong(), 5000);
//   }

//   stopPingInterval() {
//     if (this.pingInterval) {
//       clearInterval(this.pingInterval);
//       this.pingInterval = null;
//     }
//   }

//   sendPong() {
//     if (!this.isConnected()) return;

    
//     const currentRoomName = this.getCurrentRoomName();
//     const flockmodUsername = this.getFlockmodUsername();
    
    
//     this.ws.send(JSON.stringify({
//       type: 'pong',
//       username: this.username,
//       flockmodUsername: flockmodUsername,
//       room: currentRoomName
//     }));
//   }

//   getFlockmodUsername() {
    
//     return window.room?.myself?.username || null;
//   }

//   getCurrentRoomName() {
    
//     let roomName = window.room?.name || window.room?.roomName || this.currentRoom || 'unknown';
    
    
//     if (roomName === "Lobby Browser") roomName = "NaN";
    
//     return roomName;
//   }

//   _setupDocumentEventListeners() {
    
//     $(document).on('roomChanged', (event, data) => {
//       console.log('SocketMod detected room change:', data.roomName);
//       this.currentRoom = data.roomName;

//       if (this.isConnected()) {
//         this.updateRoomStatus(data.roomName);
        
        
//         setTimeout(() => {
//           this.cleanupAllUserColors();
//           this.applyUserColors();
//         }, 1000);
//       }
//     });
//   }

//   cleanupAllUserColors() {
    
//     const userlistStyleEl = document.getElementById('custom-user-colors');
//     if (userlistStyleEl) {
//       userlistStyleEl.remove();
//     }

    
//     const chatStyleEl = document.getElementById('username-colors-style');
//     if (chatStyleEl) {
//       chatStyleEl.remove();
//     }
    
//     console.log('SocketMod: Removed all user colors');
//   }

//   removeUserColor(username) {
//     if (!username) return;

    
//     const userlistStyleEl = document.getElementById('custom-user-colors');
//     if (userlistStyleEl && userlistStyleEl.sheet) {
//       const sheet = userlistStyleEl.sheet;
//       const rules = sheet.cssRules || sheet.rules;

//       for (let i = rules.length - 1; i >= 0; i--) {
//         const rule = rules[i];
//         if (rule.selectorText && rule.selectorText.includes(`[name="${username}"]`)) {
//           sheet.deleteRule(i);
//         }
//       }
//     }

    
//     const chatStyleEl = document.getElementById('username-colors-style');
//     if (chatStyleEl && chatStyleEl.sheet) {
//       const sheet = chatStyleEl.sheet;
//       const rules = sheet.cssRules || sheet.rules;

//       for (let i = rules.length - 1; i >= 0; i--) {
//         const rule = rules[i];
//         if (rule.selectorText && rule.selectorText.includes(`[data-username="${username}"]`)) {
//           sheet.deleteRule(i);
//         }
//       }
//     }

    
//     document.querySelectorAll(`.chatBlock[data-username="${username}"] .msgUsername`).forEach(el => {
//       el.style.color = '';
//     });
    
//     console.log(`SocketMod: Removed color for user ${username}`);
//   }

//   setUserColor(username, color) {
//     if (!username || !color) return false;

    
//     this.setUserlistColor(username, color);
    
    
//     this.setChatUsernameColor(username, color);
    
    
//     this.userColors[username] = color;
    
//     return true;
//   }

//   setUserlistColor(username, color) {
//     let styleEl = document.getElementById('custom-user-colors');
//     if (!styleEl) {
//       styleEl = document.createElement('style');
//       styleEl.id = 'custom-user-colors';
//       document.head.appendChild(styleEl);
//     }

//     try {
      
//       const cssRule = `#userlist tr[name="${username}"] td:nth-child(2) { color: ${color} !important; }`;
//       styleEl.sheet.insertRule(cssRule, styleEl.sheet.cssRules.length);
      
      
//       const altRule = `#userlist div[data-username="${username}"] .username { color: ${color} !important; }`;
//       styleEl.sheet.insertRule(altRule, styleEl.sheet.cssRules.length);
      
//       return true;
//     } catch (error) {
//       console.error(`SocketMod: Error setting userlist color for ${username}:`, error);
//       return false;
//     }
//   }

//   setChatUsernameColor(username, color) {
//     let styleEl = document.getElementById('username-colors-style');
//     if (!styleEl) {
//       styleEl = document.createElement('style');
//       styleEl.id = 'username-colors-style';
//       document.head.appendChild(styleEl);
//     }

//     try {
      
//       const cssRule = `.chatBlock[data-username="${username}"] .msgUsername { color: ${color} !important; }`;
//       styleEl.sheet.insertRule(cssRule, styleEl.sheet.cssRules.length);
      
      
//       document.querySelectorAll(`.chatBlock[data-username="${username}"] .msgUsername`).forEach(el => {
//         el.style.color = color;
//       });
      
//       return true;
//     } catch (error) {
//       console.error(`SocketMod: Error setting chat color for ${username}:`, error);
//       return false;
//     }
//   }

//   applyUserColors() {
//     for (const username in this.userColors) {
//       this.setUserColor(username, this.userColors[username]);
//     }
//     console.log(`SocketMod: Applied colors to ${Object.keys(this.userColors).length} users`);
//   }

//   updateRoomStatus(roomName) {
//     if (!this.isConnected()) return false;

//     try {
//       const message = {
//         type: 'updateRoomStatus',
//         room: roomName,
//         flockmodUsername: this.getFlockmodUsername()
//       };
//       this.ws.send(JSON.stringify(message));
//       this.currentRoom = roomName;
//       console.log(`SocketMod: Updated room status to ${roomName}`);
//       return true;
//     } catch (error) {
//       console.error('SocketMod: Error updating room status:', error);
//       return false;
//     }
//   }

//   setServerAddress(address) {
//     this.serverAddress = address;
//     localStorage.setItem('socketMod_serverAddress', address);
//   }

//   setAutoConnect(enabled) {
//     this.autoConnect = enabled;
//     localStorage.setItem('socketMod_autoConnect', enabled.toString());
//   }

//   connect(serverAddress) {
//     if (serverAddress) {
//       this.serverAddress = serverAddress;
//       localStorage.setItem('socketMod_serverAddress', serverAddress);
//     }

//     if (this.ws && this.ws.readyState !== WebSocket.CLOSED) {
//       this._triggerEvent('error', { message: 'Already connected or connecting' });
//       return false;
//     }

//     try {
//       this.ws = new WebSocket(this.serverAddress);

//       this.ws.onopen = () => {
//         console.log('SocketMod: Connected to server');
//         this.connected = true;
        
//         this._triggerEvent('connect', { message: 'Connected to server' });
//         this.login();
//       };

//       this.ws.onmessage = (event) => {
//         try {
//           const data = JSON.parse(event.data);
//           console.log('SocketMod: Received message:', data);

//           switch (data.type) {
//             case 'roomColorSync':
//               this.handleRoomColorSync(data);
//               break;
              
//             case 'userLeftRoom':
//               this.handleUserLeftRoom(data);
//               break;
              
//             case 'loginSuccess':
//               this.handleLoginSuccess(data);
//               break;

//             case 'error':
//               this._triggerEvent('error', data);
//               break;

//             default:
//               console.log('SocketMod: Unhandled message type:', data.type);
//           }
//         } catch (error) {
//           console.error('SocketMod: Error parsing message:', error);
//         }
//       };

//       this.ws.onclose = () => {
//         console.log('SocketMod: Disconnected from server');
//         this.connected = false;
//         this._triggerEvent('disconnect', { message: 'Disconnected from server' });
        
//         UI.dialogHandler.showAlert("Disconnected from Socket Mod server");
//       };

//       this.ws.onerror = (error) => {
//         console.error(`SocketMod: WebSocket error:`, error);
//         this._triggerEvent('error', { message: `Connection error` });
//       };

//       return true;
//     } catch (error) {
//       console.error('SocketMod: Error connecting to server:', error);
//       this._triggerEvent('error', { message: `Connection error: ${error.message}` });
//       return false;
//     }
//   }
  
//   handleRoomColorSync(data) {
//     if (!data.room || data.room === 'NaN' || !data.colorData) return;
    
//     console.log('SocketMod: Received color data for room:', data.room);
    
    
//     const oldColors = {...this.userColors};
    
    
//     this.userColors = {...data.colorData};
    
    
//     if (data.profileMap) {
//       this.profileMap = data.profileMap;
//     }
    
    
//     const myFlockmodUsername = this.getFlockmodUsername();
    
    
//     const myUsernames = [];
//     if (data.profileMap) {
//       for (const [flockmodUsername, socketModUsername] of Object.entries(data.profileMap)) {
//         if (socketModUsername === this.username) {
//           myUsernames.push(flockmodUsername);
//         }
//       }
//     }
    
    
//     if (myFlockmodUsername && !myUsernames.includes(myFlockmodUsername)) {
//       myUsernames.push(myFlockmodUsername);
//     }
    
//     console.log(`SocketMod: Identified ${myUsernames.length} usernames belonging to my profile: ${myUsernames.join(', ')}`);
    
    
    
//     if (myUsernames.length > 0) {
//       const firstUsername = myUsernames[0];
//       const serverColor = this.userColors[firstUsername];
      
//       if (serverColor && serverColor !== this.preferences.color) {
//         console.log(`SocketMod: Updating local color preference from ${this.preferences.color} to ${serverColor}`);
//         this.preferences.color = serverColor;
        
//         if (!this.lastSetColor) {
          
//           this.lastSetColor = serverColor;
          
          
//           setTimeout(() => {
//             if (this.lastSetColor === serverColor) {
//               this.lastSetColor = null;
//             }
//           }, 5000);
//         }
//       }
//     }
    
    
//     let myColor = this.preferences.color;
    
    
//     if (this.lastSetColor) {
//       myColor = this.lastSetColor;
//       console.log(`SocketMod: Using last set color ${myColor} for all my usernames`);
//     }
    
    
//     for (const username of myUsernames) {
//       this.userColors[username] = myColor;
//       console.log(`SocketMod: Applied my profile color ${myColor} to username ${username}`);
//     }
    
    
//     this.cleanupAllUserColors();
//     this.applyUserColors();
    
    
//     const addedUsers = Object.keys(this.userColors).filter(u => !oldColors[u]);
//     const removedUsers = Object.keys(oldColors).filter(u => !this.userColors[u]);
    
//     if (addedUsers.length) console.log('SocketMod: Added colors for:', addedUsers.join(', '));
//     if (removedUsers.length) console.log('SocketMod: Removed colors for:', removedUsers.join(', '));
//   }

//   handleUserLeftRoom(data) {
//     if (!data.username) return;
    
//     console.log(`SocketMod: User ${data.username} left room`);
    
    
//     delete this.userColors[data.username];
//     this.removeUserColor(data.username);
    
    
//     if (this.profileMap[data.username]) {
//       delete this.profileMap[data.username];
//     }
//   }

//   handleLoginSuccess(data) {
//     if (data.username && data.username !== this.username) {
//       console.log(`SocketMod: Server confirmed username: ${data.username}`);
//       this.username = data.username;
//       localStorage.setItem('socketMod_username', data.username);
//     }
    
//     if (data.preferences?.color) {
//       this.preferences.color = data.preferences.color;
//     }
    
//     console.log(`SocketMod: Login successful with username ${this.username}`);
    
    
//     setTimeout(() => {
//       const roomName = this.getCurrentRoomName();
//       this.updateRoomStatus(roomName);
//     }, 500);
//   }

//   disconnect() {
//     if (this.ws) {
//       this.ws.close();
//       this.ws = null;
//       this.connected = false;
//       this.cleanupAllUserColors();
      
//     }
//   }

//   login() {
//     if (!this.isConnected()) {
//       this._triggerEvent('error', { message: 'Not connected to server' });
//       return false;
//     }

//     try {
//       if (!this.username) {
//         this._triggerEvent('error', { message: 'Username is required. Set it in the Socket Mod settings.' });
//         return false;
//       }

//       const message = {
//         type: 'login',
//         username: this.username
//       };
//       this.ws.send(JSON.stringify(message));
//       console.log(`SocketMod: Sent login request for username ${this.username}`);
//       return true;
//     } catch (error) {
//       console.error('SocketMod: Error during login:', error);
//       return false;
//     }
//   }

//   setPreference(key, value) {
//     if (!this.isConnected()) {
//       this._triggerEvent('error', { message: 'Not connected to server' });
//       return false;
//     }

//     try {
      
//       const message = {
//         type: 'setPreference',
//         key: key,
//         value: value
//       };
      
//       this.ws.send(JSON.stringify(message));
      
      
//       if (key === 'color') {
        
//         this.preferences[key] = value;
//         this.lastSetColor = value;
        
        
//         const myFlockmodUsername = this.getFlockmodUsername();
//         const myUsernames = this.getMyProfileUsernames();
        
        
//         for (const username of myUsernames) {
//           this.userColors[username] = value;
//           this.setUserColor(username, value);
//           console.log(`SocketMod: Applied color ${value} to profile username ${username}`);
//         }
        
        
//         setTimeout(() => {
//           if (this.lastSetColor === value) {
//             this.lastSetColor = null;
//           }
//         }, 10000);
//       }
      
//       return true;
//     } catch (error) {
//       console.error('SocketMod: Error setting preference:', error);
//       return false;
//     }
//   }
  
//   getMyProfileUsernames() {
//     const myUsernames = [];
//     const myFlockmodUsername = this.getFlockmodUsername();
    
    
//     if (myFlockmodUsername) {
//       myUsernames.push(myFlockmodUsername);
//     }
    
    
//     if (this.profileMap) {
//       for (const [flockmodUsername, socketModUsername] of Object.entries(this.profileMap)) {
//         if (socketModUsername === this.username && !myUsernames.includes(flockmodUsername)) {
//           myUsernames.push(flockmodUsername);
//         }
//       }
//     }
    
//     return myUsernames;
//   }

//   on(event, callback) {
//     if (this.listeners[event]) {
//       this.listeners[event].push(callback);
//     }
//   }

//   off(event, callback) {
//     if (this.listeners[event]) {
//       this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
//     }
//   }

//   _triggerEvent(event, data) {
//     if (this.listeners[event]) {
//       this.listeners[event].forEach(callback => callback(data));
//     }
//   }

//   isConnected() {
//     return this.connected && this.ws && this.ws.readyState === WebSocket.OPEN;
//   }

//   colorUsername(username, color) {
//     if (!username || !color) return;
    
    
//     const isMyUsername = this.profileMap[username] === this.username || 
//                           username === this.getFlockmodUsername();
    
//     if (isMyUsername && this.isConnected()) {
      
//       this.setPreference('color', color);
//     } else {
      
//       this.userColors[username] = color;
//       this.setUserColor(username, color);
//       console.log(`SocketMod: Colored "${username}" as ${color} (local only)`);
//     }
//   }

//   resetUsernameColor(username) {
//     if (!username) return;
    
    
//     const isMyUsername = this.profileMap[username] === this.username || 
//                           username === this.getFlockmodUsername();
    
//     if (isMyUsername && this.isConnected()) {
      
//       this.setPreference('color', 'rgb(255, 255, 255)');
//     } else {
      
//       delete this.userColors[username];
//       this.removeUserColor(username);
//       console.log(`SocketMod: Reset color for "${username}" (local only)`);
//     }
//   }
// }


// window.socketMod = new SocketMod();

// window.colorUsername = function(username, color) {
//   window.socketMod.colorUsername(username, color);
// };

// window.resetUsernameColor = function(username) {
//   window.socketMod.resetUsernameColor(username);
// };

// console.log("SocketMod with chat username coloring initialized!");
// console.log("Available commands:");
// console.log("- colorUsername('username', 'color')");
// console.log("- resetUsernameColor('username')");

// function changeRoom(newRoomName) {
//   console.log(`Changing room to: ${newRoomName}`);

//   // Step 1: Leave current room
//   UI.topbar.pressButton("leaveButton");

//   // Step 2: Confirm leaving by clicking "Yes"
//   $("#confirmationContainer a[name='ok']").click();

//   // Step 3: Wait for login dialog to appear and then join new room
//   // Need a small delay to ensure UI has updated
//   setTimeout(() => {
//     // Set the room name in the input field
//     UI.loginDialog.content.find("#loginRoom").val(newRoomName);

//     // Attempt to join the room
//     UI.loginDialog.attemptJoin();

//     // If login modal appears (confirmedAccount is false), handle it
//     setTimeout(() => {
//       if (UI.loginDialog.content.find("button[name='okaccount'].joinRoom").is(":visible")) {
//         // Click the join room button in the account modal to use Anonymous or saved login
//         UI.loginDialog.content.find("button[name='okaccount'].joinRoom").click();
//       }
//     }, 0);
//   }, 0);
// }

// Example usage:
// changeRoom("drizz");


// class SocketModDialog extends Dialog {
//   constructor(_dialogParams) {
//     super(_dialogParams);

//     this.icon = "fa-plug";
//     this.caption = "Socket Mod";
//     this.width = 600;
//     this.height = 500;

//     this.loadContent(`
//       <style>
//         .socket-mod-dialog {
//           display: flex; 
//           height: 100%;
//           overflow: hidden;
//         }
//         .socket-mod-dialog h2 {
//           font-size: 1.8em;
//         }
//         .socket-mod-dialog .subcontentOption:hover {
//           background: #444;
//         }
//         .socket-mod-dialog .main-content {
//           flex: 1; 
//           background-color: #1e1e1e; 
//           color: #fff; 
//           padding: 20px;
//           display: flex;
//           flex-direction: column;
//           overflow: hidden;
//         }
//         .socket-mod-dialog .subcontent {
//           display: flex;
//           flex-direction: column;
//           flex: 1;
//           overflow: hidden;
//           height: 100%;
//         }
//         .settings-panel {
//           margin-bottom: 15px;
//           border: 1px solid #444;
//           border-radius: 4px;
//           padding: 10px;
//           background-color: #2a2a2a;
//         }
//         .settings-row {
//           display: flex;
//           margin-bottom: 10px;
//           align-items: center;
//         }
//         .settings-label {
//           width: 100px;
//           color: #ccc;
//         }
//         .settings-input {
//           flex: 1;
//           padding: 6px;
//           background-color: #333;
//           border: 1px solid #555;
//           color: #fff;
//           border-radius: 4px;
//         }
//         .connection-status {
//           margin-top: 10px;
//           padding: 5px 10px;
//           border-radius: 4px;
//           font-weight: bold;
//           text-align: center;
//         }
//         .status-connected {
//           background-color: rgba(76, 175, 80, 0.3);
//           color: #81c784;
//         }
//         .status-disconnected {
//           background-color: rgba(244, 67, 54, 0.3);
//           color: #e57373;
//         }
//         .color-preview {
//           width: 20px;
//           height: 20px;
//           border-radius: 50%;
//           display: inline-block;
//           margin-left: 10px;
//           border: 1px solid #666;
//         }
//       </style>
//       <div class="socket-mod-dialog">
//         <div class="sidebar" style="width: 150px; background-color: #2c2c2c; padding: 10px;">
//           <div class="sidebar-options">
//             <button name="connection" class="subcontentOption" data-subcontent="connection" style="display: block; width: 100%; background: none; color: #fff; border: none; text-align: left; padding: 10px; font-size: 14px; cursor: pointer;">
//                 <i class="fa fa-plug"></i> Connection
//             </button>
//             <button name="profile" class="subcontentOption" data-subcontent="profile" style="display: block; width: 100%; background: none; color: #fff; border: none; text-align: left; padding: 10px; font-size: 14px; cursor: pointer;">
//                 <i class="fa fa-user"></i> Profile
//             </button>
//           </div>
//         </div>
//         <div class="main-content">
//           <div class="subcontent"></div>
//         </div>
//       </div>
//     `);

//     this.attachEvents();
//     this.registerSocketListeners();
//     this.loadPage("connection");
//   }

//   loadContent(content) {
//     this.content.html(content);
//   }

//   attachEvents() {
//     const _this = this;
//     this.content.find(".subcontentOption").on(UI.pointerEvent("click"), function (event) {
//       event.preventDefault();
//       const subcontent = $(this).data("subcontent");
//       _this.loadPage(subcontent);
//     });
//   }

//   registerSocketListeners() {
//     socketMod.on('connect', () => {
//       this.updateConnectionStatus(true);
//     });

//     socketMod.on('disconnect', () => {
//       this.updateConnectionStatus(false);
//     });

//     socketMod.on('error', (data) => {
//     });
//   }

//   updateConnectionStatus(connected) {
//     const statusEl = this.content.find('.connection-status');
//     if (statusEl.length) {
//       if (connected) {
//         statusEl.removeClass('status-disconnected').addClass('status-connected');
//         statusEl.html('<i class="fa fa-check-circle"></i> Connected to server');

//         const connectButton = this.content.find('#connectButton');
//         if (connectButton.length) {
//           connectButton.html('<i class="fa fa-times"></i> Disconnect');
//           connectButton.css('background-color', '#F44336');
//         }
//       } else {
//         statusEl.removeClass('status-connected').addClass('status-disconnected');
//         statusEl.html('<i class="fa fa-times-circle"></i> Disconnected');

//         const connectButton = this.content.find('#connectButton');
//         if (connectButton.length) {
//           connectButton.html('<i class="fa fa-plug"></i> Connect');
//           connectButton.css('background-color', '#4CAF50');
//         }
//       }
//     }
//   }

//   loadPage(subcontent) {
//     if (subcontent !== undefined) {
//       this.content.find(".subcontentOption").css("background", "none");
//       this.content.find(`.subcontentOption[data-subcontent="${subcontent}"]`).css("background", "#444");

//       if (subcontent === "connection") {
//         this.loadConnectionPage();
//       } else if (subcontent === "profile") {
//         this.loadProfilePage();
//       }
//     }
//   }

//   loadConnectionPage() {
//     const isConnected = socketMod.isConnected();
//     const savedUsername = localStorage.getItem('socketMod_username') || '';
//     const savedServerAddress = localStorage.getItem('socketMod_serverAddress') || 'wss://SERVER.com';
//     const autoConnect = localStorage.getItem('socketMod_autoConnect') === 'true';

//     this.loadSubcontent(`
//       <div style="padding: 10px; display: flex; flex-direction: column; height: 100%;">
//         <h2 style="border-bottom: 1px solid #444; padding-bottom: 10px; margin-bottom: 20px;">Socket Connection</h2>
        
//         <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center;">
//           <div style="width: 100%; max-width: 400px; margin-bottom: 20px;">
//             <div class="settings-row">
//               <label class="settings-label">Username:</label>
//               <input id="usernameInput" class="settings-input" type="text" value="${savedUsername}" placeholder="Your profile username" maxlength="20">
//             </div>
            
//             <div class="settings-row" style="margin-top: 10px;">
//               <label class="settings-label">Server:</label>
//               <div style="display: flex; flex: 1; gap: 5px;">
//                 <input id="serverAddressInput" class="settings-input" type="text" value="${savedServerAddress}" 
//                   placeholder="WebSocket server address">
//                 <button id="resetServerButton" title="Reset to default server" style="width: 30px; height: 30px; background-color: #444; border: 1px solid #555; border-radius: 4px; color: #ccc; cursor: pointer; display: flex; align-items: center; justify-content: center;">
//                   <i class="fa fa-rotate-left"></i>
//                 </button>
//               </div>
//             </div>
            
//             <div class="settings-row" style="margin-top: 10px;">
//               <label class="settings-label"></label>
//               <label style="display: flex; align-items: center; cursor: pointer;">
//                 <input id="autoConnectCheckbox" type="checkbox" ${autoConnect ? 'checked' : ''} 
//                   style="margin-right: 8px;">
//                 Auto-connect on startup
//               </label>
//             </div>
//           </div>
          
//           <button id="connectButton" style="padding: 12px 24px; background-color: ${isConnected ? '#F44336' : '#4CAF50'}; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; transition: background-color 0.3s;">
//             <i class="fa fa-${isConnected ? 'times' : 'plug'}" style="margin-right: 8px;"></i> ${isConnected ? 'Disconnect' : 'Connect'}
//           </button>
          
//           <div class="connection-status ${isConnected ? 'status-connected' : 'status-disconnected'}" style="margin-top: 20px;">
//             <i class="fa fa-${isConnected ? 'check' : 'times'}-circle"></i> ${isConnected ? 'Connected to server' : 'Disconnected'}
//           </div>
//         </div>
//       </div>
//     `);

//     this.content.find("#connectButton").on("click", () => {
//       if (socketMod.isConnected()) {
//         socketMod.disconnect();
//       } else {
//         const username = this.content.find("#usernameInput").val().trim();
//         const serverAddress = this.content.find("#serverAddressInput").val().trim();
//         const autoConnect = this.content.find("#autoConnectCheckbox").is(":checked");

//         if (!username) {
//           UI.dialogHandler.showAlert("Please enter a username");
//           return;
//         }

//         if (!serverAddress) {
//           UI.dialogHandler.showAlert("Please enter a server address");
//           return;
//         }

//         socketMod.username = username;
//         localStorage.setItem('socketMod_username', username);
//         socketMod.setServerAddress(serverAddress);
//         socketMod.setAutoConnect(autoConnect);
//         socketMod.connect();
//       }
//     });

//     this.content.find("#resetServerButton").on("click", () => {
//       const defaultServer = "wss://SERVER.com";
//       this.content.find("#serverAddressInput").val(defaultServer);
//       localStorage.setItem('socketMod_serverAddress', defaultServer);
//     });

//     this.content.find("#autoConnectCheckbox").on("change", function () {
//       const autoConnect = $(this).is(":checked");
//       localStorage.setItem('socketMod_autoConnect', autoConnect.toString());
//     });

//     this.content.find("#usernameInput").on("change", function () {
//       const username = $(this).val().trim();
//       if (username) {
//         localStorage.setItem('socketMod_username', username);
//       }
//     });

//     this.content.find("#serverAddressInput").on("change", function () {
//       const serverAddress = $(this).val().trim();
//       if (serverAddress) {
//         localStorage.setItem('socketMod_serverAddress', serverAddress);
//       }
//     });
//   }

//   hexToRgb(hex) {
//     const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
//     hex = hex.replace(shorthandRegex, function (m, r, g, b) {
//       return r + r + g + g + b + b;
//     });

//     const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
//     return result ? `rgb(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)})` : null;
//   }

//   rgbToHex(rgb) {
//     if (!rgb) return '#FFFFFF';

//     const rgbMatch = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
//     if (!rgbMatch) return '#FFFFFF';

//     const r = parseInt(rgbMatch[1]);
//     const g = parseInt(rgbMatch[2]);
//     const b = parseInt(rgbMatch[3]);

//     const componentToHex = (c) => {
//       const hex = c.toString(16);
//       return hex.length == 1 ? "0" + hex : hex;
//     }

//     return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
//   }

//   loadProfilePage() {
//     const isConnected = socketMod.isConnected();
//     const color = socketMod.preferences?.color || 'rgb(255, 255, 255)';

//     this.loadSubcontent(`
//       <div style="padding: 10px; display: flex; flex-direction: column; height: 100%; overflow: hidden;">
//         <h2 style="border-bottom: 1px solid #444; padding-bottom: 10px; margin-bottom: 20px;">User Profile</h2>
        
//         ${!isConnected ?
//         '<div style="padding: 20px; text-align: center; color: #999;">Connect to server to edit profile</div>' :
//         `
//           <div class="settings-panel" style="flex: 1; overflow-y: auto; margin-bottom: 0; padding-bottom: 20px;">
//             <div class="profile-field">
//               <label for="usernameColor" class="settings-label">Username Color:</label>
//               <input type="color" id="usernameColor" class="settings-input" value="${this.rgbToHex(color)}" style="width: 100px;">
//               <span class="color-preview" style="background-color: ${color};"></span>
//             </div>
            
//             <button id="saveProfileButton" style="margin-top: 15px; padding: 8px 15px; background-color: #4c6c4c; color: white; border: none; border-radius: 4px; cursor: pointer;">
//               <i class="fa fa-save"></i> Save Color
//             </button>
//           </div>
//           `
//       }
//       </div>
//     `);

//     this.content.find("#usernameColor").on("input", function () {
//       $(".color-preview").css("background-color", $(this).val());
//     });

//     this.content.find("#saveProfileButton").on("click", () => {
//       if (!socketMod.isConnected()) return;

//       let color = this.content.find("#usernameColor").val();
//       color = this.hexToRgb(color);
//       socketMod.setPreference('color', color);

//       UI.dialogHandler.showAlert("Color updated successfully!");
//     });
//   }

//   loadSubcontent(html) {
//     this.content.find(".subcontent").html(html);
//   }
// }

class ModsDialog extends Dialog {
  
  constructor(_0x48b935) {
    super(_0x48b935);
    

    this.icon = config.dialog.icon;
    this.caption = config.dialog.caption;
    this.width = config.dialog.width;
    this.height = config.dialog.height;


    // Timers and states
    this.roomTimeData = JSON.parse(localStorage.getItem(config.localStorageKeys.roomTimeData)) || {};
    this.drawingTimeData = JSON.parse(localStorage.getItem(config.localStorageKeys.drawingTimeData)) || {};
    this.currentRoom = config.defaultValues.room;
    this.selectedRoom = config.defaultValues.room;
    
    this.isDrawing = false;

    this.sessionRoomTime = {};
    this.sessionDrawingTime = {};


// Full fixed code for the ModsDialog structure
this.loadContent(`
  <style>
    /* Scope all styles to this specific dialog to prevent affecting other dialogs */
    .mods-dialog {
      display: flex; 
      height: 100%;
      overflow: hidden;
    }
    .mods-dialog .subcontentOption:hover {
      background: #444;
    }
    .mods-dialog .main-content {
      flex: 1; 
      background-color: #1e1e1e; 
      color: #fff; 
      padding: 20px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .mods-dialog .subcontent {
      display: flex;
      flex-direction: column;
      flex: 1;
      overflow: hidden;
      height: 100%;
    }
  </style>
  <div class="mods-dialog">
    <div class="sidebar" style="width: 150px; background-color: #2c2c2c; padding: 10px;">
      <div class="sidebar-options">
        <button name="info" class="subcontentOption" data-subcontent="info" style="display: block; width: 100%; background: none; color: #fff; border: none; text-align: left; padding: 10px; font-size: 14px; cursor: pointer;">
            <i class="fa fa-info-circle"></i> Statistics
        </button>
        <button name="tweaks" class="subcontentOption" data-subcontent="tweaks" style="display: block; width: 100%; background: none; color: #fff; border: none; text-align: left; padding: 10px; font-size: 14px; cursor: pointer;">
            <i class="fa fa-wrench"></i> Tweaks
        </button>
        <button name="messenger" class="subcontentOption" data-subcontent="messenger" style="display: block; width: 100%; background: none; color: #fff; border: none; text-align: left; padding: 10px; font-size: 14px; cursor: pointer;">
            <i class="fa fa-ban"></i> Messenger Controls
        </button>
        <button name="undo" class="subcontentOption" data-subcontent="undo" style="display: block; width: 100%; background: none; color: #fff; border: none; text-align: left; padding: 10px; font-size: 14px; cursor: pointer;">
            <i class="fa fa-history"></i> Step Back
        </button>
        <button name="trackers" class="subcontentOption" data-subcontent="trackers" style="display: block; width: 100%; background: none; color: #fff; border: none; text-align: left; padding: 10px; font-size: 14px; cursor: pointer;">
            <i class="fa fa-chart-line"></i> Trackers
        </button>
        <!-- COMMENTED OUT: Currency button
        <button name="currency" class="subcontentOption" data-subcontent="currency" style="display: block; width: 100%; background: none; color: #fff; border: none; text-align: left; padding: 10px; font-size: 14px; cursor: pointer;">
            <i class="fa fa-coins"></i> Currency
        </button>
        -->
        <!-- COMMENTED OUT: Currency button
        <button name="stocks" class="subcontentOption" data-subcontent="stocks" style="display: block; width: 100%; background: none; color: #fff; border: none; text-align: left; padding: 10px; font-size: 14px; cursor: pointer;">
            <i class="fa fa-chart-line"></i> Stocks
        </button>
        -->
        <!-- COMMENTED OUT: Currency button
        <button name="darkweb" class="subcontentOption" data-subcontent="darkweb" style="display: block; width: 100%; background: none; color: #fff; border: none; text-align: left; padding: 10px; font-size: 14px; cursor: pointer;">
          <i class="fa fa-cannabis"></i> Dark Foxes
        </button>
        -->
        <button name="about" class="subcontentOption" data-subcontent="about" style="display: block; width: 100%; background: none; color: #fff; border: none; text-align: left; padding: 10px; font-size: 14px; cursor: pointer;">
            <i class="fa fa-users"></i> About Us
        </button>
      </div>
    </div>
    <div class="main-content">
      <div class="subcontent"></div>
    </div>
  </div>
`);
    this.attachEvents();
    this.startTimers();
    this.updateCurrentRoom(); // Update current room dynamically

    // Load the "info" tab by default when the dialog opens
    this.loadPage("info");
  }

  startTimers() {
    // Check if room times tracking is enabled
    const enableRoomTimesTracker = localStorage.getItem("enableRoomTimesTracker") === "true"; // Default to true if not set
    
    if (!enableRoomTimesTracker) {
      // Don't start timers if tracking is disabled
      return;
    }
  
    // Directly initialize the data inside the function
    this.roomTimeData = JSON.parse(localStorage.getItem(config.localStorageKeys.roomTimeData)) || {};
    this.drawingTimeData = JSON.parse(localStorage.getItem(config.localStorageKeys.drawingTimeData)) || {};
    this.sessionRoomTime = {};
    this.sessionDrawingTime = {};
    
    // Set initial room
    this.currentRoom = config.defaultValues.room;
  
    // Store the interval IDs for later use
    this.roomTimeInterval = setInterval(() => {
        if (!this.roomTimeData[this.currentRoom]) {
            this.roomTimeData[this.currentRoom] = 0;
        }
        this.roomTimeData[this.currentRoom]++;
        
        // Save the updated data to localStorage
        localStorage.setItem(config.localStorageKeys.roomTimeData, JSON.stringify(this.roomTimeData));
  
        // Increment session time
        if (!this.sessionRoomTime[this.currentRoom]) {
            this.sessionRoomTime[this.currentRoom] = 0;
        }
        this.sessionRoomTime[this.currentRoom]++;
    }, config.timers.roomUpdateInterval);
  
    // Store the interval ID for the drawing time as well
    this.drawingTimeInterval = setInterval(async () => {
        const isPenPressed = room?.myself?.surface?.penPressed;
        if (isPenPressed) {
            this.isDrawing = true;
            if (!this.drawingTimeData[this.currentRoom]) {
                this.drawingTimeData[this.currentRoom] = 0;
            }
            this.drawingTimeData[this.currentRoom] = parseFloat((this.drawingTimeData[this.currentRoom] + 0.1).toFixed(1));
            
            // Save the updated drawing data to localStorage
            localStorage.setItem("drawingTimeData", JSON.stringify(this.drawingTimeData));
  
            // Increment session drawing time
            if (!this.sessionDrawingTime[this.currentRoom]) {
                this.sessionDrawingTime[this.currentRoom] = 0;
            }
            this.sessionDrawingTime[this.currentRoom] = parseFloat((this.sessionDrawingTime[this.currentRoom] + 0.1).toFixed(1));
                  // Add FMC currency for 0.1 seconds of drawing time - NOW USING IndexedDB
            try {
              const secondValue = 0.1/60; // 0.1 second = 0.1/60 coin
              
              // Get current balance from IndexedDB
              let currentBalance = await StockMarketDB.getBalance();
              
              // Update the balance
              await StockMarketDB.updateBalance(currentBalance + secondValue);
            } catch (error) {
              console.error('Error updating FMC balance:', error);
            }
        } else {
            this.isDrawing = false;
        }
    }, 100);
  }

stopTimers() {
  // Stop both intervals
  clearInterval(this.roomTimeInterval);
  clearInterval(this.drawingTimeInterval);
}





  updateCurrentRoom() {
    setInterval(() => {
        if (room?.name) {
            const newRoom = room.name;
            if (this.currentRoom !== newRoom) {
                this.currentRoom = newRoom;
                this.updateRoomSelector(newRoom);
                this.selectedRoom = newRoom; // Ensure selected room matches the current room
                this.updateTimersDisplay(); // Update the timers display immediately
            }
        } else {
            this.currentRoom = "Lobby Browser";
            this.updateRoomSelector("Lobby Browser");
            this.selectedRoom = "Lobby Browser";
            this.updateTimersDisplay();
        }
    }, config.timers.roomUpdateInterval);
}


  updateRoomSelector(newRoom) {
    // Add the new room to the dropdown if it doesn't already exist
    if (!Object.keys(this.roomTimeData).includes(newRoom)) {
        this.roomTimeData[newRoom] = 0; // Initialize the room time
    }

    const roomSelector = this.content.find("#roomSelector");
    
    // Add new room to the selector if not already present
    if (roomSelector.find(`option[value="${newRoom}"]`).length === 0) {
        roomSelector.append(`<option value="${newRoom}">${newRoom}</option>`);
    }

    // Select the new room
    roomSelector.val(newRoom);  // Set the dropdown to the new room
    this.selectedRoom = newRoom; // Update the selected room state

    // Update the visual timers
    this.updateTimersDisplay();
}



  loadContent(content) {
    this.content.html(content);
  }

  attachEvents() {
    const _this = this;
    this.content.find(".subcontentOption").on(UI.pointerEvent("click"), function (event) {
      event.preventDefault();
      const subcontent = $(this).data("subcontent");
      _this.loadPage(subcontent);
    });
  }

  loadPage(subcontent) {
    const _this = this;
    if (subcontent !== undefined) {
      if (this.undoUpdateInterval) {
        clearInterval(this.undoUpdateInterval);
        this.undoUpdateInterval = null;
      }
      this.content.find(".subcontentOption").css("background", "none");
      this.content.find(`.subcontentOption[data-subcontent="${subcontent}"]`).css("background", "#444");
      this.loading(true);
  
      if (subcontent === "info") {

        // Update the tabs structure for proper resizing
        this.loadSubcontent(`
          <style>
            .tab-container {
              display: flex;
              flex-direction: column;
              height: 100%;
              overflow: hidden;
            }
            .tab-buttons {
              display: flex;
              border-bottom: 1px solid #444;
              margin-bottom: 10px;
            }
            .tab-button {
              flex: 1;
              background: none;
              border: none;
              padding: 10px;
              cursor: pointer;
              color: #aaa;
              transition: background 0.2s, color 0.2s;
            }
            .tab-button.active {
              background: #444;
              color: #fff;
            }
            .tab-button:hover:not(.active) {
              background: #333;
              color: #ddd;
            }
            .tab-content {
              flex: 1;
              overflow: auto;
              display: flex;
              flex-direction: column;
            }
          </style>
        
          <div class="tab-container">
            <div class="tab-buttons">
              <button id="roomTimesBtn" class="tab-button active">Room Times</button>
              <button id="ipStatsBtn" class="tab-button">IP Stats</button>
            </div>
      
            <div class="tab-content">
              <div id="roomTimesSection" style="display: flex; flex-direction: column; height: 100%; overflow: auto;">
                <h2 style="border-bottom:1px solid #444; padding-bottom:10px;">Room Times</h2>
                
                <div class="form-group" style="margin-bottom:20px;">
                  <label for="roomSelector" style="display:block; margin-bottom:5px;">Select Room:</label>
                  <div style="max-height:150px; overflow-y:auto; border:1px solid #555; border-radius:4px;">
                    <select name="roomSelector" id="roomSelector" class="form-control" style="width:100%; padding:5px; background-color:#333; color:#fff; border:none;">
                      ${Object.keys(this.roomTimeData).map(room => `<option value="${room}">${room}</option>`).join('')}
                    </select>
                  </div>
                </div>
                <div class="room-info">
                  <p style="color:#ddd;">Total time: <span id="roomTime">${this.formatTime(this.roomTimeData[this.selectedRoom] || 0)}</span></p>
                  <p style="color:#ddd;">Total drawing time: <span id="drawingTime">${this.formatTime(this.drawingTimeData[this.selectedRoom] || 0)}</span></p>
                  <hr style="border-color:#444;">
                  <p style="color:#ddd;">Current session time: <span id="sessionRoomTime">${this.formatTime(this.sessionRoomTime[this.selectedRoom] || 0)}</span></p>
                  <p style="color:#ddd;">Current session drawing time: <span id="sessionDrawingTime">${this.formatTime(this.sessionDrawingTime[this.selectedRoom] || 0)}</span></p>
                  <hr style="border-color:#444;">
                  <h3 style="margin-top:20px; font-size:20px;">Overall Totals</h3>
                  <p style="color:#ddd;">Overall total time (all rooms): <span id="overallRoomTime">${this.formatTime(this.calculateOverallTime(this.roomTimeData))}</span></p>
                  <p style="color:#ddd;">Overall total drawing time (all rooms): <span id="overallDrawingTime">${this.formatTime(this.calculateOverallTime(this.drawingTimeData))}</span></p>
                </div>
                
                <!-- Tracker info message moved to bottom -->
                <div id="trackerInfoMessage" style="font-size: 0.9em; margin-top: 20px; padding: 8px 12px; background-color: rgba(0, 123, 255, 0.2); border-left: 4px solid #007bff; color: #b8daff; border-radius: 4px; display: none;">
                  <i class="fa fa-info-circle" style="margin-right: 5px; color: #b8daff;"></i>
                  Room Times tracking is currently disabled. Enable it in the Trackers tab to use this feature.
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 5px;">
                    <a href="#" id="goToTrackersTab" style="color: #ffffff; text-decoration: underline;">Go to Trackers</a>
                    <button id="dismissTrackerInfo" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 2px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">Got it!</button>
                  </div>
                </div>
              </div>
      
              <div id="ipStatsSection" style="display:none; flex: 1; overflow: hidden;"></div>
            </div>
          </div>
        `);
      
        // Store the current subcontent for later checks
        this._currentSubcontent = "info";
      
        // Add localStorage key for dismissing the tracker info
        config.localStorageKeys.dismissedTrackerInfo = "dismissedTrackerInfo";
        
        // Initialize with default value if not set
        if (!localStorage.getItem(config.localStorageKeys.dismissedTrackerInfo)) {
          localStorage.setItem(config.localStorageKeys.dismissedTrackerInfo, "false");
        }
        
        // Check if the Room Times Tracker is enabled
        const enableRoomTimesTracker = localStorage.getItem(config.localStorageKeys.enableRoomTimesTracker) === "true";
        const isTrackerInfoDismissed = localStorage.getItem(config.localStorageKeys.dismissedTrackerInfo) === "true";
        
        // Only show message if tracker is disabled and user hasn't dismissed it
        if (!enableRoomTimesTracker && !isTrackerInfoDismissed) {
          this.content.find("#trackerInfoMessage").show();
        } else {
          this.content.find("#trackerInfoMessage").hide();
        }
        
        // Add event handler for dismissing the message
        this.content.find("#dismissTrackerInfo").on("click", function(e) {
          e.preventDefault();
          localStorage.setItem(config.localStorageKeys.dismissedTrackerInfo, "true");
          $("#trackerInfoMessage").fadeOut(200);
        });
        
        // Add event handler for going to trackers tab
        this.content.find("#goToTrackersTab").on("click", (e) => {
          e.preventDefault();
          
          // Navigate to trackers tab
          if (this.loadPage) {
            this.loadPage("trackers");
          }
        });
      
        const currentSelectedRoom = this.selectedRoom;
        this.content.find("#roomSelector").val(currentSelectedRoom);
        this.content.find("#roomSelector").on("change", function () {
          _this.selectedRoom = $(this).val();
          _this.updateTimersDisplay();
        });
        this.updateTimersDisplay();
        
        // Clear any existing interval before setting a new one
        if (this.trackerMessageInterval) {
          clearInterval(this.trackerMessageInterval);
        }
        
        this.trackerMessageInterval = setInterval(() => {
          // First check if we're still on the info page
          if (this._currentSubcontent !== "info") {
            clearInterval(this.trackerMessageInterval);
            this.trackerMessageInterval = null;
            return;
          }
          
          const enableRoomTimesTracker = localStorage.getItem(config.localStorageKeys.enableRoomTimesTracker) === "true";
          const isTrackerInfoDismissed = localStorage.getItem(config.localStorageKeys.dismissedTrackerInfo) === "true";
          
          if (!enableRoomTimesTracker && !isTrackerInfoDismissed) {
            this.content.find("#trackerInfoMessage").fadeIn(200);
          } else {
            this.content.find("#trackerInfoMessage").fadeOut(200);
          }
        }, 2000); // Check every 2 seconds
        
        // Also set up regular updates for the time display
        setInterval(() => _this.updateTimersDisplay(), config.timers.roomUpdateInterval);
      
        /** Handle switches between "Room Times" and "IP Stats". */
        this.content.find("#roomTimesBtn").on("click", () => {
          this.content.find("#roomTimesSection").show();
          this.content.find("#ipStatsSection").hide();
          this.content.find("#roomTimesBtn").addClass("active");
          this.content.find("#ipStatsBtn").removeClass("active");
        });
        
        // Rest of the code remains unchanged...
        
        this.content.find("#ipStatsBtn").on("click", async () => {
          this.content.find("#roomTimesSection").hide();
          this.content.find("#ipStatsSection").show();
          this.content.find("#roomTimesBtn").removeClass("active");
          this.content.find("#ipStatsBtn").addClass("active");
        
          // Create a scrollable container for stats content
          if (!this.content.find("#ipStatsScrollContainer").length) {
// Update the IP stats section structure
this.content.find("#ipStatsSection").html(`
  <style>
    #ipStatsSection {
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }
    #ipStatsContainer {
      background: #1a1a1a;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      margin-bottom: 15px;
      display: flex;
      flex-direction: column;
      flex: 1;
      overflow: hidden;
      min-height: 0; /* Important for Firefox */
    }
    #ipStatsScrollContainer {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
      border-radius: 6px 6px 0 0;
    }
    #ipStatsButtons {
      background: #222;
      padding: 12px 15px;
      border-top: 1px solid #333;
      border-radius: 0 0 6px 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .section-header {
      border-bottom: 1px solid #444;
      padding-bottom: 10px;
      margin-bottom: 15px;
    }
  </style>
  
  <h2 class="section-header">IP Stats</h2>
  
  <!-- IP Stats tracker warning message -->
  <div id="ipTrackerInfoMessage" style="font-size: 0.9em; margin: 0 0 15px 0; padding: 8px 12px; background-color: rgba(0, 123, 255, 0.2); border-left: 4px solid #007bff; color: #b8daff; border-radius: 4px; display: none;">
    <i class="fa fa-info-circle" style="margin-right: 5px; color: #b8daff;"></i>
    IP Statistics tracking is currently disabled. Enable it in the Trackers tab to use this feature.
    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 5px;">
      <a href="#" id="goToTrackersTabFromIP" style="color: #ffffff; text-decoration: underline;">Go to Trackers</a>
      <button id="dismissIPTrackerInfo" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 2px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">Got it!</button>
    </div>
  </div>
  
  <div id="ipStatsContainer">
    <div id="ipStatsScrollContainer">
      <div id="ipStatsText">
        <div style="text-align:center; padding:40px 20px;">
          <i class="fa fa-spinner fa-spin" style="font-size:24px; margin-bottom:10px; color:#666;"></i>
          <p style="color:#999;">Loading statistics data...</p>
        </div>
      </div>
    </div>
    
    <div id="ipStatsButtons">
      <div style="display:flex; gap:10px;">
        <button id="downloadBeautifulStats" style="padding:8px 12px; background:#2c2c2c; color:#fff; border:none; cursor:pointer; border-radius:4px; display:flex; align-items:center; transition:background 0.2s;">
          <i class="fa fa-download" style="margin-right:6px;"></i> HTML Report
        </button>
        <button id="downloadCsvStats" style="padding:8px 12px; background:#2c2c2c; color:#fff; border:none; cursor:pointer; border-radius:4px; display:flex; align-items:center; transition:background 0.2s;">
          <i class="fa fa-table" style="margin-right:6px;"></i> Export CSV
        </button>
      </div>
      <div style="margin-left:auto;">
        <button id="importCsvStats" style="padding:8px 12px; background:#2a4d69; color:#fff; border:none; cursor:pointer; border-radius:4px; display:flex; align-items:center; transition:background 0.2s;">
          <i class="fa fa-upload" style="margin-right:6px;"></i> Import CSV
        </button>
        <input type="file" id="importCsvInput" style="display: none;" accept=".csv">
      </div>
    </div>
  </div>
  
  <style>
    #ipStatsButtons button:not(#importCsvStats):hover {
      background: #444 !important;
    }
    #ipStatsButtons #importCsvStats:hover {
      background: #3a6999 !important;
    }
    #ipStatsScrollContainer::-webkit-scrollbar {
      width: 8px;
    }
    #ipStatsScrollContainer::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 4px;
    }
    #ipStatsScrollContainer::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
    }
    #ipStatsScrollContainer::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
  </style>
`);

// Add localStorage key for dismissing the IP tracker info
config.localStorageKeys.dismissedIPTrackerInfo = "dismissedIPTrackerInfo";

// Initialize with default value if not set
if (!localStorage.getItem(config.localStorageKeys.dismissedIPTrackerInfo)) {
  localStorage.setItem(config.localStorageKeys.dismissedIPTrackerInfo, "false");
}

// Check if IP Tracker is enabled
const enableIPTracker = localStorage.getItem(config.localStorageKeys.enableIPTracker) === "true";
const isIPTrackerInfoDismissed = localStorage.getItem(config.localStorageKeys.dismissedIPTrackerInfo) === "true";

// Only show message if tracker is disabled and user hasn't dismissed it
if (!enableIPTracker && !isIPTrackerInfoDismissed) {
  this.content.find("#ipTrackerInfoMessage").show();
} else {
  this.content.find("#ipTrackerInfoMessage").hide();
}

// Add event handler for dismissing the IP tracker message
this.content.find("#dismissIPTrackerInfo").on("click", function(e) {
  e.preventDefault();
  localStorage.setItem(config.localStorageKeys.dismissedIPTrackerInfo, "true");
  $("#ipTrackerInfoMessage").fadeOut(200);
});

// Add event handler for going to trackers tab
this.content.find("#goToTrackersTabFromIP").on("click", (e) => {
  e.preventDefault();
  
  // Navigate to trackers tab
  if (this.loadPage) {
    this.loadPage("trackers");
  }
});

this.content.find("#importCsvStats").on("click", () => {
  this.content.find("#importCsvInput").click();
});

this.content.find("#importCsvInput").on("change", async (event) => {
  const file = event.target.files[0];
  if (!file) return;
  
  try {
    // Show import status
    this.content.find("#ipStatsText").html(`
      <div style="text-align:center; padding: 20px;">
        <p><i class="fa fa-spinner fa-spin"></i> Importing CSV data...</p>
        <p id="importStatus">Reading file...</p>
      </div>
    `);
    
    const updateStatus = (msg) => {
      this.content.find("#importStatus").text(msg);
    };
    
    // Read the file
    const text = await new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (e) => resolve(e.target.result);
      reader.readAsText(file);
    });
    
    updateStatus("Parsing CSV data...");
    
    // Parse CSV
    const rows = text.split('\n').map(row => {
      // Handle CSV escaping (quotes, commas)
      const result = [];
      let insideQuotes = false;
      let currentValue = '';
      
      for (let i = 0; i < row.length; i++) {
        const char = row[i];
        
        if (char === '"') {
          if (insideQuotes && row[i+1] === '"') {
            // Double quotes inside quotes = escaped quote
            currentValue += '"';
            i++; // Skip next quote
          } else {
            // Toggle quotes state
            insideQuotes = !insideQuotes;
          }
        } else if (char === ',' && !insideQuotes) {
          // End of field
          result.push(currentValue);
          currentValue = '';
        } else {
          currentValue += char;
        }
      }
      
      // Add the last value
      result.push(currentValue);
      return result;
    });
    
    // Skip header rows
    const dataRows = rows.slice(4);
    
    updateStatus("Rebuilding data structure...");
    
    // Process hierarchical data
    const stats = {};
    let currentYear = null;
    let currentMonth = null;
    let currentDay = null;
    let processed = 0;
    
    for (const row of dataRows) {
      if (row.length < 3 || !row[0]) continue; // Skip empty rows
      
      const [timePeriod, uniqueIPsStr, peakUsersStr, ipAddressesStr] = row;
      const uniqueIPs = parseInt(uniqueIPsStr) || 0;
      const peakUsers = parseInt(peakUsersStr) || 0;
      
      // Parse IP addresses if present
      const ipAddresses = ipAddressesStr ? ipAddressesStr.split(';').filter(ip => ip) : [];
      
      if (timePeriod.startsWith('Year')) {
        // Year row
        const year = timePeriod.match(/Year (\d+)/)[1];
        currentYear = year;
        currentMonth = null;
        currentDay = null;
        
        // No need to store year data separately as we'll rebuild from months
      } else if (timePeriod.match(/^\s+[A-Za-z]+ \d{4}$/)) {
        // Month row (indented with month name and year)
        const matches = timePeriod.match(/\s+([A-Za-z]+) (\d{4})/);
        const monthName = matches[1];
        
        // Convert month name to number
        const monthNames = ["January", "February", "March", "April", "May", "June", 
                           "July", "August", "September", "October", "November", "December"];
        const monthNum = monthNames.findIndex(m => m === monthName) + 1;
        
        if (monthNum > 0) {
          currentMonth = monthNum.toString();
          currentDay = null;
          
          // Initialize the month structure
          const key = `ipStats_${currentYear}_${currentMonth}`;
          
          // Use actual IPs if available, otherwise generate placeholders
          const uniqueIPsArray = ipAddresses.length > 0 ? 
            ipAddresses : 
            new Array(uniqueIPs).fill().map((_, i) => `ip_${currentYear}_${currentMonth}_${i}`);
            
          stats[key] = {
            days: {},
            uniqueIPs: uniqueIPsArray,
            peak: peakUsers
          };
        }
        
      } else if (timePeriod.match(/^\s{4}[A-Za-z]+ \d+, \d{4}$/)) {
        // Day row (more indented with month, day, year)
        const matches = timePeriod.match(/\s{4}[A-Za-z]+ (\d+), \d{4}/);
        currentDay = matches[1];
        
        // Add day to current month
        const key = `ipStats_${currentYear}_${currentMonth}`;
        if (stats[key]) {
          // Use actual IPs if available, otherwise generate placeholders
          const uniqueIPsArray = ipAddresses.length > 0 ? 
            ipAddresses : 
            new Array(uniqueIPs).fill().map((_, i) => `ip_${currentYear}_${currentMonth}_${currentDay}_${i}`);
            
          stats[key].days[currentDay] = {
            hours: {},
            uniqueIPs: uniqueIPsArray,
            peak: peakUsers
          };
        }
        
      } else if (timePeriod.match(/^\s{6}\d{2}:\d{2} - \d{2}:\d{2}$/)) {
        // Hour row (even more indented with time range)
        const hourMatch = timePeriod.match(/\s{6}(\d{2}):\d{2}/);
        const hour = parseInt(hourMatch[1]);
        
        // Add hour to current day
        const key = `ipStats_${currentYear}_${currentMonth}`;
        if (stats[key] && stats[key].days[currentDay]) {
          // Use actual IPs if available, otherwise generate placeholders
          const uniqueIPsArray = ipAddresses.length > 0 ? 
            ipAddresses : 
            new Array(uniqueIPs).fill().map((_, i) => `ip_${currentYear}_${currentMonth}_${currentDay}_${hour}_${i}`);
            
          stats[key].days[currentDay].hours[hour] = {
            uniqueIPs: uniqueIPsArray,
            count: peakUsers,
            peak: peakUsers
          };
        }
      }
      
      processed++;
      if (processed % 100 === 0) {
        updateStatus(`Processed ${processed} rows...`);
        // Give UI a chance to update
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }
    
    updateStatus("Saving to IndexedDB...");
    
    // Save data to IndexedDB
    let savedCount = 0;
    for (const [key, data] of Object.entries(stats)) {
      await IDBHelper.setItem(key, data);
      savedCount++;
      
      if (savedCount % 10 === 0) {
        updateStatus(`Saved ${savedCount}/${Object.keys(stats).length} months...`);
        // Give UI a chance to update
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }
    
    // CRITICAL FIX: Properly reinitialize the tracker
    updateStatus("Reinitializing tracker cache...");
    
    // First set cache to null to force rebuild
    IPTracker._statsCache = null;
    
    try {
      // Completely reinitialize the tracker structure
      await IPTracker.init();
    } catch (initError) {
    }
    
    // Show success message
    this.content.find("#ipStatsText").html(`
      <div style="text-align:center; padding: 20px;">
        <p style="color: #4CAF50;"><i class="fa fa-check-circle"></i> Import completed successfully!</p>
        <p>Imported data for ${Object.keys(stats).length} months.</p>
        <p>Click on "IP Stats" tab again to view the imported data.</p>
      </div>
    `);
    
  } catch (error) {
    this.content.find("#ipStatsText").html(`
      <div style="text-align:center; padding: 20px;">
        <p style="color: #F44336;"><i class="fa fa-exclamation-circle"></i> Import failed</p>
        <p>${error.message}</p>
        <pre style="text-align: left; background: #222; padding: 10px; max-height: 200px; overflow: auto;">${error.stack}</pre>
      </div>
    `);
  }
  
  // Reset the file input
  event.target.value = '';
});
            // Add click handlers for the buttons
            this.content.find("#downloadBeautifulStats").on("click", async () => {
              const extStats = await IPTracker.getExtendedStats();
              const htmlContent = this.generateBeautifulHtmlStats(extStats);
              const blob = new Blob([htmlContent], { type: "text/html" });
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = "Flockmod_Stats.html";
              a.click();
              URL.revokeObjectURL(url);
            });
        
            this.content.find("#downloadCsvStats").on("click", async () => {
              const extStats = await IPTracker.getExtendedStats();
              await this.downloadCsvStats(extStats);
            });
          }
        
          // Show loading indicator
          this.content.find("#ipStatsText").html(`
            <div style="text-align:center">
              <p>Loading statistics...</p>
            </div>
          `);
        
          try {
            // Use asynchronous calls to the updated IPTracker methods
            const stats = await IPTracker.getStats(7); // 7-day IP stats
            const extStats = await IPTracker.getExtendedStats();
            
            // Display the stats UI with the data
            this.displayIPStats(stats, extStats);
          } catch (error) {
            this.content.find("#ipStatsText").html(`
              <div style="padding:10px;">
                <h3>Error Loading Statistics</h3>
                <p>There was an error loading the IP statistics: ${error.message}</p>
                <pre style="background:#111; padding:10px; overflow:auto; max-height:150px;">${error.stack}</pre>
              </div>
            `);
          }
        }),
        

this.content.find("#downloadBeautifulStats").on("click", async () => {
  const extStats = await IPTracker.getExtendedStats();
  const htmlContent = this.generateBeautifulHtmlStats(extStats);
  const blob = new Blob([htmlContent], { type: "text/html" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "Flockmod_Stats.html";
  a.click();
  URL.revokeObjectURL(url);
});

this.content.find("#downloadCsvStats").on("click", async () => {
  const extStats = await IPTracker.getExtendedStats();
  const currentDate = new Date();
  const formattedDate = `${currentDate.getFullYear()}-${currentDate.getMonth() + 1}-${currentDate.getDate()}`;
  
  // Create a hierarchical structure that mirrors our data model
  const csvRows = [
    ["Flockmod Hierarchical IP Statistics", "", ""],
    ["Generated On", formattedDate, ""],
    ["", "", ""],
    ["Time Period", "Unique IPs", "Peak Users"]
  ];
  
  // Sort years in ascending order
  const years = Object.keys(extStats.yearMonthly || {}).sort((a, b) => Number(a) - Number(b));
  
  // Process each year hierarchically
  for (const year of years) {
    // Add year row
    const yearIPs = extStats.year[year] || [];
    const yearPeak = Math.max(...Object.values(extStats.yearMonthly[year] || {}).map(m => m.peak || 0), 0);
    csvRows.push([`Year ${year}`, yearIPs.length, yearPeak]);
    
    // Sort months in ascending order
    const months = Object.keys(extStats.yearMonthly[year] || {}).sort((a, b) => Number(a) - Number(b));
    
    // Process each month in the year
    for (const month of months) {
      const monthData = extStats.yearMonthly[year][month];
      const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      const monthName = monthNames[Number(month) - 1] || `Month ${month}`;
      
      // Add month row with indentation
      csvRows.push([`  ${monthName} ${year}`, monthData.uniqueIPs?.length || 0, monthData.peak || 0]);
      
      // Get day stats from our hierarchical structure
      // We need to make a direct call to get day data since extStats might not have it all
      const monthStats = await IPTracker.getHierarchicalStats(year, month);
      
      if (monthStats && monthStats.days) {
        // Process each day in the month
        const days = Object.keys(monthStats.days).sort((a, b) => Number(a) - Number(b));
        
        for (const day of days) {
          const dayData = monthStats.days[day];
          
          // Add day row with more indentation
          csvRows.push([`    ${monthName} ${day}, ${year}`, dayData.uniqueIPs?.length || 0, dayData.peak || 0]);
          
          // Process each hour in the day if available
          if (dayData.hours) {
            const hours = Object.keys(dayData.hours).sort((a, b) => Number(a) - Number(b));
            
            for (const hour of hours) {
              const hourData = dayData.hours[hour];
              
              // Format the time with leading zeros and AM/PM
              const timeFormat = (h) => {
                const hr = Number(h);
                return `${hr.toString().padStart(2, '0')}:00 - ${hr.toString().padStart(2, '0')}:59`;
              };
              
              // Add hour row with even more indentation
              csvRows.push([
                `      ${timeFormat(hour)}`,
                hourData.uniqueIPs?.length || 0,
                hourData.count || 0 // For hours we use actual count, not peak
              ]);
            }
          }
        }
      }
    }
    
    // Add a blank row after each year for better readability
    csvRows.push(["", "", ""]);
  }
  
  // Convert rows to CSV format
  const csvContent = csvRows.map(row => {
    return row.map(cell => {
      // Escape commas and quotes in cells
      const cellStr = String(cell).replace(/"/g, '""');
      return `"${cellStr}"`;
    }).join(',');
  }).join('\n');
  
  // Create download
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `Flockmod_Hierarchical_Stats_${formattedDate}.csv`;
  a.click();
  URL.revokeObjectURL(url);
});
      }

      else if (subcontent === "undo") {
        this.loadSubcontent(`
          <style>
            #undoSection {
              display: flex;
              flex-direction: column;
              height: 100%;
              overflow: hidden;
            }
            #undoContainer {
              flex: 1;
              overflow-y: auto;
              padding-right: 10px;
              margin-bottom: 15px;
            }
            .styled-input {
              padding: 5px;
              background: #333;
              color: #ddd;
              border: 1px solid #444;
              border-radius: 4px;
            }
            .styled-checkbox {
              appearance: none;
              -webkit-appearance: none;
              -moz-appearance: none;
              width: 20px;
              height: 20px;
              border: 2px solid #333;
              border-radius: 4px;
              display: inline-block;
              position: relative;
              cursor: pointer;
              background-color: #333;
            }
            .styled-checkbox:checked::after {
              content: '\\2714';
              color: #28a745;
              position: absolute;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              font-size: 14px;
            }
            .styled-dropdown {
              width: 100%;
              padding: 5px;
              background: #333;
              color: #ddd;
              border: 1px solid #444;
              border-radius: 4px;
              cursor: pointer;
            }
            .action-button {
              padding: 5px 10px;
              background: #444;
              color: #fff;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              margin-left: 10px;
              transition: background 0.2s;
            }
            .action-button:hover {
              background: #555;
            }
            #undoContainer::-webkit-scrollbar {
              width: 8px;
            }
            #undoContainer::-webkit-scrollbar-track {
              background: #1e1e1e;
              border-radius: 4px;
            }
            #undoContainer::-webkit-scrollbar-thumb {
              background: #444;
              border-radius: 4px;
            }
            #undoContainer::-webkit-scrollbar-thumb:hover {
              background: #555;
            }
            #hotkeyWarning {
              margin-top: 10px;
              padding: 8px 12px;
              background-color: rgba(255, 165, 0, 0.2);
              border-left: 4px solid #ffa500;
              color: #ffd280;
              border-radius: 4px;
              display: none;
            }
            .settings-row {
              display: flex;
              align-items: center;
              margin-bottom: 20px;
              position: relative;
            }
            .checkbox-label {
              display: flex;
              align-items: center;
              gap: 10px;
              cursor: pointer;
              /* Width will be set dynamically via JS */
            }
            .action-button {
              width: 120px;
            }
          </style>
        
          <div id="undoSection">
            <div id="undoContainer">
              <h2 style="border-bottom: 1px solid #444; padding-bottom: 10px;">Step Back Settings</h2>
              
              <!-- Undo Steps Setting -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="undoStepsInput" style="display: flex; flex-direction: column; cursor: pointer;">
                  <span>Undo Steps:</span>
                  <input 
                    type="number" 
                    id="undoStepsInput" 
                    class="styled-input" 
                    style="margin-top: 10px; padding: 5px; width: 100px; border: 1px solid #555; border-radius: 4px; background: #222; color: #ddd;" 
                    min="0"
                    step="1"
                  >
                </label>
                <p style="color: #999; font-size: 12px; margin: 15px 0 10px 0px;">Updates only if history is clear when adjusting. Commit Now first.</p>              </div>
        
          <!-- Commit Undo History Setting -->
          <div class="settings-row">
            <label for="commitUndoHistory" class="checkbox-label">
              <input type="checkbox" id="commitUndoHistory" class="styled-checkbox">
              Commit Step Back Button
            </label>
            <button id="commitUndoHistoryAction" class="action-button"><i class="fa fa-check" style="margin-right: 5px;"></i> Commit Now</button>
          </div>

          <!-- Toggle Undo History Setting -->
          <div class="settings-row">
            <label for="toggleUndoHistory" class="checkbox-label">
              <input type="checkbox" id="toggleUndoHistory" class="styled-checkbox">
              Toggle Step Back Button
            </label>
            <button id="toggleUndoHistoryAction" class="action-button"><i class="fa fa-history" style="margin-right: 5px;"></i> Toggle Now</button>
          </div>

          <!-- Clear Undo History Setting -->
          <div class="settings-row">
            <label for="clearUndoHistory" class="checkbox-label">
              <input type="checkbox" id="clearUndoHistory" class="styled-checkbox">
              Clear Step Back Button
            </label>
            <button id="clearUndoHistoryAction" class="action-button"><i class="fa fa-times" style="margin-right: 5px;"></i> Clear Now</button>
          </div>
          
          <!-- Undo Action Setting -->
          <div class="settings-row">
            <label for="undoAction" class="checkbox-label">
              <input type="checkbox" id="undoAction" class="styled-checkbox">
              Undo Action Button
            </label>
            <button id="undoActionNow" class="action-button"><i class="fa fa-reply" style="margin-right: 5px;"></i> Undo Now</button>
          </div>

          <!-- Redo Action Setting -->
          <div class="settings-row">
            <label for="redoAction" class="checkbox-label">
              <input type="checkbox" id="redoAction" class="styled-checkbox">
              Redo Action Button
            </label>
            <button id="redoActionNow" class="action-button"><i class="fa fa-share" style="margin-right: 5px;"></i> Redo Now</button>
          </div>
              
            <!-- Current Undo State Indicator -->
            <p id="undoHistoryStateIndicator" style="color: #999; font-size: 12px; margin: 0px 0 20px 0px;">
              Current Undo History: <span id="undoHistoryState">Off</span>
            </p>

              <!-- Default Undo History Behavior -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="undoHistoryDefault" style="display: block; margin-bottom: 5px;">
                  Undo History by Default
                </label>
                <select id="undoHistoryDefault" class="styled-dropdown">
                  <option value="enabled">Always Enabled on Start</option>
                  <option value="disabled">Always Disabled on Start</option>
                  <option value="recorded">Recorded State</option>
                </select>
              </div>
              
              <p style="font-size: 0.9em; color: #bbb; margin-top: 10px; margin-bottom: 10px;">
                Note: The buttons above take effect immediately. Checkboxes control whether the buttons appear in the bottombar.
              </p>
              
<!-- Hotkey Info Message -->
<div id="hotkeyWarning" style="font-size: 0.9em; margin-top: 10px; padding: 8px 12px; background-color: rgba(0, 123, 255, 0.2); border-left: 4px solid #007bff; color: #b8daff; border-radius: 4px; display: none;">
  <i class="fa fa-info-circle" style="margin-right: 5px; color: #b8daff;"></i>
  You can set up keyboard shortcuts for undo and redo in Settings.
  <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 5px;">
    <a href="#" id="goToShortcutSettings" style="color: #ffffff; text-decoration: underline;">Go to Shortcuts</a>
    <button id="dismissHotkeyInfo" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 2px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">Got it!</button>
  </div>
</div>
            </div>
        `);

        config.localStorageKeys.undoSteps = "undoSteps";
        config.localStorageKeys.commitUndoHistory = "commitUndoHistory";
        config.localStorageKeys.toggleUndoHistory = "toggleUndoHistory";
        config.localStorageKeys.clearUndoHistory = "clearUndoHistory";
        config.localStorageKeys.undoHistoryDefault = "undoHistoryDefault";
        config.localStorageKeys.undoAction = "undoAction"; // New key
        config.localStorageKeys.redoAction = "redoAction"; // New key
        config.localStorageKeys.dismissedUndoHotkeyInfo = "dismissedUndoHotkeyInfo"; // New key for dismissal state
        
        // Then initialize localStorage with defaults only if values don't exist
        if (!localStorage.getItem(config.localStorageKeys.dismissedUndoHotkeyInfo)) {
          localStorage.setItem(config.localStorageKeys.dismissedUndoHotkeyInfo, "false");
        }
        
        // Then initialize localStorage with defaults only if values don't exist
        if (!localStorage.getItem(config.localStorageKeys.undoSteps)) {
          localStorage.setItem(config.localStorageKeys.undoSteps, "5");
        }
        if (!localStorage.getItem(config.localStorageKeys.commitUndoHistory)) {
          localStorage.setItem(config.localStorageKeys.commitUndoHistory, "false");
        }
        if (!localStorage.getItem(config.localStorageKeys.toggleUndoHistory)) {
          localStorage.setItem(config.localStorageKeys.toggleUndoHistory, "false");
        }
        if (!localStorage.getItem(config.localStorageKeys.clearUndoHistory)) {
          localStorage.setItem(config.localStorageKeys.clearUndoHistory, "false");
        }
        if (!localStorage.getItem(config.localStorageKeys.undoHistoryDefault)) {
          localStorage.setItem(config.localStorageKeys.undoHistoryDefault, "disabled");
        }
        if (!localStorage.getItem(config.localStorageKeys.undoAction)) {
          localStorage.setItem(config.localStorageKeys.undoAction, "false");
        }
        if (!localStorage.getItem(config.localStorageKeys.redoAction)) {
          localStorage.setItem(config.localStorageKeys.redoAction, "false");
        }
        
        // Set initial state from localStorage
        const undoSteps = parseInt(localStorage.getItem(config.localStorageKeys.undoSteps)) || 5;
        const commitUndoHistory = localStorage.getItem(config.localStorageKeys.commitUndoHistory) === "true";
        const toggleUndoHistory = localStorage.getItem(config.localStorageKeys.toggleUndoHistory) === "true";
        const clearUndoHistory = localStorage.getItem(config.localStorageKeys.clearUndoHistory) === "true";
        const undoHistoryDefault = localStorage.getItem(config.localStorageKeys.undoHistoryDefault) || "disabled";
        const undoAction = localStorage.getItem(config.localStorageKeys.undoAction) === "true";
        const redoAction = localStorage.getItem(config.localStorageKeys.redoAction) === "true";
        
        // Add a new variable to track the current state (separate from button visibility)
        const isUndoHistoryEnabled = localStorage.getItem("undoHistoryEnabled") === "true";
        
        this.content.find("#undoStepsInput").val(undoSteps);
        this.content.find("#commitUndoHistory").prop("checked", commitUndoHistory);
        this.content.find("#toggleUndoHistory").prop("checked", toggleUndoHistory);
        this.content.find("#clearUndoHistory").prop("checked", clearUndoHistory);
        this.content.find("#undoHistoryDefault").val(undoHistoryDefault);
        this.content.find("#undoAction").prop("checked", undoAction);
        this.content.find("#redoAction").prop("checked", redoAction);
        
        // Add an indicator of current toggle state to the UI
        this.content.find("#undoHistoryState").text(isUndoHistoryEnabled ? "On" : "Off");
        this.content.find("#toggleUndoHistoryAction").html(
          `<i class="fa fa-history" style="margin-right: 5px;"></i> Toggle Now`
        );
      
        // Clear any existing undo update interval
        if (this.undoUpdateInterval) {
          clearInterval(this.undoUpdateInterval);
          this.undoUpdateInterval = null;
        }
        
        // Function to check if the undo hotkey is configured
        const checkUndoHotkey = () => {
          // Check if user has dismissed the message permanently
          const isDismissed = localStorage.getItem(config.localStorageKeys.dismissedUndoHotkeyInfo) === "true";
          if (isDismissed) {
            this.content.find("#hotkeyWarning").hide();
            return true; // Skip further checks if dismissed
          }
          
          if (UI?.shortcutManager?.shortcuts) {
            const undoShortcut = UI.shortcutManager.shortcuts.find(s => s.id === 'undomodded');
            // Check if the shortcut exists and has at least one key binding
            const hasHotkey = undoShortcut && (undoShortcut.shortcut || undoShortcut.shortcut2);
            
            // Show or hide the warning based on hotkey presence
            if (hasHotkey) {
              this.content.find("#hotkeyWarning").fadeOut(200);
            } else {
              this.content.find("#hotkeyWarning").fadeIn(200);
            }
            
            return hasHotkey;
          }
          return false;
        };
        
        // Check hotkey status initially
        checkUndoHotkey();

        this.content.find("#dismissHotkeyInfo").on("click", function(e) {
          e.preventDefault();
          // Set localStorage flag to remember user's choice
          localStorage.setItem(config.localStorageKeys.dismissedUndoHotkeyInfo, "true");
          // Hide the info message
          $("#hotkeyWarning").fadeOut(200);
        });
        
        // Create a function to update the toggle state indicator
        const updateUndoToggleState = () => {
          const currentState = UI.undoHistoryEnabled === true;
          const stateText = currentState ? "On" : "Off";
          const currentStateText = this.content.find("#undoHistoryState").text();
          
          // Only update the DOM if the state has changed
          if (stateText !== currentStateText) {
            this.content.find("#undoHistoryState").text(stateText);
            
            // Add a brief highlight effect to indicate the change
            this.content.find("#undoHistoryStateIndicator").css({
              'background-color': '#444',
              'transition': 'background-color 0.5s'
            });
            
            setTimeout(() => {
              this.content.find("#undoHistoryStateIndicator").css({
                'background-color': 'transparent',
                'transition': 'background-color 1s'
              });
            }, 300);
          }
          
          // Also check hotkey status periodically
          checkUndoHotkey();
        };
        
        // Set up the interval to update the UI every second
        this.undoUpdateInterval = setInterval(updateUndoToggleState, 1000);
        
        // Calculate and set optimal width for checkbox labels
        const calculateOptimalLabelWidth = () => {
          // Get all checkbox label elements
          const labelElements = this.content.find(".checkbox-label");
          if (labelElements.length === 0) return;
          
          // Create a temporary element to measure text width
          const tempElement = document.createElement("span");
          tempElement.style.visibility = "hidden";
          tempElement.style.position = "absolute";
          tempElement.style.whiteSpace = "nowrap";
          tempElement.style.font = window.getComputedStyle(labelElements[0]).font;
          document.body.appendChild(tempElement);
          
          // Find the longest label width
          let maxWidth = 0;
          labelElements.each(function() {
            // Get text content without the checkbox
            const labelText = $(this).text().trim();
            tempElement.textContent = labelText;
            const width = tempElement.offsetWidth;
            maxWidth = Math.max(maxWidth, width);
          });
          
          // Remove the temporary element
          document.body.removeChild(tempElement);
          
          // Add padding for checkbox and spacing
          const totalWidth = maxWidth + 40; // 20px for checkbox, 20px for padding
          
          // Apply width to all checkbox labels
          labelElements.css("width", totalWidth + "px");
          
          return totalWidth;
        };
        
        // Calculate and apply the optimal width
        calculateOptimalLabelWidth();
        
        // Add click handler for the shortcut settings link
// Add click handler for the shortcut settings link
this.content.find("#goToShortcutSettings").on("click", (e) => {
  e.preventDefault();
  
  // First close the current dialog (which is the ModsDialog)
  // Then open config dialog and navigate to shortcuts
  if (UI?.dialogHandler) {
    // Close current dialog
    if (UI.dialogHandler.activeDialog) {
      UI.dialogHandler.activeDialog.hide();
    }
    
    // Use a timeout to ensure current dialog is fully closed
    setTimeout(() => {
      // Show config dialog
      UI.dialogHandler.showDialog("config");
      
      // Wait for config dialog to load, then navigate to shortcuts tab
      setTimeout(() => {
        const configDialog = UI.dialogHandler.dialogs.config;
        if (configDialog) {
          configDialog.loadPage("shortcuts");
        }
      }, 100); // Short delay to ensure dialog is ready
    }, 100);
  }
});

        // Add event handlers
        this.content.find("#undoStepsInput").on("input", function() {
          // Force whole numbers only
          let value = parseInt($(this).val()) || 0;
          if (value < 0) value = 0;
          
          // Update the input with the sanitized value
          $(this).val(value);
          
          // Save to localStorage
          localStorage.setItem(config.localStorageKeys.undoSteps, value.toString());
          
          // Check conditions before updating the board's maxUndoSteps
          if (room && room.board) {
            if (room.board.redoStack.length === 0 && 
                room.board.undoStack.length === 0 && 
                room.board.isProcessingCommit === false) {
              // All conditions met - update the board's maxUndoSteps in real-time
              window.updateUndoSteps(value);
            } else {
              // Conditions not met - show message explaining why
              
              // Still update once conditions are met
              const checkInterval = setInterval(() => {
                if (room && room.board && 
                    room.board.redoStack.length === 0 && 
                    room.board.undoStack.length === 0 && 
                    room.board.isProcessingCommit === false) {
                  window.updateUndoSteps(value);
                  clearInterval(checkInterval);
                }
              }, 1000); // Check every second until conditions are met
            }
          } else {
            // Room not initialized, just update when available
            window.updateUndoSteps(value);
          }
        });
        // Rest of the original event handlers remain the same
        this.content.find("#toggleUndoHistory").on("change", function() {
          const value = $(this).is(":checked");
          
          // Save visibility preference to localStorage
          localStorage.setItem(config.localStorageKeys.toggleUndoHistory, value.toString());
          
          // Show/hide the button based on checkbox state
          if (value) {
            UI.bottombar.showButton('toggleUndoHistoryButton');
          } else {
            UI.bottombar.hideButton('toggleUndoHistoryButton');
          }
          
          // Make sure current state is saved even if we don't toggle
          localStorage.setItem("undoHistoryEnabled", UI.undoHistoryEnabled.toString());
        });
        
        this.content.find("#commitUndoHistory").on("change", function() {
          const value = $(this).is(":checked");
          localStorage.setItem(config.localStorageKeys.commitUndoHistory, value.toString());
          
          // Show/hide the button based on checkbox state
          if (value) {
            UI.bottombar.showButton('commitUndoHistoryButton');
          } else {
            UI.bottombar.hideButton('commitUndoHistoryButton');
          }
          

        });
        
        this.content.find("#clearUndoHistory").on("change", function() {
          const value = $(this).is(":checked");
          localStorage.setItem(config.localStorageKeys.clearUndoHistory, value.toString());
          
          // Show/hide the button based on checkbox state
          if (value) {
            UI.bottombar.showButton('clearUndoHistoryButton');
          } else {
            UI.bottombar.hideButton('clearUndoHistoryButton');
          }
        });

        this.content.find("#undoAction").on("change", function() {
          const value = $(this).is(":checked");
          localStorage.setItem(config.localStorageKeys.undoAction, value.toString());
          
          // Show/hide the button based on checkbox state
          if (value) {
            UI.bottombar.showButton('executeUndoAction');
          } else {
            UI.bottombar.hideButton('executeUndoAction');
          }
        });
        
        this.content.find("#redoAction").on("change", function() {
          const value = $(this).is(":checked");
          localStorage.setItem(config.localStorageKeys.redoAction, value.toString());
          
          // Show/hide the button based on checkbox state
          if (value) {
            UI.bottombar.showButton('executeRedoAction');
          } else {
            UI.bottombar.hideButton('executeRedoAction');
          }
        });

        this.content.find("#undoHistoryDefault").on("change", function() {
          const value = $(this).val();
          localStorage.setItem(config.localStorageKeys.undoHistoryDefault, value);
        });
        this.content.find("#commitUndoHistoryAction").on("click", function() {
          // Simulate clicking the commitUndoHistoryButton in the bottombar
          if (UI.bottombar) {
            if (UI.uploader && UI.uploader.isVisible()) {
              UI.dialogHandler.showAlert("Cannot commit undo history while image transform is in progress. Please confirm or cancel the image operation first.");
            } else if (room && room.board) {
              room.board.commitAllPendingChanges();
            }
          }
        });
        
        // Second snippet - Menu action handler
        this.content.find("#toggleUndoHistoryAction").on("click", function() {
          // Simulate clicking the toggleUndoHistoryButton in the bottombar
          if (UI.bottombar) {
            if (UI.uploader && UI.uploader.isVisible()) {
              UI.dialogHandler.showAlert("Cannot toggle step back while image transform is in progress. Please confirm or cancel the image operation first.");
            } else if (socket && socket.isTransferInProgress) {
              UI.dialogHandler.showAlert("Cannot toggle step back while board transfer is in progress. Please wait for all transfers to complete.");
            } 
            // NEW: Check if there's an active selection
            else if (room.myself && room.myself.surface && 
                    room.myself.surface.brushHandler.brush && 
                    room.myself.surface.brushHandler.brush.isUsingSlate()) {
              UI.dialogHandler.showAlert("Cannot toggle step back while a selection is active. Please complete or cancel your selection first.");
            }
            else {
              UI.toggleUndoHistory();
              
              // Update status indicator immediately
              const isEnabled = UI.undoHistoryEnabled;
              $("#undoHistoryState").text(isEnabled ? "On" : "Off");
              
              // Add highlight effect for manual toggle
              $("#undoHistoryStateIndicator").css({
                'background-color': '#444',
                'transition': 'background-color 0.5s'
              });
              
              setTimeout(() => {
                $("#undoHistoryStateIndicator").css({
                  'background-color': 'transparent',
                  'transition': 'background-color 1s'
                });
              }, 300);
            }
          }
        });
        
        this.content.find("#clearUndoHistoryAction").on("click", function() {
          window.clearUndoHistory();
        });
        
        this.content.find("#undoActionNow").on("click", function() {
          if (room && room.board) {
            room.board.undo();
          } else {
          }
        });
        
        this.content.find("#redoActionNow").on("click", function() {
          if (room && room.board) {
            room.board.redo();
          } else {
          }
        });
      }
      else if (subcontent === "trackers") {
        // Define localStorage keys for trackers
        config.localStorageKeys.enableIPTracker = "enableIPTracker";
        config.localStorageKeys.enableRoomTimesTracker = "enableRoomTimesTracker";
      
        // Initialize localStorage with defaults if values don't exist
        if (!localStorage.getItem(config.localStorageKeys.enableIPTracker)) {
          localStorage.setItem(config.localStorageKeys.enableIPTracker, "false");
        }
        if (!localStorage.getItem(config.localStorageKeys.enableRoomTimesTracker)) {
          localStorage.setItem(config.localStorageKeys.enableRoomTimesTracker, "false");
        }
        
        // Get current values
        const enableIPTracker = localStorage.getItem(config.localStorageKeys.enableIPTracker) === "true";
        const enableRoomTimesTracker = localStorage.getItem(config.localStorageKeys.enableRoomTimesTracker) === "true";
        
        // Make sure config values are in sync with localStorage
        config.enableIPTracker = enableIPTracker;
        config.enableRoomTimesTracker = enableRoomTimesTracker;
      
        this.loadSubcontent(`
          <style>
            /* Scope all styles to the trackers-settings class to avoid conflicts */
            .trackers-settings .trackers-container {
              display: flex;
              flex-direction: column;
              height: 100%;
              overflow: auto;
              padding: 10px 0;
            }
            .trackers-settings .tracker-section {
              background: #2a2a2a;
              border-radius: 8px;
              padding: 20px;
              margin-bottom: 20px;
              box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            }
            .trackers-settings .tracker-title {
              font-size: 18px;
              margin-bottom: 5px;
              color: #ffffff;
              display: flex;
              align-items: center;
            }
            .trackers-settings .tracker-title i {
              margin-right: 10px;
              color: #7289da;
            }
            .trackers-settings .tracker-description {
              color: #aaaaaa;
              margin-bottom: 15px;
              line-height: 1.5;
            }
            .trackers-settings .tracker-toggle {
              display: flex;
              align-items: center;
              justify-content: space-between;
              margin-top: 10px;
              padding: 10px;
              background: #222;
              border-radius: 6px;
            }
            .trackers-settings .tracker-toggle-label {
              font-weight: bold;
              color: #ddd;
            }
            /* Toggle switch styling */
            .trackers-settings .switch {
              position: relative;
              display: inline-block;
              width: 60px;
              height: 30px;
            }
            .trackers-settings .switch input {
              opacity: 0;
              width: 0;
              height: 0;
            }
            .trackers-settings .slider {
              position: absolute;
              cursor: pointer;
              top: 0;
              left: 0;
              right: 0;
              bottom: 0;
              background-color: #444;
              transition: .4s;
              border-radius: 34px;
            }
            .trackers-settings .slider:before {
              position: absolute;
              content: "";
              height: 22px;
              width: 22px;
              left: 4px;
              bottom: 4px;
              background-color: white;
              transition: .4s;
              border-radius: 50%;
            }
            .trackers-settings input:checked + .slider {
              background-color: #7289da;
            }
            .trackers-settings input:focus + .slider {
              box-shadow: 0 0 1px #7289da;
            }
            .trackers-settings input:checked + .slider:before {
              transform: translateX(30px);
            }
            .trackers-settings .reload-button {
              background: #7289da;
              color: white;
              border: none;
              border-radius: 4px;
              padding: 5px 10px;
              margin-left: 10px;
              cursor: pointer;
            }
          </style>
          
          <div class="trackers-settings">
            <h2 style="border-bottom:1px solid #444; padding-bottom:10px; margin-bottom:20px;">Tracker Settings</h2>
            
            <div class="trackers-container">
              <div class="tracker-section">
                <div class="tracker-title">
                  <i class="fa fa-chart-bar"></i> IP Statistics Tracker
                </div>
                <div class="tracker-description">
                  Tracks unique IP addresses and peak online.
                </div>
                
                <div class="tracker-toggle">
                  <span class="tracker-toggle-label">Enable IP Tracker</span>
                  <label class="switch">
                    <input type="checkbox" id="ipTrackerToggle" ${enableIPTracker ? 'checked' : ''}>
                    <span class="slider"></span>
                  </label>
                </div>
              </div>
              
              <div class="tracker-section">
                <div class="tracker-title">
                  <i class="fa fa-clock"></i> Room Times Tracker
                </div>
                <div class="tracker-description">
                  Tracks the time spent in each room and drawing time.
                </div>
                
                <div class="tracker-toggle">
                  <span class="tracker-toggle-label">Enable Room Times Tracker</span>
                  <label class="switch">
                    <input type="checkbox" id="roomTimesTrackerToggle" ${enableRoomTimesTracker ? 'checked' : ''}>
                    <span class="slider"></span>
                  </label>
                </div>
              </div>
              
              <div class="tracker-section" style="background: #202020;">
                <div style="color: #ccc; font-size: 14px;">
                  <i class="fa fa-info-circle" style="color: #7289da; margin-right: 8px;"></i>
                  Please reload the page for changes to take effect.
                </div>
              </div>
            </div>
          </div>
        `);
        
        // Handle toggle events
        this.content.find("#ipTrackerToggle").on("change", function() {
          const isEnabled = $(this).is(":checked");
          config.enableIPTracker = isEnabled;
          
          // Save to localStorage
          localStorage.setItem(config.localStorageKeys.enableIPTracker, isEnabled.toString());
        });
        
        this.content.find("#roomTimesTrackerToggle").on("change", function() {
          const isEnabled = $(this).is(":checked");
          config.enableRoomTimesTracker = isEnabled;
          
          // Save to localStorage
          localStorage.setItem(config.localStorageKeys.enableRoomTimesTracker, isEnabled.toString());
        });
    }
      else if (subcontent === "tweaks") {
        this.loadSubcontent(`
          <style>
            #tweaksSection {
              display: flex;
              flex-direction: column;
              height: 100%;
              overflow: hidden;
            }
            #tweaksContainer {
              flex: 1;
              overflow-y: auto;
              padding-right: 10px;
              margin-bottom: 15px;
            }
            #tweaksButtons {
              border-top: 1px solid #333;
              padding: 15px 0 5px 0;
              display: flex;
              flex-wrap: wrap;
              justify-content: flex-end;
              gap: 10px;
            }
            .styled-dropdown {
              width: 100%;
              padding: 5px;
              background: #333;
              color: #ddd;
              border: 1px solid #444;
              border-radius: 4px;
              cursor: pointer;
            }
            .styled-checkbox {
              appearance: none;
              -webkit-appearance: none;
              -moz-appearance: none;
              width: 20px;
              height: 20px;
              border: 2px solid #333;
              border-radius: 4px;
              display: inline-block;
              position: relative;
              cursor: pointer;
              background-color: #333;
            }
            .styled-checkbox:checked::after {
              content: '\\2714';
              color: #28a745;
              position: absolute;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              font-size: 14px;
            }
            .styled-checkbox:focus {
              outline: none;
            }
            #tweaksContainer::-webkit-scrollbar {
              width: 8px;
            }
            #tweaksContainer::-webkit-scrollbar-track {
              background: #1e1e1e;
              border-radius: 4px;
            }
            #tweaksContainer::-webkit-scrollbar-thumb {
              background: #444;
              border-radius: 4px;
            }
            #tweaksContainer::-webkit-scrollbar-thumb:hover {
              background: #555;
            }
            label {
              color: #ddd;
            }
            #exportConfigButton:hover {
              background: #444 !important;
            }
            #importConfigButton:hover {
              background: #3a6999 !important;
            }  
              .action-button {
              padding: 5px 10px;
              background: #444;
              color: #fff;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              margin-left: 10px;
              transition: background 0.2s;
            }
            .action-button:hover {
              background: #555;
            }
          </style>
      
          <div id="tweaksSection">
            <div id="tweaksContainer">
              <h2 style="border-bottom: 1px solid #444; padding-bottom: 10px;">Tweaks</h2>
              
              <!-- Max Opacity Size Setting -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="maxOpacitySizeInput" style="display: flex; flex-direction: column; cursor: pointer;">
                  <span>Max Opacity Size:</span>
                  <input 
                    type="number" 
                    id="maxOpacitySizeInput" 
                    class="styled-input" 
                    style="margin-top: 10px; padding: 5px; width: 100px; border: 1px solid #555; border-radius: 4px; background: #222; color: #ddd;" 
                    step="0.1" 
                    min="0"
                  >
                </label>
              </div>
              <!-- Opacity Change Threshold Setting -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="opacityChangeThresholdInput" style="display: flex; flex-direction: column; cursor: pointer;">
                  <span>Opacity Change Threshold:</span>
                  <input 
                    type="number" 
                    id="opacityChangeThresholdInput" 
                    class="styled-input" 
                    style="margin-top: 10px; padding: 5px; width: 100px; border: 1px solid #555; border-radius: 4px; background: #222; color: #ddd;" 
                    step="0.01" 
                    min="0"
                  >
                </label>
              </div>
              <!-- Smart Opacity Cap Setting -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="smartOpacityCap" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="smartOpacityCap" class="styled-checkbox">
                  Smart Opacity Cap
                </label>
              </div>
              <!-- Mouse Mode Setting -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="mouseModeToggle" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="mouseModeToggle" class="styled-checkbox">
                  Mouse Mode
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="blurControl" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="blurControl" class="styled-checkbox">
                  Blur Control
                </label>
              </div>
              <hr style="border-top: 1px solid #444; margin: 20px 0;">
              <!-- Smoothing for Resize -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="resizeSmoothing" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="resizeSmoothing" class="styled-checkbox">
                  Enable Resize Smoothing
                </label>
              </div>
      
              <!-- Mouse Wheel Control -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="mouseWheelMode" style="display: block; margin-bottom: 5px;">
                  Mouse Wheel Control Mode
                </label>
                <select id="mouseWheelMode" class="styled-dropdown">
                  <option value="vanillaFM">Vanilla FM</option>
                  <option value="fasterScroll">Faster Scroll = Faster Changes</option>
                  <option value="cap">Cap</option>
                </select>
              </div>
              <!-- Enable 1000 Pressure Levels -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="enable1000PressureLevels" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="enable1000PressureLevels" class="styled-checkbox">
                  Enable 1000 Pressure Levels
                </label>
              </div>
      
              <!-- Bypass DENIED#101 Error -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="bypassDenied101" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="bypassDenied101" class="styled-checkbox">
                  Bypass DENIED#101 Error
                </label>
              </div>
              <!-- Position-Aware Mirroring -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="positionAwareMirroring" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="positionAwareMirroring" class="styled-checkbox">
                  Position-Aware Mirroring
                </label>
              </div>
              <!-- Position-Aware Rotation -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="positionAwareRotation" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="positionAwareRotation" class="styled-checkbox">
                  Position-Aware Rotation
                </label>
              </div>
              <!-- Mirrored text -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="mirroredText" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="mirroredText" class="styled-checkbox">
                  Additional mirrored text while flipped
                </label>
              </div>
              <!-- RMB Action Fix -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="rmbActionFix" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="rmbActionFix" class="styled-checkbox">
                  RMB Action Fix
                </label>
              </div>
              <!-- Reset Pressure on Release -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="resetPressureRelease" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="resetPressureRelease" class="styled-checkbox">
                  Reset Pressure on Release
                </label>
              </div>
              <!-- Persistent Board Sync -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="persistentBoardSync" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="persistentBoardSync" class="styled-checkbox">
                  Persistent Board Sync
                </label>
              </div>
      
              <!-- Hold to Pick Color -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="holdToPickColor" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="holdToPickColor" class="styled-checkbox">
                  Hold to Pick Color
                </label>
              </div>
              <!-- Fix Selection Options Stuck -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="fixSelectionOptionsStuck" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="fixSelectionOptionsStuck" class="styled-checkbox">
                  Fix Selection Options Stuck
                </label>
              </div>
      
              <!-- Fix Resizing Shift -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="fixResizingShift" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="fixResizingShift" class="styled-checkbox">
                  Fix Resizing Shift
                </label>
              </div>
      
              <!-- Resize Rotation Bug Fix -->
              ${ /*<div class="form-group" style="margin-bottom: 20px;">
                <label for="resizeRotationBugFix" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="resizeRotationBugFix" class="styled-checkbox">
                  Resize Rotation Bug Fix (Placeholder, does not work right now)
                </label>
              </div>*/ '' }
              <!-- Reconnect-Aware Sync -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="reconnectAwareSync" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="reconnectAwareSync" class="styled-checkbox">
                  Reconnect-Aware Sync
                </label>
              </div>
              <!-- Options 1-10 -->
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="instantReconnect" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="instantReconnect" class="styled-checkbox">
                  Instant Reconnect
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="quickLaunch" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="quickLaunch" class="styled-checkbox">
                  Quick Launch
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="unlimitedReconnect" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="unlimitedReconnect" class="styled-checkbox">
                  Unlimited Reconnect Attempts
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="detectTrolling" class="styled-checkbox">
                  Detect Trolling
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="trollSoundSelect" style="margin-left: 15px;">Troll Sound:</label>
                <select id="trollSoundSelect" class="styled-dropdown">
                  <option value="nosound">No Sound</option>
                  <option value="custom">Custom Sound</option>
                  <option value="staff">#staff Sound</option>
                </select>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="keepTabAlive" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="keepTabAlive" class="styled-checkbox">
                  Keep Tab Alive
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="disableBlur" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="disableBlur" class="styled-checkbox">
                  Disable Blur
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="preAntsResizing" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="preAntsResizing" class="styled-checkbox">
                  Revert to pre-Marching Ants Resizing
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="extendedBoardByDefault" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="extendedBoardByDefault" class="styled-checkbox">
                  Extended Board by Default
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="smallerZoomStep" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="smallerZoomStep" class="styled-checkbox">
                  10% Zoom Step
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="preciseZoomDisplay" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="preciseZoomDisplay" class="styled-checkbox">
                  Precise Zoom Display
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="skipSyncing" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="skipSyncing" class="styled-checkbox">
                  Skip Syncing
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="fixAutoScroll" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="fixAutoScroll" class="styled-checkbox">
                  Fix Auto Scroll
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="quickOpacityHotkeys" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="quickOpacityHotkeys" class="styled-checkbox">
                  Quick Opacity Hotkeys (Press 0-9)
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="fixCopyAction" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="fixCopyAction" class="styled-checkbox">
                  Fix Copy Action
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="csCursor" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="csCursor" class="styled-checkbox">
                  Counter-Strike Cursor
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="paintWithinSelection" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="paintWithinSelection" class="styled-checkbox">
                  Paint within Selection (regular brush only for now, ctrl + ~ resets the selection)
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="lineInterpolation" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="lineInterpolation" class="styled-checkbox">
                  Line Interpolation
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="lineSnappingShift" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="lineSnappingShift" class="styled-checkbox">
                  Line Snapping on Shift
                </label>
              </div>
              <div class="form-group" style="margin-bottom: 20px;">
                <label for="brushCustomPressure" style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                  <input type="checkbox" id="brushCustomPressure" class="styled-checkbox">
                  Custom Brush Pressure
                </label>
              </div>
              <!-- Background Color Control -->
              <div class="form-group socket-control-row" style="margin-bottom: 20px; display: flex; align-items: center;">
                <label for="backgroundColorEnabled" class="socket-label" style="display: flex; align-items: center; gap: 10px; cursor: pointer; white-space: nowrap;">
                  <input type="checkbox" id="backgroundColorEnabled" class="styled-checkbox">
                    Color Background Button
                </label>
                <div style="display: flex; align-items: center;">
                  <button id="backgroundColorAction" class="action-button" style="width: 150px; white-space: nowrap; height: 30px; line-height: 20px;">
                    <i class="fa fa-eyedropper" style="margin-right: 5px;"></i> Color Now
                  </button>
                  <input type="color" id="backgroundColorPicker" style="width: 30px; height: 30px; margin-left: 8px; padding: 0; border: 1px solid #444; border-radius: 4px;">
                </div>
              </div>
              <!-- Socket Connection Controls -->
              <div class="form-group socket-control-row" style="margin-bottom: 15px; display: flex; align-items: center;">
                <label for="socketConnectVisible" class="socket-label" style="display: flex; align-items: center; gap: 10px; cursor: pointer; white-space: nowrap;">
                  <input type="checkbox" id="socketConnectVisible" class="styled-checkbox">
                  Socket Connect Button
                </label>
                <button id="socketConnectAction" class="action-button" style="width: 150px; white-space: nowrap; height: 30px; line-height: 20px;"><i class="fa fa-chain" style="margin-right: 5px;"></i> Connect Now</button>
              </div>

              <div class="form-group socket-control-row" style="margin-bottom: 20px; display: flex; align-items: center;">
                <label for="socketDisconnectVisible" class="socket-label" style="display: flex; align-items: center; gap: 10px; cursor: pointer; white-space: nowrap;">
                  <input type="checkbox" id="socketDisconnectVisible" class="styled-checkbox">
                  Socket Disconnect Button
                </label>
                <button id="socketDisconnectAction" class="action-button" style="width: 150px; white-space: nowrap; height: 30px; line-height: 20px;"><i class="fa fa-chain-broken" style="margin-right: 5px;"></i> Disconnect Now</button>
              </div>
              ${ /* Hide Option 15 temporarily */ '' }
              
              <p style="font-size: 0.9em; color: #bbb; margin-top: 10px; margin-bottom: 20px;">
                Note: Please reload the page for changes to take effect.
              </p>
            </div>
            
            <!-- Export and Import Config Buttons -->
            <div id="tweaksButtons">
              <button id="exportConfigButton" style="padding:8px 12px; background:#2c2c2c; color:#fff; border:none; cursor:pointer; border-radius:4px; display:flex; align-items:center; transition:background 0.2s;">
                <i class="fa fa-download" style="margin-right:6px;"></i> Export Config
              </button>
              <button id="importConfigButton" style="padding:8px 12px; background:#2a4d69; color:#fff; border:none; cursor:pointer; border-radius:4px; display:flex; align-items:center; transition:background 0.2s;">
                <i class="fa fa-upload" style="margin-right:6px;"></i> Import Config
              </button>
              <input type="file" id="importConfigInput" style="display: none;" accept=".json">
            </div>
          </div>
        `);      
        const calculateSocketLabelWidth = () => {
          // Get all socket label elements
          const labelElements = this.content.find(".socket-label");
          if (labelElements.length === 0) return;
          
          // Create a temporary element to measure text width
          const tempElement = document.createElement("span");
          tempElement.style.visibility = "hidden";
          tempElement.style.position = "absolute";
          tempElement.style.whiteSpace = "nowrap";
          tempElement.style.font = window.getComputedStyle(labelElements[0]).font;
          document.body.appendChild(tempElement);
          
          // Find the longest label width
          let maxWidth = 0;
          labelElements.each(function() {
            // Get text content without the checkbox
            const labelText = $(this).text().trim();
            tempElement.textContent = labelText;
            const width = tempElement.offsetWidth;
            maxWidth = Math.max(maxWidth, width);
          });
          
          // Remove the temporary element
          document.body.removeChild(tempElement);
          
          // Add padding for checkbox and spacing
          const totalWidth = maxWidth + 40; // 20px for checkbox, 20px for padding
          
          // Apply width to all socket control labels
          labelElements.css("width", totalWidth + "px");
          
          return totalWidth;
        };
        
        // Calculate and apply the optimal width
        calculateSocketLabelWidth();
          // Initialize local storage keys if they don't exist
          if (!localStorage.getItem(config.localStorageKeys.quickOpacityHotkeys)) {
            config.localStorageKeys.quickOpacityHotkeys = "quickOpacityHotkeys";
            localStorage.setItem(config.localStorageKeys.quickOpacityHotkeys, "false");
          }
          if (!localStorage.getItem(config.localStorageKeys.socketConnectVisible)) {
            config.localStorageKeys.socketConnectVisible = "socketConnectVisible";
            localStorage.setItem(config.localStorageKeys.socketConnectVisible, "false");
          }
          if (!localStorage.getItem(config.localStorageKeys.socketDisconnectVisible)) {
            config.localStorageKeys.socketDisconnectVisible = "socketDisconnectVisible";
            localStorage.setItem(config.localStorageKeys.socketDisconnectVisible, "false");
          }
          if (!localStorage.getItem(config.localStorageKeys.trollSound)) {
            localStorage.setItem(config.localStorageKeys.trollSound, "nosound"); 
          }
          if (!localStorage.getItem(config.localStorageKeys.persistentBoardSync)) {
            config.localStorageKeys.persistentBoardSync = "persistentBoardSync";
            localStorage.setItem(config.localStorageKeys.persistentBoardSync, "false");
          }
          if (!localStorage.getItem(config.localStorageKeys.holdToPickColor)) {
              config.localStorageKeys.holdToPickColor = "holdToPickColor";
              localStorage.setItem(config.localStorageKeys.holdToPickColor, "false");
          }
          if (!localStorage.getItem(config.localStorageKeys.reconnectAwareSync)) {
              config.localStorageKeys.reconnectAwareSync = "reconnectAwareSync";
              localStorage.setItem(config.localStorageKeys.reconnectAwareSync, "false");
          }
          if (!localStorage.getItem(config.localStorageKeys.fixSelectionOptionsStuck)) {
              config.localStorageKeys.fixSelectionOptionsStuck = "fixSelectionOptionsStuck";
              localStorage.setItem(config.localStorageKeys.fixSelectionOptionsStuck, "false");
          }
          if (!localStorage.getItem(config.localStorageKeys.fixResizingShift)) {
              config.localStorageKeys.fixResizingShift = "fixResizingShift";
              localStorage.setItem(config.localStorageKeys.fixResizingShift, "false");
          }
          if (!localStorage.getItem(config.localStorageKeys.resizeRotationBugFix)) {
            config.localStorageKeys.resizeRotationBugFix = "resizeRotationBugFix";
            localStorage.setItem(config.localStorageKeys.resizeRotationBugFix, "false");
          }
          ["instantReconnect", "quickLaunch", "unlimitedReconnect", "detectTrolling", "blurControl", "keepTabAlive", 
            "disableBlur", "preAntsResizing", "extendedBoardByDefault", "smallerZoomStep", "preciseZoomDisplay", "skipSyncing", "fixAutoScroll", "fixCopyAction",
            "csCursor", "paintWithinSelection", "lineInterpolation", "lineSnappingShift", "brushCustomPressure", "option20", "option21", "option22", "option23", "option24", "option25", "option26", "option27", "option28", "option29", "option30"
          ].forEach(option => {
               if (!localStorage.getItem(config.localStorageKeys[option])) {
                   config.localStorageKeys[option] = option;
                   localStorage.setItem(config.localStorageKeys[option], "false");
               }
           });
          if (!localStorage.getItem(config.localStorageKeys.mouseWheelMode)) {
            config.localStorageKeys.mouseWheelMode = "mouseWheelMode";
            localStorage.setItem(config.localStorageKeys.mouseWheelMode, "vanillaFM");
          }
          if (!localStorage.getItem(config.localStorageKeys.mouseModeEnabled)) {
            config.localStorageKeys.mouseModeEnabled = "mouseModeEnabled";
            localStorage.setItem(config.localStorageKeys.mouseModeEnabled, "false");
          }
          if (!localStorage.getItem(config.localStorageKeys.smartOpacityCap)) {
            config.localStorageKeys.smartOpacityCap = "smartOpacityCap";
            localStorage.setItem(config.localStorageKeys.smartOpacityCap, "false");
          }          
          if (!localStorage.getItem(config.localStorageKeys.maxOpacitySize)) {
            config.localStorageKeys.maxOpacitySize = "maxOpacitySize";
            localStorage.setItem(config.localStorageKeys.maxOpacitySize, "1"); // Default to 1
          }
          if (!localStorage.getItem(config.localStorageKeys.bypassDenied101)) {
              config.localStorageKeys.bypassDenied101 = "bypassDenied101";
              localStorage.setItem(config.localStorageKeys.bypassDenied101, "false");
          }
          if (!localStorage.getItem(config.localStorageKeys.enable1000PressureLevels)) {
              config.localStorageKeys.enable1000PressureLevels = "enable1000PressureLevels";
              localStorage.setItem(config.localStorageKeys.enable1000PressureLevels, "false");
          }
          if (!localStorage.getItem(config.localStorageKeys.opacityChangeThreshold)) {
            config.localStorageKeys.opacityChangeThreshold = "opacityChangeThreshold";
            localStorage.setItem(config.localStorageKeys.opacityChangeThreshold, "0");
          }
          if (!localStorage.getItem(config.localStorageKeys.positionAwareMirroring)) {
            config.localStorageKeys.positionAwareMirroring = "positionAwareMirroring";
            localStorage.setItem(config.localStorageKeys.positionAwareMirroring, "false");
          }
          if (!localStorage.getItem(config.localStorageKeys.positionAwareRotation)) {
            config.localStorageKeys.positionAwareRotation = "positionAwareRotation";
            localStorage.setItem(config.localStorageKeys.positionAwareRotation, "false");
          }
          if (!localStorage.getItem(config.localStorageKeys.mirroredText)) {
            config.localStorageKeys.mirroredText = "mirroredText";
            localStorage.setItem(config.localStorageKeys.mirroredText, "false");
          }
          
          if (!localStorage.getItem(config.localStorageKeys.rmbActionFix)) {
              config.localStorageKeys.rmbActionFix = "rmbActionFix";
              localStorage.setItem(config.localStorageKeys.rmbActionFix, "false");
          }
          
          if (!localStorage.getItem(config.localStorageKeys.resetPressureRelease)) {
              config.localStorageKeys.resetPressureRelease = "resetPressureRelease";
              localStorage.setItem(config.localStorageKeys.resetPressureRelease, "false");
          }
        
        
      
          // Load the stored values for the checkboxes and inputs
          const quickOpacityHotkeysEnabled = localStorage.getItem(config.localStorageKeys.quickOpacityHotkeys) === "true";
          const socketConnectVisible = localStorage.getItem(config.localStorageKeys.socketConnectVisible) === "true";
          const socketDisconnectVisible = localStorage.getItem(config.localStorageKeys.socketDisconnectVisible) === "true";
          const backgroundColorButtonVisible = localStorage.getItem(config.localStorageKeys.backgroundColorEnabled) === "true";

          const persistentBoardSyncEnabled = localStorage.getItem(config.localStorageKeys.persistentBoardSync) === "true";
          const holdToPickColorEnabled = localStorage.getItem(config.localStorageKeys.holdToPickColor) === "true";
          const reconnectAwareSyncEnabled = localStorage.getItem(config.localStorageKeys.reconnectAwareSync) === "true";
          const fixSelectionOptionsStuckEnabled = localStorage.getItem(config.localStorageKeys.fixSelectionOptionsStuck) === "true";
          const fixResizingShiftEnabled = localStorage.getItem(config.localStorageKeys.fixResizingShift) === "true";
          const resizeRotationBugFixEnabled = localStorage.getItem(config.localStorageKeys.resizeRotationBugFix) === "true";
          const optionsEnabled = {};
          ["instantReconnect", "quickLaunch", "unlimitedReconnect", "detectTrolling", "blurControl", "keepTabAlive", "disableBlur", "preAntsResizing", "extendedBoardByDefault", "smallerZoomStep", "preciseZoomDisplay", "skipSyncing", "fixAutoScroll", "fixCopyAction",
          "csCursor", "paintWithinSelection", "lineInterpolation", "lineSnappingShift", "brushCustomPressure", "option20", "option21", "option22", "option23", "option24", "option25", "option26", "option27", "option28", "option29", "option30"
          ].forEach(option => {
              optionsEnabled[option] = localStorage.getItem(config.localStorageKeys[option]) === "true";
          });
          const mouseModeEnabled = localStorage.getItem(config.localStorageKeys.mouseModeEnabled) === "true";
          const smoothingEnabled = localStorage.getItem(config.localStorageKeys.enableSmoothing) === "true";
          const storedTrollSound = localStorage.getItem(config.localStorageKeys.trollSound) || "nosound";
          const mouseWheelMode = localStorage.getItem(config.localStorageKeys.mouseWheelMode) || "vanillaFM";
          const maxOpacitySize = isNaN(parseFloat(localStorage.getItem(config.localStorageKeys.maxOpacitySize))) ? 1 : parseFloat(localStorage.getItem(config.localStorageKeys.maxOpacitySize));
          const bypassDenied101Enabled = localStorage.getItem(config.localStorageKeys.bypassDenied101) === "true";
          const enable1000PressureLevels = localStorage.getItem(config.localStorageKeys.enable1000PressureLevels) === "true";
          const opacityChangeThreshold = isNaN(parseFloat(localStorage.getItem(config.localStorageKeys.opacityChangeThreshold))) ? 0 : parseFloat(localStorage.getItem(config.localStorageKeys.opacityChangeThreshold));
          const positionAwareMirroringEnabled = localStorage.getItem(config.localStorageKeys.positionAwareMirroring) === "true";
          const positionAwareRotationEnabled = localStorage.getItem(config.localStorageKeys.positionAwareRotation) === "true";
          const mirroredTextEnabled = localStorage.getItem(config.localStorageKeys.mirroredText) === "true";
          const rmbActionFixEnabled = localStorage.getItem(config.localStorageKeys.rmbActionFix) === "true";
          const resetPressureReleaseEnabled = localStorage.getItem(config.localStorageKeys.resetPressureRelease) === "true";
          const smartOpacityCapEnabled = localStorage.getItem(config.localStorageKeys.smartOpacityCap) === "true";

          const backgroundColorEnabled = localStorage.getItem(config.localStorageKeys.backgroundColorEnabled) === "true";
          const savedBackgroundColor = localStorage.getItem(config.localStorageKeys.backgroundColor) || "#000000";



          // Set initial state
          this.content.find("#backgroundColorEnabled").prop("checked", backgroundColorEnabled);
          this.content.find("#backgroundColorPicker").val(savedBackgroundColor);

          this.content.find("#quickOpacityHotkeys").prop("checked", quickOpacityHotkeysEnabled);
          this.content.find("#socketConnectVisible").prop("checked", socketConnectVisible);
          this.content.find("#socketDisconnectVisible").prop("checked", socketDisconnectVisible);
          this.content.find("#mouseModeToggle").prop("checked", mouseModeEnabled);
          this.content.find("#smartOpacityCap").prop("checked", smartOpacityCapEnabled);
          this.content.find("#maxOpacitySizeInput").val(maxOpacitySize);
          this.content.find("#resizeSmoothing").prop("checked", smoothingEnabled);
          this.content.find("#mouseWheelMode").val(mouseWheelMode);
          this.content.find("#bypassDenied101").prop("checked", bypassDenied101Enabled);
          this.content.find("#enable1000PressureLevels").prop("checked", enable1000PressureLevels);
          this.content.find("#opacityChangeThresholdInput").val(opacityChangeThreshold);
          this.content.find("#positionAwareMirroring").prop("checked", positionAwareMirroringEnabled);
          this.content.find("#mirroredText").prop("checked", mirroredTextEnabled);
          this.content.find("#rmbActionFix").prop("checked", rmbActionFixEnabled);
          this.content.find("#resetPressureRelease").prop("checked", resetPressureReleaseEnabled);
          this.content.find("#positionAwareRotation").prop("checked", positionAwareRotationEnabled);
          this.content.find("#positionAwareMirroring").prop("checked", positionAwareMirroringEnabled);
          this.content.find("#persistentBoardSync").prop("checked", persistentBoardSyncEnabled);
          this.content.find("#holdToPickColor").prop("checked", holdToPickColorEnabled);
          this.content.find("#reconnectAwareSync").prop("checked", reconnectAwareSyncEnabled);
          this.content.find("#fixSelectionOptionsStuck").prop("checked", fixSelectionOptionsStuckEnabled);
          this.content.find("#fixResizingShift").prop("checked", fixResizingShiftEnabled);
          this.content.find("#resizeRotationBugFix").prop("checked", resizeRotationBugFixEnabled);
          ["instantReconnect", "quickLaunch", "unlimitedReconnect", "detectTrolling", "blurControl", "keepTabAlive", 
            "disableBlur", "preAntsResizing", "extendedBoardByDefault", "smallerZoomStep", "preciseZoomDisplay", "skipSyncing", "fixAutoScroll", "fixCopyAction",
            "csCursor", "paintWithinSelection", "lineInterpolation", "lineSnappingShift", "brushCustomPressure", "option20", "option21", "option22", "option23", "option24", "option25", "option26", "option27", "option28", "option29", "option30"
          ].forEach(option => {
            this.content.find(`#${option}`).prop("checked", localStorage.getItem(config.localStorageKeys[option]) === "true");
          });
          this.content.find("#quickOpacityHotkeys").on("change", function() {
            const value = $(this).is(":checked");
            localStorage.setItem(config.localStorageKeys.quickOpacityHotkeys, value.toString());
            window.toggleQuickOpacityHotkeys(value);
          });

          this.content.find("#socketConnectVisible").on("change", function() {
            const value = $(this).is(":checked");
            localStorage.setItem(config.localStorageKeys.socketConnectVisible, value.toString());
            
            // Show/hide the button based on checkbox state
            if (value) {
              UI.bottombar.showButton('socketConnectButton');
            } else {
              UI.bottombar.hideButton('socketConnectButton');
            }
          });
          
          this.content.find("#socketDisconnectVisible").on("change", function() {
            const value = $(this).is(":checked");
            localStorage.setItem(config.localStorageKeys.socketDisconnectVisible, value.toString());
            
            // Show/hide the button based on checkbox state
            if (value) {
              UI.bottombar.showButton('socketDisconnectButton');
            } else {
              UI.bottombar.hideButton('socketDisconnectButton');
            }
          });
          
          // Event handlers for the action buttons
          this.content.find("#socketConnectAction").on("click", function() {
            if (socket) {
              socket.connect();
            }
          });
          
          this.content.find("#socketDisconnectAction").on("click", function() {
            if (socket) {
              socket.disconnect();
            }
          });
          this.content.find("#persistentBoardSync").on("change", function () {
              const value = $(this).is(":checked");
              localStorage.setItem(config.localStorageKeys.persistentBoardSync, value.toString());
          });
          
          this.content.find("#holdToPickColor").on("change", function () {
              const value = $(this).is(":checked");
              localStorage.setItem(config.localStorageKeys.holdToPickColor, value.toString());
          });
          
          this.content.find("#reconnectAwareSync").on("change", function () {
              const value = $(this).is(":checked");
              localStorage.setItem(config.localStorageKeys.reconnectAwareSync, value.toString());
          });
          
          this.content.find("#fixSelectionOptionsStuck").on("change", function () {
              const value = $(this).is(":checked");
              localStorage.setItem(config.localStorageKeys.fixSelectionOptionsStuck, value.toString());
          });
          
          this.content.find("#fixResizingShift").on("change", function () {
              const value = $(this).is(":checked");
              localStorage.setItem(config.localStorageKeys.fixResizingShift, value.toString());
          });
          
          this.content.find("#positionAwareRotation").on("change", function () {
            const positionAwareRotationValue = $(this).is(":checked");
            localStorage.setItem(config.localStorageKeys.positionAwareRotation, positionAwareRotationValue.toString());
          });

          this.content.find("#resizeRotationBugFix").on("change", function () {
            const value = $(this).is(":checked");
            localStorage.setItem(config.localStorageKeys.resizeRotationBugFix, value.toString());
        });
        ["instantReconnect", "quickLaunch", "unlimitedReconnect", "detectTrolling", "blurControl", "keepTabAlive", 
          "disableBlur", "preAntsResizing", "extendedBoardByDefault", "smallerZoomStep", "preciseZoomDisplay", "skipSyncing", "fixAutoScroll", "fixCopyAction",
          "csCursor", "paintWithinSelection", "lineInterpolation", "lineSnappingShift", "brushCustomPressure", "option20", "option21", "option22", "option23", "option24", "option25", "option26", "option27", "option28", "option29", "option30"
        ].forEach(option => {
             this.content.find(`#${option}`).on("change", function () {
                 const value = $(this).is(":checked");
                 localStorage.setItem(config.localStorageKeys[option], value.toString());
             });
         });
          this.content.find("#mouseModeToggle").on("change", function () {
            const mouseModeValue = $(this).is(":checked");
            localStorage.setItem(config.localStorageKeys.mouseModeEnabled, mouseModeValue.toString());
            window.mouseModeEnabled = mouseModeValue; // Reflect the updated value globally
          });
          this.content.find("#smartOpacityCap").on("change", function () {
              const smartOpacityCapValue = $(this).is(":checked"); // Get true/false based on checkbox state
              localStorage.setItem(config.localStorageKeys.smartOpacityCap, smartOpacityCapValue.toString()); // Save as string to localStorage
              window.smartOpacityCap = smartOpacityCapValue; // Update the global variable
          });
                  
          this.content.find("#maxOpacitySizeInput").on("input", function () {
              const newMaxOpacitySize = parseFloat($(this).val());
              if (!isNaN(newMaxOpacitySize) && newMaxOpacitySize >= 0) {
                  localStorage.setItem(config.localStorageKeys.maxOpacitySize, newMaxOpacitySize.toString());
                  window.maxOpacitySize = newMaxOpacitySize; // Ensure the global variable updates immediately
              }
          });
          // Attach events to handle changes to the checkboxes
          this.content.find("#resizeSmoothing").on("change", function () {
              const smoothingValue = $(this).is(":checked");
              localStorage.setItem(config.localStorageKeys.enableSmoothing, smoothingValue.toString());
          });
          this.content.find("#mouseWheelMode").on("change", function () {
            const selectedMode = $(this).val();
            localStorage.setItem(config.localStorageKeys.mouseWheelMode, selectedMode);
          });
          this.content.find("#trollSoundSelect").on("change", function () {
            const newValue = $(this).val();
            localStorage.setItem(config.localStorageKeys.trollSound, newValue);
          });
          this.content.find("#bypassDenied101").on("change", function () {
            const bypassValue = $(this).is(":checked");
            localStorage.setItem(config.localStorageKeys.bypassDenied101, bypassValue.toString());
        });

        this.content.find("#backgroundColorEnabled").on("change", function() {
          const isEnabled = $(this).is(":checked");
          localStorage.setItem(config.localStorageKeys.backgroundColorEnabled, isEnabled.toString());

          if (isEnabled) {
            UI.bottombar.showButton('customBgColorButton');
          } else {
            UI.bottombar.hideButton('customBgColorButton');
          }
        });

        // Handle background color picker changes
        this.content.find("#backgroundColorPicker").on("input", function() {
          const newColor = $(this).val();
          if (newColor && newColor !== "undefined") {
            localStorage.setItem(config.localStorageKeys.backgroundColor, newColor);
            
            // Apply to canvas immediately if custom background is active
            if (UI.customBgActive && room && room.board) {
              room.changeBackground(newColor);
            }
          }
        });

        // Handle "Color Now" button click
        this.content.find("#backgroundColorAction").off("click").on("click", function () {
          const color = $("#backgroundColorPicker").val();
          if (!color || color === "undefined") return;

          localStorage.setItem(config.localStorageKeys.backgroundColor, color);

          if (UI.customBgActive === undefined) UI.customBgActive = false;

          // Activate
          if (!UI.customBgActive) {
            UI.savedBgColor = (room && room.board) ? room.board.backgroundColor : UI.savedBgColor || null;

            if (room && room.board) room.changeBackground(color);

            UI.customBgActive = true;
            if (UI.bottombar && UI.bottombar.selectButton) UI.bottombar.selectButton("customBgColorButton");
            if (UI.boardContainer) UI.boardContainer.addClass("customBgEnabled");
            return;
          }

          // Deactivate and restore
          if (UI.customBgActive) {
            if (UI.savedBgColor && room && room.board) {
              room.changeBackground(UI.savedBgColor);
            }

            UI.customBgActive = false;
            if (UI.bottombar && UI.bottombar.unselectButton) UI.bottombar.unselectButton("customBgColorButton");
            if (UI.boardContainer) UI.boardContainer.removeClass("customBgEnabled");
          }
        });

        
        this.content.find("#enable1000PressureLevels").on("change", function () {
            const pressureValue = $(this).is(":checked");
            localStorage.setItem(config.localStorageKeys.enable1000PressureLevels, pressureValue.toString());
        });
        this.content.find("#opacityChangeThresholdInput").on("input", function () {
          const newThreshold = parseFloat($(this).val());
          if (!isNaN(newThreshold) && newThreshold >= 0) {
              localStorage.setItem(config.localStorageKeys.opacityChangeThreshold, newThreshold.toString());
              window.opacityChangeThreshold = newThreshold; // Update the global variable
          }
        });
        this.content.find("#positionAwareMirroring").on("change", function () {
          const value = $(this).is(":checked");
          localStorage.setItem(config.localStorageKeys.positionAwareMirroring, value.toString());
        });
        this.content.find("#mirroredText").on("change", function () {
          const mirroredTextValue = $(this).is(":checked");
          localStorage.setItem(config.localStorageKeys.mirroredText, mirroredTextValue.toString());
        });
        
        this.content.find("#rmbActionFix").on("change", function () {
            const rmbActionFixValue = $(this).is(":checked");
            localStorage.setItem(config.localStorageKeys.rmbActionFix, rmbActionFixValue.toString());
        });
        
        this.content.find("#resetPressureRelease").on("change", function () {
            const resetPressureValue = $(this).is(":checked");
            localStorage.setItem(config.localStorageKeys.resetPressureRelease, resetPressureValue.toString());
        });      
      
          // Handle the export button
          this.content.find("#exportConfigButton").on("click", () => {
            const exportData = {
              quickOpacityHotkeys: localStorage.getItem(config.localStorageKeys.quickOpacityHotkeys) === 'true',
              dismissedTrackerInfo: localStorage.getItem(config.localStorageKeys.dismissedTrackerInfo) === 'true',
              dismissedIPTrackerInfo: localStorage.getItem(config.localStorageKeys.dismissedIPTrackerInfo) === 'true',            
              socketConnectVisible: localStorage.getItem(config.localStorageKeys.socketConnectVisible) === 'true',
              socketDisconnectVisible: localStorage.getItem(config.localStorageKeys.socketDisconnectVisible) === 'true',
              undoSteps: parseInt(localStorage.getItem(config.localStorageKeys.undoSteps)) || 5,
              commitUndoHistory: localStorage.getItem(config.localStorageKeys.commitUndoHistory) === 'true',
              toggleUndoHistory: localStorage.getItem(config.localStorageKeys.toggleUndoHistory) === 'true',
              clearUndoHistory: localStorage.getItem(config.localStorageKeys.clearUndoHistory) === 'true',
              undoAction: localStorage.getItem(config.localStorageKeys.undoAction) === 'true',
              redoAction: localStorage.getItem(config.localStorageKeys.redoAction) === 'true',
              dismissedUndoHotkeyInfo: localStorage.getItem(config.localStorageKeys.dismissedUndoHotkeyInfo) === 'true', // Add new setting
              undoHistoryDefault: localStorage.getItem(config.localStorageKeys.undoHistoryDefault) || 'disabled',
              undoHistoryEnabled: localStorage.getItem("undoHistoryEnabled") === 'true',              mouseModeEnabled,
              maxOpacitySize: parseFloat(localStorage.getItem(config.localStorageKeys.maxOpacitySize)) || 1,
              opacityChangeThreshold: parseFloat(localStorage.getItem(config.localStorageKeys.opacityChangeThreshold)) || 0,
              smartOpacityCap: localStorage.getItem(config.localStorageKeys.smartOpacityCap) === 'true',
              smoothingEnabled,
              mouseWheelMode,
              bypassDenied101Enabled,
              enable1000PressureLevels,
              mirroredTextEnabled,
              rmbActionFixEnabled,
              resetPressureReleaseEnabled,
              positionAwareMirroringEnabled,
              positionAwareRotationEnabled: localStorage.getItem(config.localStorageKeys.positionAwareRotation) === 'true',
              roomTimeData: JSON.parse(localStorage.getItem(config.localStorageKeys.roomTimeData)) || {},
              drawingTimeData: JSON.parse(localStorage.getItem(config.localStorageKeys.drawingTimeData)) || {},
              blockedUsers: JSON.parse(localStorage.getItem(config.localStorageKeys.blockedUsers)) || [],
              persistentBoardSync: localStorage.getItem(config.localStorageKeys.persistentBoardSync) === 'true',
              holdToPickColor: localStorage.getItem(config.localStorageKeys.holdToPickColor) === 'true',
              reconnectAwareSync: localStorage.getItem(config.localStorageKeys.reconnectAwareSync) === 'true',
              fixSelectionOptionsStuck: localStorage.getItem(config.localStorageKeys.fixSelectionOptionsStuck) === 'true',
              fixResizingShift: localStorage.getItem(config.localStorageKeys.fixResizingShift) === 'true',
              resizeRotationBugFix: localStorage.getItem(config.localStorageKeys.resizeRotationBugFix) === 'true',
              instantReconnect: localStorage.getItem(config.localStorageKeys.instantReconnect) === 'true',
              quickLaunch: localStorage.getItem(config.localStorageKeys.quickLaunch) === 'true',
              unlimitedReconnect: localStorage.getItem(config.localStorageKeys.unlimitedReconnect) === 'true',
              detectTrolling: localStorage.getItem(config.localStorageKeys.detectTrolling) === 'true',
              blurControl: localStorage.getItem(config.localStorageKeys.blurControl) === 'true',
              keepTabAlive: localStorage.getItem(config.localStorageKeys.keepTabAlive) === 'true',
              disableBlur: localStorage.getItem(config.localStorageKeys.disableBlur) === 'true',
              preAntsResizing: localStorage.getItem(config.localStorageKeys.preAntsResizing) === 'true',
              extendedBoardByDefault: localStorage.getItem(config.localStorageKeys.extendedBoardByDefault) === 'true',
              smallerZoomStep: localStorage.getItem(config.localStorageKeys.smallerZoomStep) === 'true',
              preciseZoomDisplay: localStorage.getItem(config.localStorageKeys.preciseZoomDisplay) === 'true',
              skipSyncing: localStorage.getItem(config.localStorageKeys.skipSyncing) === 'true',
              fixAutoScroll: localStorage.getItem(config.localStorageKeys.fixAutoScroll) === 'true',
              fixCopyAction: localStorage.getItem(config.localStorageKeys.fixCopyAction) === 'true',
              csCursor: localStorage.getItem(config.localStorageKeys.csCursor) === 'true',
              paintWithinSelection: localStorage.getItem(config.localStorageKeys.paintWithinSelection) === 'true',
              lineInterpolation: localStorage.getItem(config.localStorageKeys.lineInterpolation) === 'true',
              lineSnappingShift: localStorage.getItem(config.localStorageKeys.lineSnappingShift) === 'true',
              brushCustomPressure: localStorage.getItem(config.localStorageKeys.brushCustomPressure) === 'true',
              option20: localStorage.getItem(config.localStorageKeys.option20) === 'true',
              option21: localStorage.getItem(config.localStorageKeys.option21) === 'true',
              option22: localStorage.getItem(config.localStorageKeys.option22) === 'true',
              option23: localStorage.getItem(config.localStorageKeys.option23) === 'true',
              option24: localStorage.getItem(config.localStorageKeys.option24) === 'true',
              option25: localStorage.getItem(config.localStorageKeys.option25) === 'true',
              option26: localStorage.getItem(config.localStorageKeys.option26) === 'true',
              option27: localStorage.getItem(config.localStorageKeys.option27) === 'true',
              option28: localStorage.getItem(config.localStorageKeys.option28) === 'true',
              option29: localStorage.getItem(config.localStorageKeys.option29) === 'true',
              option30: localStorage.getItem(config.localStorageKeys.option30) === 'true',
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "config.json";
            a.click();
            URL.revokeObjectURL(url);
          });

// Update the import button click handler to use a timeout that automatically restarts timers if no file is selected
// Replace the entire import button and import input change handlers with this unified implementation

// Update the import button click handler
this.content.find("#importConfigButton").on("click", () => {
  // Stop all timers and clear any existing references
  if (this.timerIds) {
    this.timerIds.forEach(id => clearInterval(id));
    this.timerIds = [];
  }
  
  // Clear any existing update interval for the dialog
  if (this.updateTimerInterval) {
    clearInterval(this.updateTimerInterval);
    this.updateTimerInterval = null;
  }
  
  // Create a timer ID for tracking the auto-resume
  this.importTimerResumeId = setTimeout(() => {
    // If we reach this point, no file was selected (user canceled)
    // So we should restart the timers, but first make sure we don't have duplicates
    this.stopTimers(); // Make sure everything is stopped first
    this.startTimers(); // Then restart cleanly
    this.importTimerResumeId = null;
  }, 5000); // 5 second timeout - should be enough time to select a file
  
  this.content.find("#importConfigInput").click();
});
// Single unified handler for the file input change event
this.content.find("#importConfigInput").on("change", (event) => {
  // Clear the auto-resume timer since a file was selected
  if (this.importTimerResumeId) {
    clearTimeout(this.importTimerResumeId);
    this.importTimerResumeId = null;
  }
  
  const file = event.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const importedData = JSON.parse(event.target.result);

        // Update localStorage with imported data
        if (importedData.dismissedTrackerInfo !== undefined) {
          localStorage.setItem(
            config.localStorageKeys.dismissedTrackerInfo, 
            importedData.dismissedTrackerInfo.toString()
          );
        }

        if (importedData.positionAwareRotationEnabled !== undefined) {  
          localStorage.setItem(config.localStorageKeys.positionAwareRotation, 
            importedData.positionAwareRotationEnabled.toString());
          this.content.find("#positionAwareRotation").prop("checked", 
            importedData.positionAwareRotationEnabled || false);
        }
        
        if (importedData.dismissedIPTrackerInfo !== undefined) {
          localStorage.setItem(
            config.localStorageKeys.dismissedIPTrackerInfo, 
            importedData.dismissedIPTrackerInfo.toString()
          );
        }
        if (importedData.socketConnectVisible !== undefined) {
          localStorage.setItem(config.localStorageKeys.socketConnectVisible, importedData.socketConnectVisible.toString());
          this.content.find("#socketConnectVisible").prop("checked", importedData.socketConnectVisible || false);
          
          // Apply the visibility setting immediately
          if (importedData.socketConnectVisible) {
            UI.bottombar.showButton('socketConnectButton');
          } else {
            UI.bottombar.hideButton('socketConnectButton');
          }
        }
        if (importedData.undoSteps !== undefined) {
          const undoStepsValue = parseInt(importedData.undoSteps);
          localStorage.setItem(config.localStorageKeys.undoSteps, undoStepsValue.toString());
          
          // If in the undo tab, update the UI
          const undoStepsInput = this.content.find("#undoStepsInput");
          if (undoStepsInput.length) {
            undoStepsInput.val(undoStepsValue);
            
            // Update actual undo steps if safe to do so
            if (window.updateUndoSteps && (!room?.board || 
                (room.board.redoStack.length === 0 && 
                 room.board.undoStack.length === 0 &&
                 !room.board.isProcessingCommit))) {
              window.updateUndoSteps(undoStepsValue);
            }
          }
        }

        if (importedData.dismissedUndoHotkeyInfo !== undefined) {
          localStorage.setItem(
            config.localStorageKeys.dismissedUndoHotkeyInfo, 
            importedData.dismissedUndoHotkeyInfo.toString()
          );
        }
        
        // Handle boolean undo settings
        const undoOptions = ["commitUndoHistory", "toggleUndoHistory", "clearUndoHistory", "undoAction", "redoAction"];
        undoOptions.forEach(option => {
          if (importedData[option] !== undefined) {
            localStorage.setItem(config.localStorageKeys[option], importedData[option].toString());
            
            // Update UI if in undo tab
            const checkbox = this.content.find(`#${option}`);
            if (checkbox.length) {
              checkbox.prop("checked", importedData[option]);
            }
            
            // Update bottombar buttons visibility
            if (UI?.bottombar) {
              // Special handling for undo and redo action buttons which don't follow standard naming
              let buttonId;
              if (option === "undoAction") {
                buttonId = "executeUndoAction";
              } else if (option === "redoAction") {
                buttonId = "executeRedoAction";
              } else {
                buttonId = `${option}Button`;
              }
              
              if (importedData[option]) {
                UI.bottombar.showButton(buttonId);
              } else {
                UI.bottombar.hideButton(buttonId);
              }
            }
          }
        });
        
        // Handle dropdown settings
        if (importedData.undoHistoryDefault !== undefined) {
          localStorage.setItem(config.localStorageKeys.undoHistoryDefault, importedData.undoHistoryDefault);
          const dropdown = this.content.find("#undoHistoryDefault");
          if (dropdown.length) {
            dropdown.val(importedData.undoHistoryDefault);
          }
        }
        
        // Handle current undo history state
        if (importedData.undoHistoryEnabled !== undefined) {
          localStorage.setItem("undoHistoryEnabled", importedData.undoHistoryEnabled.toString());
          if (UI) {
            UI.undoHistoryEnabled = importedData.undoHistoryEnabled;
            
            // Update state indicator if in undo tab
            const stateIndicator = this.content.find("#undoHistoryState");
            if (stateIndicator.length) {
              stateIndicator.text(importedData.undoHistoryEnabled ? "On" : "Off");
            }
          }
        }
        // Process all other settings
        if (importedData.socketDisconnectVisible !== undefined) {
          localStorage.setItem(config.localStorageKeys.socketDisconnectVisible, importedData.socketDisconnectVisible.toString());
          this.content.find("#socketDisconnectVisible").prop("checked", importedData.socketDisconnectVisible || false);
          
          if (importedData.socketDisconnectVisible) {
            UI.bottombar.showButton('socketDisconnectButton');
          } else {
            UI.bottombar.hideButton('socketDisconnectButton');
          }
        }

        // Process all other settings
        // Mouse wheel mode
        if (importedData.mouseWheelMode !== undefined) {
          localStorage.setItem(config.localStorageKeys.mouseWheelMode, importedData.mouseWheelMode);
          this.content.find("#mouseWheelMode").val(importedData.mouseWheelMode);
        }

        // Mouse mode
        if (importedData.mouseModeEnabled !== undefined) {
          localStorage.setItem(config.localStorageKeys.mouseModeEnabled, importedData.mouseModeEnabled.toString());
          this.content.find("#mouseModeToggle").prop("checked", importedData.mouseModeEnabled || false);
          window.mouseModeEnabled = importedData.mouseModeEnabled; // Update global variable
        }

        // Various feature toggles
        const booleanSettings = [
          "bypassDenied101", "enable1000PressureLevels", "smoothingEnabled", 
          "smartOpacityCap", "mirroredText", "rmbActionFix", "resetPressureRelease",
          "positionAwareMirroring", "positionAwareRotation", "persistentBoardSync", "holdToPickColor",
          "reconnectAwareSync", "fixSelectionOptionsStuck", "fixResizingShift", "quickOpacityHotkeys",
          "resizeRotationBugFix"
        ];
        
        booleanSettings.forEach(setting => {
          const key = setting.endsWith("Enabled") ? setting.replace("Enabled", "") : setting;
          const storageKey = config.localStorageKeys[key];
          const importKey = setting;
          
          if (importedData[importKey] !== undefined) {
            localStorage.setItem(storageKey, importedData[importKey].toString());
            this.content.find(`#${key}`).prop("checked", importedData[importKey] || false);
            
            // Special handling for quickOpacityHotkeys to immediately apply the change
            if (key === "quickOpacityHotkeys" && typeof window.toggleQuickOpacityHotkeys === "function") {
              window.toggleQuickOpacityHotkeys(importedData[importKey]);
            }
            
            // Update global variables if needed
            if (window[key] !== undefined) {
              window[key] = importedData[importKey];
            }
          }
        });

        // Numeric settings
        if (importedData.maxOpacitySize !== undefined) {
          localStorage.setItem(config.localStorageKeys.maxOpacitySize, importedData.maxOpacitySize.toString());
          this.content.find("#maxOpacitySizeInput").val(importedData.maxOpacitySize);
          window.maxOpacitySize = importedData.maxOpacitySize;
        }
        
        if (importedData.backgroundColor !== undefined) {
          localStorage.setItem(config.localStorageKeys.backgroundColor, importedData.backgroundColor);
          this.content.find("#backgroundColorPicker").val(importedData.backgroundColor);
                  
          if (importedData.backgroundColorEnabled !== undefined) {
            localStorage.setItem(config.localStorageKeys.backgroundColorEnabled, importedData.backgroundColorEnabled.toString());
            this.content.find("#backgroundColorEnabled").prop("checked", importedData.backgroundColorEnabled);
                    
          }
        }
        
        if (importedData.opacityChangeThreshold !== undefined) {
          localStorage.setItem(config.localStorageKeys.opacityChangeThreshold, importedData.opacityChangeThreshold.toString());
          this.content.find("#opacityChangeThresholdInput").val(importedData.opacityChangeThreshold);
          window.opacityChangeThreshold = importedData.opacityChangeThreshold;
        }

        // Object data
        ["roomTimeData", "drawingTimeData", "blockedUsers"].forEach(dataKey => {
          if (importedData[dataKey]) {
            localStorage.setItem(config.localStorageKeys[dataKey], JSON.stringify(importedData[dataKey]));
          }
        });

        // Handle all toggleable options
        ["instantReconnect", "quickLaunch", "unlimitedReconnect", "detectTrolling", 
         "blurControl", "keepTabAlive", "disableBlur", "preAntsResizing", 
         "extendedBoardByDefault", "smallerZoomStep", "preciseZoomDisplay", 
         "skipSyncing", "fixAutoScroll", "fixCopyAction",
         "csCursor", "paintWithinSelection", "lineInterpolation", "lineSnappingShift", "brushCustomPressure", "option20", "option21", "option22", "option23", "option24", "option25", "option26", "option27", "option28", "option29", "option30"
        ].forEach(option => {
          if (importedData[option] !== undefined) {
            localStorage.setItem(config.localStorageKeys[option], importedData[option].toString());
            this.content.find(`#${option}`).prop("checked", importedData[option] || false);
          }
        });

        UI.dialogHandler.showAlert("Configuration imported successfully!");
      } catch (e) {
        // Use UI dialog for error message
        UI.dialogHandler.showAlert("Failed to import configuration: Invalid JSON.");
      } finally {
        // Always restart timers after processing the import
        this.stopTimers();
        this.startTimers();
      }
    };

    reader.readAsText(file);
    this.content.find("#importConfigInput").val("");
  } else {
    // No file was selected, restart timers immediately
    this.stopTimers();
    this.startTimers();
  }
});
        }          
        else if (subcontent === "messenger") {
          // Add localStorage key for the messenger tip
          config.localStorageKeys.dismissedMessengerTip = "dismissedMessengerTip";
          
          // Initialize with default value if not set
          if (!localStorage.getItem(config.localStorageKeys.dismissedMessengerTip)) {
            localStorage.setItem(config.localStorageKeys.dismissedMessengerTip, "false");
          }
          
          // Check if the tip has been dismissed
          const isMessengerTipDismissed = localStorage.getItem(config.localStorageKeys.dismissedMessengerTip) === "true";
          
          // Define a function to refresh the UI
          this.refreshMessengerUI = () => {
            this.content.find("#blockedUsers").html(
              this.getBlockedUsers().map(user => `<li style="margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; padding: 4px 8px; background: #222; border-radius: 4px;">
                <span>${user}</span>
                <button class="unblockUser action-button" data-username="${user}" style="margin-left: 10px; padding: 2px 8px; background: #444; color: #fff; border: none; cursor: pointer; border-radius: 4px;">Unblock</button>
              </li>`).join('')
            );
            
            // Re-attach event handlers for the new buttons
            this.content.find(".unblockUser").on("click", function() {
              const username = $(this).data("username");
              _this.unblockUser(username);
              _this.refreshMessengerUI(); // Refresh UI after unblocking
            });
          };
          
          this.loadSubcontent(`
            <style>
              #messengerSection {
                display: flex;
                flex-direction: column;
                height: 100%;
                overflow: hidden;
              }
              #messengerContainer {
                flex: 1;
                overflow-y: auto;
                padding-right: 10px;
                margin-bottom: 15px;
              }
              .action-button {
                padding: 5px 10px;
                background: #444;
                color: #fff;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                transition: background 0.2s;
              }
              .action-button:hover {
                background: #555;
              }
              #messengerContainer::-webkit-scrollbar {
                width: 8px;
              }
              #messengerContainer::-webkit-scrollbar-track {
                background: #1e1e1e;
                border-radius: 4px;
              }
              #messengerContainer::-webkit-scrollbar-thumb {
                background: #444;
                border-radius: 4px;
              }
              #messengerContainer::-webkit-scrollbar-thumb:hover {
                background: #555;
              }
            </style>
        
            <div id="messengerSection">
              <div id="messengerContainer">
                <h2 style="border-bottom: 1px solid #444; padding-bottom: 10px;">Messenger Controls</h2>
                
                <div style="margin-bottom: 20px;">
                  <label for="blockedUsers" style="display: block; margin-bottom: 10px; color: #ddd;">Blocked Users:</label>
                  <ul id="blockedUsers" style="list-style: none; padding: 0; max-height: 150px; overflow-y: auto; border: 1px solid #444; border-radius: 4px; background-color: #222; color: #fff; padding: 8px; margin: 0;">
                    ${this.getBlockedUsers().map(user => `<li style="margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; padding: 4px 8px; background: #2a2a2a; border-radius: 4px;">
                      <span>${user}</span>
                      <button class="unblockUser action-button" data-username="${user}" style="margin-left: 10px; padding: 2px 8px;">Unblock</button>
                    </li>`).join('')}
                  </ul>
                </div>
                
                <div style="margin-bottom: 30px;">
                  <label for="blockUserInput" style="display: block; margin-bottom: 10px; color: #ddd;">Block a User:</label>
                  <div style="display: flex; gap: 10px;">
                    <input type="text" id="blockUserInput" class="form-control" style="flex: 1; padding: 8px; background-color: #222; color: #fff; border: 1px solid #444; border-radius: 4px;" placeholder="Enter username...">
                    <button id="blockUserButton" class="action-button">Block User</button>
                  </div>
                </div>
                
                <!-- Tip box moved to bottom -->
                <div id="messengerTipMessage" style="font-size: 0.9em; margin-top: 20px; padding: 8px 12px; background-color: rgba(0, 123, 255, 0.2); border-left: 4px solid #007bff; color: #b8daff; border-radius: 4px; ${isMessengerTipDismissed ? 'display: none;' : ''}">
                  <i class="fa fa-info-circle" style="margin-right: 5px; color: #b8daff;"></i>
                  You can right-click on a user in the messenger to block them directly.
                  <div style="display: flex; justify-content: flex-end; margin-top: 5px;">
                    <button id="dismissMessengerTip" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 2px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">Got it!</button>
                  </div>
                </div>
              </div>
            </div>
          `);
        
          // Attach event handler for dismissing the tip
          this.content.find("#dismissMessengerTip").on("click", function(e) {
            e.preventDefault();
            localStorage.setItem(config.localStorageKeys.dismissedMessengerTip, "true");
            $("#messengerTipMessage").fadeOut(200);
          });
        
          // Update the attachMessengerEvents function to use the refresh function
          this.attachMessengerEvents = function() {
            const _this = this;
            
            // Handle unblock buttons
            this.content.find(".unblockUser").on("click", function() {
              const username = $(this).data("username");
              _this.unblockUser(username);
              _this.refreshMessengerUI(); // Refresh UI after unblocking
            });
            
            // Handle block button
            this.content.find("#blockUserButton").on("click", function() {
              const username = _this.content.find("#blockUserInput").val().trim();
              if (username) {
                _this.blockUser(username);
                _this.content.find("#blockUserInput").val(""); // Clear input
                _this.refreshMessengerUI(); // Refresh UI after blocking
              }
            });
            
            // Handle enter key in input field
            this.content.find("#blockUserInput").on("keypress", function(e) {
              if (e.which === 13) { // Enter key
                const username = $(this).val().trim();
                if (username) {
                  _this.blockUser(username);
                  $(this).val(""); // Clear input
                  _this.refreshMessengerUI(); // Refresh UI after blocking
                }
              }
            });
          };
          
          // Attach event listeners for blocking and unblocking users
          this.attachMessengerEvents();
        }

        if (subcontent === "currency") {
          // Add FMC local storage keys to config
          config.localStorageKeys.fmcInitialDrawingTimeProcessed = "fmcInitialDrawingTimeProcessed";
          
          // Calculate coins based on drawing time
          const calculateCoinsFromDrawingTime = () => {
            let totalDrawingTime = 0;
            for (const room in this.drawingTimeData) {
              totalDrawingTime += this.drawingTimeData[room] || 0;
            }
            return totalDrawingTime / 60; // 60 seconds = 1 coin
          };
          
          // Initialize StockMarketDB if it doesn't exist yet
          if (!window.StockMarketDB) {
            // Define a minimal version if not already defined elsewhere
            window.StockMarketDB = {
              dbName: 'StockMarketDatabase',
              version: 1,
              db: null,
              
              async init() {
                if (this.db) return this.db;
                
                return new Promise((resolve, reject) => {
                  const request = indexedDB.open(this.dbName, this.version);
                  
                  request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('balance')) {
                      db.createObjectStore('balance');
                    }
                  };
                  
                  request.onsuccess = (event) => {
                    this.db = event.target.result;
                    resolve(this.db);
                  };
                  
                  request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.error);
                    reject(event.target.error);
                  };
                });
              },
              
              async getBalance() {
                await this.init();
                return new Promise((resolve, reject) => {
                  const transaction = this.db.transaction(['balance'], 'readonly');
                  const store = transaction.objectStore('balance');
                  const request = store.get('fmc');
                  
                  request.onsuccess = (event) => {
                    resolve(event.target.result || 0);
                  };
                  
                  request.onerror = (event) => {
                    reject(event.target.error);
                  };
                });
              },
              
              async updateBalance(amount) {
                await this.init();
                return new Promise((resolve, reject) => {
                  const transaction = this.db.transaction(['balance'], 'readwrite');
                  const store = transaction.objectStore('balance');
                  const request = store.put(amount, 'fmc');
                  
                  request.onsuccess = () => resolve();
                  request.onerror = (event) => reject(event.target.error);
                });
              }
            };
          }
          
          // Using an async IIFE to handle the async operations
          (async () => {
            try {
              // Check if we've already processed the initial drawing time bonus
              const hasProcessedInitialBonus = localStorage.getItem(config.localStorageKeys.fmcInitialDrawingTimeProcessed) === "true";
              
              // Get or initialize FMC balance from IndexedDB
              let currentBalance = await StockMarketDB.getBalance();
              
              // Try to migrate from localStorage if no balance in IndexedDB and not yet migrated
              if (currentBalance === 0 && !localStorage.getItem('fmcBalanceMigrated')) {
                const localStorageBalance = parseFloat(localStorage.getItem("fmcBalance") || "0");
                if (localStorageBalance > 0) {
                  await StockMarketDB.updateBalance(localStorageBalance);
                  currentBalance = localStorageBalance;
                  localStorage.setItem('fmcBalanceMigrated', 'true');
                  console.log('FMC balance migrated from localStorage to IndexedDB');
                }
              }
              
              // If this is first launch, add the drawing time bonus
              if (!hasProcessedInitialBonus) {
                const baseAmount = 100;
                const drawingTimeBonus = calculateCoinsFromDrawingTime();
                
                // Add the initial amounts
                currentBalance = baseAmount + drawingTimeBonus;
                
                // Save the new balance to IndexedDB
                await StockMarketDB.updateBalance(currentBalance);
                
                // Mark the initial drawing time as processed
                localStorage.setItem(config.localStorageKeys.fmcInitialDrawingTimeProcessed, "true");
              }
              
              // Calculate drawing time bonus (for display purposes)
              const drawingTimeBonus = calculateCoinsFromDrawingTime();
              const totalDrawingSeconds = Object.values(this.drawingTimeData).reduce((a, b) => a + b, 0) || 0;
              
              this.loadSubcontent(`
                <style>
                  .currency-container {
                    height: 100%;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                  }
                  .balance-display {
                    background: linear-gradient(to right, #2c3e50, #4c669f);
                    padding: 20px;
                    border-radius: 8px;
                    margin-bottom: 20px;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                    text-align: center;
                  }
                  .balance-amount {
                    font-size: 32px;
                    font-weight: bold;
                    margin: 10px 0;
                    color: #FFD700;
                    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                  }
                  .currency-info {
                    flex: 1;
                    overflow-y: auto;
                    background: #292929;
                    padding: 20px;
                    border-radius: 6px;
                  }
                  .info-title {
                    font-size: 18px;
                    margin-bottom: 12px;
                    color: #FFD700;
                    border-bottom: 1px solid #444;
                    padding-bottom: 8px;
                  }
                  .calculation-details {
                    background: #333;
                    padding: 15px;
                    border-radius: 6px;
                    margin: 15px 0;
                  }
                  .bonus-info {
                    padding: 10px;
                    background: ${hasProcessedInitialBonus ? '#2c3e50' : '#2d4e2a'};
                    border-radius: 4px;
                    margin-top: 10px;
                    border-left: 4px solid ${hasProcessedInitialBonus ? '#3498db' : '#4CAF50'};
                  }
                  .storage-method {
                    font-size: 11px;
                    color: #aaa;
                    margin-top: 5px;
                    text-align: right;
                  }
                </style>
                
                <div class="currency-container">
                  <div class="balance-display">
                    <h2>FlockModCoin Balance</h2>
                    <div class="balance-amount">
                      <i class="fa fa-coins"></i> ${currentBalance.toFixed(3)} FMC
                    </div>
                  </div>
                  
                  <div class="currency-info">
                    <h3 class="info-title">About FlockModCoin (FMC)</h3>
                    <p>FlockModCoin is a virtual currency that rewards your activity on FlockMod.</p>
                    
                    <div class="calculation-details">
                      <h4>Your Balance Calculation:</h4>
                      <ul>
                        <li>Base coins: 100 FMC</li>
                        <li>Drawing time bonus: ${drawingTimeBonus.toFixed(3)} FMC (${totalDrawingSeconds} seconds)</li>
                        <li>Total: ${currentBalance.toFixed(3)} FMC</li>
                      </ul>
                      
                      <div class="bonus-info">
                        <i class="fa fa-${hasProcessedInitialBonus ? 'info-circle' : 'check-circle'}" style="margin-right:5px;"></i>
                        ${hasProcessedInitialBonus ? 
                          'You have already received your one-time drawing time bonus.' : 
                          'Your drawing time bonus has been added to your balance!'}
                      </div>
                    </div>
                    
                    <h3 class="info-title">Earning FMC</h3>
                    <p>For every 60 seconds you spend drawing, you earn 1 FMC.</p>
                    <p>Your drawing time is tracked across all rooms automatically.</p>
                  </div>
                </div>
              `);
              
              // Store the current subcontent for later checks
              this._currentSubcontent = "currency";
              
            } catch (error) {
              console.error('Error loading currency subcontent:', error);
              
              // Show error message
              this.loadSubcontent(`
                <div style="padding: 20px; text-align: center;">
                  <h3 style="color: #e74c3c;">Error loading balance</h3>
                  <p>There was a problem accessing your FMC balance. Please refresh and try again.</p>
                </div>
              `);
              
              this._currentSubcontent = "currency";
            }
          })();
        }

        if (subcontent === "stocks") {
        // Store local storage keys for migration
        const storageKeys = {
        stockPortfolio: "fmcStockPortfolio",
        stockTransactions: "fmcStockTransactions",
        fmcBalance: "fmcBalance"
        };

        // Initialize stock market helper
        if (!this.stockMarket) {
        this.stockMarket = {
        // Stock definitions with different volatilities
        stocks: [
          { symbol: "FMOD", name: "FlockMod Inc.", sector: "Technology", basePrice: 45.50, volatility: 0.8 },
          { symbol: "DRAW", name: "DrawTech Solutions", sector: "Software", basePrice: 128.75, volatility: 1.2 },
          { symbol: "PXLS", name: "Pixel Systems", sector: "Entertainment", basePrice: 22.40, volatility: 1.5 },
          { symbol: "CVAS", name: "Canvas Networks", sector: "Social Media", basePrice: 76.30, volatility: 1.0 },
          { symbol: "ARTX", name: "ArtiFlex Corp", sector: "Hardware", basePrice: 53.20, volatility: 0.6 }
        ],

        // Settings for the simulation - updated for 1 month history
        settings: {
          rapidityFactor: 5, // Higher = more rapid changes
          historyPoints: 720, // 1 month (30 days * 24 hours)
          interval: 3600000, // 1 hour in milliseconds - each tick represents this much time
          refreshRate: 1000, // How often to update in ms
        },

        // Get current user balance
        getBalance: async () => {
          return await StockMarketDB.getBalance();
        },

        updateBalance: async (newBalance) => {
          return await StockMarketDB.updateBalance(newBalance);
        },

        getPortfolio: async () => {
          return await StockMarketDB.getPortfolio();
        },

        updatePortfolio: async (portfolio) => {
          return await StockMarketDB.updatePortfolio(portfolio);
        },

        getTransactions: async () => {
          return await StockMarketDB.getTransactions();
        },

        addTransaction: async (transaction) => {
          return await StockMarketDB.addTransaction(transaction);
        },

        // Seeded random number generator
        seededRandom: function(seed) {
          const x = Math.sin(seed) * 10000;
          return x - Math.floor(x);
        },

        // Generate a price for a specific time and stock
        // Replace the incorrect getPriceAt definition with this:
        getPriceAt: function(stock, timestamp) {
          // Break timestamp into components to create deterministic but varying seeds
          const minutes = Math.floor(timestamp / 60000);
          const hours = Math.floor(timestamp / 3600000);
          const day = Math.floor(hours / 24);
          const month = Math.floor(day / 30);
          
          // Get current real-time component for small fluctuations
          const now = Date.now();
          const realTimeFactor = (now % 1000) / 1000; // 0-1 based on milliseconds
          const secondsOfMinute = Math.floor((now / 1000) % 60);
          const realtimeSeed = stock.symbol.charCodeAt(0) + secondsOfMinute;
          
          // Base seed combines stock symbol, day and hour for deterministic results
          let seed = stock.symbol.charCodeAt(0) * 100 + day * 24 + (hours % 24);
          let minuteSeed = seed * 60 + (minutes % 60); // Add minute seed for minute-level variation
          
          // Generate base price from seed - use the MOST DETAILED data available for consistency
          const monthTrend = this.seededRandom(month) * 2 - 1; // -1 to 1
          const dayTrend = this.seededRandom(day) * 2 - 1; // -1 to 1
          const hourTrend = this.seededRandom(seed) * 2 - 1; // -1 to 1
          const minuteTrend = this.seededRandom(minuteSeed) * 2 - 1; // -1 to 1
          
          // Add small realtime fluctuation that changes every second
          const realtimeFluctuation = (this.seededRandom(realtimeSeed) * 2 - 1) * stock.volatility * 0.005;
          
          // Apply trends with volatility - accumulate the effects
          const monthFactor = 1 + (monthTrend * 0.2 * stock.volatility);
          const dayFactor = 1 + (dayTrend * 0.1 * stock.volatility);
          const hourFactor = 1 + (hourTrend * 0.05 * stock.volatility * this.settings.rapidityFactor);
          const minuteFactor = 1 + (minuteTrend * 0.02 * stock.volatility * this.settings.rapidityFactor);
          const realtimeFactor = 1 + realtimeFluctuation;
          
          // Calculate base price using ALL factors
          // This ensures the price is consistent across time frames but still has real-time movement
          let basePrice = stock.basePrice * monthFactor * dayFactor * hourFactor * minuteFactor * realtimeFactor;
          
          // Add appropriate randomness based on time frame for OHLC data
          let finalPrice = basePrice;
          const variance = stock.volatility * 0.02 * this.settings.rapidityFactor * finalPrice;
          
          // Generate OHLC data using the appropriate seed for the view
          let seedToUse;
          switch (this.settings.activeTimeFrame) {
            case 'minutes':
              seedToUse = minuteSeed;
              break;
            case 'hours':
              seedToUse = seed;
              break;
            case 'days':
              seedToUse = day;
              break;
            case 'months':
              seedToUse = month;
              break;
            default:
              seedToUse = seed;
          }
          
          // Include realtime seed in all calculations for consistent price movement
          seedToUse = seedToUse + (secondsOfMinute / 100);
          
          const open = finalPrice;
          const high = finalPrice + this.seededRandom(seedToUse + 1) * variance;
          const low = finalPrice - this.seededRandom(seedToUse + 2) * variance;
          const close = finalPrice + (this.seededRandom(seedToUse + 3) * 2 - 1) * variance * 0.7;
          
          // Scale volume based on time frame
          let volume;
          switch (this.settings.activeTimeFrame) {
            case 'minutes':
              volume = Math.floor(this.seededRandom(seedToUse + 4) * 200) + 50;
              break;
            case 'hours':
              volume = Math.floor(this.seededRandom(seedToUse + 4) * 10000) + 1000;
              break;
            case 'days':
              volume = Math.floor(this.seededRandom(seedToUse + 4) * 10000) + 1000 * 24;
              break;
            case 'months':
              volume = Math.floor(this.seededRandom(seedToUse + 4) * 10000) + 1000 * 24 * 30;
              break;
            default:
              volume = Math.floor(this.seededRandom(seedToUse + 4) * 10000) + 1000;
          }
          
          return {
            timestamp,
            open,
            high,
            low,
            close,
            volume,
            // Add base price for debugging/confirmation
            basePrice: finalPrice 
          };
        },

        // Get historical data for a stock
        getHistory: function(stock) {
          const now = Date.now();
          const history = [];
          
          // Generate history points
          for (let i = this.settings.historyPoints; i >= 0; i--) {
            const timestamp = now - (i * this.settings.interval);
            history.push(this.getPriceAt(stock, timestamp));
          }
          
          return history;
        },

        // Calculate portfolio value
        calculatePortfolioValue: function() {
          const portfolio = this.getPortfolio();
          let totalValue = 0;
          
          for (const symbol in portfolio) {
            const stock = this.stocks.find(s => s.symbol === symbol);
            if (stock) {
              const currentPrice = this.getPriceAt(stock, Date.now()).close;
              totalValue += portfolio[symbol] * currentPrice;
            }
          }
          
          return totalValue;
        }
        };
        }
        this.stockMarket.settings = {
        rapidityFactor: 5,
        historyPoints: 720, // Keep a month of hourly data
        interval: 3600000,  // 1 hour in milliseconds
        refreshRate: 1000,  // How often to update in ms
        timeFrames: {
        minutes: { interval: 60000, display: "Minutes" },
        hours: { interval: 3600000, display: "Hours" },
        days: { interval: 86400000, display: "Days" },
        months: { interval: 2592000000, display: "Months" }
        },
        activeTimeFrame: "hours" // Default selected timeframe
        };

        this.loadSubcontent(`
        <style>
        /* Main Container Structure */
        .stock-container {
          height: 100%;
          display: flex;
          flex-direction: column;
          overflow: hidden;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        .stock-header {
          background: #1a1a1a;
          padding: 15px;
          border-bottom: 1px solid #333;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        .stock-balance {
          background: linear-gradient(to right, #2c3e50, #4c669f);
          padding: 10px 20px;
          border-radius: 4px;
          color: #FFD700;
          font-weight: bold;
          display: flex;
          align-items: center;
          box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .stock-content {
          display: flex;
          flex: 1;
          overflow: hidden;
        }

        /* Stock List */
        .stock-list {
          width: 25%;
          background: #222;
          border-right: 1px solid #333;
          overflow-y: auto;
        }
        .stock-item {
          padding: 15px;
          border-bottom: 1px solid #333;
          cursor: pointer;
          transition: background 0.2s, border-left 0.2s;
        }
        .stock-item:hover {
          background: #2a2a2a;
        }
        .stock-item.active {
          background: #2d3436;
          border-left: 4px solid #3498db;
        }

        /* Stock Detail Section */
        .stock-detail {
          flex: 1;
          display: flex;
          flex-direction: column;
          overflow: hidden;
        }
        .stock-info {
          padding: 15px;
          background: #222;
          border-bottom: 1px solid #333;
        }

        /* Chart Styles */
        .stock-graph {
          flex: 1;
          background: #1a1a1a;
          position: relative;
          overflow: hidden;
        }
        .chart-container {
          position: relative;
          width: 100%;
          height: 100%;
        }
        .chart-tooltip {
          position: absolute;
          background: rgba(0,0,0,0.85);
          color: #fff;
          padding: 10px;
          border-radius: 4px;
          font-size: 12px;
          pointer-events: none;
          opacity: 0;
          z-index: 100;
          transition: opacity 0.15s;
          box-shadow: 0 2px 8px rgba(0,0,0,0.5);
          border: 1px solid #444;
        }
        .chart-overlay {
          position: absolute;
          top: 0;
          left: 0;
          right: 0; 
          bottom: 0;
          z-index: 1;
          cursor: crosshair;
        }
        .grid-line {
          position: absolute;
          left: 0;
          right: 0;
          height: 1px;
          background: rgba(255,255,255,0.07);
          pointer-events: none;
        }
        .price-label {
          position: absolute;
          right: 5px;
          font-size: 10px;
          color: #999;
          background: rgba(0,0,0,0.3);
          padding: 2px 4px;
          border-radius: 2px;
          pointer-events: none;
        }
        .date-label {
          position: absolute;
          bottom: 2px;
          font-size: 9px;
          color: #999;
          white-space: nowrap;
          pointer-events: none;
        }

        /* Candlestick Elements */
        .candlestick {
          position: absolute;
          cursor: pointer;
          z-index: 2;
        }
        .candle-body {
          position: absolute;
          width: 100%;
        }
        .candle-wick {
          position: absolute;
        }
        .candle-green {
          background: rgba(46, 204, 113, 0.9);
          border: 1px solid #27ae60;
        }
        .candle-red {
          background: rgba(231, 76, 60, 0.9);
          border: 1px solid #c0392b;
        }

        /* SVG Elements */
        .trend-line {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 1;
        }

        /* Trading Controls */
        .stock-actions {
          padding: 15px;
          background: #222;
          border-top: 1px solid #333;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        .trade-controls {
          display: flex;
          gap: 10px;
          align-items: center;
        }
        .trade-input {
          background: #333;
          border: 1px solid #555;
          border-radius: 4px;
          padding: 8px;
          color: white;
          width: 100px;
        }
        .btn-buy {
          background: #27ae60;
          color: white;
          border: none;
          border-radius: 4px;
          padding: 8px 15px;
          cursor: pointer;
          font-weight: bold;
          transition: background 0.2s;
        }
        .btn-buy:hover {
          background: #2ecc71;
        }
        .btn-sell {
          background: #c0392b;
          color: white;
          border: none;
          border-radius: 4px;
          padding: 8px 15px;
          cursor: pointer;
          font-weight: bold;
          transition: background 0.2s;
        }
        .btn-sell:hover {
          background: #e74c3c;
        }

        /* Price Indicators */
        .price-up {
          color: #2ecc71;
        }
        .price-down {
          color: #e74c3c;
        }

        /* Tab Navigation */
        .tab-buttons {
          display: flex;
          background: #222;
          border-bottom: 1px solid #333;
        }
        .tab-button {
          padding: 10px 15px;
          background: none;
          border: none;
          color: #aaa;
          cursor: pointer;
          transition: all 0.2s;
        }
        .tab-button.active {
          color: #3498db;
          border-bottom: 2px solid #3498db;
        }
        .tab-content {
          display: none;
          padding: 15px;
          overflow-y: auto;
          max-height: 200px;
        }
        .tab-content.active {
          display: block;
        }

        /* Portfolio Items */
        .portfolio-item {
          display: flex;
          justify-content: space-between;
          padding: 10px;
          border-bottom: 1px solid #333;
          transition: background 0.2s;
        }
        .portfolio-item:hover {
          background: #2a2a2a;
        }

        /* Transaction History */
        .transactions-list {
          font-size: 0.9em;
        }
        .transaction-item {
          padding: 8px 10px;
          border-bottom: 1px solid #333;
          margin-bottom: 5px;
          transition: background 0.2s;
        }
        .transaction-item:hover {
          background: #2a2a2a;
        }
        .transaction-buy {
          border-left: 3px solid #27ae60;
        }
        .transaction-sell {
          border-left: 3px solid #c0392b;
        }

        /* Scrollbars */
        .stock-list::-webkit-scrollbar,
        .tab-content::-webkit-scrollbar {
          width: 8px;
        }
        .stock-list::-webkit-scrollbar-track,
        .tab-content::-webkit-scrollbar-track {
          background: #1a1a1a;
        }
        .stock-list::-webkit-scrollbar-thumb,
        .tab-content::-webkit-scrollbar-thumb {
          background: #444;
          border-radius: 4px;
        }
        .stock-list::-webkit-scrollbar-thumb:hover,
        .tab-content::-webkit-scrollbar-thumb:hover {
          background: #555;
        }

        /* Time Range Selector */
        .time-range {
          display: flex;
          justify-content: center;
          gap: 5px;
          padding: 5px 0;
          background: rgba(0,0,0,0.2);
          margin-top: -1px;
        }
        .range-btn {
          background: rgba(255,255,255,0.1);
          border: none;
          color: #aaa;
          padding: 3px 8px;
          border-radius: 3px;
          font-size: 11px;
          cursor: pointer;
          transition: all 0.2s;
        }
        .range-btn:hover {
          background: rgba(255,255,255,0.15);
          color: white;
        }
        .range-btn.active {
          background: #3498db;
          color: white;
        }
              .time-selector {
        display: flex;
        justify-content: center;
        gap: 5px;
        padding: 10px 0;
        background: rgba(0,0,0,0.3);
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        z-index: 5;
        }

        .time-btn {
        background: rgba(255,255,255,0.1);
        border: none;
        color: #aaa;
        padding: 5px 10px;
        border-radius: 3px;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s;
        }

        .time-btn:hover {
        background: rgba(255,255,255,0.2);
        color: white;
        }

        .time-btn.active {
        background: #3498db;
        color: white;
        }

        /* Simplified chart styles */
        .chart-container {
        position: relative;
        width: 100%;
        height: 100%;
        }

        .candlestick {
        position: absolute;
        cursor: pointer;
        z-index: 2;
        height: 100%;
        }

        .candle-body {
        position: absolute;
        width: 100%;
        }

        .candle-wick {
        position: absolute;
        width: 1px;
        background: #999;
        }

        .chart-tooltip {
        position: absolute;
        background: rgba(0,0,0,0.85);
        color: white;
        padding: 8px 10px;
        border-radius: 4px;
        font-size: 11px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        opacity: 0;
        transition: opacity 0.2s;
        pointer-events: none;
        z-index: 50;
        max-width: 200px;
        border: 1px solid #444;
        }
        </style>

        <div class="stock-container">
        <div class="stock-header">
          <h2>FMC Stock Exchange</h2>
          <div class="stock-balance">
            <i class="fa fa-coins" style="margin-right:8px;"></i>
            <span id="fmc-balance">Loading...</span> FMC
          </div>
        </div>

        <div class="stock-content">
          <!-- Stock List -->
          <div class="stock-list">
            ${this.stockMarket.stocks.map((stock, index) => `
              <div class="stock-item ${index === 0 ? 'active' : ''}" data-symbol="${stock.symbol}">
                <div style="font-weight:bold;">${stock.symbol}</div>
                <div style="font-size:0.8em;color:#aaa;">${stock.name}</div>
                <div class="stock-price" data-symbol="${stock.symbol}">Loading...</div>
              </div>
            `).join('')}
          </div>
          
          <!-- Stock Detail -->
          <div class="stock-detail">
            <div class="stock-info">
              <h3 id="detail-name">Select a stock</h3>
              <div id="detail-price"></div>
            </div>
            
            <div class="stock-graph" id="stock-graph">
              <!-- Graph will be drawn here -->
            </div>
            
            <div class="stock-actions">
              <div class="trade-controls">
                <input type="number" min="0.001" step="0.001" class="trade-input" id="trade-amount" placeholder="Shares">
                <button class="btn-buy" id="btn-buy">Buy</button>
                <button class="btn-sell" id="btn-sell">Sell</button>
              </div>
              <div>
                Holding: <span id="holding-amount">0</span> shares
              </div>
            </div>
            
            <!-- Tabs for portfolio and transactions -->
            <div class="tab-buttons">
              <button class="tab-button active" data-tab="portfolio">Portfolio</button>
              <button class="tab-button" data-tab="transactions">Transactions</button>
            </div>
            
            <div class="tab-content active" id="portfolio">
              <div id="portfolio-list">
                <!-- Portfolio items -->
              </div>
            </div>
            
            <div class="tab-content" id="transactions">
              <div id="transactions-list" class="transactions-list">
                <!-- Transaction history -->
              </div>
            </div>
          </div>
        </div>
        </div>
        `);

        // Store the current subcontent
        this._currentSubcontent = "stocks";

        // Initialize selected stock
        this.selectedStock = this.stockMarket.stocks[0];

        // Update the stock prices and draw the chart
        const updateStockDisplay = async (updateEverything = false) => {
        // Update all stock prices in the list
        this.stockMarket.stocks.forEach(stock => {
        const currentData = this.stockMarket.getPriceAt(stock, Date.now());
        const previousData = this.stockMarket.getPriceAt(stock, Date.now() - this.stockMarket.settings.interval);

        const priceChange = currentData.close - previousData.close;
        const priceChangePercent = (priceChange / previousData.close) * 100;

        const priceElement = this.content.find(`.stock-price[data-symbol="${stock.symbol}"]`);
        priceElement.html(`
          <span class="${priceChange >= 0 ? 'price-up' : 'price-down'}">
            ${currentData.close.toFixed(2)}
            <span style="font-size:0.8em;">
              ${priceChange >= 0 ? '' : ''} ${Math.abs(priceChangePercent).toFixed(2)}%
            </span>
          </span>
        `);
        });

        // Update selected stock detail and chart
        if (this.selectedStock) {
        const currentData = this.stockMarket.getPriceAt(this.selectedStock, Date.now());
        const previousClose = this.stockMarket.getPriceAt(
          this.selectedStock, 
          Date.now() - this.stockMarket.settings.interval
        ).close;

        const priceChange = currentData.close - previousClose;
        const priceChangePercent = (priceChange / previousClose) * 100;

        this.content.find('#detail-name').text(`${this.selectedStock.name} (${this.selectedStock.symbol})`);
        this.content.find('#detail-price').html(`
          <div style="font-size:24px;">
            <span class="${priceChange >= 0 ? 'price-up' : 'price-down'}">
              ${currentData.close.toFixed(2)} 
              <span style="font-size:0.7em;">
                ${priceChange >= 0 ? '' : ''} ${Math.abs(priceChange).toFixed(2)} (${Math.abs(priceChangePercent).toFixed(2)}%)
              </span>
            </span>
          </div>
          <div style="color:#999;margin-top:5px;">${this.selectedStock.sector} | Volume: ${currentData.volume.toLocaleString()}</div>
        `);

        // Update holdings - NOW WITH PROPER AWAIT
        try {
          const portfolio = await this.stockMarket.getPortfolio();
          const holding = portfolio[this.selectedStock.symbol] || 0;
          this.content.find('#holding-amount').text(holding.toFixed(3));
        } catch (err) {
          console.error('Error fetching portfolio:', err);
          this.content.find('#holding-amount').text('Error');
        }

        // Draw the chart
        drawChart();
        }

        // Update balance - Always needed
        try {
        const balance = await this.stockMarket.getBalance();
        this.content.find('#fmc-balance').text(balance.toFixed(3));
        } catch (err) {
        console.error('Error fetching balance:', err);
        this.content.find('#fmc-balance').text('Error');
        }

        // Only update portfolio and transactions when explicitly requested
        if (updateEverything) {
        await updatePortfolio();
        await updateTransactions();
        }
        };


        if (!this.stockLivePrices) {
        this.stockLivePrices = {};
        }
        // Draw chart for selected stock - point-based version
        const drawChart = () => {
        if (!this.selectedStock) return;

        const graph = this.content.find('#stock-graph');

        // Clear previous chart
        graph.empty();

        // Add chart container
        const chartContainer = $('<div class="chart-container"></div>');
        graph.append(chartContainer);

        // Add time frame selector
        const timeSelector = $('<div class="time-selector"></div>');
        Object.keys(this.stockMarket.settings.timeFrames).forEach(period => {
        const isActive = period === this.stockMarket.settings.activeTimeFrame;
        const btn = $(`<button class="time-btn ${isActive ? 'active' : ''}">${
          this.stockMarket.settings.timeFrames[period].display
        }</button>`);

        btn.on('click', () => {
          this.stockMarket.settings.activeTimeFrame = period;
          this.content.find('.time-btn').removeClass('active');
          btn.addClass('active');
          drawChart();
        });

        timeSelector.append(btn);
        });
        chartContainer.append(timeSelector);

        // Get data based on selected time frame
        const timeFrame = this.stockMarket.settings.timeFrames[this.stockMarket.settings.activeTimeFrame];
        const now = Date.now();
        const dataPoints = [];

        // Generate data points with consistent time boundaries based on the timeframe
        for (let i = 13; i >= 0; i--) {
        // Calculate timestamp aligned to the timeframe boundaries
        let timestamp;
        const interval = timeFrame.interval;

        // Round timestamp to the nearest interval boundary in the past
        switch (this.stockMarket.settings.activeTimeFrame) {
          case 'minutes':
            // Round to the previous full minute
            timestamp = now - (now % 60000) - (i * interval);
            break;
          case 'hours':
            // Round to the previous full hour
            timestamp = now - (now % 3600000) - (i * interval);
            break;
          case 'days':
            // Round to the previous midnight
            const dayStart = new Date(now);
            dayStart.setHours(0, 0, 0, 0);
            timestamp = dayStart.getTime() - (i * interval);
            break;
          case 'months':
            // Round to the beginning of the month
            const monthStart = new Date(now);
            monthStart.setDate(1);
            monthStart.setHours(0, 0, 0, 0);
            timestamp = monthStart.getTime() - (i * interval);
            break;
          default:
            timestamp = now - (i * interval);
        }

        // Use a temporary copy of getPriceAt that doesn't include real-time fluctuations
        // for stable time-based data points
        const getStablePrice = (stock, ts) => {
          // Use the existing getPriceAt but remove real-time component
          const minutes = Math.floor(ts / 60000);
          const hours = Math.floor(ts / 3600000);
          const day = Math.floor(hours / 24);
          const month = Math.floor(day / 30);
          
          // Base seed combines stock symbol, day and hour for deterministic results
          let seed = stock.symbol.charCodeAt(0) * 100 + day * 24 + (hours % 24);
          let minuteSeed = seed * 60 + (minutes % 60); // Add minute seed for minute-level variation
          
          // Generate base price from seed - use consistent data
          const monthTrend = this.stockMarket.seededRandom(month) * 2 - 1; // -1 to 1
          const dayTrend = this.stockMarket.seededRandom(day) * 2 - 1; // -1 to 1
          const hourTrend = this.stockMarket.seededRandom(seed) * 2 - 1; // -1 to 1
          const minuteTrend = this.stockMarket.seededRandom(minuteSeed) * 2 - 1; // -1 to 1
          
          // Apply trends with volatility - accumulate the effects
          const monthFactor = 1 + (monthTrend * 0.2 * stock.volatility);
          const dayFactor = 1 + (dayTrend * 0.1 * stock.volatility);
          const hourFactor = 1 + (hourTrend * 0.05 * stock.volatility * this.stockMarket.settings.rapidityFactor);
          const minuteFactor = 1 + (minuteTrend * 0.02 * stock.volatility * this.stockMarket.settings.rapidityFactor);
          
          // Calculate base price using factors consistent with timeframe
          let basePrice = stock.basePrice * monthFactor * dayFactor * hourFactor * minuteFactor;
          
          // Add appropriate randomness based on time frame for OHLC data
          let finalPrice = basePrice;
          const variance = stock.volatility * 0.02 * this.stockMarket.settings.rapidityFactor * finalPrice;
          
          // Generate OHLC data using the appropriate seed for the view
          let seedToUse;
          switch (this.stockMarket.settings.activeTimeFrame) {
            case 'minutes': seedToUse = minuteSeed; break;
            case 'hours': seedToUse = seed; break;
            case 'days': seedToUse = day; break;
            case 'months': seedToUse = month; break;
            default: seedToUse = seed;
          }
          
          const open = finalPrice;
          const high = finalPrice + this.stockMarket.seededRandom(seedToUse + 1) * variance;
          const low = finalPrice - this.stockMarket.seededRandom(seedToUse + 2) * variance;
          const close = finalPrice + (this.stockMarket.seededRandom(seedToUse + 3) * 2 - 1) * variance * 0.7;
          
          // Scale volume based on time frame
          let volume;
          switch (this.stockMarket.settings.activeTimeFrame) {
            case 'minutes': volume = Math.floor(this.stockMarket.seededRandom(seedToUse + 4) * 200) + 50; break;
            case 'hours': volume = Math.floor(this.stockMarket.seededRandom(seedToUse + 4) * 10000) + 1000; break;
            case 'days': volume = Math.floor(this.stockMarket.seededRandom(seedToUse + 4) * 10000) + 1000 * 24; break;
            case 'months': volume = Math.floor(this.stockMarket.seededRandom(seedToUse + 4) * 10000) + 1000 * 24 * 30; break;
            default: volume = Math.floor(this.stockMarket.seededRandom(seedToUse + 4) * 10000) + 1000;
          }
          
          return {
            timestamp: ts,
            open, high, low, close, volume,
            basePrice: finalPrice
          };
        };

        dataPoints.push({
          timestamp,
          data: getStablePrice(this.selectedStock, timestamp)
        });
        }

        const realTimePrice = this.stockMarket.getPriceAt(this.selectedStock, Date.now()).close;

        // Store the live price for use in trading
        this.stockLivePrices[this.selectedStock.symbol] = realTimePrice;

        // FIX: Ensure we have valid dimensions - use explicit dimensions if DOM measurement fails
        let width = graph.width();
        let height = graph.height() - 40; // Leave room for time selector

        // Safety check - provide fallback values if width/height are not available
        if (!width || width <= 0 || isNaN(width)) width = 800;
        if (!height || height <= 0 || isNaN(height)) height = 400;

        // Find min and max values for scaling (for close prices)
        // Include the real-time price in the range calculation for consistent display
        const prices = [...dataPoints.map(p => p.data.close), realTimePrice];
        const minPrice = Math.min(...prices) * 0.98; // Add 2% padding below
        const maxPrice = Math.max(...prices) * 1.02; // Add 2% padding above

        // Rest of drawing code remains the same
        // Add grid lines
        for (let i = 0; i <= 4; i++) {
        const y = 40 + (i * (height - 40) / 4);
        const gridLine = $('<div class="grid-line"></div>').css({
          top: y + 'px'
        });
        chartContainer.append(gridLine);
        }

        // Create SVG for the line chart
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", width);
        svg.setAttribute("height", height);
        svg.style.position = "absolute";
        svg.style.top = "0";
        svg.style.left = "0";
        svg.style.zIndex = "2";

        // Create the polyline for the chart
        const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");

        // Calculate points
        const chartWidth = width - 60; // Leave room for price labels
        const pointSpacing = chartWidth / 13; // 14 points = 13 spaces
        const pointStartX = 30;

        let pointsString = "";
        const pointCoordinates = [];

        dataPoints.forEach((point, index) => {
        const x = pointStartX + (index * pointSpacing);
        const y = 40 + ((maxPrice - point.data.close) / (maxPrice - minPrice)) * (height - 40);

        // FIX: Guard against NaN values
        if (isNaN(x) || isNaN(y)) return;

        pointsString += `${x},${y} `;
        pointCoordinates.push({ x, y, data: point });
        });

        polyline.setAttribute("points", pointsString);
        polyline.setAttribute("fill", "none");
        polyline.setAttribute("stroke", "#3498db");
        polyline.setAttribute("stroke-width", "2");
        svg.appendChild(polyline);

        // Create tooltip
        const tooltip = $('<div class="chart-tooltip"></div>');
        chartContainer.append(tooltip);

        // Create circles for data points
        dataPoints.forEach((point, index) => {
        const x = pointStartX + (index * pointSpacing);
        const y = 40 + ((maxPrice - point.data.close) / (maxPrice - minPrice)) * (height - 40);

        // FIX: Guard against NaN values
        if (isNaN(x) || isNaN(y)) return;

        // Create circle for the data point
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", x);
        circle.setAttribute("cy", y);
        circle.setAttribute("r", "5");
        circle.setAttribute("fill", "#3498db");
        circle.setAttribute("stroke", "white");
        circle.setAttribute("stroke-width", "1");
        circle.setAttribute("class", "data-point");

        // Add date label (only for every other point to avoid crowding)
        if (index % 2 === 0) {
          // Format date based on timeframe
          let dateFormat = {};
          if (this.stockMarket.settings.activeTimeFrame === 'minutes') {
            dateFormat = { hour: '2-digit', minute: '2-digit' };
          } else if (this.stockMarket.settings.activeTimeFrame === 'hours') {
            dateFormat = { month: 'short', day: 'numeric', hour: '2-digit' };
          } else if (this.stockMarket.settings.activeTimeFrame === 'days') {
            dateFormat = { month: 'short', day: 'numeric' };
          } else {
            dateFormat = { year: 'numeric', month: 'short' };
          }
          
          const date = new Date(point.timestamp).toLocaleString(undefined, dateFormat);
          
          const dateLabel = $('<div class="date-label"></div>').css({
            left: (x - 20) + 'px'
          }).text(date);
          chartContainer.append(dateLabel);
        }

        // Set up hover events
        $(circle).on('mouseenter', function() {
          const data = point.data;
          const date = new Date(point.timestamp).toLocaleString();
          
          tooltip.html(`
            <div style="font-weight:bold;margin-bottom:5px;border-bottom:1px solid #555;padding-bottom:3px">
              ${date}
            </div>
            <div style="display:grid;grid-template-columns:auto auto;gap:5px">
              <div>Price:</div><div style="text-align:right">${data.close.toFixed(2)}</div>
              <div>Open:</div><div style="text-align:right">${data.open.toFixed(2)}</div>
              <div>High:</div><div style="text-align:right">${data.high.toFixed(2)}</div>
              <div>Low:</div><div style="text-align:right">${data.low.toFixed(2)}</div>
              <div>Volume:</div><div style="text-align:right">${data.volume.toLocaleString()}</div>
            </div>
          `);
          
          // Show tooltip first with opacity 0 to calculate its dimensions
          tooltip.css({
            left: '0px',
            top: '0px',
            opacity: 0,
            display: 'block'
          });
          
          // Get dimensions after rendering
          const tooltipWidth = tooltip.outerWidth();
          const tooltipHeight = tooltip.outerHeight();
          const containerWidth = chartContainer.width();
          const containerHeight = chartContainer.height();
          
          // Calculate ideal position
          let tooltipX = x - tooltipWidth / 2; // Center horizontally
          let tooltipY = y - tooltipHeight - 10; // Position above with 10px gap
          
          // Ensure tooltip doesn't go beyond container boundaries
          // Check left boundary
          if (tooltipX < 10) {
            tooltipX = 10;
          }
          
          // Check right boundary
          if (tooltipX + tooltipWidth > containerWidth - 10) {
            tooltipX = containerWidth - tooltipWidth - 10;
          }
          
          // Check top boundary - if not enough space above, show below
          if (tooltipY < 40) { // 40px is where chart starts below time selector
            tooltipY = y + 15; // Position below with 15px gap
            
            // If not enough space below either, center vertically in available space
            if (tooltipY + tooltipHeight > containerHeight - 10) {
              tooltipY = Math.max(40, Math.min(containerHeight - tooltipHeight - 10, y - tooltipHeight/2));
            }
          }
          
          // Apply final position and show tooltip
          tooltip.css({
            left: tooltipX + 'px',
            top: tooltipY + 'px',
            opacity: 1
          });
          
          // Enlarge the circle on hover
          this.setAttribute("r", "7");
          this.setAttribute("stroke-width", "2");
        });

        $(circle).on('mouseleave', function() {
          tooltip.css('opacity', 0);
          this.setAttribute("r", "5");
          this.setAttribute("stroke-width", "1");
        });

        svg.appendChild(circle);
        });

        chartContainer.append(svg);

        // Add area under the curve
        // FIX: Only create area if we have valid coordinates
        if (pointCoordinates.length > 0) {
        const area = document.createElementNS("http://www.w3.org/2000/svg", "path");
        let areaPath = `M ${pointStartX},${height} `;
        areaPath += `L ${pointStartX},${pointCoordinates[0].y} `;

        pointCoordinates.forEach((point) => {
          areaPath += `L ${point.x},${point.y} `;
        });

        areaPath += `L ${pointStartX + 13 * pointSpacing},${height} Z`;

        area.setAttribute("d", areaPath);
        area.setAttribute("fill", "url(#areaGradient)");
        area.setAttribute("opacity", "0.3");

        // Create gradient
        const gradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
        gradient.setAttribute("id", "areaGradient");
        gradient.setAttribute("x1", "0%");
        gradient.setAttribute("x2", "0%");
        gradient.setAttribute("y1", "0%");
        gradient.setAttribute("y2", "100%");

        const stop1 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        stop1.setAttribute("offset", "0%");
        stop1.setAttribute("stop-color", "#3498db");
        stop1.setAttribute("stop-opacity", "0.7");

        const stop2 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
        stop2.setAttribute("offset", "100%");
        stop2.setAttribute("stop-color", "#3498db");
        stop2.setAttribute("stop-opacity", "0");

        gradient.appendChild(stop1);
        gradient.appendChild(stop2);

        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        defs.appendChild(gradient);
        svg.insertBefore(defs, svg.firstChild);
        svg.insertBefore(area, polyline);
        }

        // Add price scale on right side
        for (let i = 0; i <= 4; i++) {
        const price = minPrice + (i * (maxPrice - minPrice) / 4);
        const y = 40 + ((4-i) * (height - 40) / 4);

        const label = $('<div class="price-label"></div>').css({
          top: (y - 10) + 'px'
        }).text(price.toFixed(2));

        chartContainer.append(label);
        }

        // Calculate the last point from the chart
        if (dataPoints.length > 0) {
        const lastChartPrice = dataPoints[dataPoints.length - 1].data.close;
        const lastChartY = 40 + ((maxPrice - lastChartPrice) / (maxPrice - minPrice)) * (height - 40);

        // Add current price indicator (shows the real-time price separate from chart)
        const realTimePriceY = 40 + ((maxPrice - realTimePrice) / (maxPrice - minPrice)) * (height - 40);

        // Add last chart point line (solid)
        const chartPriceLine = $('<div class="chart-price-line"></div>').css({
          top: lastChartY + 'px',
          left: '0',
          right: '0',
          position: 'absolute',
          borderTop: '1px solid rgba(52, 152, 219, 0.5)',
          zIndex: '1'
        });

        // Add real-time price line (dashed)
        const realTimePriceLine = $('<div class="real-time-price-line"></div>').css({
          top: realTimePriceY + 'px',
          left: '0',
          right: '0',
          position: 'absolute',
          borderTop: '1px dashed rgba(255, 215, 0, 0.7)',
          zIndex: '1'
        });

        // Add chart price indicator
        const chartPriceIndicator = $('<div class="chart-price-indicator"></div>').css({
          top: (lastChartY - 10) + 'px',
          right: '5px',
          position: 'absolute',
          background: 'rgba(52, 152, 219, 0.9)',
          color: 'white',
          padding: '2px 6px',
          borderRadius: '2px',
          fontSize: '10px',
          fontWeight: 'bold',
          zIndex: '3'
        }).text(lastChartPrice.toFixed(2));

        // Add real-time price indicator
        const realTimePriceIndicator = $('<div class="real-time-price-indicator"></div>').css({
          top: (realTimePriceY - 10) + 'px',
          right: '80px',
          position: 'absolute',
          background: 'rgba(255, 215, 0, 0.9)',
          color: 'black',
          padding: '2px 6px',
          borderRadius: '2px',
          fontSize: '10px',
          fontWeight: 'bold',
          zIndex: '3'
        }).html(`<div>LIVE: ${realTimePrice.toFixed(2)}</div>`);

        chartContainer.append(chartPriceLine);
        chartContainer.append(realTimePriceLine);
        chartContainer.append(chartPriceIndicator);
        chartContainer.append(realTimePriceIndicator);
        }

        // Remove the "chart updates" time indicator as requested
        };
        if (!this.chartUpdateIntervals) {
        this.chartUpdateIntervals = {};
        }
        // Clear existing chart update intervals
        Object.values(this.chartUpdateIntervals).forEach(interval => clearInterval(interval));
        this.chartUpdateIntervals = {};

        // Set up new chart update intervals based on timeframes
        Object.entries(this.stockMarket.settings.timeFrames).forEach(([timeframe, config]) => {
        // Calculate when the next update should happen
        let nextUpdateTime;
        switch (timeframe) {
        case 'minutes':
        // Update at the start of each minute
        nextUpdateTime = Math.ceil(Date.now() / 60000) * 60000 - Date.now();
        break;
        case 'hours':
        // Update at the start of each hour
        nextUpdateTime = Math.ceil(Date.now() / 3600000) * 3600000 - Date.now();
        break;
        case 'days':
        // Update at midnight
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(0, 0, 0, 0);
        nextUpdateTime = tomorrow.getTime() - Date.now();
        break;
        case 'months':
        // Update on the 1st of each month
        const nextMonth = new Date();
        nextMonth.setMonth(nextMonth.getMonth() + 1, 1);
        nextMonth.setHours(0, 0, 0, 0);
        nextUpdateTime = nextMonth.getTime() - Date.now();
        break;
        default:
        nextUpdateTime = 60000; // Default to 1 minute
        }

        // Set the first timeout to align with the next boundary
        setTimeout(() => {
        // Redraw if this is the active timeframe
        if (this.stockMarket.settings.activeTimeFrame === timeframe) {
        console.log(`Updating ${timeframe} chart at ${new Date().toLocaleTimeString()}`);
        drawChart();
        }

        // Then set up the regular interval
        this.chartUpdateIntervals[timeframe] = setInterval(() => {
        if (this.stockMarket.settings.activeTimeFrame === timeframe) {
          console.log(`Updating ${timeframe} chart at ${new Date().toLocaleTimeString()}`);
          drawChart();
        }
        }, config.interval);
        }, nextUpdateTime);

        console.log(`${timeframe} chart will update in ${(nextUpdateTime/1000).toFixed(1)}s`);
        });
        // Update portfolio list
        const updatePortfolio = async () => {
        try {
        const portfolio = await this.stockMarket.getPortfolio();
        const portfolioList = this.content.find('#portfolio-list');

        if (Object.keys(portfolio).length === 0) {
          portfolioList.html('<div style="padding:10px;color:#999;">You don\'t own any stocks yet.</div>');
          return;
        }

        let html = '';

        // Calculate total portfolio value
        let totalValue = 0;

        for (const symbol in portfolio) {
          const stock = this.stockMarket.stocks.find(s => s.symbol === symbol);
          if (!stock) continue;
          
          const shares = portfolio[symbol];
          const currentPrice = this.stockMarket.getPriceAt(stock, Date.now()).close;
          const value = shares * currentPrice;
          
          totalValue += value;
          
          html += `
            <div class="portfolio-item">
              <div>
                <div style="font-weight:bold;">${symbol}</div>
                <div style="font-size:0.8em;">${shares.toFixed(3)} shares</div>
              </div>
              <div>
                <div style="text-align:right;">${currentPrice.toFixed(2)} FMC</div>
                <div style="text-align:right;">${value.toFixed(2)} FMC</div>
              </div>
            </div>
          `;
        }

        // Add portfolio summary
        html = `
          <div style="padding:10px 0;text-align:right;border-bottom:1px solid #444;margin-bottom:10px;">
            <div>Total Portfolio Value:</div>
            <div style="font-size:1.2em;font-weight:bold;">${totalValue.toFixed(2)} FMC</div>
          </div>
        ` + html;

        portfolioList.html(html);
        } catch (err) {
        console.error('Error updating portfolio:', err);
        this.content.find('#portfolio-list').html('<div style="padding:10px;color:red;">Error loading portfolio</div>');
        }
        };

        // Update transactions list
        const updateTransactions = async () => {
        try {
        console.log('Fetching transactions...');
        const transactions = await this.stockMarket.getTransactions();
        console.log('Retrieved transactions:', transactions);

        const transactionsList = this.content.find('#transactions-list');

        if (!transactions || transactions.length === 0) {
          transactionsList.html('<div style="padding:10px;color:#999;">No transaction history yet.</div>');
          return;
        }

        let html = '';

        // Sort transactions from newest to oldest
        const sortedTransactions = [...transactions].sort((a, b) => b.timestamp - a.timestamp);
        console.log('Sorted transactions:', sortedTransactions);

        for (const tx of sortedTransactions) {
          const date = new Date(tx.timestamp).toLocaleString();
          
          html += `
            <div class="transaction-item transaction-${tx.type}">
              <div>${tx.type === 'buy' ? 'Bought' : 'Sold'} ${tx.shares.toFixed(3)} ${tx.symbol} @ ${tx.price.toFixed(2)}</div>
              <div style="font-size:0.8em;color:#999;margin-top:3px;">
                Total: ${tx.total.toFixed(2)} FMC | ${date}
              </div>
            </div>
          `;
        }

        transactionsList.html(html);
        } catch (err) {
        console.error('Error updating transactions:', err);
        this.content.find('#transactions-list').html('<div style="padding:10px;color:red;">Error loading transactions: ' + err.message + '</div>');
        }
        };

        // Handle stock item clicks
        this.content.find('.stock-item').on('click', function() {
        const symbol = $(this).data('symbol');
        _this.selectedStock = _this.stockMarket.stocks.find(s => s.symbol === symbol);

        // Update UI
        _this.content.find('.stock-item').removeClass('active');
        $(this).addClass('active');
        updateStockDisplay();
        });

        // Handle tab clicks
        this.content.find('.tab-button').on('click', function() {
        const tab = $(this).data('tab');

        _this.content.find('.tab-button').removeClass('active');
        _this.content.find('.tab-content').removeClass('active');

        $(this).addClass('active');
        _this.content.find(`#${tab}`).addClass('active');

        // Update data for the selected tab
        if (tab === 'portfolio') {
        updatePortfolio();
        } else if (tab === 'transactions') {
        updateTransactions();
        }
        });

        // Handle buy button
        this.content.find('#btn-buy').on('click', async () => {
        if (!this.selectedStock) return;

        try {
        // Get the amount to buy
        const amountInput = this.content.find('#trade-amount');
        const shares = parseFloat(amountInput.val());

        if (isNaN(shares) || shares <= 0) {
          alert('Please enter a valid number of shares to buy');
          return;
        }

        // Use the stored live price instead of recalculating
        const currentPrice = this.stockLivePrices[this.selectedStock.symbol];
        const totalCost = shares * currentPrice;  // Fixed variable name

        // Check if user has enough balance
        const balance = await this.stockMarket.getBalance();

        if (totalCost > balance) {
          alert(`Not enough FMC balance. You need ${totalCost.toFixed(2)} FMC to complete this purchase.`);
          return;
        }

        // Update balance
        await this.stockMarket.updateBalance(balance - totalCost);

        // Update portfolio
        const portfolio = await this.stockMarket.getPortfolio();
        portfolio[this.selectedStock.symbol] = (portfolio[this.selectedStock.symbol] || 0) + shares;
        await this.stockMarket.updatePortfolio(portfolio);

        // Add transaction record
        await this.stockMarket.addTransaction({
          type: 'buy',
          symbol: this.selectedStock.symbol,
          shares,
          price: currentPrice,
          total: totalCost,
          timestamp: Date.now()  // Fixed missing 'now' variable
        });

        // Clear input
        amountInput.val('');
        await updateStockDisplay(true);
        } catch (err) {
        console.error('Error processing buy transaction:', err);
        alert('Transaction failed. Please try again.');
        }
        });

        // Handle sell button
        // Handle sell button
        this.content.find('#btn-sell').on('click', async () => {
        if (!this.selectedStock) return;

        try {
        // Get the amount to sell
        const amountInput = this.content.find('#trade-amount');
        const shares = parseFloat(amountInput.val());

        if (isNaN(shares) || shares <= 0) {
        alert('Please enter a valid number of shares to sell');
        return;
        }

        // Check if user owns enough shares
        const portfolio = await this.stockMarket.getPortfolio();
        const ownedShares = portfolio[this.selectedStock.symbol] || 0;

        if (shares > ownedShares) {
        alert(`You don't own enough shares. You currently have ${ownedShares.toFixed(3)} shares.`);
        return;
        }

        // Use the stored live price instead of recalculating
        const currentPrice = this.stockLivePrices[this.selectedStock.symbol];
        const totalValue = shares * currentPrice;

        // Update balance
        const balance = await this.stockMarket.getBalance();
        await this.stockMarket.updateBalance(balance + totalValue);

        // Update portfolio
        portfolio[this.selectedStock.symbol] -= shares;

        // Remove stock from portfolio if no shares left
        if (portfolio[this.selectedStock.symbol] <= 0) {
        delete portfolio[this.selectedStock.symbol];
        }

        await this.stockMarket.updatePortfolio(portfolio);

        // Add transaction record
        await this.stockMarket.addTransaction({
        type: 'sell',
        symbol: this.selectedStock.symbol,
        shares,
        price: currentPrice,
        total: totalValue,
        timestamp: Date.now()  // Fixed missing 'now' variable
        });

        // Clear input
        amountInput.val('');

        // Update UI
        await updateStockDisplay(true);
        } catch (err) {
        console.error('Error processing sell transaction:', err);
        alert('Transaction failed. Please try again.');
        }
        });

        // Initial update
        updateStockDisplay();

        // Set up refresh interval
        if (this.stockUpdateInterval) {
        clearInterval(this.stockUpdateInterval);
        this.stockUpdateInterval = null;
        }

        (async () => {
        try {
        // Initial update with everything
        await updateStockDisplay(true);

        // Set up refresh interval
        if (this.stockUpdateInterval) {
          clearInterval(this.stockUpdateInterval);
          this.stockUpdateInterval = null;
        }

        this.stockUpdateInterval = setInterval(async () => {
          if (this._currentSubcontent === "stocks") {
            console.log("Updating stock prices", new Date().toLocaleTimeString());
            await updateStockDisplay(false); // false = don't update portfolio and transactions
          } else {
            console.log("Clearing stock interval - no longer on stocks page");
            clearInterval(this.stockUpdateInterval);
            this.stockUpdateInterval = null;
          }
        }, 3000);
        } catch (err) {
        console.error('Error initializing stock display:', err);
        }
        })();
        }
        if (subcontent === "darkweb") {
          // Define dark foxes database helper
          if (!window.DarkWebDB) {
            window.DarkWebDB = {
              dbName: "FlockmodDarkWeb",
              dbVersion: 2, // Increment version to trigger database upgrade
              
              // Initialize the database
              async initDB() {
                return new Promise((resolve, reject) => {
                  const request = indexedDB.open(this.dbName, this.dbVersion);
                  
                  request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Drop existing stores if version changed
                    if (event.oldVersion < 2) {
                      if (db.objectStoreNames.contains('products')) {
                        db.deleteObjectStore('products');
                      }
                    }
                    
                    // Create product store
                    if (!db.objectStoreNames.contains('products')) {
                      const productStore = db.createObjectStore('products', { keyPath: 'id' });
                      productStore.createIndex('category', 'category', { unique: false });
                    }
                    
                    // Create purchases store
                    if (!db.objectStoreNames.contains('purchases')) {
                      const purchaseStore = db.createObjectStore('purchases', { keyPath: 'id', autoIncrement: true });
                      purchaseStore.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                  };
                  
                  request.onsuccess = (event) => {
                    this.db = event.target.result;
                    
                    // Force initialization of default products after upgrade
                    if (request.transaction) {
                      this.initializeDefaultProducts().then(() => {
                        resolve(this.db);
                      });
                    } else {
                      resolve(this.db);
                    }
                  };
                  
                  request.onerror = (event) => {
                    reject(new Error('Failed to open dark web database: ' + event.target.errorCode));
                  };
                });
              },
              async updatePurchase(purchase) {
                if (!this.db) await this.initDB();
                
                return new Promise((resolve, reject) => {
                  const transaction = this.db.transaction(['purchases'], 'readwrite');
                  const store = transaction.objectStore('purchases');
                  const request = store.put(purchase);
                  
                  request.onsuccess = () => resolve(request.result);
                  request.onerror = (event) => {
                    reject(new Error('Failed to update purchase: ' + event.target.errorCode));
                  };
                });
              },
              // Get all products
              async getProducts() {
                if (!this.db) await this.initDB();
                
                return new Promise((resolve, reject) => {
                  const transaction = this.db.transaction(['products'], 'readonly');
                  const store = transaction.objectStore('products');
                  const request = store.getAll();
                  
                  request.onsuccess = () => {
                    // Always re-initialize products on first load with new version
                    if (request.result.length === 0 || !request.result.some(p => p.id === "drg-005")) {
                      this.initializeDefaultProducts().then(() => {
                        this.getProducts().then(resolve).catch(reject);
                      });
                    } else {
                      resolve(request.result);
                    }
                  };
                  
                  request.onerror = (event) => {
                    reject(new Error('Failed to get products: ' + event.target.errorCode));
                  };
                });
              },
              
              // Reset and initialize default products (for troubleshooting)
              async resetProducts() {
                if (!this.db) await this.initDB();
                
                return new Promise((resolve, reject) => {
                  const transaction = this.db.transaction(['products'], 'readwrite');
                  const store = transaction.objectStore('products');
                  const clearRequest = store.clear();
                  
                  clearRequest.onsuccess = () => {
                    this.initializeDefaultProducts().then(resolve).catch(reject);
                  };
                  
                  clearRequest.onerror = (event) => {
                    reject(new Error('Failed to clear products: ' + event.target.errorCode));
                  };
                });
              },
              
              // Get all products
              async getProducts() {
                if (!this.db) await this.initDB();
                
                return new Promise((resolve, reject) => {
                  const transaction = this.db.transaction(['products'], 'readonly');
                  const store = transaction.objectStore('products');
                  const request = store.getAll();
                  
                  request.onsuccess = () => {
                    if (request.result.length === 0) {
                      // Initialize with default products if none exist
                      this.initializeDefaultProducts().then(() => {
                        this.getProducts().then(resolve).catch(reject);
                      });
                    } else {
                      resolve(request.result);
                    }
                  };
                  
                  request.onerror = (event) => {
                    reject(new Error('Failed to get products: ' + event.target.errorCode));
                  };
                });
              },
              
              // Initialize default products
              async initializeDefaultProducts() {
                const defaultProducts = [
                  {
                    id: "drg-001",
                    name: "Premium Kush",
                    slangNames: ["Green Dreams", "Devil's Lettuce", "Chronic"],
                    description: "High-grade botanical specimen with exceptional potency. Origin: Hidden farms in Humboldt County.",
                    price: 120,
                    category: "drugs",
                    imageUrl: "https://www.easycannabiswaste.com/wp-content/uploads/2024/08/marijuana-news-364x190.png",
                    quantity: 50,
                    rating: 4.8
                  },
                  {
                    id: "drg-002",
                    name: "Bolivian Snow",
                    slangNames: ["White Lady", "Nose Candy", "Peruvian Marching Powder"],
                    description: "99.7% pure crystalline powder. Lab tested for purity. Origin: South American highlands.",
                    price: 850,
                    category: "drugs",
                    imageUrl: "https://www.odt.co.nz/sites/default/files/story/2025/02/ak_cocaine.png",
                    quantity: 25,
                    rating: 4.9
                  },
                  {
                    id: "drg-003",
                    name: "Blue Crystal",
                    slangNames: ["Ice", "Glass", "Tina"],
                    description: "Pharmaceutical-grade crystals with distinctive blue tint. 99.1% purity. Origin: Undisclosed laboratory.",
                    price: 450,
                    category: "drugs",
                    imageUrl: "https://www.euda.europa.eu/sites/default/files/styles/scale_crop_500x281_2x_used_in_jumbotron_/public/media/publications/images/istockphoto-1081637412-612x612_0.jpg.webp?itok=HhcZOseH",
                    quantity: 30,
                    rating: 4.7
                  },
                  {
                    id: "drg-004",
                    name: "Dutch Moonrock",
                    slangNames: ["Molly", "E", "Rolls"],
                    description: "Laboratory-tested MDMA powder from Amsterdam's finest chemists. 84% purity.",
                    price: 320,
                    category: "drugs",
                    imageUrl: "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fbuycolombiancoke.com%2Fwp-content%2Fuploads%2F2021%2F06%2FMDMA-powder-1.jpg&f=1&nofb=1&ipt=c19bb72dce1b9c6a6ef87b7fcc3b23a03e5e645d96e4653c16800ed174074bdd",
                    quantity: 40,
                    rating: 4.6
                  },
                  {
                  id: "drg-005",
                  name: "Ghost Powder",
                  slangNames: ["China White", "Apache", "Goodfella"],
                  description: "Extremely potent synthetic compound. Microscopic dosing required. Laboratory grade with exceptional purity.",
                  price: 780,
                  category: "drugs",
                  imageUrl: "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.usatoday.com%2Fgcdn%2F-mm-%2Fee6ec5cb38d22e3b2dc4c3365b60ea7859607a7a%2Fc%3D0-1606-2081-2782%2Flocal%2F-%2Fmedia%2F2017%2F06%2F13%2FUSATODAY%2FUSATODAY%2F636329675618044807-XXX-AP-16223010981937.JPG%3Fwidth%3D2081%26height%3D1176%26fit%3Dcrop%26format%3Dpjpg%26auto%3Dwebp&f=1&nofb=1&ipt=89d961444a87782abb33f716805831c502447a18f3be576c29af798e23276a88",
                  quantity: 15,
                  rating: 5.0
                  },
                  {
                    id: "wpn-001",
                    name: "Kalashnikov Classic",
                    slangNames: ["The Slav", "Commie Chopper"],
                    description: "Russian-manufactured assault rifle with worn serial number. Includes 3 magazines and cleaning kit.",
                    price: 3200,
                    category: "weapons",
                    imageUrl: "https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Fblog.cheaperthandirt.com%2Fwp-content%2Fuploads%2F2013%2F07%2FAK-74.jpg&f=1&nofb=1&ipt=86379a32cec44c39c2d8a1f888ef0e5369154d46d3553486089ff78c1600d848",
                    quantity: 10,
                    rating: 4.5
                  },
                  {
                    id: "wpn-002",
                    name: "Sig Ghost",
                    slangNames: ["The Whisper", "Sig Three-Two"],
                    description: "Untraceable sidearm with no serial number. Includes suppressor and 3 magazines.",
                    price: 1800,
                    category: "weapons",
                    imageUrl: "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.outdoorlife.com%2Fuploads%2F2022%2F07%2F11%2FIMG_5921-scaled.jpeg%3Fauto%3Dwebp%26width%3D1440%26height%3D1080&f=1&nofb=1&ipt=964f81fa6a1b2670a770078069af432c58e4dec17b9f4b5e6098fdb4d8d510ea",
                    quantity: 15,
                    rating: 4.7
                  },
                  {
                    id: "wpn-003",
                    name: "Chrome Predator",
                    slangNames: ["Hand Cannon", "Shiny Fifty", "Desert Storm"],
                    description: "Brushed chrome .50 AE with custom grip. Includes luxury leather case and 2 magazines.",
                    price: 2500,
                    category: "weapons",
                    imageUrl: "https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Fimages.gunsinternational.com%2Flistings_sub%2Facc_92587%2Fgi_100825269%2FMagnum-Research-Desert-Eagle-50-AE-Brushed-Chrome_100825269_92587_D9F5D6FF190F6CED.JPG&f=1&nofb=1&ipt=0355d82963ca8c4953b1686e2962ef16c6c57a0a54f485c98fe1f0389a9da15b",
                    quantity: 8,
                    rating: 4.9
                  },
                  {
                    id: "mil-001",
                    name: "M1 Abrams",
                    slangNames: ["Freedom Roller", "Desert Warrior", "American Beast"],
                    description: "Main battle tank with advanced armor and 120mm smoothbore cannon. Stripped of classified systems. Comes with basic ammunition package.",
                    price: 8500000,
                    category: "military",
                    imageUrl: "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.anvilofwar.com%2Fvehicles%2Fimgs%2F1300%2Fm1-abrams%2Fm1-front-right-tank-at-rest.jpg&f=1&nofb=1&ipt=dac78a8c9173bf302858facee18f4b38d496b0eba0b1a8f08cc50ebbd1c72187",
                    quantity: 2,
                    rating: 5.0
                  },
                  {
                    id: "mil-002",
                    name: "Leopard 2",
                    slangNames: ["German Cat", "Euro Panzer", "Steel Blitz"],
                    description: "German engineering excellence. 1500hp MTU engine with advanced targeting systems. Recently serviced, complete documentation included.",
                    price: 7800000,
                    category: "military",
                    imageUrl: "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.24rhein.de%2Fbilder%2F2023%2F02%2F10%2F92183262%2F30873602-kampfpanzer-leopard-a7v-bundeswehr-feierliche-uebergabe-panzerbataillon-104-kasernengelaend-pfreimd-bayern-Ow7d.jpg&f=1&nofb=1&ipt=f453f89a805091cf54768f48f00ee9f0f3899e8177dfc8fdb432a27cc60d67ee",
                    quantity: 1,
                    rating: 4.9
                  },
                  {
                    id: "mil-003",
                    name: "T14 Armata",
                    slangNames: ["Russian Beast", "Moscow Hunter", "Siberian Tiger"],
                    description: "Latest generation Russian main battle tank with unmanned turret. Acquired through unconventional channels. No questions asked.",
                    price: 9200000,
                    category: "military",
                    imageUrl: "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fmf.b37mrtl.ru%2Frbthmedia%2Fimages%2F2022.02%2Foriginal%2F620df87130141b173a2dcc17.jpg&f=1&nofb=1&ipt=a34af008d1612305bb571a46eb32b6914b2d3227ba5d0897dfd08ad7ce587dee",
                    quantity: 1,
                    rating: 4.7
                  },

                  // Jets
                  {
                    id: "mil-004",
                    name: "F-35 Lightning II",
                    slangNames: ["Ghost Bird", "Stealth Eagle", "Trillion Dollar Bird"],
                    description: "Stealth multirole fighter with advanced avionics and weapons systems. All identifying markings removed. Delivery to remote airstrip only.",
                    price: 75000000,
                    category: "military",
                    imageUrl: "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fimages05.military.com%2Fsites%2Fdefault%2Ffiles%2Fmedia%2Fequipment%2Fmilitary-aircraft%2Ff-35a-lightning-ii%2F2014%2F02%2Ff-35a-lightning-ii_008.jpg&f=1&nofb=1&ipt=6e9b715e9defa10d4e6fc8033bccd863d59716aa43843742b2a94c82fede0239",
                    quantity: 1,
                    rating: 5.0
                  },
                  {
                    id: "mil-005",
                    name: "SU-57",
                    slangNames: ["Felon", "Russian Phantom", "Stealth Bear"],
                    description: "Russia's 5th generation fighter aircraft with supermaneuverability. Complete with weapons systems and maintenance package.",
                    price: 65000000,
                    category: "military",
                    imageUrl: "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.defencetalk.com%2Fmilitary%2Fphotos%2Fsu-57-fighter-jet-russian-air-force.52592%2Ffull&f=1&nofb=1&ipt=f49fb4c7b7360336777082bc3a14d1d6c19c53efb1cff252586e5d61a01a3838",
                    quantity: 1,
                    rating: 4.8
                  }
                ];
                
                // Add products to database
                await Promise.all(defaultProducts.map(async product => {
                  await this.addProduct(product);
                }));
              },
              
              // Add a product
              async addProduct(product) {
                if (!this.db) await this.initDB();
                
                return new Promise((resolve, reject) => {
                  const transaction = this.db.transaction(['products'], 'readwrite');
                  const store = transaction.objectStore('products');
                  const request = store.put(product);
                  
                  request.onsuccess = () => resolve(request.result);
                  request.onerror = (event) => {
                    reject(new Error('Failed to add product: ' + event.target.errorCode));
                  };
                });
              },
              
              // Get purchases
              async getPurchases() {
                if (!this.db) await this.initDB();
                
                return new Promise((resolve, reject) => {
                  const transaction = this.db.transaction(['purchases'], 'readonly');
                  const store = transaction.objectStore('purchases');
                  const request = store.getAll();
                  
                  request.onsuccess = () => resolve(request.result);
                  request.onerror = (event) => {
                    reject(new Error('Failed to get purchases: ' + event.target.errorCode));
                  };
                });
              },
              
              // Add purchase
              async addPurchase(purchase) {
                if (!this.db) await this.initDB();
                
                return new Promise((resolve, reject) => {
                  const transaction = this.db.transaction(['purchases'], 'readwrite');
                  const store = transaction.objectStore('purchases');
                  const request = store.add({
                    ...purchase,
                    timestamp: Date.now()
                  });
                  
                  request.onsuccess = () => resolve(request.result);
                  request.onerror = (event) => {
                    reject(new Error('Failed to add purchase: ' + event.target.errorCode));
                  };
                });
              },
              
              // Update product quantity
              async updateProductQuantity(productId, newQuantity) {
                if (!this.db) await this.initDB();
                
                return new Promise((resolve, reject) => {
                  const transaction = this.db.transaction(['products'], 'readwrite');
                  const store = transaction.objectStore('products');
                  const getRequest = store.get(productId);
                  
                  getRequest.onsuccess = () => {
                    const product = getRequest.result;
                    if (product) {
                      product.quantity = newQuantity;
                      const updateRequest = store.put(product);
                      
                      updateRequest.onsuccess = () => resolve(true);
                      updateRequest.onerror = (event) => {
                        reject(new Error('Failed to update product quantity: ' + event.target.errorCode));
                      };
                    } else {
                      reject(new Error('Product not found'));
                    }
                  };
                  
                  getRequest.onerror = (event) => {
                    reject(new Error('Failed to get product: ' + event.target.errorCode));
                  };
                });
              }
            };
          }

          // Load the Dark Fox marketplace UI
          this.loadSubcontent(`
            <style>
              /* Dark Fox Theme */
              .darkweb-container {
                font-family: 'Courier New', monospace;
                background-color: #111;
                color: #0f0;
                height: 100%;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                position: relative;
              }
              
              /* Glitch effect */
              .darkweb-container::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 5px;
                background: linear-gradient(90deg, transparent, #f00, transparent);
                animation: glitch-line 10s linear infinite;
                opacity: 0.5;
              }
              
              @keyframes glitch-line {
                0% { transform: translateX(-100%); }
                100% { transform: translateX(100%); }
              }
              
              .darkweb-header {
                background: #000;
                color: #f00;
                padding: 15px;
                border-bottom: 2px solid #f00;
                text-align: center;
                text-shadow: 0 0 5px #f00;
                position: relative;
              }
              
              .darkweb-header h1 {
                font-size: 24px;
                margin: 0;
                letter-spacing: 2px;
                font-family: 'Courier New', monospace;
                text-transform: uppercase;
              }
              
              .darkweb-warning {
                background-color: rgba(255, 0, 0, 0.1);
                border-left: 3px solid #f00;
                padding: 10px 15px;
                margin-bottom: 15px;
                font-size: 0.9em;
                color: #f99;
              }
              
              .darkweb-content {
                display: flex;
                flex: 1;
                overflow: hidden;
              }
              
              .darkweb-sidebar {
                width: 200px;
                background: #0a0a0a;
                border-right: 1px solid #222;
                overflow-y: auto;
                display: flex;
                flex-direction: column;
              }
              
              .market-balance {
                padding: 15px;
                background: #070707;
                border-bottom: 1px solid #222;
                color: #fd0;
                font-size: 1.2em;
              }
              
              .category-list {
                padding: 0;
                margin: 0;
                list-style: none;
              }
              
              .category-item {
                padding: 12px 15px;
                border-bottom: 1px solid #222;
                cursor: pointer;
                transition: background 0.2s;
              }
              
              .category-item:hover {
                background: #151515;
              }
              
              .category-item.active {
                background: #1a1a1a;
                color: #f00;
                border-left: 3px solid #f00;
              }
              
              .category-icon {
                margin-right: 10px;
                opacity: 0.7;
              }
              
              .darkweb-main {
                flex: 1;
                padding: 15px;
                overflow-y: auto;
                background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAABNmlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjarY6xSsNQFEDPi6LiUCsEcXB4kygotupgxqQtRRCs1SHJ1qShSmkSXl7VfoSjWwcXd7/AyVFwUPwC/0Bx6uAQIYODCJ7p3MPlcsGo2HWnYZRhEGvVbjrS9Xw5+8QMUwDQCbPUbrUOAOIkjvjB5ysC4HnTrjsN/sZ8mCoNTIDtbpSFICpA/0KnGsQYMIN+qkHcAaY6addAPAClXu4vQCnI/Q0oKdfzQXwAZs/1fDDmADPIfQUwdXSpAWpJOlJnvVMtq5ZlSbubBJE8HmU6GmRyPw4TlSaqo6MukP8HwGK+2G46cq1qWXvr/DOu58vc3o8QgFh6LFpBOFTn3yqMnd/n4sZ4GQ5vYXpStN0ruNmAheuirVahvAX34y/Axk/96FpPYgAAACBjSFJNAAB6JQAAgIMAAPn/AACA6AAAUggAARVYAAA6lwAAF2/XWh+QAAACRElEQVR42uyaTWsTURSGn5OZpPmoJItCXShCxaULEaG1G/E3+DvETdClv8GVO/ciLsS9brpQdCNFunDlrqhtMhNnbhdzJ5PdTHLnI3M2Gb/eu/S858yZd+6IQVFQ5OFgUYzhLBY7GDussBrtsiQKA3QkwUevw5Z5R2OAhCKgZTf5wmsOqLBNmVX9XSrlIeZ4LDH3MrJJiSU5+XsC8YSnbPCRBUpUS4AsPOMX31nkkUHOQ56nPOc+a6zImFwRwp+xz2vusMl73rAuK5QKsRBLnrDJPjvs8p41rslS8sSaMM0Gm+yxR4PXDj3tkNzUFEdsSsYedaHmEB8GDSxtZ0/37VIryYgPZWsL5pBG6vBqWc+WMJRtITV9qGPZsdGVtDE4FozcbtZSicFrxc6ennx1OCYrr88OW+pOMjSIKrvWr8d0JMlViWXkQiWOSXShyZErWCBGdIni6hg4pqUH4hJy4BDCNRcqoorN6XCUS0Oi+XOG0y7bQ1PQg2g7nxfVvGoZc6TFvf/wpasD2kkz0sxIR3aoqRup6LJPu+zxmMHIsZPQdrMg6FrOyPrMMXtOVdpJ5l5XwMjAuKYO4kwHLFjXqHBdYvlVonK1MEDLBGS7QrKsYI2UkZCGcapl10NGkOOylV+MdKQpTZakP22RFUj9zFccconJvGz9vszPl1jkzJ4VM8I+h8wxz4Jc8uod4STmmGPOWPb/lwZJqpXdtDuTekuGnreHAJdsOxNJE983gBFgiDT1odXKLm0M+AcAzvw/J1LOyKsAAAAASUVORK5CYII=');
              }
              
              .products-container {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
                gap: 15px;
                padding-bottom: 20px;
              }
              
              .product-card {
                background: rgba(0, 0, 0, 0.8);
                border: 1px solid #222;
                border-radius: 5px;
                padding: 10px;
                display: flex;
                flex-direction: column;
                transition: transform 0.2s, box-shadow 0.2s;
                position: relative;
                overflow: hidden;
              }
              
              .product-card:hover {
                transform: translateY(-5px);
                box-shadow: 0 5px 15px rgba(255, 0, 0, 0.2);
                border-color: #500;
              }
              
              .product-image-container {
                position: relative;
                height: 120px;
                overflow: hidden;
                margin-bottom: 10px;
                border: 1px solid #222;
              }
              
              .product-image {
                width: 100%;
                height: 100%;
                object-fit: cover;
                filter: grayscale(30%);
                transition: filter 0.3s;
              }
              
              .product-card:hover .product-image {
                filter: grayscale(0%);
              }
              
              .product-price {
                position: absolute;
                top: 5px;
                right: 5px;
                background: rgba(0, 0, 0, 0.8);
                color: #fd0;
                padding: 3px 8px;
                border-radius: 3px;
                font-weight: bold;
              }
              
              .product-info {
                flex: 1;
              }
              
              .product-name {
                font-size: 1.1em;
                margin: 0 0 5px 0;
                color: #0f0;
              }
              
              .product-slang {
                font-size: 0.8em;
                margin: 0 0 8px 0;
                color: #888;
                font-style: italic;
              }
              
              .product-description {
                font-size: 0.85em;
                color: #aaa;
                margin-bottom: 10px;
              }
              
              .product-meta {
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-size: 0.8em;
                color: #666;
                margin-top: auto;
              }
              
              .product-rating {
                color: #fd0;
              }
              
              .product-quantity {
                color: #888;
              }
              
              .product-actions {
                margin-top: 10px;
                display: flex;
                gap: 5px;
              }
              
              .btn-buy {
                flex: 1;
                background: #300;
                color: #f00;
                border: 1px solid #500;
                padding: 5px 10px;
                cursor: pointer;
                transition: background 0.2s;
                text-align: center;
                font-family: 'Courier New', monospace;
                border-radius: 3px;
              }
              
              .btn-buy:hover {
                background: #500;
                color: #fff;
              }
              
              .btn-detail {
                background: #111;
                color: #0f0;
                border: 1px solid #0f0;
                padding: 5px;
                cursor: pointer;
                transition: background 0.2s;
                text-align: center;
                width: 30px;
                font-family: 'Courier New', monospace;
                border-radius: 3px;
              }
              
              .btn-detail:hover {
                background: #020;
              }
              
              .darkweb-footer {
                background: #000;
                color: #666;
                padding: 10px;
                text-align: center;
                font-size: 0.8em;
                border-top: 1px solid #222;
              }
              
              /* Cart section */
              .cart-section {
                padding: 15px;
                background: #0a0a0a;
                border-top: 1px solid #222;
                margin-top: auto;
              }
              
              .cart-header {
                font-size: 1.1em;
                margin: 0 0 10px 0;
                color: #0f0;
              }
              
              .cart-items {
                max-height: 150px;
                overflow-y: auto;
              }
              
              .cart-item {
                padding: 5px 0;
                border-bottom: 1px dotted #333;
                font-size: 0.85em;
                display: flex;
                justify-content: space-between;
              }
              
              .cart-total {
                margin-top: 10px;
                display: flex;
                justify-content: space-between;
                font-weight: bold;
                color: #fd0;
              }
              
              .cart-actions {
                margin-top: 10px;
              }
              
              .btn-checkout {
                width: 100%;
                padding: 8px;
                background: #300;
                color: #f00;
                border: 1px solid #500;
                cursor: pointer;
                font-family: 'Courier New', monospace;
                transition: background 0.2s;
                border-radius: 3px;
              }
              
              .btn-checkout:hover {
                background: #500;
                color: #fff;
              }
              
              /* Modal */
              .darkweb-modal {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.9);
                z-index: 1000;
                align-items: center;
                justify-content: center;
              }
              
              .modal-content {
                background: #111;
                border: 1px solid #333;
                width: 90%;
                max-width: 500px;
                max-height: 90vh;
                overflow-y: auto;
                padding: 20px;
                position: relative;
                border-radius: 5px;
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
              }
              
              .modal-close {
                position: absolute;
                top: 10px;
                right: 10px;
                background: none;
                border: none;
                color: #f00;
                font-size: 20px;
                cursor: pointer;
              }
              
              .product-detail-image {
                width: 100%;
                max-height: 300px;
                object-fit: contain;
                margin-bottom: 15px;
                border: 1px solid #333;
              }
              
              .product-detail-info {
                margin-bottom: 20px;
              }
              
              .product-detail-name {
                font-size: 1.5em;
                color: #0f0;
                margin: 0 0 5px 0;
              }
              
              .product-detail-price {
                font-size: 1.2em;
                color: #fd0;
                margin-bottom: 10px;
              }
              
              .product-detail-description {
                color: #aaa;
                margin-bottom: 15px;
              }
              
              .product-detail-meta {
                display: flex;
                justify-content: space-between;
                font-size: 0.9em;
                color: #888;
                margin-bottom: 20px;
              }
              
              .purchase-form {
                display: flex;
                gap: 10px;
                align-items: center;
              }
              
              .purchase-quantity {
                width: 70px;
                padding: 8px;
                background: #222;
                border: 1px solid #444;
                color: #fff;
                text-align: center;
              }
              
              .purchase-button {
                flex: 1;
                padding: 8px;
                background: #300;
                color: #f00;
                border: 1px solid #500;
                cursor: pointer;
                transition: background 0.2s;
              }
              
              .purchase-button:hover {
                background: #500;
              }
              
              /* Tabs */
              .tabs-container {
                margin-top: 20px;
              }
              
              .tabs-header {
                display: flex;
                border-bottom: 1px solid #333;
              }
              
              .tab-button {
                padding: 8px 15px;
                background: none;
                border: none;
                color: #888;
                cursor: pointer;
                border-bottom: 3px solid transparent;
              }
              
              .tab-button.active {
                color: #0f0;
                border-bottom-color: #0f0;
              }
              
              .tab-content {
                padding: 15px 0;
                display: none;
              }
              
              .tab-content.active {
                display: block;
              }
              
              /* Purchases tab */
              .purchases-list {
                border: 1px solid #333;
                border-radius: 3px;
              }
              
              .purchase-item {
                padding: 10px;
                border-bottom: 1px solid #333;
              }
              
              .purchase-item:last-child {
                border-bottom: none;
              }
              
              .purchase-header {
                display: flex;
                justify-content: space-between;
                margin-bottom: 5px;
              }
              
              .purchase-id {
                color: #aaa;
                font-size: 0.8em;
              }
              
              .purchase-date {
                color: #888;
                font-size: 0.8em;
              }
              
              .purchase-products {
                margin-top: 5px;
              }
              
              .purchase-product {
                padding: 5px;
                background: #0a0a0a;
                border-radius: 3px;
                margin-bottom: 5px;
                display: flex;
                justify-content: space-between;
              }
              
              .purchase-status {
                margin-top: 5px;
                font-size: 0.9em;
              }
              
              .status-processing {
                color: #fd0;
              }
              
              .status-shipped {
                color: #0af;
              }
              
              .status-delivered {
                color: #0f0;
              }
              
              @keyframes glitchText {
                0% { text-shadow: 0.05em 0 0 rgba(255,0,0,.75), -0.05em -0.025em 0 rgba(0,255,0,.75), 0.025em 0.05em 0 rgba(0,0,255,.75); }
                14% { text-shadow: 0.05em 0 0 rgba(255,0,0,.75), -0.05em -0.025em 0 rgba(0,255,0,.75), 0.025em 0.05em 0 rgba(0,0,255,.75); }
                15% { text-shadow: -0.05em -0.025em 0 rgba(255,0,0,.75), 0.025em 0.025em 0 rgba(0,255,0,.75), -0.05em -0.05em 0 rgba(0,0,255,.75); }
                49% { text-shadow: -0.05em -0.025em 0 rgba(255,0,0,.75), 0.025em 0.025em 0 rgba(0,255,0,.75), -0.05em -0.05em 0 rgba(0,0,255,.75); }
                50% { text-shadow: 0.025em 0.05em 0 rgba(255,0,0,.75), 0.05em 0 0 rgba(0,255,0,.75), 0 -0.05em 0 rgba(0,0,255,.75); }
                99% { text-shadow: 0.025em 0.05em 0 rgba(255,0,0,.75), 0.05em 0 0 rgba(0,255,0,.75), 0 -0.05em 0 rgba(0,0,255,.75); }
                100% { text-shadow: -0.025em 0 0 rgba(255,0,0,.75), -0.025em -0.025em 0 rgba(0,255,0,.75), -0.025em -0.05em 0 rgba(0,0,255,.75); }
              }
              
              .glitch-text {
                animation: glitchText 3s infinite;
              }
            </style>
            
            <div class="darkweb-container">
              <div class="darkweb-header">
                <h1 class="glitch-text">DARK FOXES MARKET</h1>
              </div>
              
              <div class="darkweb-warning">
                <strong>DISCLAIMER:</strong> This is a fictional simulation for entertainment purposes only. All items and transactions are virtual and exist only in this game. No real illegal goods are being sold or purchased.
              </div>
              
              <div class="darkweb-content">
                <div class="darkweb-sidebar">
                  <div class="market-balance">
                    <i class="fa fa-coins" style="margin-right:5px;"></i> <span id="market-balance">Loading...</span> FMC
                  </div>
                  
                  <ul class="category-list">
                    <li class="category-item active" data-category="all">
                      <i class="fa fa-border-all category-icon"></i> All Products
                    </li>
                    <li class="category-item" data-category="drugs">
                      <i class="fa fa-pills category-icon"></i> Substances
                    </li>
                    <li class="category-item" data-category="weapons">
                      <i class="fa fa-gun category-icon"></i> Firearms
                    </li>
                  <li class="category-item" data-category="military">
                      <i class="fa fa-fighter-jet category-icon"></i> Military Hardware
                    </li>
                    <li class="category-item" data-category="purchases">
                      <i class="fa fa-shopping-cart category-icon"></i> My Purchases
                    </li>
                  </ul>
                  
                  <div class="cart-section">
                    <h3 class="cart-header"><i class="fa fa-shopping-cart" style="margin-right:5px;"></i> Cart</h3>
                    <div class="cart-items" id="cart-items">
                      <div style="color:#888;font-style:italic;text-align:center;">Your cart is empty</div>
                    </div>
                    <div class="cart-total">
                      <span>Total:</span>
                      <span id="cart-total">0 FMC</span>
                    </div>
                    <div class="cart-actions" style="display: flex; gap: 5px;">
                      <button class="btn-clear-cart" id="btn-clear-cart" style="background: #222; color: #f00; border: 1px solid #500; padding: 8px; cursor: pointer; font-family: 'Courier New', monospace; transition: background 0.2s; border-radius: 3px; flex: 0.4; font-size: 0.8em;">CLEAR</button>
                      <button class="btn-checkout" id="btn-checkout" disabled style="flex: 1;">CHECKOUT</button>
                    </div>
                  </div>
                </div>
                
                <div class="darkweb-main">
                  <!-- All Products Section -->
                  <div id="section-all" class="section-content">
                    <h2 style="color:#0f0;margin-bottom:20px;border-bottom:1px solid #333;padding-bottom:10px;">
                      <i class="fa fa-border-all" style="margin-right:10px;"></i> All Products
                    </h2>
                    <div class="products-container" id="products-container">
                      <div style="text-align:center;grid-column:1/-1;padding:30px;">
                        <i class="fa fa-spinner fa-spin" style="font-size:24px;margin-bottom:10px;color:#0f0;"></i>
                        <p style="color:#0f0;">Loading products...</p>
                      </div>
                    </div>
                  </div>
                  
                  <!-- Drugs Section -->
                  <div id="section-drugs" class="section-content" style="display:none;">
                    <h2 style="color:#0f0;margin-bottom:20px;border-bottom:1px solid #333;padding-bottom:10px;">
                      <i class="fa fa-pills" style="margin-right:10px;"></i> Substances
                    </h2>
                    <div class="products-container" id="drugs-container"></div>
                  </div>
                  
                  <!-- Weapons Section -->
                  <div id="section-weapons" class="section-content" style="display:none;">
                    <h2 style="color:#0f0;margin-bottom:20px;border-bottom:1px solid #333;padding-bottom:10px;">
                      <i class="fa fa-gun" style="margin-right:10px;"></i> Firearms
                    </h2>
                    <div class="products-container" id="weapons-container"></div>
                  </div>

                  <!-- Military Hardware Section -->
                  <div id="section-military" class="section-content" style="display:none;">
                    <h2 style="color:#0f0;margin-bottom:20px;border-bottom:1px solid #333;padding-bottom:10px;">
                      <i class="fa fa-fighter-jet" style="margin-right:10px;"></i> Military Hardware
                    </h2>
                    <div class="products-container" id="military-container"></div>
                  </div>

                  <!-- Purchases Section -->
                  <div id="section-purchases" class="section-content" style="display:none;">
                    <h2 style="color:#0f0;margin-bottom:20px;border-bottom:1px solid #333;padding-bottom:10px;">
                      <i class="fa fa-shopping-cart" style="margin-right:10px;"></i> My Purchases
                    </h2>
                    <div id="purchases-container">
                      <div style="text-align:center;padding:30px;">
                        <i class="fa fa-spinner fa-spin" style="font-size:24px;margin-bottom:10px;color:#0f0;"></i>
                        <p style="color:#0f0;">Loading purchase history...</p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="darkweb-footer">
                <div style="margin-bottom:5px;">Connected via TOR Network | Encrypted | No Logs</div>
                <div>Dark Foxes Market &copy; 2024 | v3.11.4</div>
              </div>
            </div>
            
            <!-- Product Detail Modal -->
            <div class="darkweb-modal" id="product-modal">
              <div class="modal-content">
                <button class="modal-close" id="modal-close">&times;</button>
                <div id="product-detail-content"></div>
              </div>
            </div>
          `);
          
          // Store the current subcontent
          this._currentSubcontent = "darkweb";
          
          // Initialize cart
          if (!this.darkWebCart) {
            this.darkWebCart = {
              items: [],
              
              addItem(product, quantity) {
                const existingItemIndex = this.items.findIndex(item => item.id === product.id);
                
                if (existingItemIndex >= 0) {
                  this.items[existingItemIndex].quantity += quantity;
                } else {
                  this.items.push({
                    id: product.id,
                    name: product.name,
                    price: product.price,
                    quantity
                  });
                }
                
                this.updateUI();
              },
              
              removeItem(productId) {
                this.items = this.items.filter(item => item.id !== productId);
                this.updateUI();
              },
              
              clear() {
                this.items = [];
                this.updateUI();
              },
              
              getTotal() {
                return this.items.reduce((total, item) => total + item.price * item.quantity, 0);
              },
              
              updateUI() {
                const cartItemsEl = document.getElementById('cart-items');
                const cartTotalEl = document.getElementById('cart-total');
                const checkoutBtn = document.getElementById('btn-checkout');
                const clearBtn = document.getElementById('btn-clear-cart');
                
                if (this.items.length === 0) {
                  cartItemsEl.innerHTML = '<div style="color:#888;font-style:italic;text-align:center;">Your cart is empty</div>';
                  checkoutBtn.disabled = true;
                  clearBtn.disabled = true;
                } else {
                  cartItemsEl.innerHTML = this.items.map(item => `
                    <div class="cart-item">
                      <div>${item.quantity} x ${item.name}</div>
                      <div>${formatPrice(item.price * item.quantity)} FMC</div>
                    </div>
                  `).join('');                        
                  checkoutBtn.disabled = false;
                  clearBtn.disabled = false;
                }
                
                cartTotalEl.textContent = `${formatPrice(this.getTotal())} FMC`;
              }
            };
          }
          
          // Load products
          const loadProducts = async () => {
            try {
              // Get products from database
              const products = await DarkWebDB.getProducts();
              
              // Get current balance
              const balance = await StockMarketDB.getBalance();
              document.getElementById('market-balance').textContent = balance.toFixed(2);
              
              // Generate product cards for each section
              const allProductsContainer = document.getElementById('products-container');
              const drugsContainer = document.getElementById('drugs-container');
              const weaponsContainer = document.getElementById('weapons-container');
              const militaryContainer = document.getElementById('military-container');

              // Clear containers
              militaryContainer.innerHTML = '';
              allProductsContainer.innerHTML = '';
              drugsContainer.innerHTML = '';
              weaponsContainer.innerHTML = '';
              
              // Add products to containers
              const categoryOrder = {
                'drugs': 1,
                'weapons': 2,
                'military': 3
              };
              
              // Sort products by category
              const sortedProducts = [...products].sort((a, b) => {
                return (categoryOrder[a.category] || 99) - (categoryOrder[b.category] || 99);
              });
              
              // Add sorted products to containers
              sortedProducts.forEach(product => {
                const productCard = createProductCard(product);
                
                // Add to all products in sorted order
                allProductsContainer.appendChild(productCard.cloneNode(true));
                
                // Add to category-specific container
                if (product.category === 'drugs') {
                  drugsContainer.appendChild(productCard.cloneNode(true));
                } else if (product.category === 'weapons') {
                  weaponsContainer.appendChild(productCard.cloneNode(true));
                } else if (product.category === 'military') {
                  militaryContainer.appendChild(productCard);
                }
              });
              
              // Attach event listeners
              document.querySelectorAll('.btn-buy').forEach(button => {
                button.addEventListener('click', async function(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  
                  const productId = this.getAttribute('data-id');
                  const product = products.find(p => p.id === productId);
                  
                  if (product) {
                    _this.darkWebCart.addItem(product, 1);
                  }
                });
              });
              
              document.querySelectorAll('.btn-detail').forEach(button => {
                button.addEventListener('click', function(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  
                  const productId = this.getAttribute('data-id');
                  const product = products.find(p => p.id === productId);
                  
                  if (product) {
                    openProductDetail(product);
                  }
                });
              });
              document.getElementById('btn-clear-cart').addEventListener('click', function() {
                _this.darkWebCart.clear();
              });
              // Add event listener to product cards
              document.querySelectorAll('.product-card').forEach(card => {
                card.addEventListener('click', function() {
                  const productId = this.getAttribute('data-id');
                  const product = products.find(p => p.id === productId);
                  
                  if (product) {
                    openProductDetail(product);
                  }
                });
              });
            } catch (error) {
              console.error('Error loading products:', error);
              document.getElementById('products-container').innerHTML = `
                <div style="text-align:center;grid-column:1/-1;padding:30px;">
                  <i class="fa fa-exclamation-triangle" style="font-size:24px;margin-bottom:10px;color:#f00;"></i>
                  <p style="color:#f00;">Error loading products: ${error.message}</p>
                </div>
              `;
            }
          };
          
          // Load purchases
          const loadPurchases = async () => {
            try {
              const purchasesContainer = document.getElementById('purchases-container');
              
              // Get purchases from database
              const purchases = await DarkWebDB.getPurchases();

              if (purchases.length === 0) {
                purchasesContainer.innerHTML = `
                  <div style="text-align:center;padding:30px;">
                    <p style="color:#888;">You haven't made any purchases yet.</p>
                  </div>
                `;
                return;
              }
              
              // Process and update all purchases
              let hasUpdates = false;
              for (let i = 0; i < purchases.length; i++) {
                const purchase = purchases[i];
                const oldStatus = purchase.status;
                
                // Update status based on timestamps
                const updatedPurchase = updateOrderStatus(purchase);
                
                // If status changed, update in database
                if (oldStatus !== updatedPurchase.status) {
                  console.log(`Purchase #${purchase.id} status updated: ${oldStatus}  ${updatedPurchase.status}`);
                  purchases[i] = updatedPurchase;
                  await DarkWebDB.updatePurchase(updatedPurchase);
                  hasUpdates = true;
                }
              }
              
              if (hasUpdates) {
                console.log("Purchase statuses updated");
              }
              const now = Date.now();
              purchases.forEach(purchase => {
                // Apply status update based on timestamps
                if (purchase.statusTimestamps) {
                  const updated = updateOrderStatus(purchase);
                  
                  // If status changed, save back to database
                  if (purchase.status !== updated.status) {
                    purchase.status = updated.status;
                    DarkWebDB.addPurchase(purchase);
                  }
                }
              });
              // Sort purchases by timestamp (newest first)
              purchases.sort((a, b) => b.timestamp - a.timestamp);
              
              // Generate purchase items
              purchasesContainer.innerHTML = `
                <div class="purchases-list">
                  ${purchases.map(purchase => `
                    <div class="purchase-item">
                      <div class="purchase-header">
                        <div class="purchase-id">#${purchase.id}</div>
                        <div class="purchase-date">${new Date(purchase.timestamp).toLocaleString()}</div>
                      </div>
                      <div class="purchase-products">
                        ${purchase.items.map(item => `
                          <div class="purchase-product">
                            <div>${item.quantity}x ${item.name}</div>
                            <div>${formatPrice(item.price * item.quantity)} FMC</div>
                          </div>
                        `).join('')}
                      </div>                            
                      <div class="purchase-status status-${purchase.status.toLowerCase()}">
                        Status: ${purchase.status}
                      </div>
                    </div>
                  `).join('')}
                </div>
              `;
            } catch (error) {
              console.error('Error loading purchases:', error);
              document.getElementById('purchases-container').innerHTML = `
                <div style="text-align:center;padding:30px;">
                  <i class="fa fa-exclamation-triangle" style="font-size:24px;margin-bottom:10px;color:#f00;"></i>
                  <p style="color:#f00;">Error loading purchases: ${error.message}</p>
                </div>
              `;
            }
          };
          
          // Create product card
          const createProductCard = (product) => {
            const card = document.createElement('div');
            card.className = 'product-card';
            card.setAttribute('data-id', product.id);
            
            card.innerHTML = `
              <div class="product-image-container">
                <img src="${product.imageUrl}" alt="${product.name}" class="product-image">
                <div class="product-price">${formatPrice(product.price)} FMC</div>
              </div>
              </div>
              <div class="product-info">
                <h3 class="product-name">${product.name}</h3>
                <p class="product-slang">AKA: ${product.slangNames.join(', ')}</p>
                <p class="product-description">${truncate(product.description, 80)}</p>
                <div class="product-meta">
                  <div class="product-rating">
                    ${getStarRating(product.rating)}
                  </div>
                  <div class="product-quantity">${product.quantity} in stock</div>
                </div>
              </div>
              <div class="product-actions">
                <button class="btn-buy" data-id="${product.id}">ADD TO CART</button>
                <button class="btn-detail" data-id="${product.id}"><i class="fa fa-info"></i></button>
              </div>
            `;
            
            return card;
          };
          
          // Open product detail
          const openProductDetail = (product) => {
            const modal = document.getElementById('product-modal');
            const modalContent = document.getElementById('product-detail-content');
            
            modalContent.innerHTML = `
            <img src="${product.imageUrl}" alt="${product.name}" class="product-detail-image">
            <div class="product-detail-info">
              <h2 class="product-detail-name">${product.name}</h2>
              <div class="product-detail-price">${formatPrice(product.price)} FMC</div>                
                <p class="product-slang"><strong>Street Names:</strong> ${product.slangNames.join(', ')}</p>
                <p class="product-detail-description">${product.description}</p>
                <div class="product-detail-meta">
                  <div>Rating: ${getStarRating(product.rating)}</div>
                  <div>Available: ${product.quantity}</div>
                </div>
              </div>
              
              <form class="purchase-form">
                <input type="number" min="1" max="${product.quantity}" value="1" class="purchase-quantity" id="purchase-quantity">
                <button type="submit" class="purchase-button">ADD TO CART</button>
              </form>
              
              <div class="tabs-container">
                <div class="tabs-header">
                  <button class="tab-button active" data-tab="details">Details</button>
                  <button class="tab-button" data-tab="reviews">Reviews</button>
                  <button class="tab-button" data-tab="shipping">Shipping</button>
                </div>
                
                <div class="tab-content active" id="tab-details">
                  <p style="color:#aaa;">
                    ${product.category === 'drugs' ? 
                      `This product is produced in controlled environments to ensure the highest quality. Our substances are tested for purity and potency before shipping.` : 
                      `This firearm has been carefully inspected and test-fired. All serial numbers have been properly removed. Includes standard accessories.`
                    }
                  </p>
                  <p style="color:#aaa;margin-top:10px;">
                    Origin: Undisclosed secure location<br>
                    Last testing date: ${randomPastDate()}<br>
                    Satisfaction rating: ${product.rating}/5
                  </p>
                </div>
                
                <div class="tab-content" id="tab-reviews">
                  ${generateRandomReviews(product)}
                </div>
                
                <div class="tab-content" id="tab-shipping">
                  <p style="color:#aaa;">
                    All products are shipped using our secure, encrypted delivery network. Packages are vacuum-sealed and discreetly wrapped.
                  </p>
                  <p style="color:#aaa;margin-top:10px;">
                    <strong>Shipping Methods:</strong>
                  </p>
                  <ul style="color:#aaa;margin-left:20px;">
                    <li>Standard Encrypted Delivery (3-5 days)</li>
                    <li>Premium Stealth Shipping (1-2 days)</li>
                    <li>Dead Drop Location (Varies by region)</li>
                  </ul>
                  <p style="color:#f00;margin-top:10px;font-size:0.9em;">
                    <i class="fa fa-exclamation-triangle" style="margin-right:5px;"></i>
                    We do not ship to addresses under known surveillance.
                  </p>
                </div>
              </div>
            `;
            
            // Show modal
            modal.style.display = 'flex';
            
            // Add event listeners for tabs
            modalContent.querySelectorAll('.tab-button').forEach(button => {
              button.addEventListener('click', function() {
                const tabId = this.getAttribute('data-tab');
                
                // Deactivate all tabs
                modalContent.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                modalContent.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Activate selected tab
                this.classList.add('active');
                modalContent.querySelector(`#tab-${tabId}`).classList.add('active');
              });
            });
            
            // Add purchase event listener
            modalContent.querySelector('.purchase-form').addEventListener('submit', function(e) {
              e.preventDefault();
              
              const quantity = parseInt(document.getElementById('purchase-quantity').value);
              
              if (quantity > 0 && quantity <= product.quantity) {
                _this.darkWebCart.addItem(product, quantity);
                
                // Close modal
                document.getElementById('product-modal').style.display = 'none';
              }
            });
          };
          
          // Close modal
          document.getElementById('modal-close').addEventListener('click', function() {
            document.getElementById('product-modal').style.display = 'none';
          });
          
          // Close modal when clicking outside
          document.getElementById('product-modal').addEventListener('click', function(e) {
            if (e.target === this) {
              this.style.display = 'none';
            }
          });
          
          // Category navigation
          document.querySelectorAll('.category-item').forEach(item => {
            item.addEventListener('click', function() {
              const category = this.getAttribute('data-category');
              
              // Update active category
              document.querySelectorAll('.category-item').forEach(i => i.classList.remove('active'));
              this.classList.add('active');
              
              // Show corresponding section
              document.querySelectorAll('.section-content').forEach(section => {
                section.style.display = 'none';
              });
              document.getElementById(`section-${category}`).style.display = 'block';
              
              // Load purchases if needed
              if (category === 'purchases') {
                loadPurchases();
                
                // Clear any existing refresh interval
                if (_this.purchaseRefreshInterval) {
                  clearInterval(_this.purchaseRefreshInterval);
                }
                
                // Set auto-refresh every 20 seconds when viewing purchases
                _this.purchaseRefreshInterval = setInterval(() => {
                  if (document.getElementById('section-purchases').style.display === 'block') {
                    console.log("Auto-refreshing purchases");
                    loadPurchases();
                  } else {
                    // Stop refreshing if we navigate away
                    clearInterval(_this.purchaseRefreshInterval);
                    _this.purchaseRefreshInterval = null;
                  }
                }, 20000); // Check every 20 seconds
              }
            });
          });
          
          // Checkout button
          document.getElementById('btn-checkout').addEventListener('click', async function() {
            try {
              // Get total cost
              const totalCost = _this.darkWebCart.getTotal();
              
              // Check if user has enough balance
              const balance = await StockMarketDB.getBalance();
              
              if (balance < totalCost) {
                alert(`Not enough FMC! You need ${formatPrice(totalCost)} FMC to complete this purchase.`);
                return;
              }
              
              // Create purchase record
              const purchase = {
                items: [..._this.darkWebCart.items],
                totalCost,
                ...getInitialPurchaseState() // This adds status and statusTimestamps
              };
              
              // Update balance
              await StockMarketDB.updateBalance(balance - totalCost);
              
              // Add purchase to database
              await DarkWebDB.addPurchase(purchase);
              
              // Update product quantities
              for (const item of purchase.items) {
                const product = (await DarkWebDB.getProducts()).find(p => p.id === item.id);
                if (product) {
                  await DarkWebDB.updateProductQuantity(product.id, product.quantity - item.quantity);
                }
              }
              
              // Clear cart
              _this.darkWebCart.clear();
              
              // Show success message
              alert('Purchase successful! Check your "My Purchases" tab for status updates.');
              
              // Update balance display
              document.getElementById('market-balance').textContent = (balance - totalCost).toFixed(2);
              
              // Reload products to update quantities
              loadProducts();
            } catch (error) {
              console.error('Error processing purchase:', error);
              alert('Error processing purchase. Please try again.');
            }
          });
          
          // Utility functions
          function truncate(text, maxLength) {
            return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
          }
          
          function getStarRating(rating) {
            const fullStars = Math.floor(rating);
            const halfStar = rating % 1 >= 0.5;
            const emptyStars = 5 - fullStars - (halfStar ? 1 : 0);
            
            let stars = '';
            
            for (let i = 0; i < fullStars; i++) {
              stars += '<i class="fa fa-star" style="color:#fd0;"></i>';
            }
            
            if (halfStar) {
              stars += '<i class="fa fa-star-half-alt" style="color:#fd0;"></i>';
            }
            
            for (let i = 0; i < emptyStars; i++) {
              stars += '<i class="fa fa-star" style="color:#444;"></i>';
            }
            
            return stars;
          }
          
          function randomPastDate() {
            const today = new Date();
            const daysAgo = Math.floor(Math.random() * 30) + 1;
            const pastDate = new Date(today);
            pastDate.setDate(today.getDate() - daysAgo);
            
            return pastDate.toLocaleDateString();
          }
          
          function getInitialPurchaseState() {
            const now = Date.now();
            
            // 1-2 minutes for processing
            const processingTime = now + (60000 + Math.random() * 60000);
            
            // 2-3 minutes for shipping after processing completes
            const shippingTime = processingTime + (120000 + Math.random() * 60000);
            
            return {
              status: "Processing",
              statusTimestamps: {
                ordered: now,
                processingUntil: processingTime,
                shippingUntil: shippingTime
              }
            };
          }
          function updateOrderStatus(purchase) {
            const now = Date.now();
            
            // Handle purchases created before the timestamp system was added
            if (!purchase.statusTimestamps) {
              // Add timestamps for existing purchases based on their current status
              // Use the current time and add progression intervals from there
              purchase.statusTimestamps = {
                ordered: purchase.timestamp || now,
                processingUntil: now + 30000, // 30 seconds from now
                shippingUntil: now + 90000    // 1.5 minutes from now
              };
              
              // If it's already in a later state, adjust timestamps accordingly
              if (purchase.status === "Shipped") {
                purchase.statusTimestamps.processingUntil = now - 1000;
              } else if (purchase.status === "Delivered") {
                purchase.statusTimestamps.processingUntil = now - 2000;
                purchase.statusTimestamps.shippingUntil = now - 1000;
              }
              
              // Return updated purchase with timestamps
              return purchase;
            }
            
            // For purchases with timestamps, apply normal status progression
            if (now >= purchase.statusTimestamps.shippingUntil) {
              purchase.status = "Delivered";
            } else if (now >= purchase.statusTimestamps.processingUntil) {
              purchase.status = "Shipped";
            }
            
            return purchase;
          }

          function formatPrice(price) {
            return price.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
          }
          
          function generateRandomReviews(product) {
            const reviewCount = Math.floor(Math.random() * 5) + 3;
            const reviews = [];
            
            // Add specific review for Ghost Powder (fentanyl)
            if (product.id === "drg-005") {
              reviews.push(`
                <div style="margin-bottom:15px;padding-bottom:10px;border-bottom:1px dotted #333;">
                  <div style="display:flex;justify-content:space-between;margin-bottom:5px;">
                    <div style="color:#0f0;">${getStarRating(5)}</div>
                    <div style="color:#888;font-size:0.8em;">${randomPastDate()}</div>
                  </div>
                  <div style="color:#aaa;">i LOVE this shit! 10/10</div>
                  <div style="color:#666;font-size:0.8em;margin-top:5px;">- fennytanyl</div>
                </div>
              `);
            }
            
            // Original random reviews code continues below
            const positiveComments = [
              "Exactly as described. Very satisfied.",
              "Fast delivery and excellent quality.",
              "Best quality I've found on the dark web.",
              "Discreet packaging, product exceeded expectations.",
              "Reliable vendor, will purchase again.",
              "Perfect transaction from start to finish.",
              "Smooth deal, no issues whatsoever."
            ];
            
            const negativeComments = [
              "Took longer to arrive than expected.",
              "Quality was good but not great.",
              "Packaging could have been more discreet.",
              "Slightly less potent than advertised.",
              "Good product but overpriced."
            ];
            
            for (let i = 0; i < reviewCount; i++) {
              const isPositive = Math.random() < 0.8; // 80% chance of positive review
              const rating = isPositive ? Math.floor(Math.random() * 2) + 4 : Math.floor(Math.random() * 3) + 1;
              const comments = isPositive ? positiveComments : negativeComments;
              const comment = comments[Math.floor(Math.random() * comments.length)];
              
              reviews.push(`
                <div style="margin-bottom:15px;padding-bottom:10px;border-bottom:1px dotted #333;">
                  <div style="display:flex;justify-content:space-between;margin-bottom:5px;">
                    <div style="color:#0f0;">${getStarRating(rating)}</div>
                    <div style="color:#888;font-size:0.8em;">${randomPastDate()}</div>
                  </div>
                  <div style="color:#aaa;">${comment}</div>
                  <div style="color:#666;font-size:0.8em;margin-top:5px;">- Anonymous User</div>
                </div>
              `);
            }
            
            return reviews.join('');
          }
          
          // Initialize
          loadProducts();
          
          // Update cart UI
          this.darkWebCart.updateUI();
        }

        if (subcontent === "about") {
          // Update the tabs structure for proper resizing
          this.loadSubcontent(`
            <style>
              .about-container {
                display: flex;
                flex-direction: column;
                height: 100%;
                overflow: auto;
                padding: 0 10px;
              }
              .about-header {
                margin-bottom: 15px;
                border-bottom: 1px solid rgb(68, 68, 68);
                padding-bottom: 8px;
              }
              .credit-section {
                margin-bottom: 15px;
                padding: 5px 0;
              }
              .credit-name {
                font-size: 16px;
                font-weight: bold;
                padding: 3px 10px;
                border-radius: 4px;
                display: inline-block;
                margin-bottom: 5px;
                cursor: pointer;
                transition: all 0.2s ease;
                position: relative;
                overflow: hidden;
              }
              .credit-name::after {
                content: '';
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                height: 2px;
                background: currentColor;
                transform: scaleX(0);
                transition: transform 0.3s ease;
                opacity: 0.7;
              }
              .credit-name:hover::after {
                transform: scaleX(1);
              }
              .credit-name:active {
                transform: translateY(1px);
              }
              .name-lm {
                color: rgb(33, 124, 228);
                background: linear-gradient(90deg, rgba(27, 131, 221, 0.1), rgba(27, 131, 221, 0.02));
              }
              .name-lm:hover {
                color: rgb(58, 179, 250);
                background: linear-gradient(90deg, rgba(27, 131, 221, 0.15), rgba(27, 131, 221, 0.05));
              }
              .name-ro {
                color: rgb(233, 127, 40);
                background: linear-gradient(90deg, rgba(237, 147, 37, 0.1), rgba(237, 147, 37, 0.02));
              }
              .name-ro:hover {
                color: rgb(255, 166, 57);
                background: linear-gradient(90deg, rgba(237, 147, 37, 0.15), rgba(237, 147, 37, 0.05));
              }
              .name-wu {
                color: rgb(230, 58, 58);
                background: linear-gradient(90deg, rgba(255, 0, 0, 0.1), rgba(255, 0, 0, 0.02));
              }
              .name-wu:hover {
                color: rgb(255, 95, 56);
                background: linear-gradient(90deg, rgba(255, 0, 0, 0.15), rgba(255, 0, 0, 0.05));
              }
                              .name-d {
                color: rgb(221, 102, 211);
                background: linear-gradient(90deg, rgba(180, 90, 200, 0.12), rgba(255, 140, 200, 0.06));
              }
              .name-d:hover {
                color: rgb(255, 135, 171);
                background: linear-gradient(90deg, rgba(180, 90, 200, 0.18), rgba(255, 140, 200, 0.10));
              }
              .credit-content {
                margin-left: 5px;
                padding: 5px 10px;
                border-left: 2px solid rgba(255, 255, 255, 0.1);
              }
              .community-section {
                background: rgba(0, 0, 0, 0.2);
                border-radius: 6px;
                padding: 10px;
                margin-top: 8px;
              }
              .footer {
                font-size: 0.9em;
                color: rgb(136, 136, 136);
                margin-top: 15px;
                text-align: center;
                font-style: italic;
              }
              p {
                margin: 0 0 5px 0;
                word-wrap: break-word;
                overflow-wrap: break-word;
                font-size: 14px;
                line-height: 1.4;
              }
            </style>
            
            <div class="about-container">
              <div class="about-header">
                <h2>About This Mod</h2>
                <p>A collection of useful tools and enhancements for FlockMod</p>
              </div>
              
              <div class="credit-section">
                <div class="credit-name name-lm">Zexium</div>
                <div class="credit-content">
                  <p>Primary developer responsible for creating and maintaining this modification.</p>
                </div>
              </div>
              
              <div class="credit-section">
                <div class="credit-name name-ro">sphoon</div>
                <div class="credit-content">
                  <p>Deobfuscated FlockMod code, provided code snippets for bottombar buttons, blur disabling, copy action disabling, revert to pre-marching ants resize and fixed auto scroll.</p>
                </div>
              </div>

              <div class="credit-section">
                <div class="credit-name name-d">D</div>
                <div class="credit-content">
                  <p>Created the offline version of FlockMod and developed PowerApp. Currently working on new features such as game development within FlockMod and tools for recording and replaying board art progress.</p>
                </div>
              </div>
              
              <div class="credit-section">
                <div class="credit-name name-wu">Anon</div>
                <div class="credit-content">
                  <p>Distributed the menu to other users and contributed valuable ideas for implementation.</p>
                </div>
              </div>
              
              <div class="community-section">
                <h3 style="margin-top: 0; margin-bottom: 5px;">Community Contributors</h3>
                <p>Many thanks to the FlockMod community members who have provided valuable feedback and ideas that have been incorporated into this mod.</p>
                <p>Your suggestions and support help make this project better for everyone.</p>
              </div>
              
              <div class="footer">
                Version 1.3  Made with  for the FlockMod community
              </div>
            </div>
          `);
        
          // Store the current subcontent for later checks
          this._currentSubcontent = "about";
        }
        this.loading(false);
    }
}

calculateOverallTime(timeData) {
  return Object.values(timeData).reduce((total, time) => total + time, 0);
}


updateTimersDisplay() {
  const roomTime = this.roomTimeData[this.selectedRoom] || 0;
  const drawingTime = this.drawingTimeData[this.selectedRoom] || 0;
  const sessionRoomTime = this.sessionRoomTime[this.selectedRoom] || 0;
  const sessionDrawingTime = this.sessionDrawingTime[this.selectedRoom] || 0;

  const overallRoomTime = this.calculateOverallTime(this.roomTimeData);
  const overallDrawingTime = this.calculateOverallTime(this.drawingTimeData);

  this.content.find("#roomTime").text(this.formatTime(roomTime));
  this.content.find("#drawingTime").text(this.formatTime(drawingTime));
  this.content.find("#sessionRoomTime").text(this.formatTime(sessionRoomTime));
  this.content.find("#sessionDrawingTime").text(this.formatTime(sessionDrawingTime));
  this.content.find("#overallRoomTime").text(this.formatTime(overallRoomTime));
  this.content.find("#overallDrawingTime").text(this.formatTime(overallDrawingTime));
}




  loadSubcontent(content) {
    this.content.find(".subcontent").html(content);
  }

  loading(state) {
    if (state) {
      this.content.find(".subcontent").html("<div class='loading' style='color: #fff;'>Loading...</div>");
    }
  }

  formatTime(seconds) {
    // Round seconds to avoid floating-point issues in display
    const roundedSeconds = Math.floor(seconds); // Convert to natural number for display

    const days = Math.floor(roundedSeconds / 86400);
    let remainder = roundedSeconds % 86400;
    const hours = Math.floor(remainder / 3600);
    remainder %= 3600;
    const minutes = Math.floor(remainder / 60);
    const secs = remainder % 60;

    let timeString = "";
    if (days > 0) timeString += `${days}d `;
    if (hours > 0) timeString += `${hours}h `;
    if (minutes > 0 || days > 0 || hours > 0) timeString += `${minutes}m `;
    timeString += `${secs}s`;

    return timeString.trim();
}

getBlockedUsers() {
  return JSON.parse(localStorage.getItem("blockedUsers")) || [];
}

blockUser(username) {
  const blockedUsers = this.getBlockedUsers();
  if (!blockedUsers.includes(username)) {
      blockedUsers.push(username);
      localStorage.setItem("blockedUsers", JSON.stringify(blockedUsers));
  }
}

unblockUser(username) {
  const blockedUsers = this.getBlockedUsers();
  const updatedBlockedUsers = blockedUsers.filter(user => user !== String(username));

  // Update localStorage
  localStorage.setItem("blockedUsers", JSON.stringify(updatedBlockedUsers));
  // Ensure the username is treated as a string and escape it for the selector
  this.content.find(`#blockedUsers button`).filter((_, el) => $(el).data("username") == username).parent().remove();
}



attachMessengerEvents() {
  const _this = this;

  // Block user event
  this.content.find("#blockUserButton").on("click", function () {
      const username = _this.content.find("#blockUserInput").val().trim();
      if (username) {
          _this.blockUser(username);
          setTimeout(() => {
              _this.loadPage("messenger"); // Reload the messenger tab
          }, 100); // Ensure local storage updates are reflected
      }
  });

  // Unblock user event
  this.content.find(".unblockUser").off("click").on("click", function () {
      const username = $(this).data("username");
      _this.unblockUser(username);
      setTimeout(() => {
          _this.loadPage("messenger"); // Reload the messenger tab
      }, 100); // Ensure local storage updates are reflected
  });
}

generateBeautifulHtmlStats(raw) {
  // Extract data arrays - these are already properly formatted by getExtendedStats
  const hourlyData = raw.hourly || [];
  const dailyData = raw.daily || [];
  const monthlyData = raw.monthly || [];
  
  // Format date for report header
  const formattedDate = new Date().toISOString().split('T')[0];
  
  // Determine default mode based on data size
  const defaultOptimized = true // hourlyData.length > 1000;

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Flockmod IP Statistics</title>
  <style>
    body {
      background-color: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 { margin-bottom: 10px; }
    .date { color: #aaa; margin-bottom: 20px; }
    .chart-container {
      background-color: #111;
      padding: 20px;
      border-radius: 8px;
      width: 95%;
      max-width: 1200px;
      margin-bottom: 20px;
    }
    canvas { width: 100% !important; height: 500px !important; }
    .controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      margin-top: 10px;
    }
    .mode-controls {
      text-align: center;
      margin: 10px 0;
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 26px;
      margin: 0 10px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #444;
      transition: .4s;
      border-radius: 34px;
    }
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .toggle-slider {
      background-color: #2196F3;
    }
    input:checked + .toggle-slider:before {
      transform: translateX(34px);
    }
    button {
      background-color: #333;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover { background-color: #444; }
    .view-label { color: #ccc; }
    .stats {
      background-color: #111;
      padding: 15px;
      border-radius: 8px;
      width: 95%;
      max-width: 1200px;
      margin-bottom: 20px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Flockmod IP Statistics Report</h1>
  <div class="date">Generated on ${formattedDate}</div>
  
  <div class="stats">
    Available data: ${monthlyData.length} months, ${dailyData.length} days, ${hourlyData.length} hours
  </div>
  
  <div class="chart-container">
    <canvas id="myChart"></canvas>
    <div class="controls">
      <div class="view-label">Current view: <span id="zoomLevel">Loading...</span></div>
      <button id="resetZoom">Reset Zoom</button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
  <script>
    // Prepare the data
    const hourlyData = ${JSON.stringify(hourlyData)};
    const dailyData = ${JSON.stringify(dailyData)};
    const monthlyData = ${JSON.stringify(monthlyData)};
    
    // Convert string dates to Date objects
    hourlyData.forEach(d => d.x = new Date(d.x));
    dailyData.forEach(d => d.x = new Date(d.x));
    monthlyData.forEach(d => d.x = new Date(d.x));
    
    // Initial mode setting
    let isOptimizedMode = ${defaultOptimized};
    
    // Find min/max dates for x-axis range
    let minDate = new Date();
    let maxDate = new Date(0);
    
    [hourlyData, dailyData, monthlyData].forEach(dataSet => {
      if (!dataSet || dataSet.length === 0) return;
      
      dataSet.forEach(point => {
        if (point.x < minDate) minDate = new Date(point.x);
        if (point.x > maxDate) maxDate = new Date(point.x);
      });
    });
    
    // Calculate the date range and determine appropriate default view
    const totalDays = (maxDate - minDate) / (1000 * 60 * 60 * 24);
    let defaultViewType, defaultTimeUnit, defaultViewLabel;
    
    if (totalDays <= 1) {
      defaultViewType = 'hourly';
      defaultTimeUnit = 'hour';
      defaultViewLabel = 'Hourly data';
    } else if (totalDays <= 31) {
      defaultViewType = 'daily';
      defaultTimeUnit = 'day';
      defaultViewLabel = 'Daily data';
    } else {
      defaultViewType = 'monthly';
      defaultTimeUnit = 'month';
      defaultViewLabel = 'Monthly data';
    }
    
    // Add padding to the date range (10% on each side)
    const dateRange = maxDate - minDate;
    minDate = new Date(minDate.getTime() - dateRange * 0.1);
    maxDate = new Date(maxDate.getTime() + dateRange * 0.1);
    
    // Function to downsample data for optimized mode with improved visibility
    function downsampleData(data, targetPoints, min, max) {
      if (!data || data.length <= targetPoints) return data;
      
      // If zoomed in with visible range provided, prioritize points in that range
      if (min && max) {
        const padding = (max - min) * 0.2;  // 20% padding
        const paddedMin = min - padding;
        const paddedMax = max + padding;
        
        const visiblePoints = data.filter(point => {
          const x = point.x.getTime();
          return x >= paddedMin && x <= paddedMax;
        });
        
        // If visible points are few enough, show them all
        if (visiblePoints.length <= targetPoints * 1.5) {
          return visiblePoints;
        }
      }
      
      // For large datasets, use min-max sampling to preserve visual trends
      if (data.length > targetPoints * 3) {
        const factor = Math.floor(data.length / targetPoints);
        const result = [];
        
        for (let i = 0; i < data.length; i += factor) {
          const chunk = data.slice(i, i + factor);
          
          // Always include the first point of each chunk
          if (chunk.length > 0) {
            result.push(chunk[0]);
          }
          
          // If chunk has multiple points with big variations, include min/max
          if (chunk.length > 1) {
            let minIP = chunk[0].uniqueIPs;
            let maxIP = chunk[0].uniqueIPs;
            let minIPIdx = 0;
            let maxIPIdx = 0;
            
            for (let j = 1; j < chunk.length; j++) {
              if (chunk[j].uniqueIPs < minIP) {
                minIP = chunk[j].uniqueIPs;
                minIPIdx = j;
              }
              if (chunk[j].uniqueIPs > maxIP) {
                maxIP = chunk[j].uniqueIPs;
                maxIPIdx = j;
              }
            }
            
            // Add min/max points if they're significantly different
            if (maxIP - minIP > 5 && minIPIdx !== 0) {
              result.push(chunk[minIPIdx]);
            }
            if (maxIP - minIP > 5 && maxIPIdx !== 0 && maxIPIdx !== minIPIdx) {
              result.push(chunk[maxIPIdx]);
            }
          }
        }
        
        return result;
      }
      
      // Simple sampling for smaller datasets
      const factor = Math.ceil(data.length / targetPoints);
      const result = [];
      
      for (let i = 0; i < data.length; i += factor) {
        result.push(data[i]);
      }
      
      return result;
    }
    
    // Create datasets based on mode
function createDatasets(dataType, optimized, currentUnit) {
  let sourceData;
  
  if (dataType === 'hourly') sourceData = hourlyData;
  else if (dataType === 'daily') sourceData = dailyData;
  else sourceData = monthlyData;
  
  // Apply downsampling if in optimized mode and data is large
  let processedData = sourceData;
  if (optimized && sourceData.length > 1000) {
    let min, max;
    if (chart && chart.scales && chart.scales.x) {
      min = chart.scales.x.min;
      max = chart.scales.x.max;
    }
    processedData = downsampleData(sourceData, 1000, min, max);
  }
  
  // Fix: remove extra block so pointRadius is in scope
  const showPoints = dataType === 'hourly' || dataType === 'daily' || processedData.length < 100;
  const pointRadius = optimized
    ? (showPoints ? (processedData.length < 50 ? 2 : 1) : 0)
    : 2;
    
  const borderWidth = optimized ? 1.5 : 2;
  const tension = optimized ? 0.2 : 0.3;
  
  return [
    {
      label: 'Unique IPs',
      data: processedData.map(point => ({ x: point.x, y: point.uniqueIPs })),
      borderColor: 'rgba(255, 165, 0, 1)',
      backgroundColor: 'rgba(255, 165, 0, 0.2)',
      borderWidth: borderWidth,
      pointRadius: pointRadius,
      pointHoverRadius: 5, // Always show point on hover
      tension: tension,
      spanGaps: true,
      cubicInterpolationMode: 'monotone'
    },
    {
      label: 'Peak Users',
      data: processedData.map(point => ({ x: point.x, y: point.peakUsers })),
      borderColor: 'rgba(0, 123, 255, 1)',
      backgroundColor: 'rgba(0, 123, 255, 0.2)',
      borderWidth: borderWidth,
      pointRadius: pointRadius,
      pointHoverRadius: 5,
      tension: tension,
      spanGaps: true,
      cubicInterpolationMode: 'monotone'
    }
  ];
}
    
    // Create chart with initial settings
    let ctx = document.getElementById('myChart').getContext('2d');
    let chart = null;
    let currentZoom = { min: minDate.getTime(), max: maxDate.getTime() };
    
    function createChart() {
      if (chart) {
        chart.destroy();
      }
      
      const initialDatasets = createDatasets(defaultViewType, isOptimizedMode, defaultTimeUnit);
      
      chart = new Chart(ctx, {
        type: 'line',
        data: { datasets: initialDatasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: {
            duration: isOptimizedMode ? 0 : 300
          },
          interaction: { mode: 'index', intersect: false },
          scales: {
            x: {
              type: 'time',
              time: {
                unit: defaultTimeUnit,
                displayFormats: {
                  hour: 'MMM d, HH:mm', // Uses 24-hour format now
                  day: 'MMM d',
                  month: 'MMM yyyy'
                }
              },
              grid: { color: 'rgba(255, 255, 255, 0.1)' },
              ticks: { color: '#fff', maxRotation: 0 },
              min: minDate,
              max: maxDate
            },
            y: {
              beginAtZero: true,
              grid: { color: 'rgba(255, 255, 255, 0.1)' },
              ticks: { color: '#fff' }
            }
          },
          plugins: {
            decimation: {
              enabled: isOptimizedMode
            },
            legend: {
              labels: { color: '#fff' }
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.7)',
              callbacks: {
                title: context => {
                  const date = new Date(context[0].parsed.x);
                  const unit = chart.options.scales.x.time.unit;
                  
                  if (unit === 'hour') {
                    // Force 24-hour format in the tooltip
                    return date.toLocaleDateString('en-US', {
                      year: 'numeric',
                      month: 'short',
                      day: 'numeric',
                      hour: '2-digit',
                      minute: '2-digit',
                      hour12: false
                    });
                  } else if (unit === 'day') {
                    return date.toLocaleDateString('en-US', {
                      year: 'numeric',
                      month: 'short',
                      day: 'numeric'
                    });
                  } else {
                    return date.toLocaleDateString('en-US', {
                      year: 'numeric',
                      month: 'long'
                    });
                  }
                }
              }
            },
            zoom: {
              limits: {
                x: {min: minDate.getTime(), max: maxDate.getTime()},
                y: {min: 'original', max: 'original'}
              },
              zoom: {
                wheel: { 
                  enabled: true,
                  speed: 0.15 // Slower wheel zoom for more precise control
                },
                pinch: { enabled: true },
                mode: 'x',
                onZoomComplete: updateView
              },
              pan: {
                enabled: true,
                mode: 'x',
                onPanComplete: updateView
              }
            }
          }
        }
      });
      
      // Initialize zoom level display
      document.getElementById('zoomLevel').textContent = defaultViewLabel;
    }
    
    // Initialize chart
    createChart();
    
    // Update view based on zoom level
    function updateView({chart}) {
      const diff = chart.scales.x.max - chart.scales.x.min;
      const days = diff / (1000 * 60 * 60 * 24);
      
      let dataType, timeUnit, label;
      
      // Store current zoom state
      currentZoom = { min: chart.scales.x.min, max: chart.scales.x.max };
      
      // Adjust thresholds for view switching
      if (days <= 10) { // Show hourly data for up to a week
        dataType = 'hourly';
        timeUnit = 'hour';
        label = 'Hourly data';
      } else if (days <= 210) { // Show daily data for up to 3 months
        dataType = 'daily';
        timeUnit = 'day';
        label = 'Daily data';
      } else {
        dataType = 'monthly';
        timeUnit = 'month';
        label = 'Monthly data';
      }
      
      document.getElementById('zoomLevel').textContent = label;
      chart.data.datasets = createDatasets(dataType, isOptimizedMode, timeUnit);
      chart.options.scales.x.time.unit = timeUnit;
      chart.update();
    }
    
    // Reset zoom button
    document.getElementById('resetZoom').addEventListener('click', () => {
      chart.resetZoom();
      chart.data.datasets = createDatasets(defaultViewType, isOptimizedMode, defaultTimeUnit);
      chart.options.scales.x.time.unit = defaultTimeUnit;
      document.getElementById('zoomLevel').textContent = defaultViewLabel;
      chart.update();
    });
    
    // Toggle mode switch
    /*
    document.getElementById('modeToggle').addEventListener('change', function() {
      isOptimizedMode = this.checked;
      
      // Update explanation text
      const modeText = isOptimizedMode ? 
        'Using optimized mode for better performance with large dataset' : 
        'Using simple mode for smooth animations';
      this.parentElement.nextElementSibling.textContent = modeText;
      
      // Recreate chart with new settings
      createChart();
    });
    */
  </script>
</body>
</html>`;
}
// Add this helper method to display IP stats 
displayIPStats(stats, extStats) {
  // Store the data
  this._ipStatsData = {
    stats: stats,
    extStats: extStats
  };
  
  // Check if we have valid hour data before displaying
  let hasValidHourlyData = false;
  let recentHourly = [];
  
  if (extStats.hourly && extStats.hourly.length > 0) {
    // Check last 24 hours for any non-zero data
    const last24Hours = extStats.hourly.slice(-24);
    recentHourly = last24Hours.filter(point => 
      (point.uniqueIPs > 0 || point.peakUsers > 0) && 
      point.x && new Date(point.x).getTime()
    ).slice(-5);
    
    hasValidHourlyData = recentHourly.length > 0;
  }
  
  // Check specifically for today's hourly data from the raw structure
  const today = new Date();
  const year = today.getFullYear();
  const month = today.getMonth() + 1;
  const day = today.getDate();
  const hour = today.getHours();
  
  // Prepare data for the stats cards
  const todayIPCount = extStats.today?.uniqueIPs?.length || 0;
  const weekIPCount = extStats.week?.uniqueIPs?.length || 0;
  const monthIPCount = extStats.month?.uniqueIPs?.length || 0;
  
  const hourlyCount = extStats.hourly?.length || 0;
  const dailyCount = extStats.daily?.length || 0;
  const monthlyCount = extStats.monthly?.length || 0;
  
  const currentOnlineCount = extStats.today?.online?.[hour] ?? Object.values(room?.users || {}).length ?? 0;
  const singleOrPlural = currentOnlineCount === 1 ? 'user' : 'users';
  
  const stateDetails = `
    <div style="background:#222; padding:12px; border-radius:5px; margin-bottom:15px;">
      <h3 style="margin-top:0; font-size:14px; margin-bottom:8px;">Current Tracking State</h3>
      <p style="font-size:12px; margin:4px 0;">Year: ${year}, Month: ${month}, Day: ${day}, Hour: ${hour}</p>
      <p style="font-size:12px; margin:4px 0;">Currently online: <strong>${currentOnlineCount}</strong> ${singleOrPlural}</p>
      <p style="font-size:12px; margin:4px 0;">Data points collected: Hourly (${hourlyCount}), Daily (${dailyCount}), Monthly (${monthlyCount})</p>
    </div>
  `;
  
  // Generate a simple table of recent hourly data
  let recentDataTable = '';
  if (hasValidHourlyData) {
    recentDataTable = `
      <h3 style="font-size:18px; margin-top:5px; margin-bottom:8px;">Recent Hourly Data Points</h3>
      <table style="width:100%; border-collapse:collapse; margin:10px 0;">
        <tr style="border-bottom:1px solid #444; background:#222;">
          <th style="padding:8px; text-align:left;">Time</th>
          <th style="padding:8px; text-align:right;">Unique IPs</th>
          <th style="padding:8px; text-align:right;">Peak Users</th>
        </tr>
        ${recentHourly.map(point => {
          const date = new Date(point.x);
          const formattedDate = date.toLocaleDateString('en-US', {
            month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
          });
          
          return `
            <tr style="border-bottom:1px solid #333;">
              <td style="padding:8px;">${formattedDate}</td>
              <td style="padding:8px; text-align:right;">${point.uniqueIPs || 0}</td>
              <td style="padding:8px; text-align:right;">${point.peakUsers || 0}</td>
            </tr>
          `;
        }).join('')}
      </table>
    `;
  } else {
    // Show today's raw data if available
    if (extStats.today && Object.keys(extStats.today.hours).length > 0) {
      const todayHours = Object.entries(extStats.today.hours)
        .map(([hour, ips]) => ({
          hour: Number(hour),
          uniqueIPs: ips.length,
          peakUsers: extStats.today.online[hour] || 0
        }))
        .filter(d => d.uniqueIPs > 0 || d.peakUsers > 0)
        .sort((a, b) => b.hour - a.hour)
        .slice(0, 5);
      
      if (todayHours.length > 0) {
        recentDataTable = `
          <h3>Today's Hourly Data</h3>
          <table style="width:100%; border-collapse:collapse; margin:10px 0;">
            <tr style="border-bottom:1px solid #444; background:#222;">
              <th style="padding:8px; text-align:left;">Hour</th>
              <th style="padding:8px; text-align:right;">Unique IPs</th>
              <th style="padding:8px; text-align:right;">Peak Users</th>
            </tr>
            ${todayHours.map(data => `
              <tr style="border-bottom:1px solid #333;">
                <td style="padding:8px;">${data.hour}:00</td>
                <td style="padding:8px; text-align:right;">${data.uniqueIPs}</td>
                <td style="padding:8px; text-align:right;">${data.peakUsers}</td>
              </tr>
            `).join('')}
          </table>
        `;
      } else {
        recentDataTable = `<p>No hourly data with activity collected yet.</p>`;
      }
    } else {
      recentDataTable = `<p>No hourly data collected yet.</p>`;
    }
  }

  // Update the UI with statistics
  this.content.find("#ipStatsText").html(`
    <div style="padding:10px;">
      <h3 style="font-size:18px; margin-top:5px; margin-bottom:8px;">Statistics Summary</h3>
      
      <div style="display:flex; justify-content:space-between; margin:15px 0; flex-wrap:wrap;">
        <div style="background:#222; padding:15px; border-radius:5px; margin:5px; flex:1; min-width:120px; text-align:center;">
          <div style="font-size:12px; color:#aaa;">Today's IPs</div>
          <div style="font-size:24px; margin:5px 0;">${todayIPCount}</div>
        </div>
        <div style="background:#222; padding:15px; border-radius:5px; margin:5px; flex:1; min-width:120px; text-align:center;">
          <div style="font-size:12px; color:#aaa;">Week's IPs</div>
          <div style="font-size:24px; margin:5px 0;">${weekIPCount}</div>
        </div>
        <div style="background:#222; padding:15px; border-radius:5px; margin:5px; flex:1; min-width:120px; text-align:center;">
          <div style="font-size:12px; color:#aaa;">Month's IPs</div>
          <div style="font-size:24px; margin:5px 0;">${monthIPCount}</div>
        </div>
        <div style="background:#222; padding:15px; border-radius:5px; margin:5px; flex:1; min-width:120px; text-align:center;">
          <div style="font-size:12px; color:#aaa;">Current Year</div>
          <div style="font-size:24px; margin:5px 0;">${extStats.year && extStats.year[new Date().getFullYear()] ? (Array.isArray(extStats.year[new Date().getFullYear()]) ? extStats.year[new Date().getFullYear()].length : 0) : 0}</div>
        </div>
        <div style="background:#222; padding:15px; border-radius:5px; margin:5px; flex:1; min-width:120px; text-align:center;">
          <div style="font-size:12px; color:#aaa;">All Time</div>
          <div style="font-size:24px; margin:5px 0;">${Object.values(extStats.year || {}).reduce((total, yearData) => total + (Array.isArray(yearData) ? yearData.length : 0), 0)}</div>
        </div>
      </div>
      
      ${stateDetails}
      ${recentDataTable}
    </div>
  `);
}

// Add this method to handle CSV export with the updated per-month structure
async downloadCsvStats(extStats) {
  const currentDate = new Date();
  const formattedDate = `${currentDate.getFullYear()}-${currentDate.getMonth() + 1}-${currentDate.getDate()}`;
  
  // Create a hierarchical structure that mirrors our data model
  const csvRows = [
    ["Flockmod Hierarchical IP Statistics", "", ""],
    ["Generated On", formattedDate, ""],
    ["", "", ""],
    ["Time Period", "Unique IPs", "Peak Users", "IP Addresses"]  // Added IP Addresses column
  ];
  
  // Sort years in ascending order
  const years = Object.keys(extStats.yearMonthly || {}).sort((a, b) => Number(a) - Number(b));
  
  // Process each year hierarchically
  for (const year of years) {
    // Add year row
    const yearIPs = extStats.year[year] || [];
    const yearPeak = Math.max(...Object.values(extStats.yearMonthly[year] || {}).map(m => m.peak || 0), 0);
    csvRows.push([`Year ${year}`, yearIPs.length, yearPeak, yearIPs.join(';')]);  // Added IPs joined by semicolons
    
    // Sort months in ascending order
    const months = Object.keys(extStats.yearMonthly[year] || {}).sort((a, b) => Number(a) - Number(b));
    
    // Process each month in the year
    for (const month of months) {
      const monthData = extStats.yearMonthly[year][month];
      const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      const monthName = monthNames[Number(month) - 1] || `Month ${month}`;
      
      // Add month row with indentation
      csvRows.push([
        `  ${monthName} ${year}`, 
        monthData.uniqueIPs?.length || 0, 
        monthData.peak || 0,
        (monthData.uniqueIPs || []).join(';')  // Added IPs joined by semicolons
      ]);
      
      // Load individual month data from the new per-month storage
      // We use the month key directly now instead of going through the full hierarchy
      const monthKey = `ipStats_${year}_${month}`;
      const monthStats = await IDBHelper.getItem(monthKey);
      
      if (monthStats && monthStats.days) {
        // Process each day in the month
        const days = Object.keys(monthStats.days).sort((a, b) => Number(a) - Number(b));
        
        for (const day of days) {
          const dayData = monthStats.days[day];
          
          // Add day row with more indentation
          csvRows.push([
            `    ${monthName} ${day}, ${year}`, 
            dayData.uniqueIPs?.length || 0, 
            dayData.peak || 0,
            Array.isArray(dayData.uniqueIPs) ? dayData.uniqueIPs.join(';') : ''  // Added IPs joined by semicolons
          ]);
          
          // Process each hour in the day if available
          if (dayData.hours) {
            const hours = Object.keys(dayData.hours).sort((a, b) => Number(a) - Number(b));
            
            for (const hour of hours) {
              const hourData = dayData.hours[hour];
              
              // Format the time with leading zeros
              const timeFormat = (h) => {
                const hr = Number(h);
                return `${hr.toString().padStart(2, '0')}:00 - ${hr.toString().padStart(2, '0')}:59`;
              };
              
              // Add hour row with even more indentation
              csvRows.push([
                `      ${timeFormat(hour)}`,
                hourData.uniqueIPs?.length || 0,
                hourData.count || 0, // For hours we use actual count, not peak
                Array.isArray(hourData.uniqueIPs) ? hourData.uniqueIPs.join(';') : ''  // Added IPs joined by semicolons
              ]);
            }
          }
        }
      }
    }
    
    // Add a blank row after each year for better readability
    csvRows.push(["", "", "", ""]);  // Updated blank row with 4 columns
  }
  
  // Convert rows to CSV format
  const csvContent = csvRows.map(row => {
    return row.map(cell => {
      // Escape commas and quotes in cells
      const cellStr = String(cell).replace(/"/g, '""');
      return `"${cellStr}"`;
    }).join(',');
  }).join('\n');
  
  // Create download
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `Flockmod_Hierarchical_Stats_${formattedDate}.csv`;
  a.click();
  URL.revokeObjectURL(url);
}
}



class HelpDialog extends Dialog {
  constructor(_0x48b935) {
    super(_0x48b935), this["icon"] = "fa-circle-question", this["caption"] = textManager["getString"]("help.title"), this["width"] = 770, this["height"] = 600, this.loadContent(this["loadFile"]("forms/help.main.html"));
  }
  ["loadContent"](_0x43d756) {
    this["content"]["html"](_0x43d756);
  }
  ["onShow"](_0x222d5c) {
    this["content"]["find"]("iframe")["attr"]("src", _0x222d5c);
  }
  ["onHide"]() {
    this["content"]["find"]("iframe").attr("src", "");
  }
}
class FeedbackDialog extends Dialog {
  constructor(_0x4ae257) {
    super(_0x4ae257), this.icon = "fa-comment-alt", this["caption"] = textManager["getString"]("feedback.title"), this["width"] = 500, this["height"] = 500, this["loadContent"](this["loadFile"]("forms/feedback.main.html"));
    var _0xbbaf49 = this;
    this["content"]["find"]("a[name=\"send\"]").on(UI.pointerEvent("click"), function (_0x48468d) {
      _0x48468d["preventDefault"]();
      if (_0xbbaf49.content["find"]('textarea[name="comments"]')["val"]() != "") {
        var _0x4be217 = {};
        _0x4be217.command = "USERREQUEST", _0x4be217["action"] = "FEEDBACK", _0x4be217["comments"] = _0xbbaf49["content"].find("textarea[name=\"comments\"]")["val"](), _0x4be217["like"] = 1, socket.send(_0x4be217, true), UI["dialogHandler"]["showAlert"](textManager["getString"]("feedback.lblThankYou"));
      }
      _0xbbaf49.hide();
    });
  }
  ["loadContent"](_0xeb7ae5) {
    this["content"].html(_0xeb7ae5);
  }
  ["onShow"]() {
    this["content"]["find"]("textarea[name=\"comments\"]")["val"](""), this["content"].find("textarea[name=\"comments\"]").focus(), this["changed"]();
  }
}
class AnimationDialog extends Dialog {
  constructor(_0x164580) {
    super(_0x164580), this["icon"] = "fa-film", this.caption = textManager.getString("animation.title"), this["helpLink"] = "https://flockmod.com/help/tools/animation/", this["width"] = 820, this["height"] = 590, this["playing"] = false, this["rows"] = 0, this["cols"] = 0, this.layersCheckbox = [], this["frames"] = [], this["canvas"], this["animationId"], this.intervalId, this["loadContent"](this.loadFile("forms/animation.main.html"));
    var _0x28add0 = this;
    this["content"].on(UI.pointerEvent("click"), ".subcontentOption", function (_0x3c34a3) {
      _0x3c34a3["preventDefault"]();
      var _0x2e6b61 = $(this).data("subcontent");
      _0x28add0["loadPage"](_0x2e6b61);
    });
  }
  ["loadContent"](_0x4ce076) {
    this["content"]["html"](_0x4ce076);
  }
  ["loadSubcontent"](_0x369b14) {
    this.content["find"](".dynamicDialogArea").html(_0x369b14);
  }
  ["loadPage"](_0x3d924c) {
    this.cols = room["animCols"], this["rows"] = room["animRows"];
    var _0x1130a8 = this;
    if (_0x3d924c !== undefined) {
      this["form"].find(".subcontentOption")["removeClass"]("selected"), this["form"]["find"](".subcontentOption[data-subcontent=" + _0x3d924c + "]")["addClass"]("selected"), this["loading"](true), this.stop();
      if (_0x3d924c == "play") {
        this["loadSubcontent"](this["loadFile"]("forms/animation.play.html")), this["content"].find("#frameBox")["css"]("background-color", room.board["backgroundColor"]), this["speedSlider"] = new Slider(this["content"]["find"]('div[name="speed"]'), 0.1, 15, 0.1), $(this.speedSlider).on("sliderChanged", function (_0x5bd58c) {
          _0x1130a8["setPreference"]("speed", _0x5bd58c["value"]), _0x1130a8.playing && (_0x1130a8["stop"](), _0x1130a8["play"]());
        });
        this["getPreference"]("speed") !== undefined ? this.speedSlider["setValue"](this.getPreference("speed")) : this["speedSlider"]["setValue"](1.5);
        this["content"]["find"]("a[name=\"previousFrame\"]").on(UI["pointerEvent"]("click"), function (_0x156c41) {
          _0x156c41["preventDefault"](), _0x1130a8.stop(), _0x1130a8["hideFrames"](), _0x1130a8["previousFrame"](true);
        }), this.content["find"]("a[name=\"nextFrame\"]").on(UI.pointerEvent("click"), function (_0x24d31e) {
          _0x24d31e["preventDefault"](), _0x1130a8.stop(), _0x1130a8["hideFrames"](), _0x1130a8["nextFrame"](true);
        }), this["content"].find("a[name=\"playPauseFrame\"]").on(UI["pointerEvent"]("click"), function (_0xfe2c03) {
          _0xfe2c03["preventDefault"](), _0x1130a8["playing"] ? _0x1130a8["stop"]() : _0x1130a8["play"]();
        }), this.content["find"]("#framePreview")["contextmenu"](function (_0x46c649) {
          _0x46c649["preventDefault"]();
        }), this["content"]["find"]("a[name=\"stopFrame\"]").on(UI.pointerEvent("click"), function (_0x439889) {
          _0x439889["preventDefault"](), _0x1130a8["stop"](), _0x1130a8.showFrame(0);
        }), this["content"]["find"]("a[name=\"generate\"]").on(UI["pointerEvent"]("click"), function (_0x45f3e0) {
          _0x45f3e0["preventDefault"](), _0x1130a8["loading"](true), _0x1130a8["stop"]();
          var _0x2e114b = new FormData();
          _0x2e114b.append("picture", _0x1130a8.canvas.getData()), _0x2e114b["append"]("columns", _0x1130a8["cols"]), _0x2e114b["append"]("rows", _0x1130a8.rows), _0x2e114b["append"]("speed", _0x1130a8["speedSlider"]["getValue"]()), $["ajax"]({
            url: "/api/gif/gifConverter.php",
            data: _0x2e114b,
            cache: false,
            contentType: false,
            processData: false,
            method: "POST"
          })["done"](function (_0x39ced8) {
            var _0x469821 = new Image();
            _0x469821.onload = function () {
              UI.saveDialog.show("gif", this), _0x1130a8["loading"](false);
            }, _0x469821.src = "data:image/gif;base64," + _0x39ced8;
          })["fail"](function () {
            UI.dialogHandler.showAlert(textManager["getString"]("alerts.txtGIFfailed")), _0x1130a8["loading"](false);
          });
        });
        var _0x367bed = room.board["canvasWidth"] / this["cols"],
          _0x17203f = room.board["canvasHeight"] / this["rows"];
        this.content["find"]("#framePreview")["empty"]();
        var _0x1ee627 = room["board"]["getAllLayers"](0, 0, room["board"]["canvasWidth"], room["board"]["canvasHeight"]);
        _0x1ee627["then"](function (_0x4181ac) {
          var _0x380631 = new AdvancedCanvas(room["board"]["canvasWidth"], room["board"]["canvasHeight"]);
          _0x380631["clear"](room["board"]["backgroundColor"]);
          var _0x25edb7 = Object["keys"](_0x4181ac)["length"],
            _0x405c29 = {},
            _0x56cc86 = 0;
          _0x1130a8["frames"] = [], $.each(_0x4181ac, function (_0x45f60e, _0x54e3e9) {
            var _0x12b490 = new Image();
            _0x405c29[_0x45f60e] = _0x12b490, _0x12b490["onload"] = function () {
              if (++_0x56cc86 == _0x25edb7) {
                for (var _0x42c03e = 0; _0x42c03e < room["board"].nLayers; _0x42c03e++) {
                  _0x42c03e in _0x405c29 && _0x380631["drawImage"](_0x405c29[_0x42c03e]);
                }
                var _0x18b7f2 = new Image();
                _0x18b7f2.onload = function () {
                  var _0x1788ea = 0;
                  for (var _0x163890 = 0; _0x163890 < _0x1130a8["rows"]; _0x163890++) {
                    for (var _0x4bee81 = 0; _0x4bee81 < _0x1130a8["cols"]; _0x4bee81++) {
                      var _0x151b23 = new Image();
                      $(_0x151b23).attr("name", _0x1788ea++), $(_0x151b23)["addClass"]("animationPreviewFrame noMouseInteraction"), _0x151b23.onload = function () {
                        _0x1130a8["changed"]();
                      }, _0x151b23["src"] = cropImage(this, _0x4bee81 * _0x367bed, _0x163890 * _0x17203f, _0x367bed, _0x17203f), _0x1130a8["frames"]["push"](_0x151b23), _0x1130a8["content"]["find"]("#framePreview")["append"](_0x151b23);
                    }
                  }
                  _0x1130a8["play"](), _0x1130a8["loading"](false);
                }, _0x18b7f2["src"] = _0x380631["getData"](), _0x1130a8.canvas = _0x380631;
              }
            }, _0x12b490["src"] = _0x54e3e9;
          });
        });
      } else {
        if (_0x3d924c == "frames") {
          this.loadSubcontent(this["loadFile"]("forms/animation.frames.html"));
          var _0x122e2e = this.content.find('select[name="frameSelector"]'),
            _0x5f4769 = this["content"].find("select[name=\"frameSelector2\"]");
          _0x122e2e["empty"](), _0x5f4769["empty"]();
          for (var _0x4cac5b = 0; _0x4cac5b < this["rows"] * this.cols; _0x4cac5b++) {
            _0x122e2e["append"](new Option(_0x4cac5b + 1, _0x4cac5b)), _0x5f4769["append"](new Option(_0x4cac5b + 1, _0x4cac5b));
          }
          this["actionSelector"] = new Selector(this.content["find"]('div[name="action"]'), {
            clear: textManager.getString("animation.frames.optClear"),
            clone: textManager["getString"]("animation.frames.optClone")
          }), this.actionSelector["select"]("clear"), this["opacitySlider"] = new Slider(this["content"]["find"]("div[name=\"opacity\"]"), 0, 1, 0.01, zeroToOnePercentage), this["opacitySlider"].setValue(1), this["content"].find("#animationLayers").empty(), this["layersCheckbox"] = new Array();
          for (var _0x4cac5b = 0; _0x4cac5b < room.board.nLayers; _0x4cac5b++) {
            var _0x28fe0e = $("<div />");
            _0x28fe0e.css({
              float: "left",
              width: 100 / room.board["nLayers"] + "%"
            }), _0x28fe0e.addClass("smallCheckbox"), _0x28fe0e["attr"]("name", _0x4cac5b), this["content"]["find"]("#animationLayers").prepend(_0x28fe0e);
            var _0x9cef49 = new Checkbox(_0x28fe0e, textManager.getString("animation.frames.lblLayer", _0x4cac5b + 1, false));
            _0x9cef49["setValue"](true), this["layersCheckbox"].push(_0x9cef49);
          }
          room["board"].nLayers == 1 ? this.content["find"]("fieldset[name=\"layers\"]")["hide"]() : this["content"]["find"]("fieldset[name=\"layers\"]")["show"](), this.content.find('fieldset[name="cloning"]')["hide"](), $(this["actionSelector"]).on("optionSelected", function (_0x15892d) {
            _0x15892d["option"] == "clear" ? _0x1130a8["content"]["find"]("fieldset[name=\"cloning\"]")["hide"]() : _0x1130a8["content"]["find"]("fieldset[name=\"cloning\"]")["show"]();
          }), this["content"]["find"]('a[name="applyChangesFrames"]').on(UI.pointerEvent("click"), function (_0x4701f0) {
            _0x4701f0.preventDefault();
            for (var _0x5bf0c6 = 0; _0x5bf0c6 < room["board"]["nLayers"]; _0x5bf0c6++) {
              if (_0x1130a8["layersCheckbox"][_0x5bf0c6].getValue()) {
                if (_0x1130a8["actionSelector"].getSelected() == "clear") {
                  var _0x1641a0 = {};
                  _0x1641a0["command"] = "ACTIONREQUEST", _0x1641a0["action"] = "Afc", _0x1641a0["layer"] = _0x5bf0c6, _0x1641a0["source"] = _0x122e2e["val"](), socket["send"](_0x1641a0, true);
                } else {
                  var _0x1641a0 = {};
                  _0x1641a0["command"] = "ACTIONREQUEST", _0x1641a0.action = "Afd", _0x1641a0["layer"] = _0x5bf0c6, _0x1641a0["source"] = _0x122e2e["val"](), _0x1641a0["target"] = _0x5f4769.val(), _0x1641a0["opacity"] = _0x1130a8["opacitySlider"]["getValue"](), socket.send(_0x1641a0, true);
                }
              }
            }
          }), this["scroll"] = this["content"]["find"](".dialogContentArea")["overlayScrollbars"]({
            className: "os-theme-light",
            overflowBehavior: {
              x: "hidden"
            }
          }).overlayScrollbars(), this["scroll"]["addExt"]("fmExtension"), this["loading"](false);
        }
      }
      this["changed"](), this["processSizeType"](this["sizeType"]);
    }
  }
  ["play"]() {
    this["playing"] = true, this["currentFrame"] = 0, this["maxFrames"] = this["rows"] * this["cols"], this["hideFrames"](), this["showFrame"](0), this["content"]["find"]("a[name=\"playPauseFrame\"]").html(new Icon("fa-pause")["html"]());
    var _0x5bea16 = this;
    this["intervalId"] = window["setInterval"](function () {
      _0x5bea16["animationId"] = window["requestAnimationFrame"](function () {
        _0x5bea16["hideFrames"](), _0x5bea16.nextFrame(true);
      });
    }, 1e3 / this["speedSlider"]["getValue"]());
  }
  ["previousFrame"](_0xccba7c = false) {
    this["currentFrame"]--, this["currentFrame"] < 0 && (this.currentFrame = this["rows"] * this.cols - 1), _0xccba7c && this["showFrame"](this["currentFrame"]);
  }
  ["nextFrame"](_0x277c20 = false) {
    this["currentFrame"]++, this["currentFrame"] >= this["rows"] * this["cols"] && (this["currentFrame"] = 0), _0x277c20 && this["showFrame"](this.currentFrame);
  }
  ["hideFrames"]() {
    this.content["find"]("#framePreview")["find"]("img:visible").hide();
  }
  ["showFrame"](_0x610164) {
    this["content"]["find"]("#framePreview")["find"]("img[name=\"" + _0x610164 + '"]')["show"]();
  }
  ["pause"]() {
    this["content"]["find"]('a[name="playPauseFrame"]')["html"](new Icon("fa-play")["html"]());
  }
  ["stop"]() {
    this["playing"] && (window["cancelAnimationFrame"](this["animationId"]), window["clearInterval"](this["intervalId"]), this["content"]["find"]("a[name=\"playPauseFrame\"]").html(new Icon("fa-play")["html"]()), this["playing"] = false);
  }
  ["onResize"]() {
    var _0x55e86d = this["content"]["find"]("#frameBox")["width"](),
      _0x18a5b2 = this["content"]["find"]("#framePreview")["width"](),
      _0x1bd9ea = this["content"].find("#framePreview")["height"](),
      _0x21d962 = this["content"]["find"]("#previewDiv")["width"](),
      _0x583199 = this["content"]["find"]("#previewDiv")["height"](),
      _0xa9e60f = room["board"]["canvasWidth"] / this["cols"],
      _0x547c46 = room["board"]["canvasHeight"] / this.rows,
      _0x33fe16 = calculateAspectRatioFit(_0xa9e60f, _0x547c46, _0x21d962, _0x583199),
      _0x553d5b = _0x33fe16["width"] / this["canvasWidth"];
    this["content"]["find"]("#framePreview")["css"]("transform", "scale(" + _0x553d5b + ")"), this["content"].find("#frameBox").css({
      width: _0x33fe16["width"],
      height: _0x33fe16.height
    });
  }
  ["onShow"](_0x2623b1 = "play") {
    this["loadPage"](_0x2623b1), room["can"]("manageframes") ? this["content"]["find"]("li a[data-subcontent=\"frames\"]")["show"]() : this["content"]["find"]('li a[data-subcontent="frames"]')["hide"]();
  }
  ["onHide"]() {
    this["stop"]();
  }
}
class MessengerDialog extends Dialog {
  constructor(_0x4379f0) {
    super(_0x4379f0), this["icon"] = "fa-envelope", this["caption"] = textManager["getString"]("messenger.title"), this["helpLink"] = "https://flockmod.com/help/tools/social/", this["fontSize"] = 13, this["width"] = 700, this["loadContent"](this["loadFile"]("forms/messenger.main.html")), this["emojiList"] = new EmojiSelector(this.content["find"](".emojiContainer")), this["sidebarScroll"] = this.content["find"](".messengerSideBar")["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    }).overlayScrollbars(), this.sidebarScroll["addExt"]("fmExtension"), this["scroll"] = this["content"]["find"](".conversationBox")["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    })["overlayScrollbars"](), this["scroll"]["addExt"]("fmExtension"), this["previews"] = new ImagePreview(), this["selectedUserUID"] = null;
    var _0x2b231c = this;
    $(this["emojiList"]).on("dialogClosed", function (_0x51fb0f) {
      _0x2b231c["content"]["find"]("input[name=\"text\"]")["focus"]();
    }), $["contextMenu"]({
      selector: ".conversationBox",
      build: function (_0x142e4a) {
        var _0x21141a = {
          callback: function (_0x143b05, _0x102713) {
            if (_0x143b05 == "copy") document["execCommand"]("copy", false, null); else {
              if (_0x143b05 == "select") try {
                var _0x15c510 = document["createRange"]();
                _0x15c510["selectNode"](document["getElementById"]("messengerConversation")), window["getSelection"]().removeAllRanges(), window["getSelection"]()["addRange"](_0x15c510);
              } catch (_0x483132) { }
            }
          },
          items: {
            copy: {
              name: "Copy text",
              icon: "fa-copy"
            },
            select: {
              name: "Select all",
              icon: "fa-i-cursor"
            }
          }
        };
        return $["each"](_0x21141a.items, function (_0x5c2ab9, _0x36bee9) {
          _0x21141a["items"][_0x5c2ab9]["name"] && (_0x21141a["items"][_0x5c2ab9]["name"] = function () {
            return textManager["getString"]("menu.textbox." + _0x5c2ab9, null, false);
          });
        }), _0x21141a;
      }
    }), $["contextMenu"]({
      selector: ".conversationBox a",
      build: function (_0x373fad) {
        var _0x452e71 = {
          callback: function (_0x394e52, _0x1a0fc9) {
            if (_0x394e52 == "copylink") {
              var _0x48dfb6 = _0x1a0fc9["$trigger"];
              navigator["clipboard"]["writeText"](_0x48dfb6["attr"]("href"));
            } else {
              if (_0x394e52 == "openlink") {
                var _0x48dfb6 = _0x1a0fc9.$trigger;
                window["open"](_0x48dfb6["attr"]("href"), "_blank");
              }
            }
          },
          items: {
            copylink: {
              name: "Copy link",
              icon: "fa-copy"
            },
            openlink: {
              name: "Open link",
              icon: "fa-arrow-up-right-from-square"
            }
          }
        };
        return $["each"](_0x452e71["items"], function (_0x202e09, _0x11e71d) {
          _0x452e71["items"][_0x202e09]["name"] && (_0x452e71["items"][_0x202e09]["name"] = function () {
            return textManager["getString"]("menu.textbox." + _0x202e09, null, false);
          });
        }), _0x452e71;
      }
    }), $["contextMenu"]({
      selector: "a[name=\"options\"]",
      trigger: "left",
      build: function (_0x47837d) {
        var _0x2d44d1 = {
          callback: function (_0x567d18, _0x3d2359) {
            if (_0x567d18 == "remove") {
              if (_0x2b231c.selectedUserUID != null) {
                var _0x591ba6 = UI["dialogHandler"]["createConfirmation"](textManager.getString("messenger.lblDeleteConversation"));
                _0x591ba6.on("confirmationClosed", function (_0x235959) {
                  _0x235959["response"] == "ok" && _0x2b231c.requestRemoveConversation(_0x2b231c.selectedUserUID), UI["dialogHandler"].destroyConfirmation();
                });
              }
            }
          },
          items: {
            remove: {
              name: "Delete conversation",
              icon: "fa-trash-can"
            }
          }
        };
        return $["each"](_0x2d44d1.items, function (_0x36c216, _0x4acd2c) {
          _0x2d44d1["items"][_0x36c216]["name"] && (_0x2d44d1.items[_0x36c216]["name"] = function () {
            return textManager["getString"]("menu.messenger." + _0x36c216, null, false);
          });
        }), _0x2d44d1;
      }
    }), this["content"]["find"]("button[name=\"submit\"]").on(UI["pointerEvent"]("click"), function (_0x12c008) {
      _0x12c008["preventDefault"](), _0x2b231c.sendMessage(), _0x2b231c["content"].find("input[name=\"text\"]")["focus"]();
    }), this.content["find"]("input[name=\"text\"]").on("keydown", function (_0x5177ef) {
      _0x5177ef.which == 13 && (_0x5177ef.preventDefault(), _0x2b231c["sendMessage"]());
    }), this["content"].on(UI["pointerEvent"]("click"), ".messengerUser", function (_0x4c887b) {
      var _0x2ed690 = $(this)["data"]("uid");
      _0x2b231c["select"](_0x2ed690);
    }), this.content["find"](".fontIncrease").on(UI["pointerEvent"]("click"), function (_0x3ccad2) {
      _0x3ccad2["preventDefault"](), _0x2b231c.fontIncrease();
    }), this.content["find"](".fontDecrease").on(UI["pointerEvent"]("click"), function (_0x199d86) {
      _0x199d86.preventDefault(), _0x2b231c["fontDecrease"]();
    }), $(this["emojiList"]).on("emojiSelected", function (_0x2af97b) {
      _0x2b231c.content["find"]('input[name="text"]').val(_0x2b231c.content["find"]('input[name="text"]')["val"]() + _0x2af97b["emoji"]);
    }), this["content"].on(UI["pointerEvent"]("click"), ".offlineDelete a", function (_0x32b48f) {
      _0x32b48f["preventDefault"]();
      var _0x5175a9 = $(this)["attr"]("name"),
        _0x54e06f = UI["dialogHandler"].createConfirmation(textManager["getString"]("messenger.lblDeleteMessage"));
      _0x54e06f.on("confirmationClosed", function (_0x1a3eee) {
        _0x1a3eee["response"] == "ok" && _0x2b231c["requestDeleteMessage"](_0x2b231c["selectedUserUID"], _0x5175a9), UI["dialogHandler"]["destroyConfirmation"]();
      });
    }), this.content.on(UI.pointerEvent("click"), 'button[name="emoji"]', function (_0x32fefb) {
      _0x32fefb["preventDefault"](), _0x2b231c.showAndResetEmojiSelector();
    }), this["content"]["find"]("a[name=\"newConversation\"]").on(UI["pointerEvent"]("click"), function (_0x2daf6b) {
      _0x2daf6b["preventDefault"](), _0x2b231c["enableModal"](_0x2b231c["loadFile"]("forms/messenger.modal.newconversation.html")), _0x2b231c.content["find"]("input[name=\"findUsername\"]").focus(), _0x2b231c.content["find"]("a[name=\"addConversation\"]").on(UI["pointerEvent"]("click"), function (_0xf33c0e) {
        _0xf33c0e["preventDefault"](), _0x2b231c.content["find"]("input[name=\"findUsername\"]")["val"]() != "" && _0x2b231c["findUsername"](_0x2b231c.content.find("input[name=\"findUsername\"]")["val"]());
      }), _0x2b231c["content"]["find"]("input[name=\"findUsername\"]").on("keydown", function (_0x263c9a) {
        _0x263c9a["which"] == 13 && (_0x263c9a["preventDefault"](), _0x2b231c.content["find"]("input[name=\"findUsername\"]")["val"]() != "" && _0x2b231c["findUsername"](_0x2b231c["content"]["find"]("input[name=\"findUsername\"]")["val"]()));
      });
    }), $(this).on("dialogResizingEnded dialogMaximized dialogRestored", function (_0x29a828) {
      _0x2b231c["scroll"].scroll({
        y: "100%"
      }), _0x2b231c["emojiList"]["isVisible"]() && _0x2b231c.showAndResetEmojiSelector();
    }), this.content.on(UI.pointerEvent("click"), 'a[data-thumb-service="fmgallery"]', function (_0xb5f7ad) {
      _0xb5f7ad.preventDefault(), UI["galleryImageDialog"]["show"]($(this)["data"]("thumb-id"));
    }), this.content.on(UI["pointerEvent"]("click"), "a[data-thumb-service=\"fmgalleryuser\"]", function (_0x194c84) {
      _0x194c84["preventDefault"](), UI["userGalleryDialog"]["show"]({
        uid: $(this)["data"]("thumb-id")
      });
    });
  }
  ["showAndResetEmojiSelector"]() {
    var _0x109bcc = this["content"]["offset"](),
      _0x33886e = this.content["find"]("button[name=\"emoji\"]")["offset"]();
    this["emojiList"]["show"](), this["emojiList"]["move"](_0x33886e["left"] - _0x109bcc["left"], _0x33886e["top"] - _0x109bcc["top"] - this.emojiList["height"]());
  }
  ["findUsername"](_0x31a187) {
    var _0x785299 = {};
    _0x785299["command"] = "USERREQUEST", _0x785299["action"] = "Messenger", _0x785299.perform = "find", _0x785299.username = _0x31a187, socket["send"](_0x785299, true);
  }
  ["requestDeleteMessage"](_0x371108, _0x3e7300) {
    var _0x560ba8 = {};
    _0x560ba8.command = "USERREQUEST", _0x560ba8["action"] = "Messenger", _0x560ba8["perform"] = "delete", _0x560ba8["uid"] = _0x371108, _0x560ba8.id = _0x3e7300, socket.send(_0x560ba8, true);
  }
  ["messageReceived"](_0xf8d87e, _0x28b018) {
    this["content"].find(".offlineDelete a[name=\"" + _0x28b018 + '"]')["attr"]("name", _0xf8d87e);
  }
  ["deleteMessage"](_0x42ab6a, _0x15b90f) {
    if (_0x42ab6a == "OK") {
      var _0x65ea6d = this["content"]["find"]('.offlineDelete a[name="' + _0x15b90f + '"]')["parents"](".offlineMessage")["find"](".offlineBlock")["length"];
      _0x65ea6d == 1 ? this["content"].find(".offlineDelete a[name=\"" + _0x15b90f + '"]')["parents"](".offlineMessage")["remove"]() : this["content"]["find"](".offlineDelete a[name=\"" + _0x15b90f + '"]')["parents"](".offlineBlock")["remove"]();
    }
  }
  ["getUnread"](_0xfcae7) {
    return parseInt(this["content"]["find"](".messengerUser[data-uid=\"" + _0xfcae7 + "\"] .messengerBadges").data("unread"));
  }
  ["markAsUnread"](_0x3054f8, _0x3e02ca = 0) {
    this["content"]["find"](".messengerUser[data-uid=\"" + _0x3054f8 + "\"] .messengerBadges")["data"]("unread", _0x3e02ca), _0x3e02ca == 0 ? this["content"]["find"]('.messengerUser[data-uid="' + _0x3054f8 + "\"] .messengerBadges").empty() : this["content"]["find"](".messengerUser[data-uid=\"" + _0x3054f8 + "\"] .messengerBadges")["html"]("<span class=\"badge badge-pill badge-danger\" name=\"counter\">" + _0x3e02ca + "</span>");
  }
  ["markAsRead"](_0x1aa2ec) {
    this.markAsUnread(_0x1aa2ec, 0);
  }
  ["setUnreadMessages"](_0x8e7b6c) {
    $(this).triggerHandler(new unreadMessagesEvent(_0x8e7b6c)["getEvent"]());
  }
  ["conversationRemoved"](_0x4f7143, _0x164f5f) {
    _0x4f7143 == "OK" ? this["removeConversation"](_0x164f5f) : UI["dialogHandler"]["showAlert"](textManager["getString"]("client.codes.usernotfound"));
  }
  ["userFound"](_0x2c6451, _0x51f275) {
    _0x2c6451 == "OK" ? (this["disableModal"](), this["selectOrCreate"](_0x51f275.uid, _0x51f275["username"], _0x51f275["isglobal"])) : UI["dialogHandler"]["showAlert"](textManager["getString"]("client.codes.usernotfound"));
  }
  ["fontIncrease"]() {
    this["changeFontSize"](this["fontSize"] + 1);
  }
  ["fontDecrease"]() {
    this["changeFontSize"](this.fontSize - 1);
  }
  ["changeFontSize"](_0x860f81) {
    let _0x494199 = 10,
      _0x446867 = 20;
    this["fontSize"] = Math["min"](Math.max(_0x860f81, _0x494199), _0x446867), this["content"].find("#messengerConversation").css("font-size", this["fontSize"] + "px");
  }
  ["loadContent"](_0x1d841b) {
    this.content["html"](_0x1d841b);
  }
  ["loadHistory"](_0x3aa172, _0x1fe4cc, _0x585485, _0xffe0d, _0x3c6412) {
    var _0x356208 = null;
    UI["userPreferences"]["getGroupOption"]("graphics", "chatpreviews", false) && (_0x356208 = this.previews.containsImage(_0xffe0d));
    var _0x3faf6e = "";
    _0x356208 != null && (_0x3faf6e = '<div class="messengerThumb unloaded" name="' + _0x356208["service"] + ":" + _0x356208.value + "\"></div> ");
    var _0x2266c5 = this["generateMessage"](_0x1fe4cc, _0x3faf6e, _0xffe0d, _0x3c6412),
      _0x598fd0 = _0x3aa172 == room.myself["uid"];
    this["content"]["find"]("#messengerConversation .offlineMessage:first-child")["data"]("uid") == _0x3aa172 ? this["content"]["find"]("#messengerConversation .offlineMessage:first-child .offlineAuthor")["after"](_0x2266c5) : this.createMessage(_0x3aa172, _0x585485, _0x2266c5, false), _0x356208 != null && this["requestThumb"](_0x356208);
  }
  ["postMessage"](_0x17044c, _0x4f18f2, _0x13af49, _0x175c24, _0x548f5f) {
    var _0x3ab258 = null;
    UI["userPreferences"].getGroupOption("graphics", "chatpreviews", false) && (_0x3ab258 = this.previews["containsImage"](_0x175c24));
    var _0x19bbcd = "";
    _0x3ab258 != null && (_0x19bbcd = "<div class=\"messengerThumb unloaded\" name=\"" + _0x3ab258["service"] + ":" + _0x3ab258.value + "\"></div> ");
    var _0x4bd88b = this["generateMessage"](_0x4f18f2, _0x19bbcd, _0x175c24, _0x548f5f),
      _0x5687a8 = _0x17044c == room["myself"]["uid"];
    this["content"].find("#messengerConversation .offlineMessage:last-child")["data"]("uid") == _0x17044c ? this["content"]["find"]("#messengerConversation .offlineMessage:last-child").append(_0x4bd88b) : this["createMessage"](_0x17044c, _0x13af49, _0x4bd88b, true), _0x3ab258 != null && this["requestThumb"](_0x3ab258), this["moveConversationToTop"](this.selectedUserUID, _0x13af49);
  }
  ["requestRemoveConversation"](_0x30df4a) {
    this["loading"](true);
    var _0x1cc75c = {};
    _0x1cc75c.command = "USERREQUEST", _0x1cc75c["action"] = "Messenger", _0x1cc75c["perform"] = "remove", _0x1cc75c["uid"] = _0x30df4a, socket["send"](_0x1cc75c, true);
  }
  ["removeConversation"](_0x1f1fd5) {
    this["selectedUserUID"] == _0x1f1fd5 && this["content"]["find"]("#messengerConversation").empty(), this.content["find"](".messengerUser[data-uid=\"" + _0x1f1fd5 + '"]')["remove"](), this["empty"](true), this["loading"](false);
  }
  ["generateMessage"](_0x1af2c7, _0x235d21, _0x3b4228, _0xda36e5) {
    var _0x3b4228 = nl2br(parseURL(escapeHTML(_0x3b4228)));
    return _0x3b4228 = _0x3b4228.replace(/(\p{Emoji_Presentation}|\p{Extended_Pictographic})/gu, "<span class=\"chatEmoji\">$&</span>"), "<div class=\"offlineBlock\"><div class=\"offlineDelete\"><a name=\"" + _0x1af2c7 + "\" href=\"#\" class=\"btn btn-xs\"><i class=\"fas fa-times\"></i></a></div><div class=\"offlineMsg\">" + _0x235d21 + _0x3b4228 + "<div class=\"offlineTime\">" + formatHour(_0xda36e5) + "</div></div></div>";
  }
  ["createMessage"](_0x5701a3, _0x477b46, _0x485047, _0x3bba1b = true) {
    var _0x5478eb = _0x5701a3 == room["myself"]["uid"],
      _0x417d09 = "<div class=\"offlineMessage" + (_0x5478eb ? " offlineOwn" : "") + '" data-uid="' + _0x5701a3 + '"><div class="offlineAuthor">' + (_0x5478eb ? textManager["getString"]("messenger.lblYou") : _0x477b46) + "</div>" + _0x485047 + "</div>";
    _0x3bba1b ? this["content"]["find"]("#messengerConversation")["append"](_0x417d09) : this["content"]["find"]("#messengerConversation")["prepend"](_0x417d09);
  }
  ["createConversation"](_0x40e3b7, _0x1226e9, _0x75680c = false, _0x286e71 = false, _0x54fa71 = 0, _0x5f1879 = true) {
    var _0x178319 = $("<div class=\"messengerUser\" data-uid=\"" + _0x40e3b7 + "\"><span class=\"" + (_0x75680c ? "rankGM" : "") + '">' + _0x1226e9 + '</span><div class="messengerBadges"></div></div>');
    _0x178319["data"]("username", _0x1226e9), _0x178319["data"]("isglobal", _0x75680c), _0x286e71 && _0x178319["addClass"]("selected"), _0x5f1879 ? this["content"]["find"](".sidebarElements")["append"](_0x178319) : this["content"].find(".sidebarElements")["prepend"](_0x178319), this["markAsUnread"](_0x40e3b7, _0x54fa71);
  }
  ["requestThumb"](_0x538413) {
    var _0x14b461 = this;
    this["previews"]["getThumb"](_0x538413)["then"](function (_0x3fa78f) {
      _0x14b461.embedImage(_0x3fa78f);
    });
  }
  ["embedImage"](_0x2ccadc) {
    var _0x29817e = this,
      _0x4c1988 = this["content"]["find"]("div.messengerThumb.unloaded[name=\"" + _0x2ccadc["service"] + ":" + _0x2ccadc.id + '"]');
    if (_0x4c1988["length"] > 0) {
      _0x4c1988["removeClass"]("unloaded");
      var _0x129743 = new Image();
      _0x129743["onload"] = function () {
        var _0x2ced45 = _0x29817e["scroll"].scroll(),
          _0x232acf = parseInt(_0x2ced45.ratio.y * 100) >= 97 || _0x2ced45["max"].y === 0;
        _0x4c1988["append"]("<a data-thumb-service=\"" + _0x2ccadc["service"] + "\" data-thumb-id=\"" + _0x2ccadc.id + "\" href=\"" + _0x2ccadc["url"] + "\" target=\"_blank\"></a>")["find"]("a")["append"](this), _0x232acf && setTimeout(function (_0x4a9c93) {
          _0x29817e["scroll"]["scroll"]({
            y: "100%"
          });
        }, 250);
      }, _0x129743["src"] = _0x2ccadc.image;
    }
  }
  ["selectOrCreate"](_0x5e400f, _0x14734d, _0x38ed81 = false) {
    this.content["find"](".messengerUser[data-uid=\"" + _0x5e400f + '"]').length == 0 && this["createConversation"](_0x5e400f, _0x14734d, _0x38ed81, false, 0, false), this.select(_0x5e400f), this.scrollSidebarTo(_0x5e400f);
  }
  ["scrollSidebarTo"](_0x1911c4) {
    var _0x4732dc = this["content"]["find"](".messengerUser[data-uid=\"" + _0x1911c4 + '"]')["position"]();
    this["sidebarScroll"]["scroll"]({
      y: _0x4732dc.top + "px"
    });
  }
  ["select"](_0x71f239) {
    this.loading(true);
    this["selectedUserUID"] = _0x71f239;

    // Highlight the selected user
    this.content["find"](".messengerUser.selected")["removeClass"]("selected");
    this.content.find('.messengerUser[data-uid="' + _0x71f239 + '"]')["addClass"]("selected");

    // Update conversation title
    this["content"]["find"]("#conversationTitle .title").html(
        "<span class=\"" + 
        (this["content"]["find"](".messengerUser.selected")["data"]("isglobal") ? "rankGM" : "") + 
        '">' + this["content"].find(".messengerUser.selected")["data"]("username") + "</span>"
    );

    // Clear the conversation area
    this["content"]["find"]("#messengerConversation")["empty"]();
    this.empty(false);

    // Send socket request
    var _0x385e15 = {};
    _0x385e15["command"] = "USERREQUEST";
    _0x385e15.action = "Messenger";
    _0x385e15["perform"] = "read";
    _0x385e15.uid = _0x71f239;
    socket["send"](_0x385e15, true);

    // Focus on the input field
    this["content"]["find"]("input[name=\"text\"]")["focus"]();

    // console.log('User selected:', _0x71f239);

    // Attach context menu to messengerUser elements
    $["contextMenu"]({
        selector: '.messengerUser[data-uid="' + _0x71f239 + '"]', // Attach to the specific user
        trigger: "right", // Right-click trigger
        build: function (_0x47837d) {
            return {
                callback: function (_action, _opt) {
                    if (_action === "blockUser") {
                        const username = _0x47837d.data("username"); // Get username
                        if (username) {
                            // Add the user to the blockedUsers in localStorage
                            let blockedUsers = JSON.parse(localStorage.getItem("blockedUsers")) || [];
                            if (!blockedUsers.includes(username)) {
                              blockedUsers.push(username);
                                localStorage.setItem("blockedUsers", JSON.stringify(blockedUsers));
                            }
                        }
                    }
                },
                items: {
                    blockUser: {
                        name: "Block User",
                        icon: "fa-ban"
                    }
                }
            };
        }
    });
}


["conversationList"](_0x541339) {
  // Fetch blocked users
  let blockedUsers = [];
  try {
      blockedUsers = JSON.parse(localStorage.getItem("blockedUsers")) || [];
  } catch (e) {
      blockedUsers = [];
  }

  this["content"]["find"](".sidebarElements").empty();
  var _0x45eb51 = {};
  $["each"](_0x541339, function (_0x41a0bf, _0x1a2f95) {
    // Skip creating conversation if user is blocked
    if (blockedUsers.includes(_0x1a2f95["username"])) {
        return;
    }
    var _0x9a841c = _0x1a2f95["lastmessage"];
    while (_0x9a841c in _0x45eb51) {
      _0x9a841c++;
    }
    _0x45eb51[_0x9a841c] = _0x1a2f95;
  });
  var _0x35623e = this;
  $["each"](Object.keys(_0x45eb51)["reverse"](), function (_0x1ecc74, _0x1df285) {
    var _0x41de5a = _0x45eb51[_0x1df285];
    _0x35623e["createConversation"](
      _0x41de5a["uid"],
      _0x41de5a["username"],
      _0x41de5a["isglobal"],
      false,
      _0x41de5a["msgunread"],
      true
    );
  });
  this["loading"](false);
}
  ["messageList"](_0x30bb73, _0x1c96fd, _0x1f9401) {
    if (this["selectedUserUID"] == _0x30bb73) {
      this.content["find"]("#messengerConversation").empty();
      var _0xbe6d78 = this;
      $["each"](_0x1f9401, function (_0x3c489e, _0x2e8bdd) {
        _0xbe6d78["loadHistory"](_0x2e8bdd["from"], _0x2e8bdd.id, _0x1c96fd, _0x2e8bdd.message, _0x2e8bdd["date"]);
      }), this["scroll"]["scroll"]({
        y: "100%"
      });
    }
    this.markAsRead(_0x30bb73), this["loading"](false);
  }
  ["moveConversationToTop"](_0x5bd19d, _0x424eb7) {
    var _0x53d9c9 = parseInt(this.content.find(".messengerUser:first-child").data("uid"));
    if (_0x53d9c9 != _0x5bd19d) {
      var _0x4fc25c = this["content"]["find"](".messengerUser[data-uid=\"" + _0x5bd19d + '"]');
      _0x4fc25c["length"] > 0 ? this.content.find(".sidebarElements")["prepend"](_0x4fc25c) : this["createConversation"](_0x5bd19d, _0x424eb7, false, false, 0, false);
    }
    this["scrollSidebarTo"](_0x5bd19d);
  }
["newMessage"](_0x463ba0) {
  // Fetch the blockedUsers from localStorage with error handling
  let blockedUsers = [];
  try {
      blockedUsers = JSON.parse(localStorage.getItem("blockedUsers")) || [];
  } catch (e) {
      blockedUsers = [];
  }

  // Check if the sender is in the blockedUsers
  var isBlocked = blockedUsers.includes(_0x463ba0["fromUsername"]);
  var _0x30f2e9 = true;

  // If the sender is not blocked, move the conversation to the top
  if (!isBlocked) {
      this.moveConversationToTop(_0x463ba0.from, _0x463ba0["fromUsername"]);
  }

  if (this["active"]) {
      if (this.selectedUserUID == _0x463ba0["from"]) {
          // Handle active conversation
          _0x30f2e9 = false;
          var _0x155b47 = this["scroll"]["scroll"](),
              _0xf7bb57 = parseInt(_0x155b47.ratio.y * 100) >= 97 || _0x155b47["max"].y === 0;
          
          // Only show message if user is not blocked
          if (!isBlocked) {
              this["postMessage"](_0x463ba0["from"], _0x463ba0.id, _0x463ba0.fromUsername, _0x463ba0["message"], _0x463ba0["date"]);
          }
          
          this["markMessageAsRead"](this.selectedUserUID, _0x463ba0.id);

          if (_0xf7bb57 && !isBlocked) {
              var _0x2b4ef7 = this;
              setTimeout(function (_0x368cd4) {
                  _0x2b4ef7["scroll"]["scroll"]({
                      y: "100%"
                  });
              }, 250);
          }
      } else if (!isBlocked) {
          // Update unread badge count for non-blocked users
          var _0x1ccac9 = this.getUnread(_0x463ba0["from"]);
          this.markAsUnread(_0x463ba0["from"], _0x1ccac9 + 1);
      }
  }

  // Mark messages from blocked users as read
  if (isBlocked) {
      this["markMessageAsRead"](_0x463ba0["from"], _0x463ba0.id);
  }

  // Play notification sound only if the user is not blocked
  if (_0x30f2e9 && !isBlocked) {
      UI["playSound"]("chat");
  }
}


  ["markMessageAsRead"](_0x36103e, _0xc44c1d) {
    var _0x1f7575 = {};
    _0x1f7575.command = "USERREQUEST", _0x1f7575["action"] = "Messenger", _0x1f7575["perform"] = "markmsg", _0x1f7575["uid"] = _0x36103e, _0x1f7575.id = _0xc44c1d, socket["send"](_0x1f7575, true);
  }
  ["sendMessage"]() {
    var _0x3cbe6a = this["content"].find("input[name=\"text\"]")["val"]()["slice"](0, 250);
    if (_0x3cbe6a != "") {
      var _0x24f296 = Math.floor(Math.random() * 999999 + 1) * -1,
        _0xe3b823 = this["selectedUserUID"];
      this["postMessage"](room["myself"]["uid"], _0x24f296, _0xe3b823, _0x3cbe6a, parseInt(Date.now() / 1e3));
      var _0x114949 = {};
      _0x114949.command = "USERREQUEST", _0x114949["action"] = "Messenger", _0x114949["perform"] = "insert", _0x114949.to = _0xe3b823, _0x114949.tempid = _0x24f296, _0x114949["message"] = _0x3cbe6a, socket["send"](_0x114949, true), this.markAsRead(_0xe3b823), this.content["find"]("input[name=\"text\"]")["val"]("");
    }
    this["scroll"]["scroll"]({
      y: "100%"
    });
  }
  ["empty"](_0x5047f2) {
    _0x5047f2 ? (this["selectedUserUID"] = null, this["content"]["find"]("#messengerConversation")["html"]("<h4>" + new Icon("fa-comments")["html"]() + " " + textManager["getString"]("messenger.lblFMMessenger") + "</h4><p>" + textManager["getString"]("messenger.lblNoMessages") + "</p>"), this["content"]["find"]("#conversationTitle")["css"]("visibility", "hidden"), this["lockMessageBar"]()) : (this["content"]["find"]("#conversationTitle").css("visibility", "visible"), this["unlockMessageBar"]());
  }
  ["lockMessageBar"]() {
    this["content"]["find"]("input[name=\"text\"]")["attr"]("disabled", "disabled"), this["content"].find("button[name=\"submit\"]")["attr"]("disabled", "disabled"), this["content"]["find"]("button[name=\"emoji\"]")["attr"]("disabled", "disabled"), this["content"]["find"]("input[name=\"text\"]")["addClass"]("disabled"), this.content["find"]("button[name=\"submit\"]")["addClass"]("disabled"), this.content.find('button[name="emoji"]')["addClass"]("disabled");
  }
  ["unlockMessageBar"]() {
    this["content"].find('input[name="text"]').removeAttr("disabled"), this["content"]["find"]("button[name=\"submit\"]")["removeAttr"]("disabled"), this["content"]["find"]("button[name=\"emoji\"]")["removeAttr"]("disabled"), this["content"]["find"]("input[name=\"text\"]")["removeClass"]("disabled"), this["content"]["find"]("button[name=\"submit\"]").removeClass("disabled"), this["content"]["find"]('button[name="emoji"]').removeClass("disabled");
  }
  ["onShow"]() {
    this["loading"](true), this["changed"](), this.content["find"]("#messengerConversation")["empty"](), this["empty"](true);
    var _0x79c104 = {};
    _0x79c104["command"] = "USERREQUEST", _0x79c104["action"] = "Messenger", _0x79c104.perform = "list", socket.send(_0x79c104, true);
  }
  ["onHide"]() {
    this["setUnreadMessages"](0), this.selectedUserUID = null, this.content["find"](".sidebarElements").empty(), this["content"]["find"]("#messengerConversation").empty();
    var _0x17d323 = {};
    _0x17d323.command = "USERREQUEST", _0x17d323.action = "Messenger", _0x17d323["perform"] = "unread", socket["send"](_0x17d323, true);
  }
  ["disableModal"]() {
    this.emojiList.hide(), this["modal"]["hide"](), this.content["remove"](this.modal), $(this)["triggerHandler"](new dialogModalDisabledEvent()["getEvent"]());
  }
  ["hasModal"]() {
    return this.modal.is(":visible") || this["emojiList"].isVisible();
  }
}
class GalleryImageDialog extends Dialog {
  constructor(_0x4270d2) {
    super(_0x4270d2), this.icon = "fa-image", this["caption"] = textManager["getString"]("galleryimage.title"), this["imageId"], this.width = 850, this.imgWidth, this.imgHeight, this["loadContent"](this["loadFile"]("forms/galleryimage.main.html")), this.content["find"](".commentArea").empty(), this.scroll = this["content"]["find"](".commentSection")["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    })["overlayScrollbars"](), this["scroll"]["addExt"]("fmExtension");
    var _0x5a0fb0 = this;
    this["content"]["find"]("button[name=\"visitImage\"]").on(UI["pointerEvent"]("click"), function (_0x2ab947) {
      _0x2ab947["preventDefault"]();
      var _0x53a3c5 = _0x5a0fb0["content"]["find"]("input[name=\"url\"]")["val"]();
      _0x53a3c5 != "" && window["open"](_0x53a3c5, "_blank");
    }), this["content"].find(".btn[name=\"download\"]").on(UI.pointerEvent("click"), function (_0x101ca4) {
      _0x101ca4["preventDefault"](), _0x5a0fb0.saveToDisk();
    }), this["content"]["find"]("button[name=\"submitComment\"]").on(UI.pointerEvent("click"), function (_0x76e1e5) {
      _0x76e1e5["preventDefault"](), _0x5a0fb0["postComment"]();
    }), this.content["find"]("input[name=\"commentText\"]").on("keydown", function (_0x5eceab) {
      _0x5eceab["which"] == 13 && (_0x5eceab.preventDefault(), _0x5a0fb0["postComment"]());
    }), this["content"].find('.btn[name="voteup"]').on(UI["pointerEvent"]("click"), function (_0x57945a) {
      _0x5a0fb0["disableButtons"]();
      var _0x111ffa = "like";
      $(this)["hasClass"]("coloredButton") && (_0x111ffa = "unvote");
      var _0x2885fe = {};
      _0x2885fe["command"] = "GALLERYREQUEST", _0x2885fe["action"] = "Image", _0x2885fe.perform = _0x111ffa, _0x2885fe["image"] = _0x5a0fb0.imageId, socket["send"](_0x2885fe, true), _0x5a0fb0["content"]["find"]("span[name=\"score\"]")["html"](new Icon("fa-spinner", "fas", "fa-pulse")["html"]());
    }), this["content"]["find"](".btn[name=\"votedown\"]").on(UI.pointerEvent("click"), function (_0x55913b) {
      _0x5a0fb0["disableButtons"]();
      var _0x266282 = "dislike";
      $(this).hasClass("coloredButton") && (_0x266282 = "unvote");
      var _0x4b6a1d = {};
      _0x4b6a1d.command = "GALLERYREQUEST", _0x4b6a1d["action"] = "Image", _0x4b6a1d["perform"] = _0x266282, _0x4b6a1d["image"] = _0x5a0fb0["imageId"], socket["send"](_0x4b6a1d, true), _0x5a0fb0.content["find"]("span[name=\"score\"]")["html"](new Icon("fa-spinner", "fas", "fa-pulse")["html"]());
    }), this.content["find"](".btn[name=\"favorite\"]").on(UI.pointerEvent("click"), function (_0x47e2d5) {
      _0x5a0fb0["disableButtons"]();
      var _0x1bbe37 = "favorite";
      $(this)["hasClass"]("coloredButton") && (_0x1bbe37 = "unfavorite");
      var _0x3b5e9e = {};
      _0x3b5e9e.command = "GALLERYREQUEST", _0x3b5e9e["action"] = "Image", _0x3b5e9e["perform"] = _0x1bbe37, _0x3b5e9e.image = _0x5a0fb0["imageId"], socket.send(_0x3b5e9e, true);
    }), this.content.on(UI["pointerEvent"]("click"), ".offlineDelete a", function (_0x595807) {
      _0x595807["preventDefault"]();
      var _0x2e60f8 = $(this)["attr"]("name"),
        _0x215984 = UI["dialogHandler"]["createConfirmation"](textManager["getString"]("galleryimage.lblDeleteComment"));
      _0x215984.on("confirmationClosed", function (_0x4ce866) {
        _0x4ce866["response"] == "ok" && _0x5a0fb0["requestDeleteComment"](_0x2e60f8), UI["dialogHandler"]["destroyConfirmation"]();
      });
    });
  }
  ["requestDeleteComment"](_0x35e1a5) {
    var _0x50e664 = {};
    _0x50e664["command"] = "GALLERYREQUEST", _0x50e664["action"] = "Comment", _0x50e664["perform"] = "delete", _0x50e664.id = _0x35e1a5, _0x50e664["image"] = this["imageId"], socket["send"](_0x50e664, true);
  }
  ["postComment"]() {
    var _0x45495d = nl2br(parseURL(escapeHTML(this["content"]["find"]('input[name="commentText"]')["val"]()))),
      _0x1ed3d6 = Math.floor(Math.random() * 999999 + 1) * -1,
      _0xfafcc2 = {};
    _0xfafcc2["command"] = "GALLERYREQUEST", _0xfafcc2["action"] = "Comment", _0xfafcc2["perform"] = "add", _0xfafcc2["tempId"] = _0x1ed3d6, _0xfafcc2["image"] = this.imageId, _0xfafcc2.message = _0x45495d, socket["send"](_0xfafcc2, true), this["addComment"]({
      owner_id: room.myself["uid"],
      author: room["myself"].username,
      id: _0x1ed3d6,
      message: _0x45495d,
      posted: parseInt(Date["now"]() / 1e3),
      isGlobal: room.myself.rank == "GM"
    }), this["content"]["find"]("input[name=\"commentText\"]")["val"](""), this.scroll["scroll"]({
      y: "100%"
    });
  }
  ["loadContent"](_0x165779) {
    this["content"]["html"](_0x165779);
  }
  ["onResize"]() {
    var _0x43ae52 = this["content"].find("#saveBox")["width"](),
      _0x34da8f = this.content["find"]("#savePreview")["width"](),
      _0x34988f = this["content"]["find"]("#savePreview")["height"](),
      _0x4e4776 = this["content"].find("#previewDiv").width(),
      _0x307f5a = this["content"].find("#previewDiv")["height"](),
      _0xc7600d = calculateAspectRatioFit(this["imgWidth"], this.imgHeight, _0x4e4776, _0x307f5a),
      _0x406cf2 = _0xc7600d["width"] / this.imgWidth;
    this["content"]["find"]("#savePreview")["css"]("transform", "scale(" + _0x406cf2 + ")"), this["content"]["find"]("#saveBox").css({
      width: _0xc7600d["width"],
      height: _0xc7600d["height"]
    });
  }
  ["addComment"](_0x53a15c) {
    var _0x118242 = "<div class=\"offlineMessage\" data-uid=\"" + _0x53a15c["owner_id"] + "\"><div class=\"offlineAuthor " + (_0x53a15c["isGlobal"] ? "rankGM" : "") + '">' + _0x53a15c["author"] + '</div>\n							<div class="offlineBlock">\n								<div class="offlineDelete">\n									<a name="' + _0x53a15c.id + "\" href=\"#\" class=\"btn btn-xs\">" + new Icon("fa-times")["html"]() + "</a>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"offlineMsg\">" + _0x53a15c["message"] + '<div class="offlineTime">' + formatHour(_0x53a15c["posted"]) + "</div></div>\n\t\t\t\t\t\t\t</div></div>";
    this["content"].find(".commentArea")["append"](_0x118242);
  }
  ["onShow"](_0x430a99) {
    this["imageId"] = _0x430a99, this["loading"](true), this["setupInterface"](room.myself["isLogged"]()), this.content["find"]("input[name=\"commentText\"]").val(""), this["content"]["find"]("#saveBox").css("visibility", "hidden"), this["content"].find(".commentArea")["empty"](), this["changed"]();
    var _0x20ac40 = {};
    _0x20ac40["command"] = "GALLERYREQUEST", _0x20ac40["action"] = "Image", _0x20ac40["perform"] = "get", _0x20ac40.id = _0x430a99, socket.send(_0x20ac40, true);
  }
  ["onHide"]() {
    this.content["find"]("#savePreview img")["remove"]();
  }
  ["saveToDisk"]() {
    this["loading"](true), window.open(this["getDataURL"](), "_blank"), this["loading"](false);
  }
  ["getDataURL"]() {
    return this["content"]["find"]("#savePreview img")["attr"]("src");
  }
  ["deletedComment"](_0x33bec5, _0x4af236) {
    if (_0x33bec5 == "OK") {
      var _0x4c3129 = this["content"]["find"](".offlineDelete a[name=\"" + _0x4af236 + '"]').parents(".offlineMessage")["find"](".offlineBlock")["length"];
      _0x4c3129 == 1 ? this["content"]["find"](".offlineDelete a[name=\"" + _0x4af236 + '"]').parents(".offlineMessage").remove() : this.content["find"]('.offlineDelete a[name="' + _0x4af236 + '"]')["parents"](".offlineBlock").remove();
    }
  }
  ["addedComment"](_0x4b6595, _0x503017) {
    this["content"]["find"]('.offlineDelete a[name="' + _0x503017 + '"]').attr("name", _0x4b6595);
  }
  ["gotUpdated"](_0x563756) {
    this["enableButtons"](), this.imageId == _0x563756["image"].id && (this["content"]["find"]("span[name=\"score\"]")["text"](_0x563756["image"]["score"]), _0x563756["image"]["stats"].youfaved ? this["content"].find("a[name=\"favorite\"]")["addClass"]("coloredButton") : this["content"].find('a[name="favorite"]').removeClass("coloredButton"), _0x563756["image"]["stats"].youliked ? this["content"]["find"]("a[name=\"voteup\"]")["addClass"]("coloredButton") : this["content"]["find"]("a[name=\"voteup\"]")["removeClass"]("coloredButton"), _0x563756.image["stats"]["youdisliked"] ? this["content"].find("a[name=\"votedown\"]")["addClass"]("coloredButton") : this["content"]["find"]("a[name=\"votedown\"]")["removeClass"]("coloredButton"));
  }
  ["enableButtons"]() {
    this.content.find("a[name=\"favorite\"]").removeClass("disabled"), this["content"].find("a[name=\"voteup\"]").removeClass("disabled"), this["content"].find("a[name=\"votedown\"]")["removeClass"]("disabled"), this["content"]["find"]("a[name=\"submitComment\"]")["removeClass"]("disabled");
  }
  ["disableButtons"]() {
    this.content.find("a[name=\"favorite\"]")["addClass"]("disabled"), this["content"]["find"]("a[name=\"voteup\"]")["addClass"]("disabled"), this["content"].find("a[name=\"votedown\"]")["addClass"]("disabled"), this.content.find('a[name="submitComment"]')["addClass"]("disabled");
  }
  ["setupInterface"](_0x5bb7d1) {
    _0x5bb7d1 ? (this["content"]["find"]("a[name=\"favorite\"]")["show"](), this.content["find"]('a[name="voteup"]')["show"](), this["content"]["find"]('a[name="votedown"]')["show"](), this["content"].find("#commentBar")["show"]()) : (this["content"].find('a[name="favorite"]')["hide"](), this.content["find"]('a[name="voteup"]').hide(), this["content"].find('a[name="votedown"]').hide(), this["content"]["find"]("#commentBar")["hide"]()), this["content"]["find"](".offlineMessage")["each"](function (_0x53e13a, _0x24f062) {
      _0x24f062 = $(_0x24f062), !(room["myself"]["isLogged"]() && _0x24f062["data"]("uid") == room["myself"]["uid"] || room["myself"]["rank"] == "GM") && _0x24f062.find(".offlineDelete").remove();
    });
  }
  ["gotResponse"](_0x50de89) {
    var _0x2a8532 = this,
      _0x56f9f1 = new Image();
    _0x56f9f1["onload"] = function () {
      _0x2a8532["imgWidth"] = this.width, _0x2a8532["imgHeight"] = this.height, _0x2a8532["content"].find("#saveBox")["css"]("visibility", "visible"), _0x2a8532["loading"](false), _0x2a8532["changed"]();
    }, _0x56f9f1["src"] = _0x50de89["image"].url, this["content"]["find"]('input[name="url"]')["val"]("https://flockmod.com/gallery/index.php?q=/post/view/" + _0x50de89["image"].id), this["content"].find(".imageTags")["empty"](), $["each"](_0x50de89.image["tags"], function (_0x393b13, _0x37f316) {
      _0x2a8532["content"]["find"](".imageTags")["append"]("<span class=\"badge badge-default\">#" + _0x37f316 + "</span>");
    }), $.each(_0x50de89["image"]["comments"], function (_0x37cf6f, _0x20542f) {
      var _0x3288f2 = _0x20542f["message"]["replace"](/\[\/?(?:b|i|u|url|quote|code|img|color|size)*?.*?\]/gim, "");
      _0x3288f2 = nl2br(parseURL(escapeHTML(_0x3288f2))), _0x20542f["message"] = _0x3288f2, _0x2a8532.addComment(_0x20542f);
    }), this["content"]["find"]("#imageOwner").html(textManager.getString("galleryimage.lblOwner", _0x50de89["owner"]["username"], false) + "<br />" + formatHour(_0x50de89["image"]["posted"])), this.content["find"]("#savePreview")["html"](_0x56f9f1), this["setupInterface"](room.myself.isLogged()), this["gotUpdated"](_0x50de89);
  }
}
class AdminConsoleDialog extends Dialog {
  constructor(_0x41bc28) {
    super(_0x41bc28), this["icon"] = "fa-toolbox", this["caption"] = "Admin Console", this["banLengths"] = {}, this["banLengths"][0] = "Permanent", this["banLengths"][86400] = "1 day", this["banLengths"][259200] = "3 days", this["banLengths"][604800] = "1 week", this["banLengths"][1209600] = "2 weeks", this["banLengths"][2592e3] = "1 month", this["banLengths"][7776e3] = "3 months", this["banLengths"][15552e3] = "6 months", this["banLengths"][23328e3] = "9 months", this["banLengths"][31536e3] = "1 year", this["banLengths"][63072e3] = "2 years", this["banLengths"][94608e3] = "3 years", this["currentSubDialog"] = null, this.loadContent(this.loadFile("forms/adminconsole.main.html")), $(this["content"].find(".sidebar"))["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    }), this["summarySubDialog"] = new AdminConsoleSummarySubDialog(this), this["systemSubDialog"] = new AdminConsoleSystemSubDialog(this), this["clientsSubDialog"] = new AdminConsoleClientsSubDialog(this), this["roomsSubDialog"] = new AdminConsoleRoomsSubDialog(this), this.usersSubDialog = new AdminConsoleUsersSubDialog(this), this["bansSubDialog"] = new AdminConsoleBansSubDialog(this), this.eventsSubDialog = new AdminConsoleEventsSubDialog(this), this.feedbackSubDialog = new AdminConsoleFeedbackSubDialog(this);
    var _0x9b2e5b = this;
    this.content.on(UI["pointerEvent"]("click"), ".subcontentOption", function (_0x1ecbad) {
      _0x1ecbad["preventDefault"]();
      var _0xd899cc = $(this)["data"]("subcontent");
      _0x9b2e5b["loadPage"](_0xd899cc);
    });
  }
  ["loadContent"](_0x4dad13) {
    this["content"]["html"](_0x4dad13);
  }
  ["loadSubcontent"](_0x112c00) {
    this.content.find(".dynamicDialogArea")["html"](_0x112c00);
  }
  ["clearSubcontent"]() {
    this.content["find"](".dynamicDialogArea").empty();
  }
  ["loadSubDialog"](_0x9eae02) {
    var _0x87a151 = this["content"]["find"](".dynamicDialogArea");
    _0x87a151["empty"](), _0x87a151["hide"]();
    this["currentSubDialog"] && this["currentSubDialog"]["unload"]();
    if (_0x9eae02 == "summary") this["summarySubDialog"]["load"](), _0x87a151["append"](this["summarySubDialog"]["subContent"]), this["currentSubDialog"] = this["summarySubDialog"]; else {
      if (_0x9eae02 == "system") this["systemSubDialog"]["load"](), _0x87a151["append"](this["systemSubDialog"]["subContent"]), this["currentSubDialog"] = this.systemSubDialog; else {
        if (_0x9eae02 == "clients") this["clientsSubDialog"].load(), _0x87a151["append"](this["clientsSubDialog"].subContent), this["currentSubDialog"] = this["clientsSubDialog"]; else {
          if (_0x9eae02 == "rooms") this["roomsSubDialog"]["load"](), _0x87a151["append"](this["roomsSubDialog"].subContent), this["currentSubDialog"] = this.roomsSubDialog; else {
            if (_0x9eae02 == "users") this.usersSubDialog["load"](), _0x87a151["append"](this["usersSubDialog"]["subContent"]), this.currentSubDialog = this["usersSubDialog"]; else {
              if (_0x9eae02 == "bans") this.bansSubDialog["load"](), _0x87a151["append"](this["bansSubDialog"]["subContent"]), this["currentSubDialog"] = this["bansSubDialog"]; else {
                if (_0x9eae02 == "events") this["eventsSubDialog"]["load"](), _0x87a151.append(this["eventsSubDialog"].subContent), this["currentSubDialog"] = this.eventsSubDialog; else _0x9eae02 == "feedback" && (this["feedbackSubDialog"].load(), _0x87a151.append(this["feedbackSubDialog"]["subContent"]), this.currentSubDialog = this.feedbackSubDialog);
              }
            }
          }
        }
      }
    }
    _0x87a151["fadeIn"](500), this.changed();
  }
  ["loadPage"](_0x41588d) {
    var _0x1cbc92 = this;
    _0x41588d !== undefined && (this["content"]["find"](".subcontentOption.selected")["removeClass"]("selected"), this["content"]["find"](".subcontentOption[data-subcontent=" + _0x41588d + "]")["addClass"]("selected"), this["loadSubDialog"](_0x41588d), this["processSizeType"](this["sizeType"]));
  }
  ["unloadPage"]() {
    this["currentSubDialog"] && this["currentSubDialog"].unload();
  }
  ["summary"](_0x232ad5) {
    this["summarySubDialog"].data(_0x232ad5);
  }
  ["serverInfo"](_0x39bfb4) {
    this["systemSubDialog"]["data"](_0x39bfb4);
  }
  ["serverStats"](_0xc1a955, _0x4276b9) {
    this["systemSubDialog"]["intervalData"](_0xc1a955, _0x4276b9);
  }
  ["roomList"](_0x3d0017) {
    this["roomsSubDialog"]["data"](_0x3d0017);
  }
  ["feedbackList"](_0x132f0c) {
    this["feedbackSubDialog"]["data"](_0x132f0c);
  }
  ["clientList"](_0x1ac4d5) {
    this.clientsSubDialog["data"](_0x1ac4d5);
  }
  ["banList"](_0x4845d0) {
    this["bansSubDialog"]["data"](_0x4845d0);
  }
  ["eventList"](_0x28ff8b) {
    this["eventsSubDialog"]["data"](_0x28ff8b);
  }
  ["accountInfo"](_0x2bac1d, _0x54d6ce) {
    this["usersSubDialog"]["data"](_0x2bac1d, _0x54d6ce);
  }
  ["gotResponse"](_0x57bd93) {
    if (_0x57bd93["action"] == "AdminBans") this["bansSubDialog"]["gotResponse"](_0x57bd93); else {
      if (_0x57bd93.action == "AdminEvents") this["eventsSubDialog"]["gotResponse"](_0x57bd93); else {
        if (_0x57bd93.action == "AdminAccounts") this["usersSubDialog"]["gotResponse"](_0x57bd93); else _0x57bd93["action"] == "AdminClients" && this["clientsSubDialog"]["gotResponse"](_0x57bd93);
      }
    }
  }
  ["onShow"]() {
    room["myself"]["rank"] != "GM" ? this["content"]["remove"]() : this["loadPage"]("summary");
  }
  ["onHide"]() {
    this["clearSubcontent"](), this.unloadPage();
  }
}
class AdminConsoleRoomsSubDialog extends SubDialog {
  constructor(_0x5e57e3, _0x5684e6) {
    super(_0x5e57e3, _0x5684e6), this.table;
  }
  ["load"]() {
    this["dialog"]["loading"](true), this["subContent"]["html"](this["dialog"].loadFile("forms/adminconsole.rooms.html")), this["table"] = new Table(this.subContent.find("#adminRoomsTable"), null, "roomsTable", "fmTable"), this["table"]["setFilterable"](true), this.table["setTitle"]("Active Rooms"), this["table"]["setHeader"](["Room", "Visibility", '<i class="fas fa-users"></i>']);
    var _0x172fb1 = this;
    $(this.dialog).on("dialogResizingEnded dialogMaximized dialogRestored", function (_0x4d8794) {
      _0x172fb1["table"] && _0x172fb1["table"]["updated"]();
    });
    var _0x2df85c = {};
    _0x2df85c["command"] = "ADMINREQUEST", _0x2df85c.action = "RoomList", socket["send"](_0x2df85c, true);
  }
  ["unload"]() {
    this["dialog"]["modal"].off(".adminSubdialog"), this["table"]["reset"]();
  }
  ["data"](_0x2cbc0f) {
    this["table"].clear();
    var _0x38a19f = this;
    $["each"](_0x2cbc0f, function (_0x2a6996, _0x5688e) {
      var _0xe11ab3 = '<span data-tooltip="<strong>Type:</strong> ' + _0x5688e["type"] + "<br /><strong>Background:</strong> " + _0x5688e["background"] + "<br /><strong>Size:</strong> " + _0x5688e.size + "<br /><strong>Password:</strong> " + (_0x5688e["password"] ? "Yes" : "No") + '">' + _0x5688e.name + "</span>";
      _0x38a19f["table"]["addRow"]([_0xe11ab3, _0x5688e["hidden"] ? "Private" : "Public", _0x5688e["usercount"]], false);
    }), this.dialog["changed"](), this["table"]["updated"](), this["table"]["sort"](3, false), this["dialog"]["loading"](false);
  }
}
class AdminConsoleUsersSubDialog extends SubDialog {
  constructor(_0x45ef3e, _0x5d2106) {
    super(_0x45ef3e, _0x5d2106), this.table, this.tableRooms;
  }
  ["load"]() {
    this["dialog"]["loading"](true), this.subContent.html(this.dialog["loadFile"]("forms/adminconsole.users.html")), this["subContent"].find('a[name="changePass"]')["addClass"]("disabled"), this["subContent"].find("a[name=\"toggleEnable\"]").addClass("disabled"), this["table"] = new Table(this["subContent"]["find"]("#adminAccountsTable"), null, "accountsTable", "fmTable"), this["table"]["setFilterable"](false), this["table"]["setHeader"](["Parameter", "Value"]), this.tableRooms = new Table(this["subContent"]["find"]("#adminAccountsRoomsTable"), null, "accountsRoomsTable", "fmTable"), this["tableRooms"]["setFilterable"](false), this["tableRooms"].setHeader(["Room"]);
    var _0x16f008 = this;
    $(this["dialog"]).on("dialogResizingEnded dialogMaximized dialogRestored", function (_0x10cb25) {
      _0x16f008["table"] && _0x16f008.table["updated"](), _0x16f008.tableRooms && _0x16f008.tableRooms["updated"]();
    }), this.subContent["find"]("#searchButton").on(UI["pointerEvent"]("click"), function (_0x510b9c) {
      _0x510b9c.preventDefault(), _0x16f008["searchAccount"](_0x16f008["subContent"]["find"]("input[name=\"search\"]")["val"]());
    }), this.subContent.find("input[name=\"search\"]").on("keydown", function (_0x56a29e) {
      _0x56a29e["which"] == 13 && (_0x56a29e["preventDefault"](), _0x16f008.searchAccount(_0x16f008.subContent["find"]("input[name=\"search\"]")["val"]()));
    }), this["subContent"]["find"]("a[name=\"toggleEnable\"]").on(UI["pointerEvent"]("click", "adminSubdialog"), function (_0x5190d1) {
      _0x5190d1["preventDefault"](), _0x16f008["dialog"]["loading"](true);
      var _0x1b328a = {};
      _0x1b328a["command"] = "ADMINREQUEST", _0x1b328a["action"] = "AdminAccounts", _0x1b328a["option"] = "ToggleEnable", _0x1b328a["username"] = _0x16f008["subContent"]["find"]("input[name=\"search\"]")["val"](), socket["send"](_0x1b328a, true);
    }), this["subContent"].find("a[name=\"changePass\"]").on(UI["pointerEvent"]("click", "adminSubdialog"), function (_0x470a09) {
      _0x470a09["preventDefault"](), _0x16f008["dialog"]["enableModal"](_0x16f008["dialog"]["loadFile"]("forms/adminconsole.modal.changepassword.html")), _0x16f008["dialog"].modal["find"]("input[name=\"newpassword\"]")["focus"]();
    }), this.dialog["modal"].on(UI["pointerEvent"]("click", "adminSubdialog"), "a[name=\"applyChange\"]", function (_0x3597ac) {
      _0x3597ac["preventDefault"](), _0x16f008["dialog"]["loading"](true);
      var _0x14add1 = {};
      _0x14add1["command"] = "ADMINREQUEST", _0x14add1["action"] = "AdminAccounts", _0x14add1.option = "ChangePass", _0x14add1["username"] = _0x16f008.subContent["find"]("input[name=\"search\"]")["val"](), _0x14add1["password"] = _0x16f008["dialog"].modal["find"]("input[name=\"newpassword\"]")["val"](), socket["send"](_0x14add1, true);
    }), this["dialog"].loading(false);
  }
  ["searchAccount"](_0x556ae1) {
    this["dialog"].loading(true);
    var _0x3f71f3 = {};
    _0x3f71f3["command"] = "ADMINREQUEST", _0x3f71f3.action = "AccountInfo", _0x3f71f3["username"] = _0x556ae1, socket["send"](_0x3f71f3, true);
  }
  ["unload"]() {
    this["dialog"].modal["off"](".adminSubdialog"), this["table"]["reset"]();
  }
  ["data"](_0x54f221, _0x4e82ac) {
    this["table"]["clear"](), this["tableRooms"]["clear"]();
    var _0x18777 = this;
    $["each"](_0x54f221, function (_0x4e117d, _0x354b84) {
      _0x18777.table["addRow"]([_0x4e117d, _0x354b84], false);
    }), $["each"](_0x4e82ac, function (_0x54b464, _0x2b2a5c) {
      _0x18777["tableRooms"]["addRow"]([_0x2b2a5c], false);
    }), this["dialog"]["changed"](), this.table["updated"](), this.tableRooms["updated"](), this["subContent"].find("a[name=\"changePass\"]").removeClass("disabled"), this.subContent["find"]("a[name=\"toggleEnable\"]")["removeClass"]("disabled"), this["dialog"]["loading"](false);
  }
  ["gotResponse"](_0x72da85) {
    if (_0x72da85["option"] == "ToggleEnable") _0x72da85["code"] == "OK" ? this["searchAccount"](_0x72da85.username) : (UI["dialogHandler"]["showAlert"]("Error: " + _0x72da85.code), this["dialog"]["loading"](false)); else _0x72da85["option"] == "ChangePass" && (_0x72da85["code"] == "OK" ? (UI.dialogHandler["showAlert"]("Password changed successfully"), this.dialog["disableModal"]()) : UI.dialogHandler["showAlert"]("Error: " + _0x72da85["code"]), this.dialog["loading"](false));
  }
}
class AdminConsoleClientsSubDialog extends SubDialog {
  constructor(_0x3390b3, _0x30820c) {
    super(_0x3390b3, _0x30820c), this["table"];
  }
  ["load"]() {
    this["dialog"]["loading"](true), this["subContent"]["html"](this.dialog["loadFile"]("forms/adminconsole.clients.html")), this["subContent"]["find"]("a[name=\"disconnectAddress\"]")["addClass"]("disabled"), this["subContent"]["find"]('a[name="closeConnection"]')["addClass"]("disabled"), this["subContent"].find("a[name=\"moveClient\"]").addClass("disabled"), this["table"] = new Table(this["subContent"].find("#adminClientsTable"), null, "clientsTable", "fmTable"), this["table"].setFilterable(true), this["table"]["setTitle"]("Active Clients"), this["table"]["setHeader"](["uniqueID", "uid", "Username", "Address", "User", "IP", "Room", "Client", "Connected since"]), this["table"]["hideColumns"]([1, 2, 3, 4]);
    var _0x5e40a2 = this;
    $(this["dialog"]).on("dialogResizingEnded dialogMaximized dialogRestored", function (_0x259e19) {
      _0x5e40a2["table"] && _0x5e40a2.table["updated"]();
    }), this["subContent"].on(UI["pointerEvent"]("click", "adminSubdialog"), "a[name=\"moveClient\"]", function (_0x2938bb) {
      _0x2938bb["preventDefault"](), _0x5e40a2["dialog"]["enableModal"](_0x5e40a2["dialog"]["loadFile"]("forms/adminconsole.modal.moveclient.html")), _0x5e40a2.dialog["modal"]["find"]("input[name=\"roommove\"]")["focus"]();
    }), this["subContent"].on(UI.pointerEvent("click", "adminSubdialog"), "a[name=\"closeConnection\"]", function (_0x112c9d) {
      _0x112c9d["preventDefault"]();
      var _0x55ceb6 = _0x5e40a2["table"].getSelected();
      let _0x46342a = {};
      _0x46342a["command"] = "ADMINREQUEST", _0x46342a["action"] = "ClientClose", _0x46342a["uniqueid"] = _0x55ceb6[0]["uniqueID"], socket["send"](_0x46342a, true);
    }), this["subContent"].on(UI["pointerEvent"]("click", "adminSubdialog"), "a[name=\"disconnectAddress\"]", function (_0x1b60eb) {
      _0x1b60eb["preventDefault"]();
      var _0xbcc16f = _0x5e40a2["table"].getSelected();
      let _0x220b03 = {};
      _0x220b03["command"] = "ADMINREQUEST", _0x220b03["action"] = "ClientIPDisconnect", _0x220b03.address = _0xbcc16f[0]["Address"], socket["send"](_0x220b03, true);
    }), this["dialog"]["modal"].on(UI["pointerEvent"]("click", "adminSubdialog"), 'a[name="confirmMoveClient"]', function (_0x3bd3fc) {
      _0x3bd3fc["preventDefault"](), _0x5e40a2["moveClient"](), _0x5e40a2.dialog["disableModal"]();
    }), this.dialog["modal"].on(UI["pointerEvent"]("keydown", "adminSubdialog"), "input[name=\"roommove\"]", function (_0x33f5a1) {
      _0x33f5a1["which"] == 13 && (_0x33f5a1["preventDefault"](), _0x5e40a2["moveClient"](), _0x5e40a2["dialog"]["disableModal"]());
    });
    var _0x5ca19d = {};
    _0x5ca19d["command"] = "ADMINREQUEST", _0x5ca19d["action"] = "ClientList", socket.send(_0x5ca19d, true), $["contextMenu"]({
      selector: "#clientsTable tr",
      build: function (_0x5abecb) {
        var _0x21c1ef = {
          callback: function (_0x178bd1, _0xd0964d) {
            var _0x17e018 = _0xd0964d["$trigger"]["attr"]("data-rowid");
            _0x5e40a2["table"]["select"](_0x17e018);
            if (_0x178bd1 == "Ugd") {
              var _0x55795a = _0x5e40a2.table["getRow"](_0x17e018);
              parseInt(_0x55795a[2]) != 0 && UI["userGalleryDialog"].show({
                uid: _0x55795a[2]
              });
            } else _0x178bd1 == "Dbg" && _0x5e40a2["debugClient"]();
          },
          items: {
            Dbg: {
              name: "Debug",
              icon: "fa-bug"
            },
            Ugd: {
              name: "Gallery",
              icon: "fa-image"
            }
          }
        };
        return $["each"](_0x21c1ef["items"], function (_0x42333e, _0x4930b7) {
          _0x21c1ef.items[_0x42333e]["name"] && (_0x21c1ef["items"][_0x42333e].name = function () {
            return textManager["getString"]("menu.userList." + _0x42333e, null, false);
          });
        }), _0x21c1ef;
      }
    });
  }
  ["moveClient"]() {
    var _0x33f3dd = this["table"].getSelected(),
      _0x2d7065 = {};
    _0x2d7065["command"] = "ADMINREQUEST", _0x2d7065.action = "MoveClient", _0x2d7065.uniqueid = _0x33f3dd[0]["uniqueID"], _0x2d7065["room"] = this["dialog"].modal["find"]("input[name=\"roommove\"]")["val"](), _0x2d7065["roompassword"] = this["dialog"].modal["find"]("input[name=\"roommovepass\"]").val(), socket["send"](_0x2d7065, true);
  }
  ["debugClient"]() {
    var _0x5e999e = this.table.getSelected(),
      _0x4e7efd = {};
    _0x4e7efd["command"] = "GLOBALFUNCTIONS", _0x4e7efd["option"] = "DEBUG", _0x4e7efd["target"] = _0x5e999e[0]["Username"], _0x4e7efd.room = _0x5e999e[0]["Room"], socket["send"](_0x4e7efd, true);
  }
  ["unload"]() {
    this["dialog"]["modal"]["off"](".adminSubdialog"), this["table"]["reset"]();
  }
  ["data"](_0x2f60d0) {
    this.table["clear"]();
    var _0x32cfc4 = this;
    $["each"](_0x2f60d0, function (_0x18ff8f, _0x1f874d) {
      var _0x443815,
        _0x30da03 = "";
      _0x1f874d["rank"] != "UU" && (_0x30da03 = "<strong>Reg. Username:</strong> " + _0x1f874d["regusername"] + "<br /><strong>Rank:</strong> " + UI.userRank(_0x1f874d["rank"], null, false) + "<br />");
      _0x443815 = "<span class=\"" + UI["rankToStyle"](_0x1f874d["rank"]) + "\" data-tooltip=\"<strong>UID:</strong> " + _0x1f874d["uid"] + "<br />" + _0x30da03 + "<strong>Silenced:</strong> " + (_0x1f874d["silenced"] ? "Yes" : "No") + "<br /><strong>Muted:</strong> " + (_0x1f874d["muted"] ? "Yes" : "No") + "<br /><strong>Group:</strong> " + _0x1f874d["group"] + "<br /><strong>SID:</strong> " + (_0x1f874d.info ? _0x1f874d.info["software"] : "") + "<br /><strong>HID:</strong> " + (_0x1f874d["info"] ? _0x1f874d["info"].hardware : "") + "<br /><strong>CID:</strong> " + (_0x1f874d["info"] ? _0x1f874d["info"]["cookie"] : "") + "<br /><strong>FP:</strong> " + (_0x1f874d.info ? _0x1f874d["info"].fingerprint : "") + "<br /><strong>Serv:</strong> " + (_0x1f874d["info"] ? _0x1f874d.info["serv"] : "") + "<br/><strong>Bst:</strong> " + (_0x1f874d.info ? _0x1f874d["info"].bst : "") + "<br /><strong>Tst:</strong> " + (_0x1f874d["info"] ? _0x1f874d["info"]["tst"] : "") + "<br /><strong>Languages:</strong> " + (_0x1f874d["info"] ? _0x1f874d["info"]["acceptLanguage"] : "") + '">' + (_0x1f874d.username || "") + "</span>";
      var _0x59ff06 = '<span data-tooltip="<strong>Version:</strong> ' + _0x1f874d["version"] + "<br /><strong>Encryption:</strong> " + _0x1f874d["encryption"] + '">' + (_0x1f874d.client || "") + "</span>",
        _0x4d8ef8 = "<span data-tooltip=\"<strong>Visibility: </strong>" + (_0x1f874d["hiddenroom"] ? "Private" : "Public") + '">' + (_0x1f874d["room"] || "") + "</span>",
        _0x31d004 = "<span data-tooltip=\"<strong>IP Address:</strong> " + _0x1f874d.ip + "<br /><strong>Public IP:</strong> " + _0x1f874d["publicip"] + "<br /><strong>Proxy:</strong> " + (_0x1f874d["proxy"] ? "Yes" : "No") + "<br /><strong>Hosting:</strong> " + (_0x1f874d["hosting"] ? "Yes" : "No") + "<br /><strong>Country:</strong> " + _0x1f874d["country"] + "<br /><strong>Shadowbanned:</strong> " + (_0x1f874d["ghostbanned"] ? "Yes" : "No") + '">' + (isIPv4(_0x1f874d.ip) ? "IPv4" : "IPv6") + "</span>",
        _0x5ed491 = formatTimestamp(_0x1f874d["connectedSince"]);
      _0x32cfc4["table"].addRow([_0x1f874d["uniqueID"], _0x1f874d["uid"], _0x1f874d.username, _0x1f874d.ip, _0x443815, _0x31d004, _0x4d8ef8, _0x59ff06, _0x5ed491], false);
    }), this["dialog"].changed(), this["table"]["updated"](), $(this["table"]).on("tableRowSelected.banSubdialog tableRowUnselected.banSubdialog", function (_0x88f5eb) {
      _0x32cfc4["subContent"]["find"]('a[name="disconnectAddress"]').removeClass("disabled"), _0x32cfc4["subContent"]["find"]("a[name=\"closeConnection\"]").removeClass("disabled"), _0x32cfc4["subContent"]["find"]('a[name="moveClient"]')["removeClass"]("disabled");
    }), this["dialog"]["loading"](false);
  }
  ["gotResponse"](_0x538728) {
    if (_0x538728["option"] == "xxx") {
      if (_0x538728["perform"] == "update") { }
      this["dialog"].loading(false);
    }
  }
}
class AdminConsoleBansSubDialog extends SubDialog {
  constructor(_0x3767bf, _0x27af62) {
    super(_0x3767bf, _0x27af62), this["table"], this.bantypeCheckbox;
  }
  ["load"]() {
    this["dialog"]["loading"](true), this["subContent"]["html"](this.dialog["loadFile"]("forms/adminconsole.bans.html")), this["subContent"]["find"]("a[name=\"removeServerBan\"]")["addClass"]("disabled"), this["table"] = new Table(this["subContent"].find("#adminBansTable"), null, "bansTable", "fmTable"), this["table"]["setFilterable"](true), this["table"]["setTitle"]("Active Bans"), this["table"]["setHeader"](["ID", "IP", "Username", "Type", "Expires", "Banned by"]), this["table"]["hideColumns"]([1, 6]);
    var _0x1d59c2 = this;
    $(this["dialog"]).on("dialogResizingEnded dialogMaximized dialogRestored", function (_0x1f5d8b) {
      _0x1d59c2["table"] && _0x1d59c2["table"]["updated"]();
    }), this["subContent"]["find"]("a[name=\"removeServerBan\"]").on(UI["pointerEvent"]("click", "adminSubdialog"), function (_0x51df63) {
      _0x51df63["preventDefault"]();
      var _0x33be8f = _0x1d59c2.table["getSelected"](),
        _0x4ed027 = {};
      _0x4ed027["command"] = "ADMINREQUEST", _0x4ed027.action = "AdminBans", _0x4ed027["option"] = "IPServBan", _0x4ed027.perform = "delete", _0x4ed027.id = _0x33be8f[0].ID, socket.send(_0x4ed027, true);
    }), this["subContent"]["find"]("a[name=\"addServerBan\"]").on(UI.pointerEvent("click", "adminSubdialog"), function (_0x3df6de) {
      _0x3df6de["preventDefault"](), _0x1d59c2["dialog"]["enableModal"](_0x1d59c2["dialog"]["loadFile"]("forms/adminconsole.modal.addban.html")), _0x1d59c2["bantypeCheckbox"] = new Switch(_0x1d59c2["dialog"]["modal"]["find"]("div[name=\"banType\"]"), function (_0x32bf41) {
        return _0x32bf41 ? "Shadowban" : "Serverban";
      }), _0x1d59c2["dialog"].modal["find"]("input[name=\"address\"]").focus();
      var _0x419879 = _0x1d59c2["dialog"]["modal"].find("select[name=\"banLength\"]");
      _0x419879["empty"](), $["each"](_0x1d59c2["dialog"].banLengths, function (_0x4203e7, _0x267e18) {
        _0x419879["append"](new Option(_0x267e18, _0x4203e7));
      }), _0x419879.val(0);
    }), this.dialog["modal"].on(UI["pointerEvent"]("click", "adminSubdialog"), "#insertBan", function (_0x4265f2) {
      _0x4265f2["preventDefault"]();
      var _0x87576d = _0x1d59c2["dialog"]["modal"]["find"]('input[name="address"]')["val"]();
      if (isValidIP(_0x87576d)) {
        var _0x24a51d = {};
        _0x24a51d["command"] = "ADMINREQUEST", _0x24a51d["action"] = "AdminBans", _0x24a51d.option = "IPServBan", _0x24a51d["perform"] = "insert", _0x24a51d["comment"] = _0x1d59c2["dialog"]["modal"]["find"]('input[name="comment"]')["val"](), _0x24a51d.ip = _0x87576d, _0x24a51d["ghost"] = _0x1d59c2["bantypeCheckbox"]["checked"], _0x24a51d.expires = _0x1d59c2["dialog"]["modal"]["find"]("select[name=\"banLength\"]")["val"](), socket.send(_0x24a51d, true), _0x1d59c2["dialog"].loading(true);
      } else UI["dialogHandler"]["showAlert"](textManager.getString("alerts.txtInvalidIP"));
    });
    var _0xf94385 = {};
    _0xf94385["command"] = "ADMINREQUEST", _0xf94385.action = "BanList", socket["send"](_0xf94385, true);
  }
  ["unload"]() {
    this["dialog"]["modal"]["off"](".adminSubdialog"), this["table"].reset();
  }
  ["data"](_0x3012ea) {
    this["table"]["clear"]();
    var _0x570e02 = this;
    $.each(_0x3012ea, function (_0x2c4e92, _0x1dbb78) {
      _0x570e02["addBanRow"](_0x1dbb78.id, _0x1dbb78.ip, _0x1dbb78.username, _0x1dbb78["type"] == 1, _0x1dbb78["expires"], _0x1dbb78["staffname"], _0x1dbb78["staffrank"], _0x1dbb78["staffuid"]);
    }), this["dialog"]["changed"](), this.table["updated"](), $(this["table"]).on("tableRowSelected.adminSubdialog tableRowUnselected.adminSubdialog", function (_0x598b62) {
      _0x570e02.subContent["find"]("a[name=\"removeServerBan\"]")["removeClass"]("disabled");
    }), this["dialog"]["loading"](false);
  }
  ["addBanRow"](_0x448257, _0x4ce1e4, _0x1c7b2f, _0x47cf59, _0x3b805a, _0x1e113b, _0x3e3a62, _0x57f456) {
    var _0x2ac79c = "<span class=\"" + UI["rankToStyle"](_0x3e3a62) + '">' + _0x1e113b + "</span>",
      _0x4daa88 = _0x3b805a == 0 ? "Never" : formatTimestamp(_0x3b805a);
    return this["table"].addRow([_0x448257, _0x4ce1e4, _0x1c7b2f, _0x47cf59 ? "Shadowban" : "Serverban", _0x4daa88, _0x2ac79c], false);
  }
  ["gotResponse"](_0x4537b9) {
    if (_0x4537b9.option == "IPSba") {
      if (_0x4537b9["code"] == "OK") {
        this["dialog"]["disableModal"]();
        var _0xdb7de3 = this["addBanRow"](_0x4537b9.ban.id, _0x4537b9.ban.ip, _0x4537b9["ban"]["comment"], _0x4537b9["ban"]["ghost"], _0x4537b9["ban"]["expires"], _0x4537b9["ban"].staffname, _0x4537b9["ban"].staffrank, _0x4537b9["ban"]["staffuid"]),
          _0xdb7de3 = this["table"]["find"](this["table"].getColumnId("ID"), _0x4537b9["ban"].id);
        _0xdb7de3 != null && this["table"].locate(_0xdb7de3);
      } else UI["dialogHandler"]["showAlert"]("Error: " + _0x4537b9["code"]);
      this["table"]["updated"](), this["dialog"]["loading"](false);
    } else {
      if (_0x4537b9["option"] == "IPSbd") {
        if (_0x4537b9.code == "OK") {
          var _0xdb7de3 = this["table"]["find"](this["table"]["getColumnId"]("ID"), _0x4537b9["ban"].id);
          _0xdb7de3 != null && this.table["deleteRow"](_0xdb7de3);
        } else UI["dialogHandler"]["showAlert"]("Error: " + _0x4537b9.code);
        this["dialog"]["loading"](false);
      }
    }
  }
}
class AdminConsoleEventsSubDialog extends SubDialog {
  constructor(_0x541a0f, _0x34dce7) {
    super(_0x541a0f, _0x34dce7), this["events"] = ["BEFORE_JOIN_ROOM", "BEFORE_ACCOUNT_CREATE", "BEFORE_ROOM_CREATE", "BEFORE_SERVERBAN", "AFTER_ROOMBAN", "AFTER_SHADOWBAN", "AFTER_NEGOTIATION", "AFTER_FEEDBACK", "AFTER_LOGIN_FAILED", "AFTER_EXCEPTION"], this["table"], this.bantypeCheckbox;
  }
  ["load"]() {
    this["dialog"]["loading"](true), this.subContent.html(this.dialog["loadFile"]("forms/adminconsole.events.html")), this.subContent["find"]("a[name=\"editServerEvent\"]")["addClass"]("disabled"), this["subContent"].find("a[name=\"removeServerEvent\"]")["addClass"]("disabled"), this["table"] = new Table(this.subContent["find"]("#adminEventsTable"), null, "eventsTable", "fmTable"), this["table"].setFilterable(true), this["table"]["setTitle"]("Events"), this["table"]["setHeader"](["ID", "Description", "Event", "Condition", "Action", "Enabled", "Active", "Added by"]), this["table"]["hideColumns"]([4, 5, 6, 8]);
    var _0x23cf4b = this;
    $(this["dialog"]).on("dialogResizingEnded dialogMaximized dialogRestored", function (_0x52f9b5) {
      _0x23cf4b["table"] && _0x23cf4b.table["updated"]();
    }), this["subContent"]["find"]("a[name=\"removeServerEvent\"]").on(UI["pointerEvent"]("click", "eventsSubdialog"), function (_0xc3f95) {
      _0xc3f95["preventDefault"]();
      var _0x25a6f5 = _0x23cf4b["table"].getSelected(),
        _0x8da1e = {};
      _0x8da1e["command"] = "ADMINREQUEST", _0x8da1e["action"] = "AdminEvents", _0x8da1e["option"] = "Event", _0x8da1e["perform"] = "delete", _0x8da1e["evid"] = _0x25a6f5[0].ID, socket["send"](_0x8da1e, true);
    }), this["subContent"]["find"]("a[name=\"addServerEvent\"]").on(UI["pointerEvent"]("click", "eventsSubdialog"), function (_0x3fa963) {
      _0x3fa963["preventDefault"](), _0x23cf4b["dialog"]["enableModal"](_0x23cf4b["dialog"]["loadFile"]("forms/adminconsole.modal.addevent.html"));
      var _0x3899dc = _0x23cf4b.dialog["modal"].find('select[name="eventType"]');
      _0x3899dc.focus(), _0x3899dc.empty(), $["each"](_0x23cf4b.events, function (_0x422ccf, _0x55c616) {
        _0x3899dc["append"](new Option(_0x55c616, _0x55c616));
      }), _0x3899dc.val(_0x23cf4b.events[0]), _0x23cf4b.dialog["modal"]["find"]("select[name=\"enabled\"]")["val"](1);
    }), this.subContent["find"]('a[name="editServerEvent"]').on(UI.pointerEvent("click", "eventsSubdialog"), function (_0x4ba050) {
      _0x4ba050.preventDefault(), _0x23cf4b["editEvent"]();
    }), this["dialog"].modal.on(UI.pointerEvent("click", "adminSubdialog"), "#insertEvent", function (_0xf321dd) {
      _0xf321dd["preventDefault"]();
      var _0x22ef5f = {};
      _0x22ef5f["command"] = "ADMINREQUEST", _0x22ef5f.action = "AdminEvents", _0x22ef5f["option"] = "Event", _0x22ef5f["perform"] = "insert", _0x22ef5f["evevent"] = _0x23cf4b["dialog"]["modal"]["find"]("select[name=\"eventType\"]")["val"](), _0x22ef5f.evdescription = _0x23cf4b["dialog"]["modal"]["find"]("input[name=\"description\"]").val(), _0x22ef5f.evcondition = _0x23cf4b["dialog"]["modal"]["find"]('textarea[name="condition"]').val();
      ;
      _0x22ef5f["evaction"] = _0x23cf4b["dialog"]["modal"]["find"]("textarea[name=\"action\"]")["val"](), _0x22ef5f.evenabled = parseInt(_0x23cf4b["dialog"]["modal"]["find"]("select[name=\"enabled\"]")["val"]()), socket.send(_0x22ef5f, true), _0x23cf4b["dialog"]["loading"](true);
    }), this["dialog"]["modal"].on(UI["pointerEvent"]("click", "adminSubdialog"), "#editEvent", function (_0xecc457) {
      _0xecc457.preventDefault();
      var _0x2c7543 = {};
      _0x2c7543.command = "ADMINREQUEST", _0x2c7543["action"] = "AdminEvents", _0x2c7543["option"] = "Event", _0x2c7543["perform"] = "edit", _0x2c7543["evid"] = _0x23cf4b["dialog"]["modal"]["find"]('input[name="eventid"]').val(), _0x2c7543["evevent"] = _0x23cf4b["dialog"]["modal"].find("select[name=\"eventType\"]").val(), _0x2c7543["evdescription"] = _0x23cf4b.dialog["modal"]["find"]("input[name=\"description\"]").val(), _0x2c7543.evcondition = _0x23cf4b.dialog["modal"].find("textarea[name=\"condition\"]").val(), _0x2c7543["evaction"] = _0x23cf4b.dialog["modal"].find("textarea[name=\"action\"]")["val"](), _0x2c7543["evenabled"] = parseInt(_0x23cf4b["dialog"]["modal"]["find"]("select[name=\"enabled\"]").val()), socket.send(_0x2c7543, true), _0x23cf4b["dialog"]["loading"](true);
    });
    var _0x1491ea = {};
    _0x1491ea.command = "ADMINREQUEST", _0x1491ea["action"] = "EventList", socket["send"](_0x1491ea, true);
  }
  ["editEvent"]() {
    this.dialog["enableModal"](this["dialog"]["loadFile"]("forms/adminconsole.modal.editevent.html"));
    var _0x25bb28 = this.table["getSelected"](),
      _0x146dbe = this.dialog.modal["find"]("select[name=\"eventType\"]");
    _0x146dbe.focus(), _0x146dbe.empty(), $["each"](this["events"], function (_0x4015e3, _0x53b486) {
      _0x146dbe["append"](new Option(_0x53b486, _0x53b486));
    }), _0x146dbe.val(_0x25bb28[0]["Event"]), this.dialog.modal["find"]("input[name=\"description\"]")["val"](_0x25bb28[0]["Description"]), this["dialog"]["modal"]["find"]("textarea[name=\"condition\"]")["val"](_0x25bb28[0]["Condition"]), this.dialog["modal"]["find"]('textarea[name="action"]')["val"](_0x25bb28[0]["Action"]), this.dialog["modal"]["find"]('input[name="eventid"]')["val"](_0x25bb28[0].ID), this["dialog"]["modal"]["find"]("select[name=\"enabled\"]")["val"](_0x25bb28[0]["Enabled"] ? 1 : 0);
  }
  ["unload"]() {
    this.dialog["modal"]["off"](".eventsSubdialog"), this["table"].reset();
  }
  ["data"](_0x74018c) {
    this.table["clear"]();
    var _0x3e4a39 = this;
    $(this.table).on("tableRowDoubleClick.eventsSubdialog", function (_0x155f86) {
      _0x3e4a39["editEvent"]();
    }), $["each"](_0x74018c, function (_0x22759e, _0xc0ac8f) {
      _0x3e4a39["addEventRow"](_0xc0ac8f.id, _0xc0ac8f.description, _0xc0ac8f.event, _0xc0ac8f.condition, _0xc0ac8f["action"], _0xc0ac8f.enabled, _0xc0ac8f["staffuid"]);
    }), this["dialog"].changed(), this["table"]["updated"](), $(this.table).on("tableRowSelected.eventsSubdialog tableRowUnselected.eventsSubdialog", function (_0x2d7920) {
      _0x3e4a39.subContent.find("a[name=\"editServerEvent\"]").removeClass("disabled"), _0x3e4a39["subContent"]["find"]('a[name="removeServerEvent"]')["removeClass"]("disabled");
    }), this["dialog"]["loading"](false);
  }
  ["addEventRow"](_0x51d276, _0x5b1ac0, _0x1499e5, _0x2eeae9, _0x4ccec5, _0x54f7a0, _0x55490e) {
    return this.table["addRow"]([_0x51d276, _0x5b1ac0, _0x1499e5, _0x2eeae9, _0x4ccec5, _0x54f7a0, _0x54f7a0 ? "yes" : "no", _0x55490e]);
  }
  ["updateEventRow"](_0x4b07dd, _0x2df8fe, _0x309e3d, _0x248c0b, _0xcc698e, _0x35d26c, _0x316e05) {
    var _0x3cbd21 = this["table"].find(this["table"]["getColumnId"]("ID"), _0x4b07dd);
    if (_0x3cbd21 != null) {
      var _0x4bd058 = {};
      _0x4bd058[this["table"]["getColumnId"]("Description")] = _0x2df8fe, _0x4bd058[this["table"]["getColumnId"]("Event")] = _0x309e3d, _0x4bd058[this.table.getColumnId("Condition")] = _0x248c0b, _0x4bd058[this["table"]["getColumnId"]("Action")] = _0xcc698e, _0x4bd058[this.table["getColumnId"]("Enabled")] = _0x35d26c, _0x4bd058[this["table"]["getColumnId"]("Active")] = _0x35d26c ? "yes" : "no", _0x4bd058[this["table"]["getColumnId"]("Staffuid")] = _0x316e05, this["table"]["updateRow"](_0x3cbd21, _0x4bd058);
    }
  }
  ["gotResponse"](_0x265405) {
    if (_0x265405["option"] == "EventA") {
      if (_0x265405.code == "OK") {
        this["dialog"]["disableModal"]();
        var _0x30c7d8 = this["addEventRow"](_0x265405["event"].id, _0x265405["event"]["description"], _0x265405["event"]["event"], _0x265405["event"]["condition"], _0x265405["event"]["action"], _0x265405["event"]["enabled"], _0x265405["event"].staffuid, false),
          _0x30c7d8 = this["table"]["find"](this["table"]["getColumnId"]("ID"), _0x265405["event"].id);
        _0x30c7d8 != null && this.table.locate(_0x30c7d8);
      } else UI["dialogHandler"]["showAlert"]("Error: " + _0x265405.code);
      this["table"]["updated"](), this.dialog["loading"](false);
    } else {
      if (_0x265405["option"] == "EventD") {
        if (_0x265405["code"] == "OK") {
          var _0x30c7d8 = this.table.find(this["table"]["getColumnId"]("ID"), _0x265405.event.id);
          _0x30c7d8 != null && this.table["deleteRow"](_0x30c7d8);
        } else UI["dialogHandler"].showAlert("Error: " + _0x265405["code"]);
        this.dialog["loading"](false);
      } else {
        if (_0x265405["option"] == "EventU") {
          if (_0x265405["code"] == "OK") {
            this["dialog"]["disableModal"](), this["updateEventRow"](_0x265405.event.id, _0x265405["event"].description, _0x265405["event"]["event"], _0x265405["event"]["condition"], _0x265405["event"]["action"], _0x265405["event"]["enabled"], _0x265405["event"]["staffuid"]);
            var _0x30c7d8 = this.table.find(this.table["getColumnId"]("ID"), _0x265405["event"].id);
            _0x30c7d8 != null && this["table"]["locate"](_0x30c7d8);
          } else UI["dialogHandler"]["showAlert"]("Error: " + _0x265405.code);
          this["dialog"]["loading"](false);
        }
      }
    }
  }
}
class AdminConsoleFeedbackSubDialog extends SubDialog {
  constructor(_0x200479, _0x5d2fb1) {
    super(_0x200479, _0x5d2fb1), this["table"];
  }
  ["load"]() {
    this["dialog"]["loading"](true), this["subContent"]["html"](this.dialog["loadFile"]("forms/adminconsole.feedback.html")), this["subContent"]["find"]('a[name="readFeedback"]')["addClass"]("disabled");
    var _0x3cb57b = this;
    this.subContent.on(UI.pointerEvent("click", "adminSubdialog"), "a[name=\"readFeedback\"]", function (_0x526115) {
      _0x526115.preventDefault(), _0x3cb57b["viewFeedback"]();
    }), this["table"] = new Table(this["subContent"]["find"]("#adminFeedbackTable"), null, "feedbackTable", "fmTable"), this["table"].setFilterable(true), this.table["setTitle"]("Feedback"), this["table"].setHeader(["Id", "Version", "Date", "From", "IP", "Time", "Comments"]), this["table"]["hideColumns"]([5, 6, 7]), $(this.dialog).on("dialogResizingEnded dialogMaximized dialogRestored", function (_0x594e2e) {
      _0x3cb57b.table && _0x3cb57b["table"]["updated"]();
    });
    var _0x58505e = {};
    _0x58505e["command"] = "ADMINREQUEST", _0x58505e["action"] = "FeedbackList", socket.send(_0x58505e, true);
  }
  ["viewFeedback"]() {
    this["dialog"]["enableModal"](this["dialog"]["loadFile"]("forms/adminconsole.modal.readfeedback.html"));
    var _0xea5ccb = this.table["getSelected"]();
    this["dialog"]["modal"]["find"]('input[name="fbversion"]')["val"](_0xea5ccb[0]["Version"]), this["dialog"].modal["find"]("input[name=\"fbfrom\"]").val(_0xea5ccb[0].From + " (" + _0xea5ccb[0].IP + ")"), this["dialog"].modal["find"]("input[name=\"fbdate\"]")["val"](_0xea5ccb[0]["Date"]), this["dialog"]["modal"].find("textarea[name=\"fbcomments\"]")["val"](_0xea5ccb[0].Comments);
  }
  ["unload"]() {
    this.dialog["modal"].off(".feedbackSubdialog"), this["table"]["reset"]();
  }
  ["data"](_0x5fced) {
    this.table["clear"]();
    var _0x26980e = this;
    $["each"](_0x5fced, function (_0xe4fc85, _0x8cc570) {
      _0x26980e["table"].addRow([_0x8cc570.id, _0x8cc570.version, formatTimestamp(_0x8cc570["time"]), _0x8cc570["from_user"], _0x8cc570["from_ip"], _0x8cc570["time"], _0x8cc570["comments"]], false);
    }), this.dialog["changed"](), this["table"]["updated"](), this["table"]["sort"](1, false), $(this["table"]).on("tableRowSelected.feedbackSubdialog tableRowUnselected.feedbackSubdialog", function (_0x453577) {
      _0x26980e["subContent"].find("a[name=\"readFeedback\"]").removeClass("disabled");
    }), $(this["table"]).on("tableRowDoubleClick.feedbackSubdialog", function (_0x2261fe) {
      _0x26980e.viewFeedback();
    }), this.dialog["loading"](false);
  }
}
class AdminConsoleSystemSubDialog extends SubDialog {
  constructor(_0x138952, _0x599b21) {
    super(_0x138952, _0x599b21), this.chart, this["visible"] = false;
  }
  ["load"]() {
    this["visible"] = true, this["subContent"].html(this["dialog"]["loadFile"]("forms/adminconsole.system.html"));
    var _0x4a99b3 = this;
    setTimeout(function () {
      var _0x13f82e = {
        red: "rgb(255, 99, 132)",
        orange: "rgb(255, 159, 64)",
        yellow: "rgb(255, 205, 86)",
        green: "rgb(75, 192, 192)",
        blue: "rgb(54, 162, 235)",
        purple: "rgb(153, 102, 255)",
        grey: "rgb(201, 203, 207)"
      },
        _0x31a7dd = Chart["helpers"]["color"],
        _0x3a2e72 = {
          type: "line",
          data: {
            datasets: [{
              label: "CPU",
              backgroundColor: _0x31a7dd(_0x13f82e["blue"])["alpha"](0.5)["rgbString"](),
              borderColor: _0x13f82e["blue"],
              fill: false,
              cubicInterpolationMode: "monotone",
              data: []
            }, {
              label: "RAM",
              backgroundColor: _0x31a7dd(_0x13f82e["orange"])["alpha"](0.5)["rgbString"](),
              borderColor: _0x13f82e.orange,
              fill: false,
              cubicInterpolationMode: "monotone",
              data: []
            }]
          },
          options: {
            title: {
              display: false
            },
            scales: {
              x: {
                type: "realtime",
                realtime: {
                  duration: 2e4,
                  refresh: 5e3,
                  delay: 8e3,
                  onRefresh: function () {
                    if (_0x4a99b3["visible"]) {
                      var _0x558d81 = {};
                      _0x558d81["command"] = "ADMINREQUEST", _0x558d81.action = "Stats", socket["send"](_0x558d81, true);
                    }
                  }
                }
              },
              y: {
                min: 0,
                max: 100,
                scaleLabel: {
                  display: false
                },
                ticks: {
                  suggestedMin: 0,
                  suggestedMax: 100
                }
              }
            }
          }
        },
        _0x4a03cf = _0x4a99b3["subContent"].find("#systemChart")[0]["getContext"]("2d");
      _0x4a99b3["chart"] = new Chart(_0x4a03cf, _0x3a2e72), _0x4a99b3.chart["update"]();
    }, 500);
    var _0x1b6b48 = {};
    _0x1b6b48["command"] = "ADMINREQUEST", _0x1b6b48["action"] = "SystemInfo", socket["send"](_0x1b6b48, true);
  }
  ["unload"]() {
    var _0x36c38e = this["chart"]["scales"].x;
    _0x36c38e.destroy();
  }
  ["data"](_0x1c076) {
    this["subContent"]["find"]("h1[name=\"platform\"]").text(_0x1c076["platform"]), this["subContent"].find('h1[name="cpucount"]')["text"](_0x1c076["cpuCount"]), this["subContent"]["find"]("h1[name=\"uptime\"]")["text"](_0x1c076.uptime);
  }
  ["intervalData"](_0x2f2e83, _0x51f004) {
    if (this["chart"]) {
      var _0x469193 = Date.now();
      this.chart["config"]["data"]["datasets"][0]["data"].push({
        x: _0x469193,
        y: _0x2f2e83
      }), this["chart"]["config"]["data"]["datasets"][1].data["push"]({
        x: _0x469193,
        y: _0x51f004
      });
    }
  }
}
class AdminConsoleSummarySubDialog extends SubDialog {
  constructor(_0x585f60, _0x17465e) {
    super(_0x585f60, _0x17465e), this.table;
  }
  ["load"]() {
    this["dialog"]["loading"](true), this["subContent"]["html"](this.dialog["loadFile"]("forms/adminconsole.summary.html")), this["allowIPv4Checkbox"] = new Switch(this["subContent"]["find"]("div[name=\"allowIPv4\"]")), this["allowIPv6Checkbox"] = new Switch(this.subContent["find"]("div[name=\"allowIPv6\"]")), this["allowProxyCheckbox"] = new Switch(this["subContent"]["find"]("div[name=\"allowProxy\"]")), this.newUsersCheckbox = new Switch(this["subContent"]["find"]('div[name="newUsers"]')), this["newRoomsCheckbox"] = new Switch(this["subContent"]["find"]("div[name=\"newRooms\"]")), this.consoleOutputSelector = new Selector(this["subContent"]["find"]("div[name=\"consoleOutput\"]"), {
      0: "Minimal",
      1: "Extended",
      2: "Debug"
    });
    var _0x13d47b = this;
    this["subContent"].find(".dialogContentArea")["overlayScrollbars"]({
      className: "os-theme-light",
      overflowBehavior: {
        x: "hidden"
      }
    }), this["subContent"].find("a[name=\"sendGM\"]").on(UI["pointerEvent"]("click", "systemSubdialog"), function (_0x869267) {
      _0x869267["preventDefault"]();
      if (_0x13d47b["subContent"]["find"]("input[name=\"textGM\"]").val() != "") {
        var _0x50a5f0 = {};
        _0x50a5f0["command"] = "ADMINREQUEST", _0x50a5f0["action"] = "GlobalMessage", _0x50a5f0["text"] = _0x13d47b["subContent"]["find"]("input[name=\"textGM\"]")["val"](), socket["send"](_0x50a5f0, true);
      }
    }), this["subContent"]["find"]("a[name=\"applySettings\"]").on(UI["pointerEvent"]("click", "systemSubdialog"), function (_0x4508f6) {
      _0x4508f6["preventDefault"]();
      var _0x404098 = {};
      _0x404098["command"] = "ADMINREQUEST", _0x404098["action"] = "ServerSettings", _0x404098["allowIPv4"] = _0x13d47b.allowIPv4Checkbox["checked"], _0x404098["allowIPv6"] = _0x13d47b["allowIPv6Checkbox"]["checked"], _0x404098["allowProxy"] = _0x13d47b["allowProxyCheckbox"]["checked"], _0x404098["allowNewUsers"] = _0x13d47b["newUsersCheckbox"]["checked"], _0x404098["allowNewRooms"] = _0x13d47b["newRoomsCheckbox"]["checked"], _0x404098.consoleOutput = _0x13d47b.consoleOutputSelector["getSelected"](), socket["send"](_0x404098, true);
    });
    var _0x53cfa0 = {};
    _0x53cfa0["command"] = "ADMINREQUEST", _0x53cfa0["action"] = "Summary", socket["send"](_0x53cfa0, true);
  }
  ["unload"]() {
    this["dialog"].modal["off"](".adminSubdialog");
  }
  ["data"](_0x41c2b1) {
    this["subContent"]["find"]("h1[name=\"activeClients\"]")["text"](_0x41c2b1["activeClients"]), this["subContent"]["find"]("h1[name=\"activeRooms\"]")["text"](_0x41c2b1["activeRooms"]), this.subContent["find"]("h1[name=\"users\"]")["text"](_0x41c2b1["users"]), this["subContent"].find('h1[name="rooms"]').text(_0x41c2b1["rooms"]), this.allowIPv4Checkbox["setValue"](_0x41c2b1.allowIPv4), this.allowIPv6Checkbox["setValue"](_0x41c2b1["allowIPv6"]), this["allowProxyCheckbox"]["setValue"](_0x41c2b1["allowProxy"]), this["newUsersCheckbox"]["setValue"](_0x41c2b1["allowNewUsers"]), this["newRoomsCheckbox"]["setValue"](_0x41c2b1.allowNewRooms), this["consoleOutputSelector"]["select"](_0x41c2b1["consoleOutput"]), this["dialog"]["changed"](), this["dialog"]["loading"](false);
  }
}
function log(_0x527162) {
  console["log"](_0x527162);
}
function GetVariable(_0x548422) {
  var _0x47bfbf = null,
    _0x15b6f7 = location["search"]["replace"]("?", "")["split"]("&");
  return $["each"](_0x15b6f7, function (_0x3198e7, _0x3a8c01) {
    value = _0x3a8c01.split("=");
    if (value[0] == _0x548422) _0x47bfbf = value[1];
  }), _0x47bfbf;
}
function rgb2obj(_0x3b82b6) {
  return _0x3b82b6 = _0x3b82b6["match"](/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+))?\)$/), {
    r: parseInt(_0x3b82b6[1]),
    g: parseInt(_0x3b82b6[2]),
    b: parseInt(_0x3b82b6[3])
  };
}
function rgb2hex(_0x16fc8a) {
  _0x16fc8a = _0x16fc8a["match"](/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+))?\)$/);
  function _0x19280d(_0x51d826) {
    return ("0" + parseInt(_0x51d826)["toString"](16))["slice"](-2);
  }
  return "#" + _0x19280d(_0x16fc8a[1]) + _0x19280d(_0x16fc8a[2]) + _0x19280d(_0x16fc8a[3]);
}
function hex2rgb(_0x437c44) {
  _0x437c44.length == 4 && (_0x437c44 = _0x437c44[1] + _0x437c44[1] + _0x437c44[2] + _0x437c44[2] + _0x437c44[3] + _0x437c44[3]);
  var _0x5800b6 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i["exec"](_0x437c44);
  if (_0x5800b6) return {
    r: parseInt(_0x5800b6[1], 16),
    g: parseInt(_0x5800b6[2], 16),
    b: parseInt(_0x5800b6[3], 16)
  };
  return null;
}
function rgb2hsl(_0x1eae40, _0x1702f5, _0x2aea8e) {
  _0x1eae40 /= 255, _0x1702f5 /= 255, _0x2aea8e /= 255;
  var _0x51da49 = Math["max"](_0x1eae40, _0x1702f5, _0x2aea8e),
    _0x61e637 = Math["min"](_0x1eae40, _0x1702f5, _0x2aea8e),
    _0x134053,
    _0x4e474e,
    _0x4c8602 = (_0x51da49 + _0x61e637) / 2;
  if (_0x51da49 == _0x61e637) _0x134053 = _0x4e474e = 0; else {
    var _0x3708cc = _0x51da49 - _0x61e637;
    _0x4e474e = _0x4c8602 > 0.5 ? _0x3708cc / (2 - _0x51da49 - _0x61e637) : _0x3708cc / (_0x51da49 + _0x61e637);
    switch (_0x51da49) {
      case _0x1eae40:
        _0x134053 = (_0x1702f5 - _0x2aea8e) / _0x3708cc + (_0x1702f5 < _0x2aea8e ? 6 : 0);
        break;
      case _0x1702f5:
        _0x134053 = (_0x2aea8e - _0x1eae40) / _0x3708cc + 2;
        break;
      case _0x2aea8e:
        _0x134053 = (_0x1eae40 - _0x1702f5) / _0x3708cc + 4;
        break;
    }
    _0x134053 /= 6;
  }
  return {
    h: Math["floor"](_0x134053 * 360),
    s: Math["floor"](_0x4e474e * 100),
    l: Math["floor"](_0x4c8602 * 100)
  };
}
function hsl2rgb(_0x1638b1, _0x5a389d, _0x39d6f7) {
  var _0x51cd3c, _0x16c2ae, _0x371d7;
  _0x1638b1 /= 360, _0x5a389d /= 100, _0x39d6f7 /= 100;
  if (_0x5a389d == 0) _0x51cd3c = _0x16c2ae = _0x371d7 = _0x39d6f7; else {
    var _0x54bd27 = function _0x13c7dc(_0x414c4f, _0x4d4eac, _0x588a6c) {
      if (_0x588a6c < 0) _0x588a6c += 1;
      if (_0x588a6c > 1) _0x588a6c -= 1;
      if (_0x588a6c < 0.16666666666666666) return _0x414c4f + (_0x4d4eac - _0x414c4f) * 6 * _0x588a6c;
      if (_0x588a6c < 0.5) return _0x4d4eac;
      if (_0x588a6c < 0.6666666666666666) return _0x414c4f + (_0x4d4eac - _0x414c4f) * (0.6666666666666666 - _0x588a6c) * 6;
      return _0x414c4f;
    },
      _0x598257 = _0x39d6f7 < 0.5 ? _0x39d6f7 * (1 + _0x5a389d) : _0x39d6f7 + _0x5a389d - _0x39d6f7 * _0x5a389d,
      _0x1f3c8e = 2 * _0x39d6f7 - _0x598257;
    _0x51cd3c = _0x54bd27(_0x1f3c8e, _0x598257, _0x1638b1 + 0.3333333333333333), _0x16c2ae = _0x54bd27(_0x1f3c8e, _0x598257, _0x1638b1), _0x371d7 = _0x54bd27(_0x1f3c8e, _0x598257, _0x1638b1 - 0.3333333333333333);
  }
  return {
    r: Math["round"](_0x51cd3c * 255),
    g: Math["round"](_0x16c2ae * 255),
    b: Math["round"](_0x371d7 * 255)
  };
}
function rgb2hsv(_0x3041f5, _0x134085, _0x41e42b) {
  let _0x1b27f6, _0x1d01a3, _0x17c29e, _0x58fce4, _0x451169, _0x99dea3, _0x4b6c69, _0x3ab5c6, _0x5ab288, _0x1eab59, _0x53c525, _0x440b2a;
  _0x1b27f6 = _0x3041f5 / 255, _0x1d01a3 = _0x134085 / 255, _0x17c29e = _0x41e42b / 255, _0x5ab288 = Math.max(_0x1b27f6, _0x1d01a3, _0x17c29e), _0x1eab59 = _0x5ab288 - Math["min"](_0x1b27f6, _0x1d01a3, _0x17c29e), _0x53c525 = _0x34c3c9 => (_0x5ab288 - _0x34c3c9) / 6 / _0x1eab59 + 0.5, _0x440b2a = _0x2b8c04 => Math["round"](_0x2b8c04 * 100) / 100;
  if (_0x1eab59 == 0) _0x4b6c69 = _0x3ab5c6 = 0; else {
    _0x3ab5c6 = _0x1eab59 / _0x5ab288, _0x58fce4 = _0x53c525(_0x1b27f6), _0x451169 = _0x53c525(_0x1d01a3), _0x99dea3 = _0x53c525(_0x17c29e);
    if (_0x1b27f6 === _0x5ab288) _0x4b6c69 = _0x99dea3 - _0x451169; else {
      if (_0x1d01a3 === _0x5ab288) _0x4b6c69 = 0.3333333333333333 + _0x58fce4 - _0x99dea3; else _0x17c29e === _0x5ab288 && (_0x4b6c69 = 0.6666666666666666 + _0x451169 - _0x58fce4);
    }
    if (_0x4b6c69 < 0) _0x4b6c69 += 1; else _0x4b6c69 > 1 && (_0x4b6c69 -= 1);
  }
  return {
    h: Math.round(_0x4b6c69 * 360),
    s: _0x440b2a(_0x3ab5c6 * 100),
    v: _0x440b2a(_0x5ab288 * 100)
  };
}
function hsv2rgb(_0x5cb03b, _0x2d07ed, _0x482f27) {
  _0x5cb03b = _0x5cb03b / 360, _0x2d07ed = _0x2d07ed / 100, _0x482f27 = _0x482f27 / 100;
  var _0x425b5e, _0x332354, _0x100c04, _0x1e5b99, _0xbd5109, _0x51c44e, _0x14711f, _0x79d69c;
  _0x1e5b99 = Math["floor"](_0x5cb03b * 6), _0xbd5109 = _0x5cb03b * 6 - _0x1e5b99, _0x51c44e = _0x482f27 * (1 - _0x2d07ed), _0x14711f = _0x482f27 * (1 - _0xbd5109 * _0x2d07ed), _0x79d69c = _0x482f27 * (1 - (1 - _0xbd5109) * _0x2d07ed);
  switch (_0x1e5b99 % 6) {
    case 0:
      _0x425b5e = _0x482f27, _0x332354 = _0x79d69c, _0x100c04 = _0x51c44e;
      break;
    case 1:
      _0x425b5e = _0x14711f, _0x332354 = _0x482f27, _0x100c04 = _0x51c44e;
      break;
    case 2:
      _0x425b5e = _0x51c44e, _0x332354 = _0x482f27, _0x100c04 = _0x79d69c;
      break;
    case 3:
      _0x425b5e = _0x51c44e, _0x332354 = _0x14711f, _0x100c04 = _0x482f27;
      break;
    case 4:
      _0x425b5e = _0x79d69c, _0x332354 = _0x51c44e, _0x100c04 = _0x482f27;
      break;
    case 5:
      _0x425b5e = _0x482f27, _0x332354 = _0x51c44e, _0x100c04 = _0x14711f;
      break;
  }
  return {
    r: Math["round"](_0x425b5e * 255),
    g: Math["round"](_0x332354 * 255),
    b: Math["round"](_0x100c04 * 255)
  };
}
function isHexColor(_0x425b48) {
  return typeof _0x425b48 === "string" && (_0x425b48["length"] === 3 || _0x425b48["length"] === 6) && !isNaN(Number("0x" + _0x425b48));
}
function sizeToName(_0x3b33c5) {
  if (_0x3b33c5 >= 0 && _0x3b33c5 <= 767) return "xs"; else {
    if (_0x3b33c5 >= 768 && _0x3b33c5 <= 991) return "sm"; else return _0x3b33c5 >= 992 && _0x3b33c5 <= 1199 ? "md" : "lg";
  }
}
function cropImage(_0x21717d, _0xf61bda, _0x1832ff, _0x398cac, _0x5e39d7) {
  _0xf61bda = parseInt(_0xf61bda), _0x1832ff = parseInt(_0x1832ff);
  var _0x50c7b5 = $("<canvas />");
  _0x50c7b5.attr("width", _0x398cac), _0x50c7b5.attr("height", _0x5e39d7);
  var _0x50d529 = _0x50c7b5[0]["getContext"]("2d");
  _0x50d529.drawImage(_0x21717d, _0xf61bda, _0x1832ff, _0x398cac, _0x5e39d7, 0, 0, _0x398cac, _0x5e39d7);
  var _0x8add46 = _0x50c7b5[0]["toDataURL"]("image/png");
  return _0x50c7b5.remove(), _0x8add46;
}
function getLimits(_0x307082) {
  var _0x508b8f = _0x307082[0],
    _0x152473 = _0x307082[0];
  for (var _0x453895 = 1; _0x453895 < _0x307082["length"]; _0x453895++) {
    if (_0x307082[_0x453895] > _0x152473) _0x152473 = _0x307082[_0x453895];
    if (_0x307082[_0x453895] < _0x508b8f) _0x508b8f = _0x307082[_0x453895];
  }
  return new Point(_0x508b8f, _0x152473);
}
function imagedataEqual(_0x1af2bc, _0x13b62e, _0x2c9401, _0xbfb11f) {
  for (var _0x3fee81 = 0; _0x3fee81 < _0x1af2bc["length"]; _0x3fee81++) {
    for (var _0x2e019b = 0; _0x2e019b < _0x2c9401; _0x2e019b++) {
      for (var _0x4e8092 = 0; _0x4e8092 < _0xbfb11f; _0x4e8092++) {
        var _0xa3802b = getPixel(_0x1af2bc[_0x3fee81], _0x2e019b, _0x4e8092),
          _0x44234e = getPixel(_0x13b62e[_0x3fee81], _0x2e019b, _0x4e8092);
        if (!(_0xa3802b[0] == _0x44234e[0] && _0xa3802b[1] == _0x44234e[1] && _0xa3802b[2] == _0x44234e[2] && _0xa3802b[3] == _0x44234e[3])) return false;
      }
    }
  }
  return true;
}
function getPixelIndex(_0x3aa269, _0x249942) {
  var _0x531b7e = _0x3aa269["data"],
    _0x171407 = _0x249942 * 4;
  return [_0x531b7e[_0x171407], _0x531b7e[_0x171407 + 1], _0x531b7e[_0x171407 + 2], _0x531b7e[_0x171407 + 3]];
}
function getPixel(_0x97835f, _0x383894, _0x5c74c9) {
  return getPixelIndex(_0x97835f, _0x5c74c9 * _0x97835f["width"] + _0x383894);
}
function blurPercentage(_0x38aa28) {
  var _0x1f1dca = 10;
  return parseInt(_0x38aa28 * 100 / _0x1f1dca);
}
function yesnoFunction(_0x22e83a) {
  return _0x22e83a ? textManager["getString"]("global.lblYes") : textManager["getString"]("global.lblNo");
}
function lassoRectFunction(_0x31c4f4) {
  return _0x31c4f4 ? textManager.getString("global.lblLasso") : textManager["getString"]("global.lblRectangle");
}
function canvas2blob(_0x11a8bc) {
  var _0x2fddf2 = atob(_0x11a8bc["split"](",")[1]),
    _0x485390 = new Uint8Array(_0x2fddf2["length"]);
  for (var _0x305ff7 = 0; _0x305ff7 < _0x2fddf2.length; _0x305ff7++) {
    _0x485390[_0x305ff7] = _0x2fddf2["charCodeAt"](_0x305ff7);
  }
  return new Blob([_0x485390], {
    type: "image/png"
  });
}
function tooltipShortcut(_0x1f53b5) {
  var _0x2394de = _0x1f53b5[0];
  if (_0x1f53b5["length"] > 1) {
    var _0x2a8998 = UI["shortcutManager"]["getShortcut"](_0x1f53b5[1]);
    if (_0x2a8998) return textManager["getString"](_0x2394de) + "<br />" + (_0x2a8998["shortcut2"] ? textManager["getString"]("global.shortcut.lblOr", [shortcutToKeys(_0x2a8998["shortcut"]), shortcutToKeys(_0x2a8998["shortcut2"])], false) : shortcutToKeys(_0x2a8998["shortcut"]));
  }
  return textManager["getString"](_0x2394de);
}
function tooltipText(_0x52fd2d) {
  var _0x321ea2 = _0x52fd2d[0];
  return textManager["getString"](_0x321ea2);
}
function colorBubbleTooltip(_0xa9a418) {
  var _0x2a9826 = UI["bottombar"].colorBubbles["getColor"](_0xa9a418),
    _0x1c412f = "<div class=\"params\">";
  return _0x2a9826 && (_0x1c412f += "<div class=\"paramRow\"><div class=\"paramName\">" + textManager.getString("global.lblColor") + '</div><div class="paramValue" style="background-color: ' + _0x2a9826.color + "\">&nbsp;</div></div>"), _0x1c412f += tooltipShortcut(["", "pickcolor" + (_0xa9a418 + 1)]), _0x1c412f += "</div>", _0x1c412f;
}
function presetBubbleTooltip(_0x2b74f8) {
  var _0x13d01f = UI["sidebar"]["presets"]["getPreset"](_0x2b74f8),
    _0x286f85 = '<div class="params">';
  return _0x13d01f && (_0x286f85 += '<div class="paramRow"><div class="paramName">' + textManager.getString("global.lblTool") + "</div><div class=\"paramValue\">" + UI["brushToIcon"](_0x13d01f.brush)["html"]() + " " + UI["brushToName"](_0x13d01f["brush"]) + "</div></div>", _0x286f85 += '<div class="paramRow"><div class="paramName">' + textManager.getString("global.lblColor") + "</div><div class=\"paramValue\" style=\"background-color: " + _0x13d01f["color"] + '">&nbsp;</div></div>', $["each"](_0x13d01f["options"], function (_0x1c8827, _0x3e0a3a) {
    var _0x2b04bd = UI["optionToObject"](_0x1c8827, _0x3e0a3a);
    if (!_0x2b04bd.hidden) {
      if (_0x3e0a3a === true) _0x3e0a3a = textManager.getString("global.lblYes"); else _0x3e0a3a === false && (_0x3e0a3a = textManager["getString"]("global.lblNo"));
      _0x2b04bd["callbackFunction"] && (_0x3e0a3a = _0x2b04bd.callbackFunction(_0x3e0a3a)), _0x2b04bd["type"] == "list" && (_0x3e0a3a = _0x2b04bd["list"][_0x3e0a3a]), _0x286f85 += "<div class=\"paramRow\"><div class=\"paramName\">" + UI["optionToName"](_0x1c8827) + "</div><div class=\"paramValue\">" + _0x3e0a3a + "</div></div>";
    } else _0x1c8827 == "image" && (_0x286f85 += "<div class=\"paramRow\"><div class=\"paramName\">" + UI["optionToName"](_0x1c8827) + '</div><div class="paramValue"><img style="width: 30px; height: 30px; padding: 2px;" src="' + _0x3e0a3a + "\" /></div></div>");
  })), _0x286f85 += tooltipShortcut(["", "loadpreset" + (_0x2b74f8 + 1)]), _0x286f85 += "</div>", _0x286f85;
}
function openBrushDesigner() {
  UI["dialogHandler"].showDialog("brushdesigner"), UI["brushDesignerDialog"]["setImage"](room["myself"]["surface"].brushHandler["brush"]["getOption"]("image"));
}
function openBrushGallery() {
  UI.dialogHandler["showDialog"]("brushgallery");
}
function angleSnap(_0x7ab342) {
  _0x7ab342 = _0x7ab342 % 360 + 180;
  if (_0x7ab342 <= 22.5 || _0x7ab342 >= 337.5) _0x7ab342 = 0; else {
    if (_0x7ab342 <= 67.5) _0x7ab342 = 45; else {
      if (_0x7ab342 <= 112.5) _0x7ab342 = 90; else {
        if (_0x7ab342 <= 157.5) _0x7ab342 = 135; else {
          if (_0x7ab342 <= 202.5) _0x7ab342 = 180; else {
            if (_0x7ab342 <= 247.5) _0x7ab342 = 225; else {
              if (_0x7ab342 <= 292.5) _0x7ab342 = 270; else {
                if (_0x7ab342 < 337.5) _0x7ab342 = 315;
              }
            }
          }
        }
      }
    }
  }
  return _0x7ab342 -= 180, _0x7ab342;
}
function rot13(_0x379013) {
  var _0x17b7e4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    _0xceddc = "NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm",
    _0x311db9 = _0x3f9de0 => _0x17b7e4["indexOf"](_0x3f9de0),
    _0x4b3c98 = _0x3bf7ae => _0x311db9(_0x3bf7ae) > -1 ? _0xceddc[_0x311db9(_0x3bf7ae)] : _0x3bf7ae;
  return _0x379013["split"]("")["map"](_0x4b3c98).join("");
}
function encryptMessage(_0x36f537, _0x5e597c = "none") {
  return _0x5e597c == "rot13" && (_0x36f537 = rot13(_0x36f537)), _0x36f537;
}
function decryptMessage(_0x17e229, _0xc2d07 = "none") {
  return _0xc2d07 == "rot13" && (_0x17e229 = rot13(_0x17e229)), _0x17e229;
}
function firstMatch(_0x73e110, _0x2e721f) {
  var _0x17dfe9 = null;
  return $.each(_0x73e110, function (_0x4567be, _0x5f9352) {
    _0x17dfe9 == null && _0x2e721f["indexOf"](_0x5f9352) > -1 && (_0x17dfe9 = _0x5f9352);
  }), _0x17dfe9;
}
function processSizes(_0x118953) {
  var _0x2f369b = ["xs", "sm", "md", "lg", "xl", "xxl"],
    _0x209cfc = {};
  $.each(_0x2f369b, function (_0x26db8c, _0x3d2e1d) {
    _0x209cfc[_0x3d2e1d] = _0x118953[_0x3d2e1d] ? _0x118953[_0x3d2e1d] : 0;
  });
  var _0x530aa3 = true,
    _0xa6667b = 0;
  return $["each"](_0x209cfc, function (_0x111d6e, _0x1e52f4) {
    _0x1e52f4 != 0 && (_0x530aa3 = false, _0xa6667b == 0 && (_0xa6667b = _0x1e52f4));
  }), _0x530aa3 ? null : (_0x209cfc[_0x2f369b[0]] == 0 && (_0x209cfc[_0x2f369b[0]] = _0xa6667b), $["each"](_0x209cfc, function (_0x17356f, _0x539a41) {
    if (_0x2f369b["indexOf"](_0x17356f) < _0x2f369b["length"] - 1) {
      var _0xa3fecd = _0x2f369b[_0x2f369b["indexOf"](_0x17356f) + 1];
      _0x209cfc[_0xa3fecd] == 0 && (_0x209cfc[_0xa3fecd] = _0x539a41);
    }
  }), _0x209cfc);
}
function formatHour(_0x4e6581, _0x35d642 = true, _0x521cac = true) {
  var _0x335504 = dateToObj(moment["unix"](_0x4e6581)),
    _0x4d6a89 = [];
  for (var _0xf3921b = 1; _0xf3921b <= 12; _0xf3921b++) {
    _0x4d6a89["push"](textManager["getString"]("global.months." + _0xf3921b, null, _0x521cac));
  }
  var _0x1abc2d = _0x335504.year,
    _0x594f78 = _0x4d6a89[parseInt(_0x335504.month) - 1],
    _0x35d642 = parseInt(_0x335504.day)["toString"](),
    _0xa175a5 = _0x335504["hours"],
    _0x3a26d9 = _0x335504["minutes"],
    _0x5e896e = _0x335504["seconds"],
    _0x37c032 = _0xa175a5 + ":" + _0x3a26d9;
  if (_0x35d642) {
    var _0xc41b4a = dateToObj(moment["unix"](Date["now"]() / 1e3)),
      _0x4d2287 = dateToObj(moment["unix"](Date["now"]() / 1e3 - 86400)),
      _0x33a597 = "";
    if (_0xc41b4a["year"] == _0x335504["year"] && _0xc41b4a["month"] == _0x335504["month"] && _0xc41b4a["day"] == _0x335504["day"]) _0x33a597 = textManager["getString"]("global.days.today", null, _0x521cac); else _0x4d2287["year"] == _0x335504["year"] && _0x4d2287["month"] == _0x335504["month"] && _0x4d2287["day"] == _0x335504["day"] ? _0x33a597 = textManager["getString"]("global.days.yesterday", null, _0x521cac) : _0x33a597 = _0x35d642 + " " + _0x594f78 + " " + _0x1abc2d;
    _0x37c032 = _0x37c032 + " | " + _0x33a597;
  }
  return _0x37c032;
}
function formatTimestamp(_0x1c730f, _0x55d2a4 = true) {
  var _0x4d17d8 = dateToObj(moment.unix(_0x1c730f)),
    _0x4f304e = [];
  for (var _0x4ee013 = 1; _0x4ee013 <= 12; _0x4ee013++) {
    _0x4f304e.push(textManager.getString("global.months." + _0x4ee013, null, _0x55d2a4));
  }
  var _0x142b69 = _0x4d17d8.year,
    _0x702b04 = _0x4f304e[parseInt(_0x4d17d8.month) - 1],
    _0x37adbe = parseInt(_0x4d17d8["day"])["toString"](),
    _0x3a97de = _0x4d17d8["hours"],
    _0x31aeec = _0x4d17d8["minutes"],
    _0x114f34 = _0x4d17d8.seconds;
  return _0x37adbe + " " + _0x702b04 + " " + _0x142b69 + " " + _0x3a97de + ":" + _0x31aeec;
}
function formatSeconds(_0x2a745d) {
  var _0x5dd61d = Math["floor"](_0x2a745d / 3600),
    _0x5816e5 = Math.floor(_0x2a745d % 3600 / 60),
    _0xbab6cd = Math.ceil(_0x2a745d % 3600 % 60),
    _0x1b4c93 = "";
  if (_0x5dd61d >= 1) _0x1b4c93 += " " + textManager["getString"]("global.lengths.lblHour", _0x5dd61d, false);
  if (_0x5816e5 >= 1) _0x1b4c93 += " " + textManager["getString"]("global.lengths.lblMinute", _0x5816e5, false);
  return _0x1b4c93 += " " + textManager.getString("global.lengths.lblSecond", _0xbab6cd, false), _0x1b4c93["substr"](1);
}
function dateToObj(_0x2e7e1e = null) {
  _0x2e7e1e == null && (_0x2e7e1e = moment());
  var _0x553d58 = {};
  return _0x553d58["year"] = _0x2e7e1e["format"]("YYYY"), _0x553d58["month"] = _0x2e7e1e["format"]("MM"), _0x553d58["day"] = _0x2e7e1e["format"]("DD"), _0x553d58.hours = _0x2e7e1e.format("HH"), _0x553d58["minutes"] = _0x2e7e1e.format("mm"), _0x553d58["seconds"] = _0x2e7e1e["format"]("ss"), _0x553d58;
}
function formatDateString(_0xc16db9) {
  var _0xc16db9 = moment();
  return _0xc16db9["format"]("YYYYMMDDHHmmss");
}
function hash(_0xe57a3c) {
  var _0x4cebcb = 0,
    _0x503fc4,
    _0x10a12e;
  if (_0xe57a3c["length"] === 0) return _0x4cebcb;
  for (_0x503fc4 = 0; _0x503fc4 < _0xe57a3c.length; _0x503fc4++) {
    _0x10a12e = _0xe57a3c["charCodeAt"](_0x503fc4), _0x4cebcb = (_0x4cebcb << 5) - _0x4cebcb + _0x10a12e, _0x4cebcb |= 0;
  }
  return _0x4cebcb;
}
function getNewListOfObjects(_0x260203, _0x11baa0) {
  var _0x4ced6b = [];
  return $["each"](_0x260203, function (_0x5f2f71, _0x5ecd5c) {
    _0x4ced6b["push"](getNewObject(_0x5ecd5c, _0x11baa0));
  }), _0x4ced6b;
}
function getNewObject(_0x58c288, _0x558dda) {
  var _0x121733 = {};
  return $["each"](_0x58c288, function (_0x582993, _0x2ea8dc) {
    _0x558dda["indexOf"](_0x582993) > -1 && (_0x121733[_0x582993] = _0x2ea8dc);
  }), _0x121733;
}
function calculateAspectRatioFit(_0x48b15a, _0x393056, _0x4fb073, _0x2814f6) {
  var _0x3cea74 = Math.min(_0x4fb073 / _0x48b15a, _0x2814f6 / _0x393056);
  return {
    width: _0x48b15a * _0x3cea74,
    height: _0x393056 * _0x3cea74
  };
}
function getRadialAvg(_0x4b49e9, _0x3e9113, _0x32816c, _0x352597, _0x74d5cb = "#FFFFFF") {
  var _0x17a5e4 = _0x352597 * _0x352597,
    _0x349cb5 = 0,
    _0x24adc9 = 0,
    _0x36ab82 = 0,
    _0x365189 = 0,
    _0x2b6fa2 = 0,
    _0x7432c7 = [];
  for (var _0x566cca = -_0x352597; _0x566cca <= _0x352597; _0x566cca++) {
    for (var _0x1d7c6e = -_0x352597; _0x1d7c6e <= _0x352597; _0x1d7c6e++) {
      if (_0x1d7c6e * _0x1d7c6e + _0x566cca * _0x566cca < _0x17a5e4) {
        if (!(_0x3e9113 + _0x1d7c6e < 0 || _0x3e9113 + _0x1d7c6e > _0x4b49e9["width"] || _0x32816c + _0x566cca > _0x4b49e9.height || _0x32816c + _0x566cca < 0)) {
          _0x7432c7 = getPixel(_0x4b49e9, parseInt(_0x3e9113 + _0x1d7c6e), parseInt(_0x32816c + _0x566cca));
          if (_0x7432c7[0] == 0 && _0x7432c7[1] == 0 && _0x7432c7[2] == 0 && _0x7432c7[3] == 0 || _0x7432c7[0] == undefined && _0x7432c7[1] == undefined && _0x7432c7[2] == undefined && _0x7432c7[3] == undefined) {
            var _0x48a600 = hex2rgb(_0x74d5cb);
            _0x7432c7 = [_0x48a600.r, _0x48a600.g, _0x48a600.b, 255];
          }
          _0x349cb5 += _0x7432c7[0], _0x24adc9 += _0x7432c7[1], _0x36ab82 += _0x7432c7[2], _0x365189 += _0x7432c7[3], _0x2b6fa2++;
        }
      }
    }
  }
  return [parseInt(_0x349cb5 / _0x2b6fa2), parseInt(_0x24adc9 / _0x2b6fa2), parseInt(_0x36ab82 / _0x2b6fa2), parseInt(_0x365189 / _0x2b6fa2)];
}
function leadingZeros(_0x293764, _0xa0bd3c = 1) {
  var _0x501bdd = _0x293764["toString"](),
    _0x5d44a4 = "";
  for (var _0x16b026 = Math["max"](_0x501bdd.length, _0xa0bd3c) - 1; _0x16b026 >= 0; _0x16b026--) {
    _0x5d44a4 += _0x16b026 < _0x501bdd.length ? _0x501bdd[_0x16b026] : "0";
  }
  return _0x5d44a4;
}
function loopValue(_0x3713f2, _0x24af8c) {
  do {
    if (_0x3713f2 >= _0x24af8c) _0x3713f2 = _0x3713f2 - _0x24af8c; else _0x3713f2 < 0 && (_0x3713f2 = _0x24af8c + _0x3713f2);
  } while (_0x3713f2 > _0x24af8c || _0x3713f2 < 0);
  return _0x3713f2;
}
function parseURL(_0x323e46) {
  var _0x40b8d6 = /(https?:\/\/[^\s]+)/g;
  return _0x323e46.replace(_0x40b8d6, function (_0x2581a3) {
    return '<a href="' + _0x2581a3 + "\" target=\"_blank\">" + _0x2581a3 + "</a>";
  });
}
function nl2br(_0x59690e, _0x101513) {
  if (typeof _0x59690e === "undefined" || _0x59690e === null) return "";
  var _0x5de4f4 = _0x101513 || typeof _0x101513 === "undefined" ? "<br />" : "<br>";
  return (_0x59690e + "").replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g, "$1" + _0x5de4f4 + "$2");
}
function shortcutToKeys(_0x4ddc07) {
  var _0x17562c = "";
  if (_0x4ddc07 && _0x4ddc07 != "") {
    var _0x11beca;
    _0x4ddc07["charAt"](_0x4ddc07["length"] - 1) == UI["shortcutManager"]["keySeparator"] ? (_0x11beca = _0x4ddc07.substring(0, _0x4ddc07["length"] - 1)["split"](UI["shortcutManager"].keySeparator), _0x11beca.length == 0 ? _0x11beca["push"](UI["shortcutManager"].keySeparator) : _0x11beca[_0x11beca.length - 1] += UI.shortcutManager["keySeparator"]) : _0x11beca = _0x4ddc07["split"](UI["shortcutManager"].keySeparator);
    var _0x57a91f = "";
    $["each"](_0x11beca, function (_0x5420f6, _0x306080) {
      _0x17562c += _0x57a91f + "<kbd>" + _0x306080 + "</kbd>", _0x57a91f = " + ";
    });
  }
  return _0x17562c;
}
function isValidIP(_0x407849) {
  var _0x11a925 = _0x407849["split"](".");
  let _0x1ebaf7 = _0x11a925["length"] == 4;
  var _0x2d5ec3 = _0x407849["split"](":");
  let _0x36879f = _0x2d5ec3.length >= 4;
  return _0x1ebaf7 || _0x36879f;
}
function getExtension(_0x43bc77) {
  return _0x43bc77["split"](".").pop()["toUpperCase"]();
}
function randomElement(_0x50de94) {
  return _0x50de94[Math["floor"](Math["random"]() * _0x50de94["length"])];
}
function rgba2rgb(_0xe3e02, _0x68a3f3, _0x54a657, _0x459beb = 1) {
  var _0x5d5f11 = {};
  if (_0x459beb != 1) {
    var _0x30a513 = 1 - _0x459beb,
      _0x50e243 = 255,
      _0x5e3359 = 255,
      _0x9ec3e6 = 255;
    _0x5d5f11.r = Math["round"]((_0x459beb * (_0xe3e02 / 255) + _0x30a513 * (_0x50e243 / 255)) * 255), _0x5d5f11.g = Math["round"]((_0x459beb * (_0x68a3f3 / 255) + _0x30a513 * (_0x5e3359 / 255)) * 255), _0x5d5f11.b = Math.round((_0x459beb * (_0x54a657 / 255) + _0x30a513 * (_0x9ec3e6 / 255)) * 255);
  } else _0x5d5f11.r = _0xe3e02, _0x5d5f11.g = _0x68a3f3, _0x5d5f11.b = _0x54a657;
  return _0x5d5f11;
}
function escapeHTML(_0x465a41) {
  if (typeof _0x465a41 === "string") {
    var _0xe8aa04 = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#039;"
    };
    return _0x465a41.replace(/[&<>"']/g, function (_0x537269) {
      return _0xe8aa04[_0x537269];
    });
  }
  return _0x465a41;
}
function unescapeHTML(_0x532bb6) {
  return _0x532bb6["replace"](/&amp;/g, "&")["replace"](/&lt;/g, "<")["replace"](/&gt;/g, ">")["replace"](/&quot;/g, '"')["replace"](/&#039;/g, "'");
}
function matches(_0x325d49, _0x103ca3) {
  if ($["isArray"](_0x325d49)) {
    if (_0x325d49["length"] == _0x103ca3.length) {
      var _0x5cf789 = true;
      return $.each(_0x325d49, function (_0xff1a22, _0x4f6f16) {
        (!(_0xff1a22 in _0x103ca3) || _0x4f6f16 != _0x103ca3[_0xff1a22]) && (_0x5cf789 = false);
      }), _0x5cf789;
    }
  } else return _0x325d49 == _0x103ca3;
  return false;
}
function inArray(_0x38e4b7, _0x160dbb) {
  let _0x436580 = false;
  return $["each"](_0x160dbb, function (_0x55b5a3, _0x596554) {
    _0x596554 == _0x38e4b7 && (_0x436580 = true);
  }), _0x436580;
}
function getRoomFromURL(_0x2d2b46) {
  var _0x2c51d7 = new RegExp("/" + _0x2d2b46 + "/([^#/]*)")["exec"](window["location"].href);
  if (_0x2c51d7 == null) return null;
  return decodeURI(_0x2c51d7[1]) || "";
}
function isIPv4(_0x4feaa2) {
  return _0x4feaa2["split"](".")["length"] == 4;
}
function getLengthDescription(_0x1269f0) {
  let _0x447053;
  if (_0x1269f0 == 0) _0x447053 = textManager.getString("global.lengths.lblPermanent", null, false); else {
    if (parseInt(_0x1269f0 / 60 / 60) <= 0) _0x447053 = textManager["getString"]("global.lengths.lblMinute", parseInt(_0x1269f0 / 60), false); else {
      if (parseInt(_0x1269f0 / 60 / 60 / 24) <= 0) _0x447053 = textManager["getString"]("global.lengths.lblHour", parseInt(_0x1269f0 / 60 / 60), false); else {
        if (parseInt(_0x1269f0 / 60 / 60 / 24 / 7) <= 0) _0x447053 = textManager["getString"]("global.lengths.lblDay", parseInt(_0x1269f0 / 60 / 60 / 24), false); else {
          if (parseInt(_0x1269f0 / 60 / 60 / 24 / 30) <= 0) _0x447053 = textManager["getString"]("global.lengths.lblWeek", parseInt(_0x1269f0 / 60 / 60 / 24 / 7), false); else parseInt(_0x1269f0 / 60 / 60 / 24 / 365) <= 0 ? _0x447053 = textManager["getString"]("global.lengths.lblMonth", parseInt(_0x1269f0 / 60 / 60 / 24 / 30), false) : _0x447053 = textManager["getString"]("global.lengths.lblYear", parseInt(_0x1269f0 / 60 / 60 / 24 / 365), false);
        }
      }
    }
  }
  return _0x447053;
}
function formatNumber(_0x23388b, _0x1ff9d4 = 2) {
  var _0x1c5e54 = 10 ^ _0x1ff9d4;
  return parseInt(_0x23388b * _0x1c5e54) / _0x1c5e54;
}
function setCaretPosition(_0x5b36c2, _0x19126d) {
  if (typeof _0x5b36c2["selectionStart"] == "number") _0x5b36c2["selectionStart"] = _0x5b36c2["selectionEnd"] = _0x19126d; else {
    if (typeof _0x5b36c2["createTextRange"] != "undefined") {
      _0x5b36c2.focus();
      var _0x174a5d = _0x5b36c2["createTextRange"]();
      _0x174a5d["collapse"](false), _0x174a5d["select"]();
    }
  }
}
function getCaretPosition(_0x490b3e) {
  var _0x1a8f97 = 0;
  if (document.selection) {
    _0x490b3e["focus"]();
    var _0x4af81e = document.selection.createRange();
    _0x4af81e["moveStart"]("character", -_0x490b3e.value["length"]), _0x1a8f97 = _0x4af81e.text.length;
  } else (_0x490b3e["selectionStart"] || _0x490b3e["selectionStart"] == "0") && (_0x1a8f97 = _0x490b3e["selectionStart"]);
  return _0x1a8f97;
}
class UserPreferences {
  constructor(_0x22e369 = null) {
    this["storage"] = _0x22e369, this["preferences"] = {}, this["preferences"]["groupOptions"] = {}, this["preferences"].properties = {}, this["preferences"]["sidebarOrder"] = [], this["preferences"]["sidebarComponentsCollapsed"] = {}, this["preferences"]["sidebarComponentsHeight"] = {}, this.loadFromStorage();
  }
  ["hasGroupOption"](_0x34197d, _0x462d68) {
    return _0x34197d in this["preferences"]["groupOptions"] && _0x462d68 in this.preferences.groupOptions[_0x34197d];
  }
  ["getGroupOption"](_0x47c631, _0x4a2dc2, _0x21b9a4 = null) {
    if (this["hasGroupOption"](_0x47c631, _0x4a2dc2)) return this["preferences"].groupOptions[_0x47c631][_0x4a2dc2];
    return _0x21b9a4;
  }
  ["setGroupOptions"](_0xfac7ce, _0x1d2d99) {
    var _0x799cd0 = this;
    $["each"](_0x1d2d99, function (_0x530b00, _0x3b42fd) {
      !(_0xfac7ce in _0x799cd0["preferences"]["groupOptions"]) && (_0x799cd0["preferences"].groupOptions[_0xfac7ce] = {}), _0x799cd0["preferences"]["groupOptions"][_0xfac7ce][_0x530b00] = _0x3b42fd;
    }), this["saveToStorage"]();
  }
  ["hasProperty"](_0x547f74) {
    return _0x547f74 in this["preferences"]["properties"];
  }
  ["getProperty"](_0x34410f, _0x719e83 = null) {
    if (this.hasProperty(_0x34410f)) return this["preferences"]["properties"][_0x34410f];
    return _0x719e83;
  }
  ["setProperty"](_0x2acc11, _0x42c291) {
    this["preferences"]["properties"][_0x2acc11] = _0x42c291, this["saveToStorage"]();
  }
  ["setSidebarOrder"](_0x2a9e69) {
    this["preferences"]["sidebarOrder"] = _0x2a9e69, this["saveToStorage"]();
  }
  ["setSidebarComponentCollapsed"](_0x52546c, _0x3f8919) {
    this["preferences"]["sidebarComponentsCollapsed"][_0x52546c] = _0x3f8919, this["saveToStorage"]();
  }
  ["setSidebarComponentHeight"](_0x40f8da, _0x599182) {
    this["preferences"].sidebarComponentsHeight[_0x40f8da] = _0x599182, this["saveToStorage"]();
  }
  ["loadFromStorage"]() {
    if (this.storage) {
      var _0x55c1d7 = this["storage"].getParameter("preferences");
      _0x55c1d7 && (this["preferences"] = JSON["parse"](_0x55c1d7), this.preferences["groupOptions"] === undefined && (this["preferences"]["groupOptions"] = {}), this["preferences"].properties === undefined && (this.preferences["properties"] = {}), this["preferences"].sidebarOrder === undefined && (this["preferences"].sidebarOrder = []), this["preferences"]["sidebarComponentsCollapsed"] === undefined && (this["preferences"]["sidebarComponentsCollapsed"] = {}), this["preferences"]["sidebarComponentsHeight"] === undefined && (this.preferences["sidebarComponentsHeight"] = {}));
    }
  }
  ["saveToStorage"]() {
    this["storage"] && this["storage"]["setParameter"]("preferences", JSON.stringify(this["preferences"]));
  }
}
class Transfer {
  constructor(_0x186c3e, _0x39e29b, _0x19c4a9, _0x54ac31, _0x331f18 = false) {
    this.targettype = _0x186c3e, this["username"] = _0x39e29b, this["ttype"] = _0x19c4a9, this["timestamp"] = _0x54ac31, this["currentLayerId"], this["layers"] = new Array(), this["mask"] = new Array(), this["completed"] = false, this["failed"] = false, this["intTimeout"] = null, this["secTimeout"] = 15, this.sending = _0x331f18, this["maxLength"] = 1e5;
  }
  ["matches"](_0x29a6dd, _0x531ef5, _0x3d68fb, _0x4c8cb6) {
    return this["targettype"] == _0x29a6dd && this["username"] == _0x531ef5 && this.ttype == _0x3d68fb && this["timestamp"] == _0x4c8cb6;
  }
  ["receive"](_0x3ab14a, _0x23dbe4, _0x293ad1, _0x3d01c3, _0x5cfa6d, _0x5480a8, _0x1e8375, _0x317a91, _0x3a86f6, _0x3f3386) {
    !this["existsLayer"](_0x3ab14a) && this["addLayer"](_0x3ab14a, _0x5cfa6d, _0x5480a8, _0x1e8375, _0x317a91, _0x3a86f6);
    var _0x3266b6 = this["getLayerId"](_0x3ab14a);
    if (_0x3266b6 != null) {
      this.layers[_0x3266b6].data += _0x3f3386, this.layers[_0x3266b6]["position"] = _0x293ad1, this["layers"][_0x3266b6]["max"] = _0x3d01c3, $(this)["triggerHandler"](new transferProgressEvent(this["targettype"], this["username"], this["ttype"], this["timestamp"], _0x3266b6 + 1, _0x23dbe4, this["layers"][_0x3266b6].position, this.layers[_0x3266b6].max)["getEvent"]());
      if (this["layers"][_0x3266b6]["position"] == this["layers"][_0x3266b6]["max"]) {
        $(this)["triggerHandler"](new transferLayerCompleteEvent(this["targettype"], this["username"], this.ttype, this["timestamp"], _0x3ab14a, this["layers"][_0x3266b6].x, this["layers"][_0x3266b6].y, this.layers[_0x3266b6]["width"], this["layers"][_0x3266b6]["height"], this["layers"][_0x3266b6].rotation, this["mask"], this["layers"][_0x3266b6]["data"])["getEvent"]());
        if (this["layers"]["length"] == _0x23dbe4) {
          this["completed"] = true;
          var _0x442204 = this["layers"][_0x3266b6]["width"] == room.board["canvasWidth"] && this["layers"][_0x3266b6]["height"] == room["board"]["canvasHeight"];
          $(this).triggerHandler(new transferCompleteEvent(this["targettype"], this["username"], this["ttype"], this["timestamp"], _0x442204)["getEvent"]());
        }
      }
    }
    this.refreshTimeout();
  }
  ["refreshTimeout"]() {
    var _0x304886 = this;
    this["intTimeout"] && clearTimeout(this["intTimeout"]), this["intTimeout"] = setTimeout(function () {
      _0x304886["fail"]();
    }, _0x304886.secTimeout * 1e3);
  }
  ["addData"](_0xcce34c, _0x402efa, _0x119a5c, _0x2707c0, _0x1fc6a1, _0x47f471, _0x4c3328) {
    !this.existsLayer(_0xcce34c) && this["addLayer"](_0xcce34c, _0x402efa, _0x119a5c, _0x2707c0, _0x1fc6a1, _0x47f471);
    var _0x4bc43a = this.getLayerId(_0xcce34c);
    this.layers[_0x4bc43a]["data"] = _0x4c3328, this["layers"][_0x4bc43a]["max"] = Math["ceil"](_0x4c3328["length"] / this.maxLength);
  }
  ["addMask"](_0x1c437b) {
    this["mask"] = _0x1c437b;
  }
  ["send"]() {
    this["currentLayerId"] = 0, this["firstPart"]();
  }
  ["firstPart"]() {
    return $(this)["triggerHandler"](new transferStartEvent(this["targettype"], this["username"], this["ttype"], this.timestamp, this["mask"]).getEvent()), true;
  }
  ["nextPart"]() {
    var _0x4e521b = this["layers"][this.currentLayerId];
    if (_0x4e521b) {
      _0x4e521b.position++;
      if (_0x4e521b.position <= _0x4e521b["max"]) {
        var _0x2e2833 = _0x4e521b.data["substr"]((_0x4e521b["position"] - 1) * this["maxLength"], this["maxLength"]);
        return $(this).triggerHandler(new transferChunkReadyEvent(this["targettype"], this["username"], this["ttype"], this["timestamp"], _0x4e521b["number"], this["layers"]["length"], _0x4e521b["position"], _0x4e521b["max"], _0x4e521b.x, _0x4e521b.y, _0x4e521b["width"], _0x4e521b["height"], _0x4e521b.rotation, _0x2e2833)["getEvent"]()), _0x4e521b["position"] == _0x4e521b["max"] && this.currentLayerId++, true;
      }
    }
    return false;
  }
  ["fail"]() {
    this["failed"] = true, $(this)["triggerHandler"](new transferFailEvent(this["targettype"], this["username"], this["ttype"], this.timestamp).getEvent());
  }
  ["getLayerId"](_0xb9193) {
    var _0x31d542 = null;
    return $["each"](this["layers"], function (_0x41c6c0, _0x2cfccf) {
      _0x2cfccf["number"] == _0xb9193 && (_0x31d542 = _0x41c6c0);
    }), _0x31d542;
  }
  ["existsLayer"](_0x50b780) {
    var _0x4d10a0 = false;
    return $["each"](this.layers, function (_0x26a935, _0x54162a) {
      _0x54162a["number"] == _0x50b780 && (_0x4d10a0 = true);
    }), _0x4d10a0;
  }
  ["addLayer"](_0x5e042e, _0x598f9a, _0x4687e3, _0x16c928, _0x46d605, _0x77e96f) {
    this["layers"]["push"](new TransferLayer(_0x5e042e, 0, 0, _0x598f9a, _0x4687e3, _0x16c928, _0x46d605, _0x77e96f, ""));
  }
}
function rejectTransfer(_0x2926a8) {
  var _0x3e41cc = room.findTransfer(_0x2926a8.targettype, _0x2926a8["from"], _0x2926a8.ttype, _0x2926a8.timestamp);
  _0x3e41cc && _0x3e41cc["fail"]();
}
function processTransfer(_0x212151) {
  var _0x3ee7ea = room.findTransfer(_0x212151["targettype"], _0x212151["from"], _0x212151["ttype"], _0x212151["timestamp"]);
  !_0x3ee7ea && _0x212151["firstPart"] && (_0x3ee7ea = new Transfer(_0x212151["targettype"], _0x212151["from"], _0x212151["ttype"], _0x212151.timestamp), _0x212151["mask"] && _0x3ee7ea.addMask(_0x212151["mask"]), $(_0x3ee7ea).on("transferLayerComplete", transferLayerComplete), $(_0x3ee7ea).on("transferComplete", transferComplete), $(_0x3ee7ea).on("transferProgress", transferProgress), $(_0x3ee7ea).on("transferFail", transferFail), room["addTransfer"](_0x3ee7ea));
  if (_0x3ee7ea) {
    _0x212151.chunk && _0x3ee7ea["receive"](_0x212151.layer, _0x212151["layerCount"], _0x212151["position"], _0x212151["max"], _0x212151.x, _0x212151.y, _0x212151["width"], _0x212151["height"], _0x212151["rotation"], _0x212151["chunk"]);
    if (_0x212151["targettype"] != "BROADCAST" && _0x3ee7ea != null && !_0x3ee7ea["completed"]) {
      var _0x31eb0e = {};
      _0x31eb0e.command = "DIRECT", _0x31eb0e["targettype"] = _0x212151["targettype"], _0x31eb0e["target"] = _0x212151["from"], _0x31eb0e["action"] = "PARTIALNEXT", _0x31eb0e["ttype"] = _0x212151.ttype, _0x31eb0e.timestamp = _0x212151["timestamp"], socket["send"](_0x31eb0e, true);
    }
  } else {
    var _0x31eb0e = {};
    _0x31eb0e.command = "DIRECT", _0x31eb0e["targettype"] = _0x212151["targettype"], _0x31eb0e["target"] = _0x212151.from, _0x31eb0e["action"] = "NOTHANKS", _0x31eb0e.ttype = _0x212151["ttype"], _0x31eb0e["timestamp"] = _0x212151.timestamp, socket["send"](_0x31eb0e, true);
  }
}
function transferFail(_0x315ec3) {
  UI["topbar"].progressBar["getName"]() == _0x315ec3["username"] + "," + _0x315ec3["ttype"] + "," + _0x315ec3.timestamp && (UI.topbar["progressBar"]["hide"](), UI["topbar"]["progressBar"]["setName"]("")), room["deleteTransfer"](_0x315ec3["username"], _0x315ec3.ttype, _0x315ec3["timestamp"]), _0x315ec3.ttype == "sync" && UI.firstSyncEnabled && UI.firstSyncUser == _0x315ec3["username"] && $(UI).triggerHandler(new firstSyncEndedEvent(_0x315ec3["username"], true)["getEvent"]());
}
function transferComplete(_0x151214) {
  UI.topbar["progressBar"]["getName"]() == _0x151214.username + "," + _0x151214.ttype + "," + _0x151214["timestamp"] && (UI.topbar["progressBar"]["setProgress"](100), setTimeout(function () {
    UI.topbar["progressBar"]["hide"](), UI["topbar"]["progressBar"]["setName"]("");
  }, 1e3));
  room.deleteTransfer(_0x151214["username"], _0x151214["ttype"], _0x151214["timestamp"]);
  if (_0x151214["ttype"] == "undo") {
    var _0x3734b6 = "events.txtUndo";
    !_0x151214["fullboard"] && (_0x3734b6 = "events.txtPartialUndo"), UI["chatDialog"]["registerEvent"](textManager["getString"](_0x3734b6, _0x151214["username"], false));
  } else {
    if (_0x151214["ttype"] == "sync") UI["chatDialog"].registerEvent(textManager["getString"]("events.txtSync", _0x151214["username"], false)); else _0x151214["ttype"] == "load" && UI["chatDialog"].registerEvent(textManager["getString"]("events.txtLoad", _0x151214.username, false));
  }
  _0x151214["ttype"] == "sync" && UI["firstSyncEnabled"] && UI.firstSyncUser == _0x151214["username"] && $(UI)["triggerHandler"](new firstSyncEndedEvent(_0x151214.username, false)["getEvent"]());
}
function transferLayerComplete(_0x5d3b91) {
  if (_0x5d3b91.ttype == "undo") _0x5d3b91.mask && _0x5d3b91["mask"].length > 0 ? room["board"]["clearMask"](_0x5d3b91.layer, _0x5d3b91.mask, -1) : room["board"].clearLayer(_0x5d3b91["layer"], -1); else _0x5d3b91.ttype == "sync" && room["board"]["clearLayer"](_0x5d3b91["layer"], -1);
  room["board"]["putLayerData"](_0x5d3b91["layer"], atob(_0x5d3b91["chunk"]), _0x5d3b91.x, _0x5d3b91.y, null, null, _0x5d3b91.rotation);
}
function transferProgress(_0x2baecb) {
  var _0x398b70 = 100 / _0x2baecb["layerCount"],
    _0x3f6cdd = _0x398b70 / _0x2baecb["max"] * (_0x2baecb["max"] - _0x2baecb["position"]),
    _0x52bd11 = _0x2baecb.layerPos * _0x398b70 - _0x3f6cdd,
    _0x43287c = UI.topbar.progressBar["getName"]();
  (!_0x43287c || _0x43287c == "" || _0x43287c == _0x2baecb["username"] + "," + _0x2baecb.ttype + "," + _0x2baecb.timestamp) && (UI["topbar"].progressBar["setName"](_0x2baecb.username + "," + _0x2baecb["ttype"] + "," + _0x2baecb["timestamp"]), UI.topbar["progressBar"]["setProgress"](_0x52bd11), UI["topbar"]["progressBar"].show()), _0x2baecb.ttype == "sync" && UI.firstSyncEnabled && UI["firstSyncUser"] == _0x2baecb.username && $(UI).triggerHandler(new firstSyncProgressEvent(_0x2baecb["username"], _0x52bd11).getEvent());
}
function sendChunk(_0x2109a2) {
  var _0x2d4e49 = {};
  _0x2d4e49["command"] = _0x2109a2["targettype"] == "BROADCAST" ? "IMG" : "DIRECT", _0x2d4e49.targettype = _0x2109a2.targettype, _0x2d4e49["target"] = _0x2109a2.username, _0x2d4e49["action"] = "PARTIAL", _0x2d4e49.ttype = _0x2109a2.ttype, _0x2d4e49.timestamp = _0x2109a2["timestamp"], _0x2109a2["type"] == "transferStart" ? (_0x2d4e49["firstPart"] = true, _0x2109a2["mask"].length > 0 && (_0x2d4e49["mask"] = _0x2109a2.mask)) : (_0x2d4e49["layer"] = _0x2109a2.layer, _0x2d4e49.layerCount = _0x2109a2.layerCount, _0x2d4e49["position"] = _0x2109a2["position"], _0x2d4e49.max = _0x2109a2["max"], _0x2d4e49.x = _0x2109a2.x, _0x2d4e49.y = _0x2109a2.y, _0x2d4e49["width"] = _0x2109a2.width, _0x2d4e49.height = _0x2109a2["height"], _0x2d4e49["rotation"] = _0x2109a2["rotation"], _0x2d4e49["chunk"] = _0x2109a2["chunk"]), socket.send(_0x2d4e49, true);
}
class TransferLayer {
  constructor(_0x829d41, _0xec6e3e, _0x4d5b44, _0x15749, _0x3db9f4, _0x2b5610, _0x4e3e43, _0x4f7133, _0x543aaa) {
    this["number"] = _0x829d41, this.position = _0xec6e3e, this.max = _0x4d5b44, this.x = _0x15749, this.y = _0x3db9f4, this.width = _0x2b5610, this["height"] = _0x4e3e43, this["rotation"] = _0x4f7133, this["data"] = _0x543aaa;
  }
}
class LocalStorage {
  constructor(_0x427a42) {
    this["cid"], this["name"] = _0x427a42, this.data = {}, this["storageType"], this.storage, this.linkStorage(), this["clearData"](), this.loadSavedData();
  }
  ["linkStorage"]() {
    window["localStorage"] ? (this.storage = window["localStorage"], this["storageType"] = "local") : (this.storage = this["getCookie"](this["name"]), this.storageType = "cookie");
  }
  ["clearData"]() {
    this["data"] = {};
  }
  ["loadSavedData"]() {
    this["storageType"] == "local" ? this["loadLocalStorage"]() : this["loadCookie"](), this["existsParameter"]("cid") ? this["cid"] = this["getParameter"]("cid") : (this["cid"] = parseInt(Math["random"]() * 999999), this["setParameter"]("cid", this.cid));
  }
  ["saveData"]() {
    this["storageType"] == "local" ? this["saveLocalStorage"]() : this["saveCookie"]();
  }
  ["loadLocalStorage"]() {
    try {
      this["data"] = JSON["parse"](this["storage"].getItem(this["name"]));
    } catch (_0x158350) { }
    !this["data"] && (this["data"] = {});
  }
  ["saveLocalStorage"]() {
    localStorage["setItem"](this["name"], JSON.stringify(this["data"]));
  }
  ["loadCookie"]() {
    var _0x56e674 = JSON["parse"](this["storage"]),
      _0x1ffb6d = this;
    $["each"](_0x56e674, function (_0x3dd54a, _0x8e8a96) {
      _0x1ffb6d.data[_0x3dd54a] = _0x8e8a96;
    });
  }
  ["saveCookie"]() {
    var _0x1e9ca7 = new Date();
    _0x1e9ca7["setTime"](_0x1e9ca7.getTime() + this["daysExpiration"] * 1e3 * 60 * 60 * 24), document["cookie"] = this["name"] + "=" + JSON["stringify"](this["data"]) + ";expires=" + _0x1e9ca7.toGMTString() + ";path=/;SameSite=Strict";
  }
  ["getCookie"]() {
    var _0x496c6e = this["name"] + "=",
      _0x3cd2da = decodeURIComponent(document.cookie),
      _0x2d044b = _0x3cd2da["split"](";");
    for (var _0x52637a = 0; _0x52637a < _0x2d044b["length"]; _0x52637a++) {
      var _0x3120ff = _0x2d044b[_0x52637a];
      while (_0x3120ff["charAt"](0) == " ") {
        _0x3120ff = _0x3120ff["substring"](1);
      }
      if (_0x3120ff["indexOf"](_0x496c6e) == 0) return _0x3120ff["substring"](_0x496c6e["length"], _0x3120ff.length);
    }
    return null;
  }
  ["existsParameter"](_0x25bd48) {
    return _0x25bd48 in this.data;
  }
  ["setParameter"](_0x18ea97, _0x3ee49b) {
    this["data"][_0x18ea97] = _0x3ee49b, this["saveData"]();
  }
  ["getParameter"](_0x30aaf0) {
    if (_0x30aaf0 in this.data) return this.data[_0x30aaf0];
    return null;
  }
  ["removeParameter"](_0x7fa5e) {
    _0x7fa5e in this["data"] && (delete this["data"][_0x7fa5e], this["saveData"]());
  }
  ["exportableData"]() {
    var _0x105ade = this["data"];
    return _0x105ade.preferences = _0x105ade.preferences.replace(/(\p{Emoji_Presentation}|\p{Extended_Pictographic})/gu, ""), _0x105ade;
  }
  ["exportData"]() {
    var _0x992ad4 = function (_0x44ac99) {
      var _0x276df7 = new Blob([_0x44ac99], {
        type: "text/plain"
      });
      return window.URL["createObjectURL"](_0x276df7);
    },
      _0x53cb12 = $("<a />");
    _0x53cb12["addClass"]("invisible"), _0x53cb12.attr("download", "config.fmc"), _0x53cb12["attr"]("href", _0x992ad4(btoa(JSON["stringify"](this["exportableData"]())))), $("body").append(_0x53cb12), _0x53cb12[0]["click"](), _0x53cb12["remove"]();
  }
}
class AdvancedCanvas {
  constructor(_0x2af655, _0x154684) {
    this["width"] = _0x2af655, this["height"] = _0x154684, this["smoothing"] = false, this["canvas"] = $("<canvas />"), this.canvas.attr("width", _0x2af655), this["canvas"].attr("height", _0x154684), this["clearCanvasProperties"](), this["clearCSSProperties"]();
  }
  ["getContext"](_0x343d7b = false) {
    return this.canvas[0]["getContext"]("2d", {
      willReadFrequently: _0x343d7b
    });
  }
  ["getImageData"](_0x4afe82 = 0, _0x1fe645 = 0, _0x4f1797 = null, _0x1e518e = null) {
    var _0x244917 = this["getContext"]();
    return _0x244917["getImageData"](_0x4afe82, _0x1fe645, _0x4f1797 == null ? _0x244917["canvas"]["width"] : _0x4f1797, _0x1e518e == null ? _0x244917.canvas["height"] : _0x1e518e);
  }
  ["getData"]() {
    return this["canvas"][0]["toDataURL"]("image/png");
  }
  ["isBasicRotation"](_0x4f3a79) {
    return _0x4f3a79 < 0 && (_0x4f3a79 *= -1), _0x4f3a79 == 0 || _0x4f3a79 == 90 || _0x4f3a79 == 180 || _0x4f3a79 == 270;
  }
  ["putData"](_0x269203, _0x1e997e = 0, _0x14f37d = 0, _0x2b85db = null, _0xd05511 = null, _0x443247 = 0) {
    var _0x1e06d9 = this;
    return new Promise(function (_0x42afe2, _0x27b656) {
      var _0x2e9f51 = new Image();
      _0x2e9f51.onload = function () {
        var _0x424e62 = _0x1e06d9["getContext"]();
        _0x1e06d9["setCanvasProperties"]({
          blendmode: "normal",
          alpha: 1,
          blur: 0
        }), _0x1e06d9["smoothing"] = !_0x1e06d9["isBasicRotation"](_0x443247);
        if (_0x443247 != 0) {
          var _0x2bfb1f = parseInt(_0x443247) * (Math.PI / 180);
          _0x424e62["translate"](_0x1e997e + _0x2e9f51["width"] / 2, _0x14f37d + _0x2e9f51["height"] / 2), _0x424e62["rotate"](_0x2bfb1f), _0x1e06d9["drawImage"](_0x2e9f51, -_0x2e9f51.width / 2, -_0x2e9f51["height"] / 2), _0x424e62.rotate(-_0x2bfb1f), _0x424e62["translate"](-(_0x1e997e + _0x2e9f51["width"] / 2), -(_0x14f37d + _0x2e9f51["height"] / 2));
        } else _0x1e06d9["drawImage"](_0x2e9f51, _0x1e997e, _0x14f37d, _0x2b85db, _0xd05511);
        _0x1e06d9["smoothing"] = false, _0x42afe2("ok");
      }, _0x2e9f51["onerror"] = function () {
        _0x27b656("fail");
      }, _0x2e9f51["src"] = _0x269203;
    });
  }
  ["putImageData"](_0x5a2f9f, _0x1029a3 = 0, _0x40f175 = 0) {
    var _0x4475ab = this["getContext"]();
    _0x4475ab.putImageData(_0x5a2f9f, _0x1029a3, _0x40f175);
  }
  ["drawImage"](_0x1ca5f1, _0x4f757a = 0, _0xc4037e = 0, _0xaa5fa7 = null, _0x328860 = null) {
    var _0x31176f = this.getContext();
    _0x31176f.imageSmoothingEnabled = this["smoothing"], _0x31176f["imageSmoothingQuality"] = "high", _0xaa5fa7 == null || _0x328860 == null ? _0x31176f.drawImage(_0x1ca5f1, _0x4f757a, _0xc4037e) : _0x31176f["drawImage"](_0x1ca5f1, _0x4f757a, _0xc4037e, _0xaa5fa7, _0x328860), _0x31176f["imageSmoothingEnabled"] = false;
  }
  ["clear"](_0x124755 = -1, _0x412530 = 0, _0x506057 = 0, _0x27da78 = null, _0xb03667 = null) {
    var _0x3b3f2d = this["getContext"]();
    _0x27da78 == null && (_0x27da78 = _0x3b3f2d["canvas"]["width"]), _0xb03667 == null && (_0xb03667 = _0x3b3f2d.canvas["height"]), this["setCanvasProperties"]({
      blendmode: "normal",
      alpha: 1,
      blur: 0
    }), _0x124755 == -1 ? _0x3b3f2d["clearRect"](_0x412530, _0x506057, _0x27da78, _0xb03667) : (_0x3b3f2d["fillStyle"] = _0x124755, _0x3b3f2d.fillRect(_0x412530, _0x506057, _0x27da78, _0xb03667));
  }
  ["clearMask"](_0x30202e, _0x20bece = -1) {
    var _0x580f0a = this["getContext"]();
    _0x580f0a.save(), this.setCanvasProperties({
      blendmode: "normal",
      alpha: 1,
      blur: 0
    }), _0x580f0a["beginPath"](), $.each(_0x30202e, function (_0x407937, _0x17424c) {
      _0x407937 == 0 && _0x580f0a["moveTo"](_0x17424c.x, _0x17424c.y), _0x580f0a.lineTo(_0x17424c.x, _0x17424c.y);
    }), _0x580f0a["closePath"](), _0x580f0a.clip(), this.clear(_0x20bece), _0x580f0a["restore"](), this["clearCanvasProperties"]();
  }
  ["flip"](_0x585f74 = true, _0x72c65f = false) {
    var _0x3aa80a = this["getContext"]();
    this["setCanvasProperties"]({
      blendmode: "normal",
      alpha: 1,
      blur: 0
    });
    var _0x34cc06 = this,
      _0x32f1fd = new Image();
    _0x32f1fd["onload"] = function () {
      _0x3aa80a["clearRect"](0, 0, _0x3aa80a["canvas"]["width"], _0x3aa80a["canvas"]["height"]), _0x3aa80a["save"](), _0x3aa80a["translate"](_0x3aa80a["canvas"]["width"] / 2, _0x3aa80a["canvas"]["height"] / 2), _0x3aa80a["scale"](_0x585f74 ? -1 : 1, _0x72c65f ? -1 : 1), _0x34cc06["drawImage"](_0x32f1fd, -_0x3aa80a["canvas"]["width"] / 2, -_0x3aa80a["canvas"]["height"] / 2, _0x3aa80a["canvas"].width, _0x3aa80a["canvas"]["height"]), _0x3aa80a.restore(), _0x34cc06["clearCanvasProperties"]();
    }, _0x32f1fd["src"] = this["getData"]();
  }
  ["blur"](_0x38e939 = 1) {
    var _0x3154e7 = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1],
      _0x211742 = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18],
      _0x4ddb59 = this.width,
      _0x287448 = this["height"],
      _0x525299 = 1,
      _0x285064 = this.canvas[0],
      _0x33087c = _0x285064.getContext("2d"),
      _0x5674c7 = this["getImageData"](),
      _0x120a03 = _0x5674c7["data"],
      _0x3c89bd,
      _0x5b5e59,
      _0x425e83,
      _0xaa3cef,
      _0xd6fadf,
      _0x10b90c,
      _0x5ccebb,
      _0x35b47b,
      _0x11c035,
      _0x313ef4,
      _0x41c8ca,
      _0x2c6823,
      _0x39c748,
      _0x32a5fb,
      _0x537480,
      _0x1dbcd5 = _0x4ddb59 - 1,
      _0x5a9975 = _0x287448 - 1,
      _0x54be00 = _0x4ddb59 * _0x287448,
      _0x41371d = _0x38e939 + 1,
      _0x13e8b1 = _0x3154e7[_0x38e939],
      _0x461872 = _0x211742[_0x38e939],
      _0x4f22f8 = [],
      _0x44e8a1 = [],
      _0x3f1efe = [],
      _0x3f3b30 = [],
      _0x29b7ef = [],
      _0x356a3d = [];
    while (_0x525299-- > 0) {
      _0x39c748 = _0x2c6823 = 0;
      for (_0x10b90c = 0; _0x10b90c < _0x287448; _0x10b90c++) {
        _0x3c89bd = _0x120a03[_0x39c748] * _0x41371d, _0x5b5e59 = _0x120a03[_0x39c748 + 1] * _0x41371d, _0x425e83 = _0x120a03[_0x39c748 + 2] * _0x41371d, _0xaa3cef = _0x120a03[_0x39c748 + 3] * _0x41371d;
        for (_0x5ccebb = 1; _0x5ccebb <= _0x38e939; _0x5ccebb++) {
          _0x35b47b = _0x39c748 + ((_0x5ccebb > _0x1dbcd5 ? _0x1dbcd5 : _0x5ccebb) << 2), _0x3c89bd += _0x120a03[_0x35b47b++], _0x5b5e59 += _0x120a03[_0x35b47b++], _0x425e83 += _0x120a03[_0x35b47b++], _0xaa3cef += _0x120a03[_0x35b47b];
        }
        for (_0xd6fadf = 0; _0xd6fadf < _0x4ddb59; _0xd6fadf++) {
          _0x4f22f8[_0x2c6823] = _0x3c89bd, _0x44e8a1[_0x2c6823] = _0x5b5e59, _0x3f1efe[_0x2c6823] = _0x425e83, _0x3f3b30[_0x2c6823] = _0xaa3cef, _0x10b90c == 0 && (_0x29b7ef[_0xd6fadf] = ((_0x35b47b = _0xd6fadf + _0x41371d) < _0x1dbcd5 ? _0x35b47b : _0x1dbcd5) << 2, _0x356a3d[_0xd6fadf] = (_0x35b47b = _0xd6fadf - _0x38e939) > 0 ? _0x35b47b << 2 : 0), _0x11c035 = _0x39c748 + _0x29b7ef[_0xd6fadf], _0x313ef4 = _0x39c748 + _0x356a3d[_0xd6fadf], _0x3c89bd += _0x120a03[_0x11c035++] - _0x120a03[_0x313ef4++], _0x5b5e59 += _0x120a03[_0x11c035++] - _0x120a03[_0x313ef4++], _0x425e83 += _0x120a03[_0x11c035++] - _0x120a03[_0x313ef4++], _0xaa3cef += _0x120a03[_0x11c035] - _0x120a03[_0x313ef4], _0x2c6823++;
        }
        _0x39c748 += _0x4ddb59 << 2;
      }
      for (_0xd6fadf = 0; _0xd6fadf < _0x4ddb59; _0xd6fadf++) {
        _0x41c8ca = _0xd6fadf, _0x3c89bd = _0x4f22f8[_0x41c8ca] * _0x41371d, _0x5b5e59 = _0x44e8a1[_0x41c8ca] * _0x41371d, _0x425e83 = _0x3f1efe[_0x41c8ca] * _0x41371d, _0xaa3cef = _0x3f3b30[_0x41c8ca] * _0x41371d;
        for (_0x5ccebb = 1; _0x5ccebb <= _0x38e939; _0x5ccebb++) {
          _0x41c8ca += _0x5ccebb > _0x5a9975 ? 0 : _0x4ddb59, _0x3c89bd += _0x4f22f8[_0x41c8ca], _0x5b5e59 += _0x44e8a1[_0x41c8ca], _0x425e83 += _0x3f1efe[_0x41c8ca], _0xaa3cef += _0x3f3b30[_0x41c8ca];
        }
        _0x2c6823 = _0xd6fadf << 2;
        for (_0x10b90c = 0; _0x10b90c < _0x287448; _0x10b90c++) {
          _0x120a03[_0x2c6823 + 3] = _0x537480 = _0xaa3cef * _0x13e8b1 >>> _0x461872, _0x537480 > 0 ? (_0x537480 = 255 / _0x537480, _0x120a03[_0x2c6823] = (_0x3c89bd * _0x13e8b1 >>> _0x461872) * _0x537480, _0x120a03[_0x2c6823 + 1] = (_0x5b5e59 * _0x13e8b1 >>> _0x461872) * _0x537480, _0x120a03[_0x2c6823 + 2] = (_0x425e83 * _0x13e8b1 >>> _0x461872) * _0x537480) : _0x120a03[_0x2c6823] = _0x120a03[_0x2c6823 + 1] = _0x120a03[_0x2c6823 + 2] = 0, _0xd6fadf == 0 && (_0x29b7ef[_0x10b90c] = ((_0x35b47b = _0x10b90c + _0x41371d) < _0x5a9975 ? _0x35b47b : _0x5a9975) * _0x4ddb59, _0x356a3d[_0x10b90c] = (_0x35b47b = _0x10b90c - _0x38e939) > 0 ? _0x35b47b * _0x4ddb59 : 0), _0x11c035 = _0xd6fadf + _0x29b7ef[_0x10b90c], _0x313ef4 = _0xd6fadf + _0x356a3d[_0x10b90c], _0x3c89bd += _0x4f22f8[_0x11c035] - _0x4f22f8[_0x313ef4], _0x5b5e59 += _0x44e8a1[_0x11c035] - _0x44e8a1[_0x313ef4], _0x425e83 += _0x3f1efe[_0x11c035] - _0x3f1efe[_0x313ef4], _0xaa3cef += _0x3f3b30[_0x11c035] - _0x3f3b30[_0x313ef4], _0x2c6823 += _0x4ddb59 << 2;
        }
      }
    }
    _0x33087c.putImageData(_0x5674c7, 0, 0);
  }
  ["changeSize"](_0x19e616, _0x1de4c1) {
    this["width"] = _0x19e616, this["height"] = _0x1de4c1, this["canvas"]["attr"]("width", _0x19e616), this["canvas"]["attr"]("height", _0x1de4c1), this["clearCanvasProperties"]();
  }
  ["remove"]() {
    this["canvas"]["remove"](), this["clearCanvasProperties"](), this.clearCSSProperties();
  }
  ["getCanvasProperty"](_0x5c31d7) {
    return null;
  }
  ["clearCanvasProperties"]() {
    this.currentCanvasProperties = {};
  }
  ["setCanvasProperties"](_0x2ab9df = {}) {
    var _0x601035 = this,
      _0x40086e = this["getContext"]();
    $["each"](_0x2ab9df, function (_0xd451bf, _0x47a8f9) {
      _0xd451bf = _0xd451bf["toLowerCase"]();
      if (_0xd451bf == "blendmode") _0x47a8f9 == "normal" && (_0x47a8f9 = "source-over"), _0x601035["getCanvasProperty"](_0xd451bf) != _0x47a8f9 && (_0x40086e["globalCompositeOperation"] = _0x47a8f9); else {
        if (_0xd451bf == "alpha") _0x601035["getCanvasProperty"](_0xd451bf) != _0x47a8f9 && (_0x40086e["globalAlpha"] = _0x47a8f9); else {
          if (_0xd451bf == "blur") _0x601035["getCanvasProperty"](_0xd451bf) != _0x47a8f9 && (_0x47a8f9 == 0 ? _0x40086e["filter"] = "none" : _0x40086e["filter"] = "blur(" + _0x47a8f9 + "px)"); else {
            if (_0xd451bf == "linedash") _0x601035.getCanvasProperty(_0xd451bf) != _0x47a8f9 && _0x40086e["setLineDash"](_0x47a8f9); else {
              if (_0xd451bf == "linejoin") _0x601035["getCanvasProperty"](_0xd451bf) != _0x47a8f9 && (_0x40086e["lineJoin"] = _0x47a8f9); else {
                if (_0xd451bf == "linecap") _0x601035["getCanvasProperty"](_0xd451bf) != _0x47a8f9 && (_0x40086e.lineCap = _0x47a8f9); else {
                  if (_0xd451bf == "linewidth") _0x601035["getCanvasProperty"](_0xd451bf) != _0x47a8f9 && (_0x40086e["lineWidth"] = _0x47a8f9); else {
                    if (_0xd451bf == "strokestyle") _0x601035.getCanvasProperty(_0xd451bf) != _0x47a8f9 && (_0x40086e["strokeStyle"] = _0x47a8f9); else {
                      if (_0xd451bf == "fillstyle") _0x601035["getCanvasProperty"](_0xd451bf) != _0x47a8f9 && (_0x40086e["fillStyle"] = _0x47a8f9); else {
                        if (_0xd451bf == "font") _0x601035["getCanvasProperty"](_0xd451bf) != _0x47a8f9 && (_0x40086e["font"] = _0x47a8f9); else {
                          if (_0xd451bf == "textbaseline") _0x601035["getCanvasProperty"](_0xd451bf) != _0x47a8f9 && (_0x40086e["textBaseline"] = _0x47a8f9); else _0xd451bf == "linedashoffset" && _0x601035["getCanvasProperty"](_0xd451bf) != _0x47a8f9 && (_0x40086e["lineDashOffset"] = _0x47a8f9);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      _0x601035["currentCanvasProperties"][_0xd451bf] = _0x47a8f9;
    });
  }
  ["getCSSProperty"](_0x5df3c0) {
    if (_0x5df3c0 in this["currentCSSProperties"]) return this["currentCSSProperties"][_0x5df3c0];
    return null;
  }
  ["clearCSSProperties"]() {
    this["currentCSSProperties"] = {};
  }
  ["setCSSProperties"](_0x842640 = {}) {
    var _0x1e4cb7 = this;
    $.each(_0x842640, function (_0x324bae, _0x245a89) {
      _0x324bae = _0x324bae["toLowerCase"]();
      if (_0x324bae == "alpha") _0x1e4cb7["getCSSProperty"](_0x324bae) != _0x245a89 && $(_0x1e4cb7.canvas)["css"]("opacity", _0x245a89); else {
        if (_0x324bae == "blendmode") _0x1e4cb7["getCSSProperty"](_0x324bae) != _0x245a89 && $(_0x1e4cb7["canvas"])["css"]("mix-blend-mode", _0x245a89); else _0x324bae == "blur" && _0x1e4cb7["getCSSProperty"](_0x324bae) != _0x245a89 && (_0x245a89 == 0 ? $(_0x1e4cb7["canvas"])["css"]("filter", "") : $(_0x1e4cb7.canvas)["css"]("filter", "blur(" + _0x245a89 + "px)"));
      }
      _0x1e4cb7["currentCSSProperties"][_0x324bae] = _0x245a89;
    });
  }
}
class Layer {
  constructor(_0x278d68, _0x413b10, _0x4f24e3, _0x223af1 = "board", _0x1d09fb = null) {
    this.number = _0x278d68, this["locked"] = false, this["visible"] = true, this.advCanvas = new AdvancedCanvas(_0x413b10, _0x4f24e3), this["advCanvas"].canvas["addClass"](_0x223af1), _0x1d09fb != null && this["advCanvas"]["canvas"].css("z-index", _0x1d09fb);
  }
  ["getCanvas"]() {
    return this["advCanvas"]["canvas"][0];
  }
  ["getContext"]() {
    return this["advCanvas"]["getContext"]();
  }
  ["getData"]() {
    return this.advCanvas["getData"]();
  }
  ["getOffset"]() {
    return this["advCanvas"].canvas["offset"]();
  }
  ["putData"](_0x982176, _0x4d72dc = 0, _0x165726 = 0, _0x10b90b = null, _0x26e1c4 = null, _0x293cd0 = 0) {
    return this["advCanvas"]["putData"](_0x982176, _0x4d72dc, _0x165726, _0x10b90b, _0x26e1c4, _0x293cd0);
  }
  ["clear"](_0x3f04a4 = -1, _0x2fd37a = 0, _0x4b9414 = 0, _0x5e13e5 = null, _0x4e655b = null) {
    this["advCanvas"].clear(_0x3f04a4, _0x2fd37a, _0x4b9414, _0x5e13e5, _0x4e655b), $(this)["triggerHandler"](new layerClearedEvent(this["number"]).getEvent());
  }
  ["clearMask"](_0x3b4d20, _0x137cc1 = -1) {
    this["advCanvas"]["clearMask"](_0x3b4d20, _0x137cc1);
  }
  ["flip"](_0x5eac4f = true, _0x3eeff5 = false) {
    this.advCanvas.flip(_0x5eac4f, _0x3eeff5), $(self).triggerHandler(new layerFlippedEvent(self["number"])["getEvent"]());
  }
  ["show"]() {
    this["advCanvas"].canvas.show(), this.visible = true;
  }
  ["hide"]() {
    this["advCanvas"].canvas["hide"](), this["visible"] = false;
  }
  ["toggle"]() {
    this["advCanvas"]["canvas"]["toggle"]();
  }
  ["isVisible"]() {
    return this["advCanvas"]["canvas"].is(":visible");
  }
  ["lock"]() {
    this["locked"] = true;
  }
  ["unlock"]() {
    this.locked = false;
  }
  ["remove"]() {
    this["advCanvas"]["remove"]();
  }
}
window.updateUndoSteps = function(steps) {
  // Update the current board instance if it exists
  if (room?.board) {
    room.board.maxUndoSteps = steps;
  }
};
var positionAwareRotation = localStorage.getItem("positionAwareRotation") === "true";
class Board {
  constructor(_0x4d5a80, _0x1cdd26, _0x3a496a, _0x127d1d, _0x21edc8, _0x1389b8) {
    this["canvasWidth"], this["canvasHeight"], this.nLayers = _0x127d1d, this["layers"] = new Array(), this["backgroundColor"] = "#FFFFFF", this["bottomTransparency"] = true, this["boardContainer"] = _0x4d5a80, this["grid"], this["onion"], this.onionSkin = false, this["scale"] = 0, this["rotation"] = 0, 
    
    // Check if smallerZoomStep is enabled
    this["zoomStep"] = localStorage.getItem("smallerZoomStep") === "true" ? 0.10 : 0.25, 
    
    this.minZoom = 0.25, this["maxZoom"] = 13, this["cursorContainer"] = $("<div />"), this.cursorContainer["addClass"]("CursorContainer"), this["boardContainer"]["append"](this["cursorContainer"]), this.canvasContainer = $("<div />"), this["canvasContainer"]["addClass"]("CanvasContainer"), this["boardContainer"]["append"](this["canvasContainer"]), this.zIndexFrom = 10, this["lastChangeTime"] = new Date(), this["changeSize"](_0x1cdd26, _0x3a496a), this.changeLayers(_0x127d1d), this.changeTransparency(_0x1389b8), this["changeBackground"](_0x21edc8);
    this.undoStack = [];
    this.redoStack = [];
    this.maxUndoSteps = parseInt(localStorage.getItem("undoSteps")) || 5;
    this.currentStrokeId = 1; // Track current stroke ID - increment with each new stroke
    this.strokeCommitQueue = []; // Queue for pending stroke commits
    this.isProcessingCommit = false; // Flag to track if we're currently processing a commit
    this.undoneStrokes = new Set(); // Track strokes that have been undone

    // New mapping properties for stroke coordination
    this.strokeIdMap = new Map(); // Maps Board strokeId -> Surface strokeNumber
    this.surfaceStrokeMap = new Map(); // Maps Surface strokeNumber -> Board strokeId
    // Setup localStorage change monitoring
    this.needToUnmuteWhenComplete = false; // New flag to track pending unmute
    this.needToUnblockMessagesWhenComplete = false; // Flag to track pending message unblock
    this.setupUndoHistoryToggleHandler();
  // Add tracking for commit progress
  this.commitProgress = {
    processed: 0,
    total: 0,
    active: false
  };
  if (positionAwareRotation === true) {
    this.changeRotation = this.changeRotationPositionAware;
  } else {
    this.changeRotation = this.changeRotationDefault;
  }
}

    // Helper method to check if undo history is enabled
    isUndoHistoryEnabled() {
      // Change from localStorage check to UI instance check
      return UI && UI.undoHistoryEnabled;
    }
      // Add this new method to the Board class
handleUndoHistoryEnabled() {
  
  // Set defaultBlockMessages to true
  if (room && room.myself && room.myself.frameBuffer) {
    room.myself.frameBuffer.defaultBlockMessages = true;
  }
}
// Update setupUndoHistoryToggleHandler method
setupUndoHistoryToggleHandler() {
  // Listen for our custom events (only affects current tab)
  document.addEventListener('undoHistoryStateChanged', (event) => {
    if (event.detail.enabled) {
      this.handleUndoHistoryEnabled();
    } else {
      this.handleUndoHistoryDisabled();
    }
  });
  
  // Initialize based on current UI state
  if (UI && typeof UI.undoHistoryEnabled !== 'undefined') {
    if (UI.undoHistoryEnabled) {
      this.handleUndoHistoryEnabled();
    } else {
      this.handleUndoHistoryDisabled();
    }
  }
  
  // REMOVE the localStorage monkeypatching - this causes cross-tab issues
  /*
  const originalSetItem = localStorage.setItem;
  localStorage.setItem = (key, value) => {
    originalSetItem.call(localStorage, key, value);
    if (key === 'undoHistoryEnabled') {
      if (value === 'false') {
        this.handleUndoHistoryDisabled();
      } else if (value === 'true') {
        this.handleUndoHistoryEnabled();
      }
    }
  };
  */
}
// Add this as a method of the Board class
isActuallyMuted() {
  return UI && UI.muteSeconds > 0;
}

// Update handleUndoHistoryDisabled method
// Update handleUndoHistoryDisabled method
handleUndoHistoryDisabled() {
  
  // Check if user is moderator-muted
  const moderatorMuted = UI && UI.muteSeconds > 0;
  
  // Clear any existing safety timeouts
  if (this._safetyUnmuteTimeout) {
    clearTimeout(this._safetyUnmuteTimeout);
    this._safetyUnmuteTimeout = null;
  }
  
  // Reset progress tracking but don't set active yet
  this.commitProgress = {
    processed: 0,
    total: 0,
    active: false // Set to false initially until we confirm there's work to do
  };
  
  // Step 1: Check if there's anything to commit before muting
  const hasUndoItems = this.undoStack.length > 0;
  const hasQueuedItems = this.strokeCommitQueue.length > 0;
  
  if (!hasUndoItems && !hasQueuedItems) {
    
    // Check if room and necessary objects exist before accessing them
    if (room && room.myself && room.myself.frameBuffer) {
      room.myself.frameBuffer.defaultBlockMessages = false;
      
      const currentBrush = room.myself.surface.brushHandler.currentBrush;
      const brushOptions = room.myself.surface.getBrushOptions();
      const currentColor = room.myself.surface.drawColor;
      
      const frameBuffer = room.myself.frameBuffer;
      const sourceId = `clearHistory-${Date.now()}`;
      
      frameBuffer.authorizeSource(sourceId);
      
      const cmdBrush = frameBuffer.netcode.brushChanged({brush: currentBrush});
      frameBuffer.outBuffer(cmdBrush, sourceId);
      
      if (brushOptions) {
        for (const option in brushOptions) {
          const cmdOption = frameBuffer.netcode.brushOptionChanged({
            option: option,
            value: brushOptions[option]
          });
          frameBuffer.outBuffer(cmdOption, sourceId);
        }
      }
      
      const cmdColor = frameBuffer.netcode.colorChanged({color: currentColor});
      frameBuffer.outBuffer(cmdColor, sourceId);
      
      frameBuffer.execFrame();
      frameBuffer.revokeSource(sourceId);
    }
    
    return {
      actionsQueued: 0,
      totalQueueSize: 0,
      commitProgress: this.commitProgress
    };
  }
  
  // Only set active flag if there's work to do
  this.commitProgress.active = true;
  
  // Now proceed with temporary muting since we have work to do
  if (room && room.myself && !moderatorMuted) {
    room.myself.mute();
    
    // Rest of the existing muting code...
    this.needToUnmuteWhenComplete = true;
    
    this._safetyUnmuteTimeout = setTimeout(() => {
      if (this.needToUnmuteWhenComplete && room && room.myself && !moderatorMuted) {
        room.myself.unmute();
        this.needToUnmuteWhenComplete = false;
        this.commitProgress.active = false; // Also reset progress flag
      }
    }, 300000);
  }
  
  // Set flag to unblock messages when done
  this.needToUnblockMessagesWhenComplete = true;
  
  // Step 2: Commit all pending changes
  const commitResult = this.commitAllPendingChanges();
  
  // Log status if moderator-muted
  if (moderatorMuted) {
  }
  
  return commitResult;
}

// Also update handleUndoHistoryEnabled to cancel pending unmute
handleUndoHistoryEnabled() {
  
  // Set defaultBlockMessages to true
  if (room && room.myself && room.myself.frameBuffer) {
    room.myself.frameBuffer.defaultBlockMessages = true;
  }
  
  // If we have a pending unmute from a previous disable action,
  // execute it immediately since we're enabling again
  if (this.needToUnmuteWhenComplete && room && room.myself && !(UI && UI.muteSeconds > 0)) {
    room.myself.unmute();
    this.needToUnmuteWhenComplete = false;
    
    // Clear any safety timeout
    if (this._safetyUnmuteTimeout) {
      clearTimeout(this._safetyUnmuteTimeout);
      this._safetyUnmuteTimeout = null;
    }
  }
}
  
  pushUndo(action) {
    // Assign stroke ID for tracking purposes
    const strokeId = this.currentStrokeId++;
    action.strokeId = strokeId;
    
    // Add to undo stack only if enabled
    if (!this.isUndoHistoryEnabled()) {
      return action;
    }
    
    // Normal behavior - add to undo stack
    this.undoStack.push(action);
    
    // Keep undo stack within size limit and commit old strokes
    while (this.undoStack.length > this.maxUndoSteps) {
      const oldestAction = this.undoStack.shift();
      
      if (typeof window.showStrokeToOthers === "function" && 
          oldestAction.strokeId && 
          !this.undoneStrokes.has(oldestAction.strokeId)) {
        this.queueStrokeCommit(oldestAction.strokeId);
      }
    }
    
    this.redoStack = [];
    return action;
  }
  
  pushGroupUndo(group) {
    if (!group || !group.actions || !group.actions.length) return null;
    
    // Assign stroke ID for tracking purposes
    const strokeId = this.currentStrokeId++;
    group.strokeId = strokeId;
    
    // Also assign the stroke ID to all actions in the group
    group.actions.forEach(action => {
      action.strokeId = strokeId;
    });
    
    // Skip history if disabled
    if (!this.isUndoHistoryEnabled()) {
      return group;
    }
    
    // Normal behavior - add to undo stack
    this.undoStack.push(group);
    
    // Keep undo stack within size limit and commit old strokes
    while (this.undoStack.length > this.maxUndoSteps) {
      const oldestAction = this.undoStack.shift();
      
      if (typeof window.showStrokeToOthers === "function" && 
          oldestAction.strokeId && 
          !this.undoneStrokes.has(oldestAction.strokeId)) {
        this.queueStrokeCommit(oldestAction.strokeId);
      }
    }
    
    this.redoStack = [];
    return group;
  }

// Queue a stroke for commit and process the queue
queueStrokeCommit(strokeId) {
  if (!this.undoneStrokes.has(strokeId)) {
    this.strokeCommitQueue.push(strokeId);
    
    // Only call processCommitQueue if we're not already processing
    if (!this.isProcessingCommit) {
      setTimeout(() => this.processCommitQueue(), 0);
    } else {
    }
  }
}
checkAndUnmuteIfReady() {
  // Make sure we're not muted by moderator
  const moderatorMuted = UI && UI.muteSeconds > 0;
  if (moderatorMuted) {
    this.needToUnmuteWhenComplete = false;
    return;
  }
  
  // Check 1: Queue must be empty (recheck to ensure no new strokes were added)
  const queueStillEmpty = this.strokeCommitQueue.length === 0;
  
  // Check 2: No active transfers/chunks in progress
  const hasActiveTransfers = room?.frameBuffer?.activeTransfers?.size > 0 || 
                           room?.frameBuffer?.transferChunksInProgress?.size > 0;
                           
  // Check 3: No pending strokes in surface
  const pendingStrokes = room?.myself?.surface?._pendingStrokes?.length > 0;
  
  // Check 4: No current strokes active
  const currentStrokeActive = Boolean(room?.myself?.surface?.currentStroke);
  
  // Check 5: Network is idle (no queued commands)
  const networkBusy = room?.frameBuffer?.isBusy?.() || false;
  
  // Check 6: Ensure any final transfer is complete
  const recentlyCompleted = Date.now() - (this._lastTransferCompleteTime || 0) < 1000;
  
  // Log all check results
  
  const allChecksPass = queueStillEmpty && 
                        !hasActiveTransfers && 
                        !pendingStrokes && 
                        !currentStrokeActive &&
                        !networkBusy &&
                        !recentlyCompleted;
  
  if (allChecksPass) {
    if (room && room.myself) {
      room.myself.unmute();
      this.needToUnmuteWhenComplete = false;
      window.clearUndoHistory();
      // Clear any safety timeout as we've handled unmuting
      if (this._safetyUnmuteTimeout) {
        clearTimeout(this._safetyUnmuteTimeout);
        this._safetyUnmuteTimeout = null;
      }
    }
  } else {
    
    // Try again after a delay but don't retry forever
    if (!this._unmuteSafetyRetries) {
      this._unmuteSafetyRetries = 0;
    }
    
    this._unmuteSafetyRetries++;
    
    // Limit retry attempts (max 20 = ~20 seconds)
    if (this._unmuteSafetyRetries < 20) {
      setTimeout(() => this.checkAndUnmuteIfReady(), 1000);
    } else {
      if (room && room.myself) {
        room.myself.unmute();
        this.needToUnmuteWhenComplete = false;
        this._unmuteSafetyRetries = 0;
        
        // Clear any safety timeout
        if (this._safetyUnmuteTimeout) {
          clearTimeout(this._safetyUnmuteTimeout);
          this._safetyUnmuteTimeout = null;
        }
      }
    }
  }
}

// Add this method to capture transfer completion events
handleTransferComplete() {
  // Record timestamp of latest transfer completion
  this._lastTransferCompleteTime = Date.now();
  
  // If we're waiting to unmute, check again after a delay
  if (this.needToUnmuteWhenComplete) {
    setTimeout(() => this.checkAndUnmuteIfReady(), 1000);
  }
}
processCommitQueue() {
  // If the queue is empty, check if we need to unmute
  if (this.strokeCommitQueue.length === 0) {
    this.isProcessingCommit = false;
    this.commitProgress.active = false;
    
    // Check if we need to unblock messages
    if (this.needToUnblockMessagesWhenComplete) {
      if (room && room.myself && room.myself.frameBuffer) {
        room.myself.frameBuffer.defaultBlockMessages = false;
      }
      this.needToUnblockMessagesWhenComplete = false;
      const currentBrush = room.myself.surface.brushHandler.currentBrush;
      const brushOptions = room.myself.surface.getBrushOptions();
      const currentColor = room.myself.surface.drawColor;
      const currentLayer = room.myself.surface.currentLayer;
      
      if (room.myself.frameBuffer) {
        const frameBuffer = room.myself.frameBuffer;
        const sourceId = `clearHistory-${Date.now()}`;
        
        frameBuffer.authorizeSource(sourceId);
        
        const cmdBrush = frameBuffer.netcode.brushChanged({brush: currentBrush});
        frameBuffer.outBuffer(cmdBrush, sourceId);
        
        if (brushOptions) {
          for (const option in brushOptions) {
            const cmdOption = frameBuffer.netcode.brushOptionChanged({
              option: option,
              value: brushOptions[option]
            });
            frameBuffer.outBuffer(cmdOption, sourceId);
          }
        }
        
        const cmdColor = frameBuffer.netcode.colorChanged({color: currentColor});
        frameBuffer.outBuffer(cmdColor, sourceId);
        
        // Add current layer broadcast
        const cmdLayer = frameBuffer.netcode.layerSelected({layer: currentLayer});
        frameBuffer.outBuffer(cmdLayer, sourceId);
        
        frameBuffer.execFrame();
        frameBuffer.revokeSource(sourceId);
      }
    }
    
    // Check if we need to unmute the user now that everything is processed
    if (this.needToUnmuteWhenComplete) {
      // Use helper function for comprehensive unmute safety checks
      this.checkAndUnmuteIfReady();
      return;
    }
    return;
  }
  
  // Set processing flag
  this.isProcessingCommit = true;
  
  // Get the next stroke ID to commit
  const strokeId = this.strokeCommitQueue.shift();
  
  // Initialize tracking collections if they don't exist
  if (!this._inProgressBoardStrokes) this._inProgressBoardStrokes = new Set();
  if (!this._inProgressSurfaceStrokes) this._inProgressSurfaceStrokes = new Set();
  
  // Check if this Board stroke is already being processed
  if (this._inProgressBoardStrokes.has(strokeId)) {
    setTimeout(() => this.processCommitQueue(), 50);
    return;
  }
  
  // Check if this maps to a Surface stroke that's already being processed
  const surfaceStrokeNum = this.strokeIdMap.get(strokeId);
  if (surfaceStrokeNum && this._inProgressSurfaceStrokes.has(surfaceStrokeNum)) {
    setTimeout(() => this.processCommitQueue(), 50);
    return;
  }
  
  // Mark as in-progress to prevent duplicates
  this._inProgressBoardStrokes.add(strokeId);
  if (surfaceStrokeNum) {
    this._inProgressSurfaceStrokes.add(surfaceStrokeNum);
  }
  
  // Update progress counters
  this.commitProgress.processed++;
  this.commitProgress.total = this.commitProgress.processed + this.strokeCommitQueue.length;
 
  // Skip undone strokes
  if (this.undoneStrokes.has(strokeId)) {
    // Clean up tracking before skipping
    this._inProgressBoardStrokes.delete(strokeId);
    if (surfaceStrokeNum) this._inProgressSurfaceStrokes.delete(surfaceStrokeNum);
    setTimeout(() => this.processCommitQueue(), 50);
    return;
  }
  
  try {
    const actionInStack = this.findActionWithStrokeId(strokeId);
    const isMoveOrCloneAction = actionInStack && 
                               (actionInStack.isMoveAction || 
                                actionInStack.isCloneAction ||
                               (actionInStack.type === 'group' && 
                                (actionInStack.isMoveAction || actionInStack.isCloneAction)));
    
    // For move/clone actions
    if (isMoveOrCloneAction) {
      
      // NEW: Check if room is connected before proceeding
      if (!room || !room.connected) {
        
        // Clean up tracking before continuing
        this._inProgressBoardStrokes.delete(strokeId);
        if (surfaceStrokeNum) this._inProgressSurfaceStrokes.delete(surfaceStrokeNum);
        
        // Continue with next item in queue
        setTimeout(() => this.processCommitQueue(), 100);
        return;
      }
      
      let isCompleted = false;
      
      // Handler for transfer complete
      const handleTransferComplete = (event, data) => {
        if (isCompleted) return; // Prevent duplicate handling
        isCompleted = true;
        $(document).off("transferComplete", handleTransferComplete);
        clearTimeout(safetyTimeout);
        
        // IMPORTANT: Force a mandatory cool-down period after move actions
        // This ensures all operations are truly complete before next stroke
        
        setTimeout(() => {
          // Reset any potential state and ensure clean slate for next operation
          if (window.resetAfterStrokeCompletion) {
            window.resetAfterStrokeCompletion();
          }
          
          // Clean up tracking before continuing
          this._inProgressBoardStrokes.delete(strokeId);
          if (surfaceStrokeNum) {
            this._inProgressSurfaceStrokes.delete(surfaceStrokeNum);
          }
          setTimeout(() => this.processCommitQueue(), 100);
        }, 2000); // Use a 2-second cool-down period after move actions
      };
      
      $(document).on("transferComplete", handleTransferComplete);
      
      // Safety timeout as fallback only (longer timeout for reliability)
      const safetyTimeout = setTimeout(() => {
        if (isCompleted) return; // Don't handle if already completed
        isCompleted = true;
        $(document).off("transferComplete", handleTransferComplete);
        
        // Log an error to help debug why the event isn't firing
        
        // Still enforce cool-down period for safety
        setTimeout(() => {
          if (window.resetAfterStrokeCompletion) {
            window.resetAfterStrokeCompletion();
          }
          
          // Clean up tracking before continuing
          this._inProgressBoardStrokes.delete(strokeId);
          if (surfaceStrokeNum) {
            this._inProgressSurfaceStrokes.delete(surfaceStrokeNum);
          }
          
          setTimeout(() => this.processCommitQueue(), 100);
        }, 1000);
      }, 40000); // Longer timeout (40s) but only as fallback
      
      // Call function to show stroke and trigger the event flow
      window.showStrokeToOthers(strokeId);
      
    } else {
      // For regular actions

      if (!room || !room.connected) {
        
        // Clean up tracking before continuing
        this._inProgressBoardStrokes.delete(strokeId);
        if (surfaceStrokeNum) this._inProgressSurfaceStrokes.delete(surfaceStrokeNum);
        
        // Continue with next item in queue
        setTimeout(() => this.processCommitQueue(), 100);
        return;
      }
      
      // Process one at a time with sequential execution guarantees
      const processStroke = () => {
        return new Promise((resolve) => {
          try {
            const result = window.showStrokeToOthers(strokeId);
            
            if (result && typeof result.then === "function") {
              result.then(resolve).catch(() => {
                // Even if it fails, resolve to continue queue
                setTimeout(resolve, 300);
              });
            } else {
              // Give plenty of time for completion
              setTimeout(resolve, 500);
            }
          } catch (err) {
            // Still resolve to keep queue moving
            setTimeout(resolve, 300);
          }
        });
      };
      
      processStroke().then(() => {
        
        // Clean up tracking before continuing
        this._inProgressBoardStrokes.delete(strokeId);
        if (surfaceStrokeNum) {
          this._inProgressSurfaceStrokes.delete(surfaceStrokeNum);
        }
        
        // Wait a consistent time before next stroke
        setTimeout(() => this.processCommitQueue(), 300);
      });
    }
  } catch (err) {
    
    // Clean up tracking before continuing
    this._inProgressBoardStrokes.delete(strokeId);
    if (surfaceStrokeNum) {
      this._inProgressSurfaceStrokes.delete(surfaceStrokeNum);
    }
    
    // Continue processing queue after error
    setTimeout(() => this.processCommitQueue(), 300);
  }
}
// Add this new method to the Board class
registerStrokeMapping(boardStrokeId, surfaceStrokeNumber) {
  if (!boardStrokeId || !surfaceStrokeNumber) return;
  
  // Create bidirectional mapping
  this.strokeIdMap.set(boardStrokeId, surfaceStrokeNumber);
  this.surfaceStrokeMap.set(surfaceStrokeNumber, boardStrokeId);
  
  return {
    boardId: boardStrokeId,
    surfaceId: surfaceStrokeNumber
  };
}
// Complete replacement for the findActionWithStrokeId method
findActionWithStrokeId(strokeId) {
  // First check the undo stack directly
  for (let i = this.undoStack.length - 1; i >= 0; i--) {
    if (this.undoStack[i].strokeId === strokeId) {
      return this.undoStack[i];
    }
  }
  
  // Check if this stroke ID has a mapping to a Surface stroke number
  const surfaceStrokeNumber = this.strokeIdMap.get(strokeId);
  
  // Use either the mapped ID or the original ID when searching surface strokes
  const searchStrokeId = surfaceStrokeNumber || strokeId;
  
  // Next, try to find the stroke in the room's surface strokes
  if (room && room.myself && room.myself.surface && room.myself.surface.strokes) {
    // Look through all the strokes in the surface
    for (const stroke of room.myself.surface.strokes) {
      if (stroke.strokeNumber === searchStrokeId) {
        
        // Direct check for move/clone actions based on finalAction property
        if (stroke.isSelectionStroke && stroke.finalAction) {
          if (stroke.finalAction === 'move') {
            return { 
              strokeId: strokeId, // Keep original strokeId for consistency
              mappedStrokeId: searchStrokeId, // Also store the mapped ID
              isMoveAction: true,
              isCloneAction: false
            };
          } else if (stroke.finalAction === 'clone') {
            return { 
              strokeId: strokeId, // Keep original strokeId for consistency
              mappedStrokeId: searchStrokeId, // Also store the mapped ID
              isMoveAction: false,
              isCloneAction: true
            };
          }
        }
        
        // Fallback check for selectionActions array
        if (stroke.isSelectionStroke && stroke.selectionActions && stroke.selectionActions.length > 0) {
          for (const action of stroke.selectionActions) {
            if (action.type === 'action') {
              if (action.action === 'move') {
                return { 
                  strokeId: strokeId, // Keep original strokeId for consistency
                  mappedStrokeId: searchStrokeId, // Also store the mapped ID
                  isMoveAction: true,
                  isCloneAction: false
                };
              } else if (action.action === 'clone') {
                return { 
                  strokeId: strokeId, // Keep original strokeId for consistency
                  mappedStrokeId: searchStrokeId, // Also store the mapped ID
                  isMoveAction: false,
                  isCloneAction: true
                };
              }
            }
          }
        }
        
        // Return the stroke even if we couldn't identify a specific action
        return {
          strokeId: strokeId, // Keep original strokeId for consistency
          mappedStrokeId: searchStrokeId, // Also store the mapped ID
          ...stroke
        };
      }
    }
  }
  
  // If not found in the strokes array, check pending strokes
  if (room && room.myself && room.myself.surface && room.myself.surface._pendingStrokes) {
    for (const stroke of room.myself.surface._pendingStrokes) {
      if (stroke.strokeNumber === searchStrokeId) {
        
        // Direct check for move/clone actions
        if (stroke.isSelectionStroke && stroke.finalAction) {
          if (stroke.finalAction === 'move') {
            return { 
              strokeId: strokeId,
              mappedStrokeId: searchStrokeId,
              isMoveAction: true,
              isCloneAction: false
            };
          } else if (stroke.finalAction === 'clone') {
            return { 
              strokeId: strokeId,
              mappedStrokeId: searchStrokeId,
              isMoveAction: false,
              isCloneAction: true
            };
          }
        }
        
        // Return the stroke even if we couldn't identify a specific action
        return {
          strokeId: strokeId,
          mappedStrokeId: searchStrokeId,
          ...stroke
        };
      }
    }
  }
  
  // Check any other arrays that might contain strokes
  const possibleStrokeArrays = [
    this._pendingSelectionStrokes,
    room?.myself?.surface?.currentStroke ? [room.myself.surface.currentStroke] : null,
    room?.myself?.surface?.completedStrokes
  ];
  
  for (const strokeArray of possibleStrokeArrays) {
    if (!strokeArray) continue;
    
    for (const stroke of strokeArray) {
      if (stroke && stroke.strokeNumber === searchStrokeId) {
        
        // Check for finalAction or selectionActions
        if (stroke.isSelectionStroke && stroke.finalAction) {
          if (stroke.finalAction === 'move') {
            return { 
              strokeId: strokeId,
              mappedStrokeId: searchStrokeId,
              isMoveAction: true,
              isCloneAction: false
            };
          } else if (stroke.finalAction === 'clone') {
            return { 
              strokeId: strokeId,
              mappedStrokeId: searchStrokeId,
              isMoveAction: false,
              isCloneAction: true
            };
          }
        }
        
        return {
          strokeId: strokeId,
          mappedStrokeId: searchStrokeId,
          ...stroke
        };
      }
    }
  }
  
  // Look for special stroke pairings in transfer history
  if (room?.board?.transferHistory) {
    // Use timestamp-based approach to find the closest match
    const now = Date.now();
    const FIVE_MINUTES = 5 * 60 * 1000;
    
    // Find transfers close to this time that might be related
    const recentTransfers = room.board.transferHistory.filter(t => 
      Math.abs(t.timestamp - now) < FIVE_MINUTES &&
      (t.type === "selection" || t.imageData)
    );
    
    if (recentTransfers.length) {

      // We could implement additional matching logic here if needed
    }
  }
  
  // If nothing found, log and return null

  return null;
}
// In Board class, update the undo method

undo() {
  if (room?.myself?.surface?.penPressed) return;
  if (!this.isUndoHistoryEnabled() || !this.undoStack.length) return;
  const action = this.undoStack.pop();
  
  // Check if this is a group action
  if (action.type === 'group') {
    // Mark this stroke as undone so it won't be committed
    if (action.strokeId) {
      this.undoneStrokes.add(action.strokeId);
    }
    
    // Create a corresponding group for redo
    const redoGroup = {
      type: 'group',
      actions: [],
      strokeId: action.strokeId,
      actionType: action.actionType
    };
    
    // Copy specific action flags
    if (action.isMoveAction) redoGroup.isMoveAction = true;
    if (action.isCloneAction) redoGroup.isCloneAction = true;
    
    // Process each action in the group
    for (const groupAction of action.actions) {
      const ctx = this.getContext(groupAction.layer);
      
      // Store current state for redo
      const currentData = ctx.getImageData(
        groupAction.bbox[0], groupAction.bbox[1], 
        groupAction.bbox[2], groupAction.bbox[3]
      );
      
      // Create the redo action
      const redoAction = {
        layer: groupAction.layer,
        bbox: groupAction.bbox,
        oldData: groupAction.newData,
        newData: currentData,
        strokeId: groupAction.strokeId,
        actionType: groupAction.actionType
      };
      
      // Copy specific action flags
      if (groupAction.isMoveAction) redoAction.isMoveAction = true;
      if (groupAction.isCloneAction) redoAction.isCloneAction = true;
      
      // Add to redo group
      redoGroup.actions.push(redoAction);
      
      // Restore old data
      ctx.putImageData(groupAction.oldData, groupAction.bbox[0], groupAction.bbox[1]);
      this.layerChanged(groupAction.layer, true);
    }
    
    // Push the group to redo stack
    this.redoStack.push(redoGroup);
  } else {
    // Handle single action
    if (action.strokeId) {
      this.undoneStrokes.add(action.strokeId);
    }
    
    // Store current state for redo
    const ctx = this.getContext(action.layer);
    const currentData = ctx.getImageData(
      action.bbox[0], action.bbox[1], 
      action.bbox[2], action.bbox[3]
    );
    
    // Create the redo action
    const redoAction = {
      layer: action.layer,
      bbox: action.bbox,
      oldData: action.newData,
      newData: currentData,
      strokeId: action.strokeId,
      actionType: action.actionType
    };
    
    // Copy specific action flags
    if (action.isMoveAction) redoAction.isMoveAction = true;
    if (action.isCloneAction) redoAction.isCloneAction = true;
    
    this.redoStack.push(redoAction);
    
    // Restore old data
    ctx.putImageData(action.oldData, action.bbox[0], action.bbox[1]);
    this.layerChanged(action.layer, true);
  }
}

// Update the redo method similarly
redo() {
  // Check if pen is currently pressed - if so, do nothing
  if (room?.myself?.surface?.penPressed) return;
  if (!this.isUndoHistoryEnabled() || !this.redoStack.length) return;
  const action = this.redoStack.pop();
  
  // Check if this is a group action
  if (action.type === 'group') {
    // Remove from undone strokes if it was previously undone
    if (action.strokeId) {
      this.undoneStrokes.delete(action.strokeId);
    }
    
    // Create a corresponding group for undo
    const undoGroup = {
      type: 'group',
      actions: [],
      strokeId: action.strokeId,
      actionType: action.actionType
    };
    
    // Copy specific action flags
    if (action.isMoveAction) undoGroup.isMoveAction = true;
    if (action.isCloneAction) undoGroup.isCloneAction = true;
    
    // Process each action in the group
    for (const groupAction of action.actions) {
      const ctx = this.getContext(groupAction.layer);
      
      // Store current state for undo
      const currentData = ctx.getImageData(
        groupAction.bbox[0], groupAction.bbox[1], 
        groupAction.bbox[2], groupAction.bbox[3]
      );
      
      // Create the undo action
      const undoAction = {
        layer: groupAction.layer,
        bbox: groupAction.bbox,
        oldData: currentData,
        newData: groupAction.oldData,
        strokeId: groupAction.strokeId,
        actionType: groupAction.actionType
      };
      
      // Copy specific action flags
      if (groupAction.isMoveAction) undoAction.isMoveAction = true;
      if (groupAction.isCloneAction) undoAction.isCloneAction = true;
      
      // Add to undo group
      undoGroup.actions.push(undoAction);
      
      // Restore new data
      ctx.putImageData(groupAction.newData, groupAction.bbox[0], groupAction.bbox[1]);
      this.layerChanged(groupAction.layer, true);
    }
    
    // Push the group to undo stack
    this.undoStack.push(undoGroup);
  } else {
    // Handle single action
    if (action.strokeId) {
      this.undoneStrokes.delete(action.strokeId);
    }
    
    // Store current state for undo
    const ctx = this.getContext(action.layer);
    const currentData = ctx.getImageData(
      action.bbox[0], action.bbox[1], 
      action.bbox[2], action.bbox[3]
    );
    
    // Create the undo action
    const undoAction = {
      layer: action.layer,
      bbox: action.bbox,
      oldData: currentData,
      newData: action.newData,
      strokeId: action.strokeId,
      actionType: action.actionType
    };
    
    // Copy specific action flags
    if (action.isMoveAction) undoAction.isMoveAction = true;
    if (action.isCloneAction) undoAction.isCloneAction = true;
    
    this.undoStack.push(undoAction);
    
    // Restore new data
    ctx.putImageData(action.newData, action.bbox[0], action.bbox[1]);
    this.layerChanged(action.layer, true);
  }
}
commitAllPendingChanges() {

  
  // Initialize progress counters but don't set active yet
  this.commitProgress = {
    processed: 0,
    total: 0,
    active: false // Start inactive until we confirm there's work
  };
  
  // Collect actions to commit
  const actionsToCommit = [];
  
  // Track both Board strokes and Surface strokes we've already processed
  const processedBoardStrokes = new Set();
  const processedSurfaceStrokes = new Set();
  
  // Process undo stack
  if (this.undoStack.length > 0) {

    
    this.undoStack.forEach(action => {
      // Skip if no stroke ID, already undone, already in queue, or already processed in this run
      if (!action.strokeId || 
          this.undoneStrokes.has(action.strokeId) || 
          this.strokeCommitQueue.includes(action.strokeId) ||
          processedBoardStrokes.has(action.strokeId)) {
        return;
      }
      
      // Check if this Board strokeId maps to a Surface stroke
      const surfaceStrokeNum = this.strokeIdMap.get(action.strokeId);
      
      // If it maps to a Surface stroke we've already processed, skip it
      if (surfaceStrokeNum && processedSurfaceStrokes.has(surfaceStrokeNum)) {

        return;
      }
      
      // Check if this stroke is currently being processed
      if (this._inProgressBoardStrokes && this._inProgressBoardStrokes.has(action.strokeId)) {

        return;
      }
      
      // Check if its Surface stroke is currently being processed
      if (surfaceStrokeNum && this._inProgressSurfaceStrokes && 
          this._inProgressSurfaceStrokes.has(surfaceStrokeNum)) {

        return;
      }
      
      // If we get here, add the action to be committed
      actionsToCommit.push(action.strokeId);
      
      // Mark both IDs as processed to prevent duplicates
      processedBoardStrokes.add(action.strokeId);
      
      if (surfaceStrokeNum) {
        processedSurfaceStrokes.add(surfaceStrokeNum);

      }
    });
  }
  

  
  // Clear the undo stack since everything will be committed
  const previousStackSize = this.undoStack.length;
  this.undoStack = [];
  
  // Also clear the redo stack
  this.redoStack = [];
  
  // Add all collected actions to the queue
  if (actionsToCommit.length > 0 || this.strokeCommitQueue.length > 0) {
    // Only set active if there's actual work to do
    this.commitProgress.active = true;
    
    if (actionsToCommit.length > 0) {

      this.commitProgress.total = actionsToCommit.length + this.strokeCommitQueue.length;
      
      // Add each action to the queue in order
      actionsToCommit.forEach(strokeId => {
        this.strokeCommitQueue.push(strokeId);
      });
    } else {
      // Update total with existing queue items
      this.commitProgress.total = this.strokeCommitQueue.length;
    }
    
    // Start processing the queue if not already processing
    if (!this.isProcessingCommit) {

      setTimeout(() => this.processCommitQueue(), 0);
    }
  } else {
    // Nothing to commit, make sure processing indicator is disabled

    this.commitProgress.active = false;
    
    // Still process the queue to handle any unmute logic
    if (this.needToUnmuteWhenComplete) {

      setTimeout(() => this.processCommitQueue(), 0);
    }
  }
  

  
  // Return useful stats
  return {
    actionsQueued: actionsToCommit.length,
    totalQueueSize: this.strokeCommitQueue.length,
    commitProgress: this.commitProgress
  };
}

  ["changeTransparency"](_0x5b9e25, _0x3cf9c3 = false) {
    this["bottomTransparency"] != _0x5b9e25 && (this["bottomTransparency"] = _0x5b9e25, $(this).triggerHandler(new bottomLayerTransparencyChangedEvent(_0x5b9e25).getEvent()));
  }
  ["changeBackground"](_0x3091c0, _0x31ad6e = false) {
    if (this["backgroundColor"] != _0x3091c0 || _0x31ad6e) {
      var _0x58ba52 = this.backgroundColor;
      this["backgroundColor"] = _0x3091c0, $(this)["triggerHandler"](new backgroundColorChangedEvent(_0x3091c0, _0x58ba52)["getEvent"]());
    }
  }
  ["changeSize"](_0x2ea2c6, _0x173068, _0x1d02e2 = false) {
    if (_0x2ea2c6 != this["canvasWidth"] || _0x173068 != this["canvasHeight"] || _0x1d02e2) {
      var _0xc0293c = this["canvasWidth"],
        _0x239fd4 = this["canvasHeight"];
      $(this).triggerHandler(new canvasSizeChangeEvent(_0x2ea2c6, _0x173068, _0xc0293c, _0x239fd4)["getEvent"]()), this["canvasWidth"] = _0x2ea2c6, this["canvasHeight"] = _0x173068, this["removeLayers"](), this.createLayers(), $(this)["triggerHandler"](new canvasSizeChangedEvent(_0x2ea2c6, _0x173068, _0xc0293c, _0x239fd4)["getEvent"]());
    }
  }
  ["changeLayers"](_0x9f30ca) {
    if (_0x9f30ca != this["nLayers"]) {
      $(this)["triggerHandler"](new layerCountChangeEvent(this.nLayers, _0x9f30ca).getEvent());
      let _0x313e39 = this["nLayers"];
      this.removeLayers(), this["nLayers"] = _0x9f30ca, this.createLayers(), $(this)["triggerHandler"](new layerCountChangedEvent(this["nLayers"], _0x313e39)["getEvent"]());
    }
  }
  ["addLayer"](_0x351d08) {
    var _0x22abf8 = new Layer(_0x351d08, this["canvasWidth"], this["canvasHeight"], "board", this.getLayerZIndex(_0x351d08)),
      _0x1c4c43 = this;
    $(_0x22abf8).on("layerFlipped", function (_0x2908fc) {
      _0x1c4c43["layerChanged"](_0x2908fc.number, true);
    }), $(_0x22abf8).on("layerCleared", function (_0x5da7fe) {
      _0x1c4c43.layerChanged(_0x5da7fe["number"], true);
    }), this["layers"].push(_0x22abf8), this["canvasContainer"]["append"](_0x22abf8["advCanvas"]["canvas"]), this.clearLayer(_0x351d08);
  }
  ["onionSkin"](_0x2caf5e) {
    this.onionSkin && this.onion["putImageData"](_0x2caf5e);
  }
  ["changeOnionSkinOpacity"](_0x2189f4) {
    this["onionSkin"] && $(this["onion"]["canvas"]).css("opacity", _0x2189f4);
  }
  ["createLayers"]() {
    this["grid"] = new AdvancedCanvas(this.canvasWidth, this["canvasHeight"]), this["grid"].canvas.addClass("canvasGrid noMouseInteraction"), this.canvasContainer["append"](this.grid["canvas"]);
    this["onionSkin"] && (this["onion"] = new AdvancedCanvas(this["canvasWidth"], this["canvasHeight"]), this.onion["canvas"]["addClass"]("canvasOnion noMouseInteraction"), this.canvasContainer["append"](this["onion"]["canvas"]));
    for (var _0x30156c = 0; _0x30156c < this.nLayers; _0x30156c++) {
      this["addLayer"](_0x30156c);
    }
  }
  ["removeLayers"]() {
    for (var _0x156433 = 0; _0x156433 < this["nLayers"]; _0x156433++) {
      this["layers"][_0x156433] && this["layers"][_0x156433]["remove"]();
    }
    this.layers = new Array(), this["canvasContainer"]["find"]("canvas.board")["remove"](), this["canvasContainer"]["find"]("canvas.canvasGrid")["remove"](), this["onionSkin"] && (this["canvasContainer"]["find"]("canvas.canvasOnion")["remove"](), this["onion"]["remove"]()), this["grid"] && this.grid["remove"]();
  }
  ["drawGrid"](_0x1e11ad, _0x5d8d6d, _0xea5ddb = true) {
    this.clearGrid(false), this["grid"].setCanvasProperties({
      linejoin: "round",
      linecap: "round",
      linewidth: 1,
      strokestyle: "#000000",
      alpha: 0.5,
      blendmode: "normal",
      blur: 0,
      linedash: []
    });
    var _0x3b1ac0 = 100,
      _0x27d511 = this.grid["getContext"]();
    _0x27d511["beginPath"]();
    var _0x383b8a = this["canvasWidth"] / _0x5d8d6d,
      _0x1ecd10 = this["canvasHeight"] / _0x1e11ad;
    for (var _0x59f5c7 = 0; _0x59f5c7 < _0x5d8d6d; _0x59f5c7++) {
      _0x27d511.moveTo(_0x59f5c7 * _0x383b8a, 0), _0x27d511["lineTo"](_0x59f5c7 * _0x383b8a, this["canvasHeight"]);
    }
    for (var _0x45bf51 = 0; _0x45bf51 < _0x1e11ad; _0x45bf51++) {
      _0x27d511["moveTo"](0, _0x45bf51 * _0x1ecd10), _0x27d511["lineTo"](this["canvasWidth"], _0x45bf51 * _0x1ecd10);
    }
    _0x27d511["stroke"](), this["grid"]["canvas"].show();
  }
  ["clearGrid"](_0x38bda6 = true) {
    this.grid.clear(), _0x38bda6 && this["grid"]["canvas"].hide();
  }
  ["offset"]() {
    return this["canvasContainer"]["offset"]();
  }
  ["layerChanged"](_0x112b12, _0x49e34d = false) {
    $(this)["triggerHandler"](new layerChangedEvent(_0x112b12, _0x49e34d)["getEvent"]()), this["lastChangeTime"] = new Date();
  }
  ["clearLayers"]() {
    for (var _0x26fb1c = 0; _0x26fb1c < this["nLayers"]; _0x26fb1c++) {
      this.clearLayer(_0x26fb1c);
    }
  }
  ["partiallyClearLayer"](_0x258e9c, _0x3ce255 = null, _0x2034ae = 0, _0x20f0ab = 0, _0x214cac = null, _0x43a690 = null) {
    if (_0x258e9c in this["layers"]) {
      var _0x13b76a = _0x258e9c == 0 && !this["bottomTransparency"] ? this.backgroundColor : -1;
      this["layers"][_0x258e9c].clear(_0x3ce255 == null ? _0x13b76a : _0x3ce255, _0x2034ae, _0x20f0ab, _0x214cac, _0x43a690);
    }
  }
  ["clearLayer"](_0x1bb3fd, _0x28d117 = null) {
    if (_0x1bb3fd in this["layers"]) {
      var _0x279677 = _0x1bb3fd == 0 && !this.bottomTransparency ? this.backgroundColor : -1;
      this.layers[_0x1bb3fd].clear(_0x28d117 == null ? _0x279677 : _0x28d117), $(this)["triggerHandler"](new clearLayerEvent(_0x1bb3fd)["getEvent"]());
    }
  }
  ["clearMask"](_0x5b8403, _0x1b1add, _0x2e9f43 = null) {
    if (_0x5b8403 in this["layers"]) {
      var _0x388799 = _0x5b8403 == 0 && !this["bottomTransparency"] ? this["backgroundColor"] : -1;
      this.layers[_0x5b8403].clearMask(_0x1b1add, _0x2e9f43 == null ? _0x388799 : _0x2e9f43);
    }
  }
  ["flipLayer"](_0x42ad39, _0x4f66f3 = true, _0x367018 = false) {
    _0x42ad39 in this.layers && (this["layers"][_0x42ad39]["flip"](_0x4f66f3, _0x367018), _0x4f66f3 && $(this)["triggerHandler"](new flipLayerEvent(_0x42ad39, "horizontal")["getEvent"]()), _0x367018 && $(this).triggerHandler(new flipLayerEvent(_0x42ad39, "vertical").getEvent()));
  }
  ["lockLayer"](_0x45eb10) {
    _0x45eb10 in this.layers && (this.layers[_0x45eb10].lock(), $(this)["triggerHandler"](new layerLockedEvent(_0x45eb10)["getEvent"]()));
  }
  ["unlockLayer"](_0x1550e3) {
    _0x1550e3 in this["layers"] && (this["layers"][_0x1550e3]["unlock"](), $(this)["triggerHandler"](new layerUnlockedEvent(_0x1550e3).getEvent()));
  }
  ["mergeLayer"](_0xb89af1, _0x48d305) {
    var _0x5ee2db = $("<canvas />");
    _0x5ee2db["attr"]("width", this["canvasWidth"]), _0x5ee2db["attr"]("height", this["canvasHeight"]);
    var _0x11685c = _0x5ee2db[0]["getContext"]("2d"),
      _0x9bb6d3 = this["getContext"](_0xb89af1),
      _0x3c0ba3 = this["getContext"](_0x48d305),
      _0x4b338c = _0xb89af1,
      _0x55efc3 = _0x48d305;
    _0x4b338c > _0x55efc3 && (_0x4b338c = _0x48d305, _0x55efc3 = _0xb89af1);
    var _0x2376eb = this,
      _0x2c3c97 = new Image();
    _0x2c3c97.onload = function () {
      _0x11685c["drawImage"](_0x2c3c97, 0, 0, _0x11685c.canvas["width"], _0x11685c["canvas"]["height"]);
      var _0x154f13 = new Image();
      _0x154f13.onload = function () {
        _0x11685c["drawImage"](_0x154f13, 0, 0, _0x11685c["canvas"].width, _0x11685c["canvas"]["height"]);
        var _0x4b043c = new Image();
        _0x4b043c["onload"] = function () {
          _0x9bb6d3["clearRect"](0, 0, _0x9bb6d3.canvas["width"], _0x9bb6d3["canvas"]["height"]), _0x3c0ba3["clearRect"](0, 0, _0x3c0ba3["canvas"]["width"], _0x3c0ba3.canvas["height"]), _0x2376eb.layers[_0x48d305]["advCanvas"]["setCanvasProperties"]({
            blendmode: "normal"
          });
          let _0xc92fd = _0x3c0ba3["globalAlpha"];
          _0x3c0ba3["globalAlpha"] = 1, _0x3c0ba3["drawImage"](_0x4b043c, 0, 0, _0x11685c.canvas["width"], _0x11685c["canvas"]["height"]), _0x3c0ba3["globalAlpha"] = _0xc92fd, _0x2376eb["layerChanged"](_0xb89af1, true), _0x2376eb["layerChanged"](_0x48d305, true), _0x5ee2db["remove"](), $(_0x2376eb)["triggerHandler"](new mergeLayerEvent(_0xb89af1, _0x48d305).getEvent());
        }, _0x4b043c.src = _0x5ee2db[0]["toDataURL"]("image/png");
      }, _0x154f13.src = _0x2376eb["layers"][_0x55efc3]["getData"]();
    }, _0x2c3c97["src"] = _0x2376eb["layers"][_0x4b338c]["getData"]();
  }
  ["getContext"](_0x545e6e) {
    if (_0x545e6e in this["layers"]) return this["layers"][_0x545e6e]["getContext"](true);
    return null;
  }
  ["getLayerZIndex"](_0x5c9b7b) {
    return this.zIndexFrom + _0x5c9b7b * 2;
  }
  ["getLayerData"](_0xef4810) {
    if (_0xef4810 in this["layers"]) return this["layers"][_0xef4810]["getData"]();
    return null;
  }
  ["putLayerData"](_0x3b91af, _0x42463c, _0x4837fd = 0, _0x4cde60 = 0, _0x3c1477 = null, _0x2d3dc1 = null, _0x3f401e = 0) {
    if (_0x3b91af in this.layers) {
      let _0x523f90 = this.layers[_0x3b91af]["putData"](_0x42463c, _0x4837fd, _0x4cde60, _0x3c1477, _0x2d3dc1, _0x3f401e);
      return this["layerChanged"](_0x3b91af), _0x523f90;
    }
  }
  ["setZoom"](_0x56ebdc) {
    this["scale"] != _0x56ebdc && this["changeScale"](_0x56ebdc, true);
  }
  ["increaseZoom"](_0x284489 = null) {
    _0x284489 == null && (_0x284489 = this["zoomStep"]), this["scale"] + _0x284489 <= this["maxZoom"] && this["changeScale"](this["scale"] + _0x284489);
  }
  ["decreaseZoom"](_0x3fede3 = null) {
    _0x3fede3 == null && (_0x3fede3 = this["zoomStep"]), this.scale - _0x3fede3 >= this["minZoom"] && this["changeScale"](this["scale"] - _0x3fede3);
  }
  ["changeScale"](_0x459635, _0x369d38 = false) {
    // Check if preciseZoomDisplay is enabled
    if (localStorage.getItem("preciseZoomDisplay") === "true") {
        _0x459635 = parseInt(_0x459635 * 1000) / 1000;
    } else {
        _0x459635 = parseInt(_0x459635 * 100) / 100;
    }
    
    this["scale"] != _0x459635 && (this.scale = _0x459635, this["boardContainer"]["css"]("transform", "scale(" + _0x459635 + ") rotate(" + this.rotation + "deg) translateZ(0)"), $(this).triggerHandler(new scaleChangedEvent(_0x459635, _0x369d38)["getEvent"]()));
  }
  ["changeRotationDefault"](_0x265160) {
    _0x265160 = parseInt(_0x265160);
    if (_0x265160 >= 360) _0x265160 = _0x265160 - 360; 
    else _0x265160 < 0 && (_0x265160 = 360 + _0x265160);
    
    this["rotation"] != _0x265160 && (
      this["rotation"] = _0x265160, 
      this["boardContainer"].css("transform", "scale(" + this["scale"] + ") rotate(" + _0x265160 + "deg) translateZ(0)"), 
      $(this)["triggerHandler"](new rotationChangedEvent(_0x265160)["getEvent"]())
    );
  }
  
  ["changeRotationPositionAware"](_0x265160) {
    _0x265160 = parseInt(_0x265160);
    if (_0x265160 >= 360) _0x265160 -= 360;
    else if (_0x265160 < 0) _0x265160 = 360 + _0x265160;
  
    if (this["rotation"] !== _0x265160) {
      // Calculate center before rotation
      const xC = -(UI.screenToBoard(UI.drawingArea.offset().left + UI.drawingArea.width()/2, UI.drawingArea.offset().top + UI.drawingArea.height()/2).x);
      const yC = -(UI.screenToBoard(UI.drawingArea.offset().left + UI.drawingArea.width()/2, UI.drawingArea.offset().top + UI.drawingArea.height()/2).y);
  
      // Apply new rotation
      this["rotation"] = _0x265160;
      this["boardContainer"].css("transform",
        "scale(" + this["scale"] + ") rotate(" + _0x265160 + "deg) translateZ(0)"
      );
      $(this).triggerHandler(new rotationChangedEvent(_0x265160).getEvent());
  
      // Calculate center after rotation
      const xC1 = -(UI.screenToBoard(UI.drawingArea.offset().left + UI.drawingArea.width()/2, UI.drawingArea.offset().top + UI.drawingArea.height()/2).x);
      const yC1 = -(UI.screenToBoard(UI.drawingArea.offset().left + UI.drawingArea.width()/2, UI.drawingArea.offset().top + UI.drawingArea.height()/2).y);
  
      // Keep top-left anchored
      const deltaX = xC1 - xC;
      const deltaY = yC1 - yC;
      const x1 = -(UI.screenToBoard(UI.drawingArea.offset().left, UI.drawingArea.offset().top).x);
      const y1 = -(UI.screenToBoard(UI.drawingArea.offset().left, UI.drawingArea.offset().top).y);
      movePointToTopLeft(-x1 + deltaX, -y1 + deltaY);
    }
  }
  ["getAllLayers"](_0x30e798 = 0, _0x2214ef = 0, _0x20a53d = undefined, _0x5d90bd = undefined) {
    _0x20a53d === undefined && (_0x20a53d = this.canvasWidth);
    _0x5d90bd === undefined && (_0x5d90bd = this.canvasHeight);
    var _0x26f7c3 = this;
    return new Promise(function (_0x535713, _0x50e294) {
      var _0x10e007 = _0x26f7c3["getImgLayers"]({}, _0x30e798, _0x2214ef, _0x20a53d, _0x5d90bd);
      _0x10e007.then(function (_0x4cb3e8) {
        _0x535713(_0x4cb3e8);
      });
    });
  }
  ["getImgLayers"](_0x19cd6e, _0x575cae, _0x1e7ece, _0x1c208e, _0x2acf6d, _0xee0fa8 = null) {
    var _0x5803f3 = this;
    return new Promise(function (_0x5c3fcb, _0x1106a7) {
      var _0x1b8a86 = _0x5803f3["nextLayer"](_0xee0fa8);
      if (_0x1b8a86 != null) {
        var _0x3170f7 = new AdvancedCanvas(_0x1c208e, _0x2acf6d),
          _0x1dd386 = _0x5803f3["getContext"](_0x1b8a86),
          _0x2a0f63 = _0x1dd386["getImageData"](_0x575cae, _0x1e7ece, _0x1c208e, _0x2acf6d);
        _0x3170f7["putImageData"](_0x2a0f63), _0x19cd6e[_0x1b8a86] = _0x3170f7["getData"](), _0x3170f7["remove"]();
        var _0x1a2e8d = _0x5803f3["getImgLayers"](_0x19cd6e, _0x575cae, _0x1e7ece, _0x1c208e, _0x2acf6d, _0x1b8a86);
        _0x1a2e8d["then"](function (_0x4b619a) {
          _0x4b619a == false ? _0x5c3fcb(_0x19cd6e) : _0x5c3fcb(_0x4b619a);
        });
      } else _0x5c3fcb(false);
    });
  }
  ["nextLayer"](_0xa066d7 = null, _0x2de05c = false) {
    for (var _0x37d9bf = 0; _0x37d9bf < this.nLayers; _0x37d9bf++) {
      if (!_0x2de05c || _0x2de05c && this["layers"][_0x37d9bf]["visible"]) {
        if (_0xa066d7 == null || _0xa066d7 < _0x37d9bf) return _0x37d9bf;
      }
    }
    return null;
  }
  ["getPixelAllLayers"](_0x3b5ea5, _0x271d1d, _0x8cc768 = false) {
    var _0x257dde = $("<canvas />");
    _0x257dde["attr"]("width", 1), _0x257dde["attr"]("height", 1);
    var _0xb0b2b7 = _0x257dde[0]["getContext"]("2d");
    !_0x8cc768 && (_0xb0b2b7["fillStyle"] = this["backgroundColor"], _0xb0b2b7["fillRect"](0, 0, 1, 1));
    for (var _0x146902 = 0; _0x146902 < this["nLayers"]; _0x146902++) {
      if (this["layers"][_0x146902]["visible"]) {
        var _0x2bcd9c = this["getContext"](_0x146902),
          _0x1ee144 = _0x2bcd9c["getImageData"](_0x3b5ea5, _0x271d1d, 1, 1)["data"];
        _0xb0b2b7["fillStyle"] = "rgba(" + _0x1ee144[0] + "," + _0x1ee144[1] + "," + _0x1ee144[2] + "," + _0x1ee144[3] / 255 + ")", _0xb0b2b7.fillRect(0, 0, 1, 1);
      }
    }
    var _0x1d3151 = _0xb0b2b7["getImageData"](0, 0, 1, 1)["data"];
    return _0x257dde["remove"](), _0x1d3151;
  }
  ["getImageData"](_0x2502a9, _0x24baa1 = 0, _0x4d6b44 = 0, _0x364a02 = null, _0x51bc77 = null) {
    var _0x1c8f33 = this["getContext"](_0x2502a9, true);
    return _0x1c8f33["getImageData"](_0x24baa1, _0x4d6b44, _0x364a02 == null ? _0x1c8f33.canvas["width"] : _0x364a02, _0x51bc77 == null ? _0x1c8f33["canvas"]["height"] : _0x51bc77);
  }
  ["destroy"]() {
    this.cursorContainer.remove(), this["canvasContainer"]["remove"]();
  }
}
class Cursor {
  constructor(_0xb8d23b) {
    this.surface = _0xb8d23b;
    this.x;
    this.y;
    this.size;
    this.pressure = 1;
    this.subPointerVisible = true;
    this.labelOffset = new Point(5, -5);
    this.graphic = $("<div />").addClass("cursor");
    if (this.surface.isMyself) this.graphic.addClass("myself");
    this.pointer = $("<div/>").addClass("pointer");
    this.graphic.append(this.pointer);
    this.subPointer = $("<div/>").addClass("pointer");
    this.graphic.append(this.subPointer);
    this.label = $("<div/>").addClass("pointerLabel");
    this.graphic.append(this.label);
    room.board.cursorContainer.append(this.graphic);

    // Feature toggle: Counter-Strike Cursor
    const csCursorEnabled =
      localStorage.getItem(
        (window.config && window.config.localStorageKeys && window.config.localStorageKeys.csCursor) || "csCursor"
      ) === "true";

    // Choose initial pointer style
    if (csCursorEnabled && this.surface.isMyself) {
      if (typeof window.OWN_CURSOR_OPACITY !== "number") window.OWN_CURSOR_OPACITY = 0.35;
      this.graphic.css("opacity", window.OWN_CURSOR_OPACITY);
      this.changePointer("pscross");
    } else {
      this.changePointer("circle");
    }

    const _self = this;

    $(this.surface).on("brushOptionChanged", function (e) {
      if (e.option == "size") {
        _self.size = e.value;
        _self.update(_self.x, _self.y, _self.size, _self.pressure);
      } else if (e.option == "pressure") {
        _self.pressure = e.value[1];
        _self.update(_self.x, _self.y, _self.size, _self.pressure);
      }
    });

    $(this.surface).on("penMove penDown penUp", function (e) {
      _self.x = e.x;
      _self.y = e.y;
      _self.update(_self.x, _self.y, _self.size, _self.pressure);
      if (e.type == "penUp" || _self.pressure == 1) _self.hideSubPointer();
      else _self.surface.penPressed && _self.showSubPointer();
    });

    $(this.surface).on("brushChanged", function () {
      _self.size = _self.surface.brushHandler.getOption("size");
      _self.pressure = _self.surface.brushHandler.hasOption("pressure")
        ? _self.surface.brushHandler.getOption("pressure")[1]
        : 1;
      _self.update(_self.x, _self.y, _self.size, _self.pressure);
    });
  }
  ["showSubPointer"]() {
    !this.subPointerVisible && (this["subPointer"]["show"](), this["subPointerVisible"] = true);
  }
  ["hideSubPointer"]() {
    this["subPointerVisible"] && (this.subPointer.hide(), this["subPointerVisible"] = false);
  }
  ["changePointer"](_0x528a06) {
    var _0x54faf3 = {};
    _0x54faf3["circle"] = "pointerCircle", _0x54faf3["square"] = "pointerSquare", _0x54faf3.crosshair = "pointerCrosshair", _0x54faf3["cross"] = "pointerCross", _0x54faf3["dot"] = "pointerDot", _0x54faf3["invisible"] = "pointerInvisible";
    var _0x5dd2fa = this;
    $["each"](Object["keys"](_0x54faf3), function (_0x2f3e0b, _0x26c861) {
      _0x5dd2fa["pointer"]["removeClass"](_0x54faf3[_0x26c861]), _0x5dd2fa["subPointer"].removeClass(_0x54faf3[_0x26c861]);
    }), this["pointer"].addClass(_0x54faf3[_0x528a06]), this["subPointer"]["addClass"](_0x54faf3[_0x528a06]);
  }
  ["setPosition"](_0x10bd9e, _0x35f88c) {
    this.x = _0x10bd9e, this.y = _0x35f88c;
  }
  ["showUsername"]() {
    this["label"]["css"]("visibility", "visible");
  }
  ["hideUsername"]() {
    this["label"]["css"]("visibility", "hidden");
  }
  ["getUsername"]() {
    this["label"]["html"]();
  }
  ["setUsername"](_0x4906cb) {
    this["label"].html(_0x4906cb);
  }
  ["update"](_0x69005e, _0x5429ef, _0x1ff046, _0x272846) {
    this["graphic"]["css"]({
      left: _0x69005e - _0x1ff046 / 2,
      top: _0x5429ef - _0x1ff046 / 2
    }), this["pointer"]["css"]({
      width: _0x1ff046 + "px",
      height: _0x1ff046 + "px"
    });
    var _0x22e821 = _0x1ff046 * _0x272846;
    this["subPointer"]["css"]({
      left: (_0x1ff046 - _0x22e821) / 2 + "px",
      top: (_0x1ff046 - _0x22e821) / 2 + "px",
      width: _0x22e821 + "px",
      height: _0x22e821 + "px"
    }), this["label"]["css"]({
      left: this.labelOffset.x + _0x1ff046 / 2 + "px",
      top: this.labelOffset.y + _0x1ff046 / 2 + "px"
    });
  }
  ["isVisible"]() {
    return this["label"].is(":visible");
  }
  ["show"]() {
    this["graphic"]["show"]();
  }
  ["hide"]() {
    this["graphic"]["hide"]();
  }
  ["delete"]() {
    this["graphic"]["remove"]();
  }
}
class FMEvent {
  constructor() {
    this["event"] = null;
  }
  ["getEvent"]() {
    return this["event"];
  }
}
class checkboxChangeEvent extends FMEvent {
  constructor(_0x244fdf) {
    super(), this.event = jQuery["Event"]("checkboxChange"), this["event"].checked = _0x244fdf;
  }
}
class checkboxChangedEvent extends FMEvent {
  constructor(_0x5d4088) {
    super(), this["event"] = jQuery.Event("checkboxChanged"), this.event["checked"] = _0x5d4088;
  }
}
class buttonClickedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("buttonClicked");
  }
}
class listChangedEvent extends FMEvent {
  constructor(_0x372a10) {
    super(), this["event"] = jQuery.Event("listChanged"), this["event"]["value"] = _0x372a10;
  }
}
class sliderChangeEvent extends FMEvent {
  constructor(_0x59ed70, _0x50ec14 = null) {
    super(), this["event"] = jQuery["Event"]("sliderChange"), this["event"]["oldvalue"] = _0x50ec14, this["event"].value = _0x59ed70;
  }
}
class sliderChangedEvent extends FMEvent {
  constructor(_0x1511ed, _0xd236b3 = null) {
    super(), this["event"] = jQuery["Event"]("sliderChanged"), this["event"]["oldvalue"] = _0xd236b3, this["event"]["value"] = _0x1511ed;
  }
}
class sliderCheckChangeEvent extends FMEvent {
  constructor(_0x40951, _0x513a2a = null) {
    super(), this["event"] = jQuery.Event("sliderCheckChange"), this["event"]["oldvalue"] = _0x513a2a, this["event"]["value"] = _0x40951;
  }
}
class sliderCheckChangedEvent extends FMEvent {
  constructor(_0x21baf5, _0x2e2867 = null) {
    super(), this.event = jQuery["Event"]("sliderCheckChanged"), this["event"].oldvalue = _0x2e2867, this.event["value"] = _0x21baf5;
  }
}
class sliderMovedEvent extends FMEvent {
  constructor(_0x5cf0c9, _0x4cde1e = null) {
    super(), this["event"] = jQuery["Event"]("sliderMoved"), this.event.oldvalue = _0x4cde1e, this["event"]["value"] = _0x5cf0c9;
  }
}
class transferStartEvent extends FMEvent {
  constructor(_0x20a9ab, _0x3eb294, _0x4462a4, _0x1c9e88, _0x4f1f1d) {
    super(), this["event"] = jQuery["Event"]("transferStart"), this["event"]["targettype"] = _0x20a9ab, this.event["username"] = _0x3eb294, this["event"]["ttype"] = _0x4462a4, this.event.timestamp = _0x1c9e88, this["event"]["mask"] = _0x4f1f1d;
  }
}
class slateUseChangedEvent extends FMEvent {
  constructor(_0x2ff450) {
    super(), this["event"] = jQuery["Event"]("slateUseChanged"), this["event"].inUse = _0x2ff450;
  }
}
class uploadModeChangedEvent extends FMEvent {
  constructor(_0x10384f) {
    super(), this["event"] = jQuery.Event("uploadModeChanged"), this["event"]["status"] = _0x10384f;
  }
}
class transferLayerCompleteEvent extends FMEvent {
  constructor(_0x46309f, _0x51afdc, _0x5ddc06, _0x19a5ec, _0x4e75a1, _0x5d4151, _0x4729ef, _0x48592a, _0x5a60ca, _0x3b9a29, _0x4e40d6, _0x3c1c64) {
    super(), this.event = jQuery["Event"]("transferLayerComplete"), this.event.targettype = _0x46309f, this["event"]["username"] = _0x51afdc, this["event"].ttype = _0x5ddc06, this["event"]["timestamp"] = _0x19a5ec, this["event"].layer = _0x4e75a1, this["event"].x = _0x5d4151, this["event"].y = _0x4729ef, this["event"]["width"] = _0x48592a, this.event["height"] = _0x5a60ca, this.event["rotation"] = _0x3b9a29, this.event["mask"] = _0x4e40d6, this.event["chunk"] = _0x3c1c64;
  }
}
class transferCompleteEvent extends FMEvent {
  constructor(_0x3f2bf1, _0x1901c6, _0x106a4c, _0x2cca95, _0x18e1bf) {
    super(), this["event"] = jQuery.Event("transferComplete"), this.event["targettype"] = _0x3f2bf1, this["event"]["username"] = _0x1901c6, this["event"]["ttype"] = _0x106a4c, this["event"]["timestamp"] = _0x2cca95, this["event"]["fullboard"] = _0x18e1bf;
  }
}
class transferProgressEvent extends FMEvent {
  constructor(_0x469516, _0x211d9f, _0x225156, _0xa90594, _0x35f13e, _0x5a6bc7, _0x4d7a48, _0x3e7a1a) {
    super(), this["event"] = jQuery["Event"]("transferProgress"), this["event"]["targettype"] = _0x469516, this["event"]["username"] = _0x211d9f, this["event"].ttype = _0x225156, this["event"]["timestamp"] = _0xa90594, this["event"]["layerPos"] = _0x35f13e, this["event"].layerCount = _0x5a6bc7, this["event"]["position"] = _0x4d7a48, this["event"]["max"] = _0x3e7a1a;
  }
}
class transferFailEvent extends FMEvent {
  constructor(_0x19e50c, _0x3b7366, _0x1b6574, _0x1cd50a) {
    super(), this["event"] = jQuery["Event"]("transferFail"), this["event"]["targettype"] = _0x19e50c, this.event["username"] = _0x3b7366, this["event"].ttype = _0x1b6574, this["event"]["timestamp"] = _0x1cd50a;
  }
}
class transferChunkReadyEvent extends FMEvent {
  constructor(_0x33ca5c, _0x4425f0, _0x55f3f2, _0xdaa975, _0x2e671a, _0x50f41f, _0x4af35e, _0x32e0bb, _0x1100ca, _0x861efe, _0x2ddae7, _0x2fd128, _0x58f797, _0x4e4582) {
    super(), this["event"] = jQuery.Event("transferChunkReady"), this["event"]["targettype"] = _0x33ca5c, this["event"]["username"] = _0x4425f0, this["event"]["ttype"] = _0x55f3f2, this["event"]["timestamp"] = _0xdaa975, this["event"]["layer"] = _0x2e671a, this["event"].layerCount = _0x50f41f, this["event"].position = _0x4af35e, this["event"]["max"] = _0x32e0bb, this["event"].x = _0x1100ca, this["event"].y = _0x861efe, this["event"].width = _0x2ddae7, this["event"]["height"] = _0x2fd128, this["event"].rotation = _0x58f797, this["event"]["chunk"] = _0x4e4582;
  }
}
class usernameChangedEvent extends FMEvent {
  constructor(_0x4c2b81, _0x54003b) {
    super(), this["event"] = jQuery.Event("usernameChanged"), this["event"]["oldname"] = _0x54003b, this["event"]["newname"] = _0x4c2b81;
  }
}
class statusChangedEvent extends FMEvent {
  constructor(_0x4857f1) {
    super(), this.event = jQuery["Event"]("statusChanged"), this["event"]["status"] = _0x4857f1;
  }
}
class rankChangedEvent extends FMEvent {
  constructor(_0x36b348) {
    super(), this["event"] = jQuery["Event"]("rankChanged"), this["event"].rank = _0x36b348;
  }
}
class connectionIssueChangedEvent extends FMEvent {
  constructor(_0x57ac5b) {
    super(), this.event = jQuery["Event"]("connectionIssueChanged"), this["event"]["status"] = _0x57ac5b;
  }
}
class muteChangedEvent extends FMEvent {
  constructor(_0x4e2bd) {
    super(), this["event"] = jQuery["Event"]("muteChanged"), this.event["status"] = _0x4e2bd;
  }
}
class muteTimerStartedEvent extends FMEvent {
  constructor(_0x4256cf) {
    super(), this.event = jQuery["Event"]("muteTimerStarted"), this["event"]["time"] = _0x4256cf;
  }
}
class silenceChangedEvent extends FMEvent {
  constructor(_0x3c9328) {
    super(), this["event"] = jQuery.Event("silenceChanged"), this.event["status"] = _0x3c9328;
  }
}
class ignoreChangedEvent extends FMEvent {
  constructor(_0x4dec86) {
    super(), this["event"] = jQuery["Event"]("ignoreChanged"), this["event"].status = _0x4dec86;
  }
}
class userIgnoredEvent extends FMEvent {
  constructor(_0x205d0e) {
    super(), this["event"] = jQuery["Event"]("userIgnored"), this["event"]["username"] = _0x205d0e;
  }
}
class userUnignoredEvent extends FMEvent {
  constructor(_0x32b1f3) {
    super(), this["event"] = jQuery.Event("userUnignored"), this["event"]["username"] = _0x32b1f3;
  }
}
class inactiveChangedEvent extends FMEvent {
  constructor(_0x3bf620) {
    super(), this["event"] = jQuery["Event"]("inactiveChanged"), this["event"]["status"] = _0x3bf620;
  }
}
class inputDeviceChangedEvent extends FMEvent {
  constructor(_0x15575c) {
    super(), this["event"] = jQuery["Event"]("inputDeviceChanged"), this["event"].inputDevice = _0x15575c;
  }
}
class scaleChangedEvent extends FMEvent {
  constructor(_0x37a02f, _0x3a7e13) {
    super(), this["event"] = jQuery["Event"]("scaleChanged"), this["event"].scale = _0x37a02f, this.event["center"] = _0x3a7e13;
  }
}
class rotationChangedEvent extends FMEvent {
  constructor(_0x4311b9) {
    super(), this.event = jQuery["Event"]("rotationChanged"), this["event"].rotation = _0x4311b9;
  }
}
class roomChangedEvent extends FMEvent {
  constructor(_0x464744, _0x20a683) {
    super(), this.event = jQuery["Event"]("roomChanged"), this["event"].newName = _0x464744, this["event"]["oldName"] = _0x20a683;
  }
}
class roomTypeChangedEvent extends FMEvent {
  constructor(_0x3793d5, _0x1841df) {
    super(), this.event = jQuery["Event"]("roomTypeChanged"), this.event["newType"] = _0x3793d5, this["event"]["oldType"] = _0x1841df;
  }
}
class roomPrivilegesChangedEvent extends FMEvent {
  constructor(_0x2c324a) {
    super(), this["event"] = jQuery["Event"]("roomPrivilegesChanged"), this.event["privileges"] = _0x2c324a;
  }
}
class roomToolsChangedEvent extends FMEvent {
  constructor(_0x438ee6) {
    super(), this["event"] = jQuery.Event("roomToolsChanged"), this["event"]["tools"] = _0x438ee6;
  }
}
class canvasSizeChangeEvent extends FMEvent {
  constructor(_0x39a93d, _0x657e46, _0x468668, _0x1cac3f) {
    super(), this["event"] = jQuery["Event"]("canvasSizeChange"), this["event"].newWidth = _0x39a93d, this["event"]["newHeight"] = _0x657e46, this["event"]["oldWidth"] = _0x468668, this.event.oldHeight = _0x1cac3f;
  }
}
class canvasSizeChangedEvent extends FMEvent {
  constructor(_0x44e7b8, _0x4f9515, _0x582d35, _0x34bf3e) {
    super(), this["event"] = jQuery["Event"]("canvasSizeChanged"), this["event"].newWidth = _0x44e7b8, this["event"]["newHeight"] = _0x4f9515, this["event"].oldWidth = _0x582d35, this["event"]["oldHeight"] = _0x34bf3e;
  }
}
class imageChangedEvent extends FMEvent {
  constructor(_0x40f9fc, _0x3173c9, _0x34fd08, _0x93ad29, _0xd2d078) {
    super(), this["event"] = jQuery["Event"]("imageChanged"), this["event"].x = _0x40f9fc, this.event.y = _0x3173c9, this["event"].width = _0x34fd08, this["event"].height = _0x93ad29, this.event["rotation"] = _0xd2d078;
  }
}
class silhouetteChangedEvent extends FMEvent {
  constructor(_0x4a50e6, _0x440c0d, _0x26507c, _0x3a9da1, _0x2d7bf7) {
    super(), this["event"] = jQuery.Event("silhouetteChanged"), this["event"].x = _0x4a50e6, this["event"].y = _0x440c0d, this["event"]["width"] = _0x26507c, this["event"]["height"] = _0x3a9da1, this["event"]["rotation"] = _0x2d7bf7;
  }
}
class backgroundColorChangedEvent extends FMEvent {
  constructor(_0x128d81, _0x3f189d) {
    super(), this.event = jQuery["Event"]("backgroundColorChanged"), this["event"]["newColor"] = _0x128d81, this["event"]["oldColor"] = _0x3f189d;
  }
}
class bottomLayerTransparencyChangedEvent extends FMEvent {
  constructor(_0x3c4d5e) {
    super(), this["event"] = jQuery["Event"]("bottomLayerTransparencyChanged"), this.event["transparency"] = _0x3c4d5e;
  }
}
class roomConnectedEvent extends FMEvent {
  constructor(_0x55e99e, _0x4b80fa, _0x333278) {
    super(), this["event"] = jQuery["Event"]("roomConnected"), this["event"].room = _0x55e99e, this["event"]["rtype"] = _0x4b80fa, this["event"].description = _0x333278;
  }
}
class roomDisconnectedEvent extends FMEvent {
  constructor(_0x4b0a53, _0x4eb12d, _0x207a7d) {
    super(), this["event"] = jQuery["Event"]("roomDisconnected"), this["event"]["room"] = _0x4b0a53;
  }
}
class layerCountChangedEvent extends FMEvent {
  constructor(_0x2db15c, _0x29e146 = null) {
    super(), this.event = jQuery["Event"]("layerCountChanged"), this["event"]["layers"] = _0x2db15c, this["event"]["oldLayers"] = _0x29e146;
  }
}
class layerCountChangeEvent extends FMEvent {
  constructor(_0x3181e7, _0x479556) {
    super(), this["event"] = jQuery.Event("layerCountChange"), this["event"]["layers"] = _0x3181e7, this["event"]["oldLayers"] = _0x3181e7;
  }
}
class layerChangedEvent extends FMEvent {
  constructor(_0x5ee6f0, _0xb8f1cf = false) {
    super(), this["event"] = jQuery["Event"]("layerChanged"), this["event"].layer = _0x5ee6f0, this["event"].immediate = _0xb8f1cf;
  }
}
class layerSelectedEvent extends FMEvent {
  constructor(_0x1fc090) {
    super(), this["event"] = jQuery["Event"]("layerSelected"), this["event"].layer = _0x1fc090;
  }
}
class slatePriorityChangedEvent extends FMEvent {
  constructor(_0x1382da) {
    super(), this.event = jQuery["Event"]("slatePriorityChanged"), this["event"]["zindex"] = _0x1382da;
  }
}
class penDownEvent extends FMEvent {
  constructor(_0x3b1488, _0x5001cf) {
    super(), this["event"] = jQuery["Event"]("penDown"), this["event"].x = _0x3b1488, this.event.y = _0x5001cf;
  }
}
class penUpEvent extends FMEvent {
  constructor(_0x3e3901, _0x2173c2) {
    super(), this["event"] = jQuery["Event"]("penUp"), this["event"].x = _0x3e3901, this.event.y = _0x2173c2;
  }
}
class penMoveEvent extends FMEvent {
  constructor(_0xefd1c8, _0x5a67b6) {
    super(), this["event"] = jQuery["Event"]("penMove"), this.event.x = _0xefd1c8, this["event"].y = _0x5a67b6;
  }
}
class penCancelEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("penCancel");
  }
}
class penHideEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("penHide");
  }
}
class penShowEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery.Event("penShow");
  }
}
class keyPressEvent extends FMEvent {
  constructor(_0x26af17) {
    super(), this["event"] = jQuery["Event"]("keyPress"), this["event"]["key"] = _0x26af17;
  }
}

class modifierDownEvent extends FMEvent {
  constructor(_0x128e95) {
    super(), this["event"] = jQuery["Event"]("modifierDown"), this["event"]["code"] = _0x128e95;
  }
}
class modifierUpEvent extends FMEvent {
  constructor(_0x5a9c79) {
    super(), this["event"] = jQuery["Event"]("modifierUp"), this["event"].code = _0x5a9c79;
  }
}
class brushParameterEvent extends FMEvent {
  constructor(_0x3bd5e1, _0x4e1426) {
    super(), this["event"] = jQuery["Event"]("brushParameter"), this.event.brush = _0x3bd5e1, this["event"].parameters = _0x4e1426;
  }
}
class clearLayerEvent extends FMEvent {
  constructor(_0x5a1902) {
    super(), this["event"] = jQuery["Event"]("clearLayer"), this["event"]["layer"] = _0x5a1902;
  }
}
class layerActionRequestEvent extends FMEvent {
  constructor(_0x1ad98d, _0x2f4eb5, _0x3e4d27) {
    super(), this.event = jQuery["Event"]("layerActionRequest"), this.event["action"] = _0x1ad98d, this["event"]["layerFrom"] = _0x2f4eb5, this.event["layerTo"] = _0x3e4d27;
  }
}
class userActionRequestEvent extends FMEvent {
  constructor(_0x3d24a3, _0xd131c6) {
    super(), this.event = jQuery["Event"]("userActionRequest"), this["event"]["action"] = _0x3d24a3, this["event"]["username"] = _0xd131c6;
  }
}
class flipLayerEvent extends FMEvent {
  constructor(_0x2e8047, _0x243aa5) {
    super(), this["event"] = jQuery["Event"]("flipLayer"), this["event"]["layer"] = _0x2e8047, this["event"].mode = _0x243aa5;
  }
}
class mergeLayerEvent extends FMEvent {
  constructor(_0x3fd4cb, _0x311c59) {
    super(), this["event"] = jQuery["Event"]("mergeLayer"), this["event"]["layerFrom"] = _0x3fd4cb, this["event"]["layerTo"] = _0x311c59;
  }
}
class colorChangedEvent extends FMEvent {
  constructor(_0x47ee77) {
    super(), this["event"] = jQuery["Event"]("colorChanged"), this["event"]["color"] = _0x47ee77;
  }
}
class brushChangedEvent extends FMEvent {
  constructor(_0x117227) {
    super(), this["event"] = jQuery["Event"]("brushChanged"), this["event"]["brush"] = _0x117227;
  }
}
class brushOptionChangedEvent extends FMEvent {
  constructor(_0x5a5b2a, _0x1f8c83) {
    super(), this.event = jQuery.Event("brushOptionChanged"), this.event["option"] = _0x5a5b2a, this["event"].value = _0x1f8c83;
  }
}
class brushOptionReadOnlyEvent extends FMEvent {
  constructor(_0x29550d, _0x2c0ea5) {
    super(), this["event"] = jQuery["Event"]("brushOptionReadOnly"), this["event"]["option"] = _0x29550d, this["event"]["status"] = _0x2c0ea5;
  }
}
class userJoinedEvent extends FMEvent {
  constructor(_0x1184c8, _0x4dc61d) {
    super(), this.event = jQuery["Event"]("userJoined"), this["event"]["username"] = _0x1184c8, this["event"]["wasintheroom"] = _0x4dc61d;
  }
}
class userLeavingEvent extends FMEvent {
  constructor(_0x48c292, _0x25f52f = null) {
    super(), this.event = jQuery["Event"]("userLeaving"), this["event"].username = _0x48c292, this["event"]["reason"] = _0x25f52f;
  }
}
class userLeftEvent extends FMEvent {
  constructor(_0x57cc9b, _0x18c172 = null) {
    super(), this["event"] = jQuery.Event("userLeft"), this["event"]["username"] = _0x57cc9b, this.event.reason = _0x18c172;
  }
}
class youLeftEvent extends FMEvent {
  constructor(_0x283a9a, _0xaa0903) {
    super(), this["event"] = jQuery["Event"]("youLeft"), this["event"]["username"] = _0x283a9a, this["event"]["room"] = _0xaa0903;
  }
}
class confirmationClosedEvent extends FMEvent {
  constructor(_0xc293da) {
    super(), this.event = jQuery.Event("confirmationClosed"), this["event"]["response"] = _0xc293da;
  }
}
class floatingToolbarOpenedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("floatingToolbarOpened");
  }
}
class floatingToolbarClosedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("floatingToolbarClosed");
  }
}
class uploaderOpenedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery.Event("uploaderOpened");
  }
}
class uploaderClosedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("uploaderClosed");
  }
}
class dialogOpenedEvent extends FMEvent {
  constructor(_0x478a31) {
    super(), this["event"] = jQuery.Event("dialogOpened"), this["event"].name = _0x478a31;
  }
}
class dialogClosedEvent extends FMEvent {
  constructor(_0x259fbd) {
    super(), this["event"] = jQuery["Event"]("dialogClosed"), this["event"]["name"] = _0x259fbd;
  }
}
class dialogModalEnabledEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("dialogModalEnabled");
  }
}
class dialogModalDisabledEvent extends FMEvent {
  constructor() {
    super(), this.event = jQuery.Event("dialogModalDisabled");
  }
}
class dialogContentChangedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("dialogContentChanged");
  }
}
class dialogSizeTypeChangedEvent extends FMEvent {
  constructor(_0x344523, _0x3e7662) {
    super(), this["event"] = jQuery.Event("dialogSizeTypeChanged"), this["event"]["current"] = _0x344523, this["event"].previous = _0x3e7662;
  }
}
class windowResizingStartedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("windowResizingStarted");
  }
}
class windowResizingEndedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("windowResizingEnded");
  }
}
class dialogResizingStartedEvent extends FMEvent {
  constructor(_0x3bc91c = "Dialog") {
    super(), this.event = jQuery["Event"]("dialogResizingStarted"), this["event"]["resizeType"] = _0x3bc91c;
  }
}
class dialogResizingEndedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery.Event("dialogResizingEnded");
  }
}

class dialogDraggingStartedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("dialogDraggingStarted");
  }
}
class dialogDraggingEndedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("dialogDraggingEnded");
  }
}
class dialogMaximizedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("dialogMaximized");
  }
}
class dialogRestoredEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery.Event("dialogRestored");
  }
}
class layerFlippedEvent extends FMEvent {
  constructor(_0x2356f1) {
    super(), this["event"] = jQuery["Event"]("layerFlipped"), this["event"].number = _0x2356f1;
  }
}
class layerClearedEvent extends FMEvent {
  constructor(_0x43b589) {
    super(), this["event"] = jQuery.Event("layerCleared"), this.event["number"] = _0x43b589;
  }
}
class layerLockedEvent extends FMEvent {
  constructor(_0x5b7afa) {
    super(), this["event"] = jQuery.Event("layerLocked"), this["event"]["layer"] = _0x5b7afa;
  }
}
class layerUnlockedEvent extends FMEvent {
  constructor(_0x47eb9d) {
    super(), this["event"] = jQuery["Event"]("layerUnlocked"), this["event"].layer = _0x47eb9d;
  }
}
class optionSelectedEvent extends FMEvent {
  constructor(_0x34d043) {
    super(), this["event"] = jQuery["Event"]("optionSelected"), this.event["option"] = _0x34d043;
  }
}
class viewFlippedEvent extends FMEvent {
  constructor(_0x332e59) {
    super(), this["event"] = jQuery.Event("viewFlipped"), this["event"]["status"] = _0x332e59;
  }
}
class elementResizedEvent extends FMEvent {
  constructor(_0x197398, _0x382c82, _0x17a9f2, _0x25e678, _0x1aa74a) {
    super(), this["event"] = jQuery["Event"]("elementResized"), this["event"].x = _0x197398, this["event"].y = _0x382c82, this.event.width = _0x17a9f2, this["event"]["height"] = _0x25e678, this["event"]["movingFrom"] = _0x1aa74a;
  }
}
class shortcutPressedEvent extends FMEvent {
  constructor(_0x49b4da, _0xa993ac, _0x3448fb, _0x2ef690, _0x37f4d4, _0x1fd1ab) {
    super(), this["event"] = jQuery["Event"]("shortcutPressed"), this["event"].id = _0x49b4da, this["event"]["stype"] = _0xa993ac, this["event"]["shortcut"] = _0x3448fb, this.event["category"] = _0x2ef690, this["event"]["wod"] = _0x37f4d4, this["event"]["eventType"] = _0x1fd1ab;
  }
}
class shortcutReleasedEvent extends FMEvent {
  constructor(_0x29552c, _0x3d0bee, _0x234bc7, _0x4fa52a, _0x513fbb, _0x472ffa, _0x470abf) {
    super(), this["event"] = jQuery["Event"]("shortcutReleased"), this.event.id = _0x29552c, this["event"].stype = _0x3d0bee, this.event["shortcut"] = _0x234bc7, this.event["category"] = _0x4fa52a, this["event"].wod = _0x513fbb, this["event"]["eventType"] = _0x472ffa, this["event"]["heldFor"] = _0x470abf;
  }
}
class pageSelectedEvent extends FMEvent {
  constructor(_0x5cbe09) {
    super(), this["event"] = jQuery["Event"]("pageSelected"), this.event["page"] = _0x5cbe09;
  }
}
class tableRowSelectedEvent extends FMEvent {
  constructor(_0x4d1904) {
    super(), this["event"] = jQuery.Event("tableRowSelected"), this["event"].selection = _0x4d1904;
  }
}
class tableRowUnselectedEvent extends FMEvent {
  constructor(_0x4630e0) {
    super(), this["event"] = jQuery["Event"]("tableRowUnselected");
  }
}
class tableRowDoubleClickEvent extends FMEvent {
  constructor(_0x1a480b) {
    super(), this.event = jQuery["Event"]("tableRowDoubleClick"), this["event"]["selection"] = _0x1a480b;
  }
}
class socketConnectedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("socketConnected");
  }
}
class socketDisconnectedEvent extends FMEvent {
  constructor(_0x375440, _0xfdf569) {
    super(), this["event"] = jQuery["Event"]("socketDisconnected"), this.event["intentional"] = _0x375440, this["event"]["inRoom"] = _0xfdf569;
  }
}
class socketErrorEvent extends FMEvent {
  constructor(_0x8ddf35) {
    super(), this["event"] = jQuery.Event("socketError"), this["event"].gotContact = _0x8ddf35;
  }
}
class socketNegotiatedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery.Event("socketNegotiated");
  }
}
class buttonPressedEvent extends FMEvent {
  constructor(_0x1db6fd, _0x54da6c = null) {
    super(), this["event"] = jQuery["Event"]("buttonPressed"), this.event.id = _0x1db6fd, this["event"]["element"] = _0x54da6c;
  }
}
class bubbleClickedEvent extends FMEvent {
  constructor(_0x45c93b, _0x3fe129, _0x56518f, _0x3aa45e, _0x6f5438 = null) {
    super(), this["event"] = jQuery.Event("bubbleClicked"), this["event"].gridid = _0x45c93b, this["event"]["number"] = _0x3fe129, this["event"]["etype"] = _0x56518f, this.event["btype"] = _0x3aa45e, this.event["obj"] = _0x6f5438;
  }
}
class layerOptionClickedEvent extends FMEvent {
  constructor(_0x47f7d8, _0x11c599, _0x2ced31) {
    super(), this["event"] = jQuery["Event"]("layerOptionClicked"), this.event.id = _0x47f7d8, this["event"].layer = _0x11c599, this["event"]["parameters"] = _0x2ced31;
  }
}
class windowFocusedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery.Event("windowFocused");
  }
}
class windowBlurredEvent extends FMEvent {
  constructor() {
    super(), this.event = jQuery.Event("windowBlurred");
  }
}
class emojiSelectedEvent extends FMEvent {
  constructor(_0x57a331) {
    super(), this["event"] = jQuery["Event"]("emojiSelected"), this["event"]["emoji"] = _0x57a331;
  }
}
class processFinishedEvent extends FMEvent {
  constructor() {
    super(), this.event = jQuery.Event("processFinished");
  }
}
class imageLoadedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("imageLoaded");
  }
}
class fileLoadedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("fileLoaded");
  }
}
class localeChangedEvent extends FMEvent {
  constructor(_0x58be76, _0x55a30b) {
    super(), this["event"] = jQuery.Event("localeChanged"), this.event["current"] = _0x58be76, this["event"]["previous"] = _0x55a30b;
  }
}
class unreadMessagesEvent extends FMEvent {
  constructor(_0x446195, _0x529da6 = null) {
    super(), this["event"] = jQuery["Event"]("unreadMessages"), this["event"]["messages"] = _0x446195, this["event"]["messagetype"] = _0x529da6;
  }
}
class chatChannelPropertyChangedEvent extends FMEvent {
  constructor(_0x1335d6, _0x29e859) {
    super(), this.event = jQuery["Event"]("chatChannelPropertyChanged"), this["event"].prop = _0x1335d6, this["event"]["value"] = _0x29e859;
  }
}
class sidebarCollapsedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("sidebarCollapsed");
  }
}
class sidebarUncollapsedEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("sidebarUncollapsed");
  }
}
class elementCollapsedEvent extends FMEvent {
  constructor(_0x35c6aa) {
    super(), this.event = jQuery["Event"]("elementCollapsed"), this["event"].id = _0x35c6aa;
  }
}
class elementHeightChangedEvent extends FMEvent {
  constructor(_0x2ef27f, _0x2afa77) {
    super(), this["event"] = jQuery["Event"]("elementHeightChanged"), this.event.id = _0x2ef27f, this.event["height"] = _0x2afa77;
  }
}
class elementUncollapsedEvent extends FMEvent {
  constructor(_0x52f68d) {
    super(), this["event"] = jQuery["Event"]("elementUncollapsed"), this["event"].id = _0x52f68d;
  }
}
class componentEnabledEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery["Event"]("componentEnabled");
  }
}
class componentDisabledEvent extends FMEvent {
  constructor() {
    super(), this["event"] = jQuery.Event("componentDisabled");
  }
}
class firstSyncStartedEvent extends FMEvent {
  constructor(_0x14344e, _0x5d3469) {
    super(), this["event"] = jQuery["Event"]("firstSyncStarted"), this["event"]["username"] = _0x14344e, this["event"].roomsession = _0x5d3469;
  }
}
class firstSyncProgressEvent extends FMEvent {
  constructor(_0x4d54ff, _0x27d7e8) {
    super(), this["event"] = jQuery["Event"]("firstSyncProgress"), this["event"]["username"] = _0x4d54ff, this["event"].progress = _0x27d7e8;
  }
}
class firstSyncEndedEvent extends FMEvent {
  constructor(_0xbc6239, _0x27c238 = false) {
    super(), this["event"] = jQuery["Event"]("firstSyncEnded"), this["event"]["username"] = _0xbc6239, this["event"]["failed"] = _0x27c238;
    UI.firstSyncEnabled = false;
  }
}
class userRenamedEvent extends FMEvent {
  constructor(_0xc19df2, _0x1753de, _0x531d02, _0x151c20) {
    super(), this["event"] = jQuery["Event"]("userRenamed"), this["event"]["beforeRank"] = _0xc19df2, this["event"]["beforeUsername"] = _0x1753de, this["event"]["afterRank"] = _0x531d02, this["event"]["afterUsername"] = _0x151c20;
  }
}
class userUnwantedEvent extends FMEvent {
  constructor(_0x25c646) {
    super(), this["event"] = jQuery["Event"]("userUnwanted"), this["event"]["reason"] = _0x25c646;
  }
}
class animationFrameChangedEvent extends FMEvent {
  constructor(_0xc294f5, _0x24880e) {
    super(), this["event"] = jQuery["Event"]("animationFrameChanged"), this["event"]["rows"] = _0xc294f5, this["event"]["cols"] = _0x24880e;
  }
}
class viewSizeChangedEvent extends FMEvent {
  constructor(_0x540ce3, _0x539c5b, _0x36398c) {
    super(), this["event"] = jQuery["Event"]("viewSizeChanged"), this["event"]["limited"] = _0x540ce3, this.event["width"] = _0x539c5b, this.event["height"] = _0x36398c;
  }
}
class userTaggedEvent extends FMEvent {
  constructor(_0x5157a1, _0x29e7a6 = "") {
    super(), this.event = jQuery["Event"]("userTagged"), this.event["username"] = _0x5157a1, this["event"].filter = _0x29e7a6;
  }
}
class propertyChangedEvent extends FMEvent {
  constructor(_0x12d4f1, _0x18d0f1) {
    super(), this["event"] = jQuery.Event("propertyChanged"), this.event["property"] = _0x12d4f1, this["event"]["value"] = _0x18d0f1;
  }
}
var bypassDenied101 = localStorage.getItem('bypassDenied101') === 'true';
class FrameBuffer {
    constructor(_0x4b1b25) {
      this.user = _0x4b1b25;
      this.buffer = new Array();
      this.obuffer = new Array();
      this.netcode = new NetworkCode(_0x4b1b25);
      this.isAlone = false;
      this.user.surface.isMyself && this.bindEvents();
  
      // Authorization system (always enabled)
      this.authorizedSources = new Set();
      this.defaultBlockMessages = localStorage.getItem('undoHistoryEnabled') !== 'false';
    
      // Always bypass auth for certain events
      this.alwaysAuthorizedEvents = new Set([
        'statusChanged', 
        'inactiveChanged', 
        'usernameChanged', 
        'userActionRequest'
      ]);
      
      // Throttling properties (only used when bypassDenied101 is true)
      if (bypassDenied101) {
        this.sendCounts = Array(10).fill(0); 
        this.currentIntervalCount = 0;
        this.intervalIndex = 0;
        this.lastIntervalTime = Date.now();
        this.maxSendsPerSecond = 500;
      }
    }
    
    authorizeSource(sourceId) {
      if (!sourceId) return false;
      this.authorizedSources.add(sourceId);
  
      return true;
    }
    
    revokeSource(sourceId) {
      if (!sourceId) return false;
      const result = this.authorizedSources.delete(sourceId);
  
      return result;
    }
    
    isSourceAuthorized(sourceId) {
      return sourceId && this.authorizedSources.has(sourceId);
    }
    
    bindEvents() {
      var _0x566753 = this;
      $(this.user.surface).on("penDown", function(_0x3fca08) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.penDown(_0x3fca08));
      });
      $(this.user.surface).on("penUp", function(_0x1c069e) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.penUp(_0x1c069e));
      });
      $(this.user.surface).on("penMove", function(_0x532b30) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.penMove(_0x532b30));
      });
      $(this.user.surface).on("penCancel", function(_0x5cfea0) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.penCancel(_0x5cfea0));
      });
      $(this.user.surface).on("layerSelected", function(_0x4f7b6b) {
        _0x566753.outBuffer(_0x566753.netcode.layerSelected(_0x4f7b6b));
      });
      $(this.user.surface).on("penHide", function(_0x1c7d26) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.penHide(_0x1c7d26));
      });
      $(this.user.surface).on("penShow", function(_0x4a9dbf) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.penShow(_0x4a9dbf));
      });
      $(this.user.surface).on("keyPress", function(_0x4fd0bc) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.keyPress(_0x4fd0bc));
      });
      $(this.user.surface).on("modifierDown", function(_0x2db476) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.modifierDown(_0x2db476));
      });
      $(this.user.surface).on("modifierUp", function(_0xae972e) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.modifierUp(_0xae972e));
      });
      $(this.user.surface).on("brushParameter", function(_0xf6844e) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.brushParameter(_0xf6844e));
      });
      $(this.user.surface).on("colorChanged", function(_0xdb76d5) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.colorChanged(_0xdb76d5));
      });
      $(this.user.surface).on("brushChanged", function(_0x45bff2) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.brushChanged(_0x45bff2));
      });
      $(this.user.surface).on("brushOptionChanged", function(_0x6ac63c) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.brushOptionChanged(_0x6ac63c));
      });
      $(this.user.surface).on("uploadModeChanged", function(_0x1055d9) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.uploadModeChanged(_0x1055d9));
      });
      $(this.user.surface).on("silhouetteChanged", function(_0x2d80b6) {
        if (!_0x566753.isAlone) _0x566753.outBuffer(_0x566753.netcode.silhouetteChanged(_0x2d80b6));
      });
      $(this.user.surface).on("layerActionRequest", function(_0xbac86b) {
        _0x566753.outBuffer(_0x566753.netcode.layerActionRequest(_0xbac86b));
      });
      $(this.user.surface).on("userActionRequest", function(_0x26ce06) {
        _0x566753.outBuffer(_0x566753.netcode.userActionRequest(_0x26ce06), null, 'userActionRequest');
      });
      $(this.user).on("usernameChanged", function(_0x100e30) {
        _0x566753.outBuffer(_0x566753.netcode.usernameChanged(_0x100e30), null, 'usernameChanged');
      });
      $(this.user).on("statusChanged", function(_0x2f2c5d) {
        _0x566753.outBuffer(_0x566753.netcode.statusChanged(_0x2f2c5d), null, 'statusChanged');
      });
      $(this.user).on("inactiveChanged", function(_0x5823f0) {
        _0x566753.outBuffer(_0x566753.netcode.inactiveChanged(_0x5823f0), null, 'inactiveChanged');
      });
      $(this.user).on("inputDeviceChanged", function(_0x10f56d) {
        _0x566753.outBuffer(_0x566753.netcode.inputDeviceChanged(_0x10f56d));
      });
    }
    
    alone(_0x506c79) {
      this.isAlone = _0x506c79;
    }
  
    outBuffer(_0x3bdda1, sourceId = null, eventType = null) {
      this.obuffer.push({
        data: _0x3bdda1,
        source: sourceId,
        eventType: eventType,
        authorized: this.isSourceAuthorized(sourceId) || (eventType && this.alwaysAuthorizedEvents.has(eventType)),
        timestamp: Date.now()
      });
    }  
    pushNetCode(_0x4d3ff5) {
      this.buffer.push(_0x4d3ff5);
    }
  
    execFrame() {
      if (bypassDenied101) {
        // Throttled version with authorization
        const now = Date.now();
        
        if (now - this.lastIntervalTime >= 100) {
          this.lastIntervalTime = now;
          this.sendCounts[this.intervalIndex] = this.currentIntervalCount;
          this.intervalIndex = (this.intervalIndex + 1) % 10;
          this.currentIntervalCount = 0;
          this.isThrottled = this.sendCounts.reduce((sum, count) => sum + count, 0) > this.maxSendsPerSecond;
        }
        
        const maxSendsThisFrame = this.isThrottled ? this.maxSendsPerSecond/2 : this.maxSendsPerSecond;
        let sendsThisFrame = 0;
        let blockedCount = 0;
        
        while (this.obuffer.length > 0 && sendsThisFrame < maxSendsThisFrame) {
          const event = this.obuffer.shift();
          if (event.authorized || !this.defaultBlockMessages) {
            socket.send(event.data);
            sendsThisFrame++;
            this.currentIntervalCount++;
          } else {
            blockedCount++;
          }
        }
      } else {
        // Non-throttled version with authorization
        if (this.obuffer.length > 0) {
          let _0x15a86b = "", _0x1ea01a = "";
          let authorizedEvents = [];
          
          while (this.obuffer.length > 0) {
            const event = this.obuffer.shift();
            if (event.authorized || !this.defaultBlockMessages) {
              authorizedEvents.push(event.data);
            }
          }
          
          if (authorizedEvents.length > 0) {
            for (let i = 0; i < authorizedEvents.length; i++) {
              _0x15a86b += _0x1ea01a + authorizedEvents[i];
              _0x1ea01a = "\t";
            }
            socket.send(_0x15a86b);
          }
        }
      }
      
      // Process input buffer (common for both versions)
      while (this.buffer.length > 0) {
        this.netcode.execFrame(this.buffer.shift());
      }
    }
  }
class NetworkCode {
  constructor(_0x57635f) {
    this["user"] = _0x57635f;
  }
  ["penDown"](_0x127fd4) {
    var _0x4dc80d = {};
    return _0x4dc80d["command"] = "BROADCAST", _0x4dc80d.action = "Pd", _0x4dc80d.x = formatNumber(_0x127fd4.x, 2), _0x4dc80d.y = formatNumber(_0x127fd4.y, 2), JSON["stringify"](_0x4dc80d);
  }
  ["penUp"](_0x252ece) {
    var _0x576d9e = {};
    return _0x576d9e.command = "BROADCAST", _0x576d9e["action"] = "Pu", _0x576d9e.x = formatNumber(_0x252ece.x, 2), _0x576d9e.y = formatNumber(_0x252ece.y, 2), JSON.stringify(_0x576d9e);
  }
  ["penMove"](_0xb1f833) {
    var _0x471eb4 = {};
    return _0x471eb4.command = "BROADCAST", _0x471eb4["action"] = "Pm", _0x471eb4.x = formatNumber(_0xb1f833.x, 2), _0x471eb4.y = formatNumber(_0xb1f833.y, 2), JSON["stringify"](_0x471eb4);
  }
  ["penCancel"](_0x3aa9df) {
    var _0x3b2a67 = {};
    return _0x3b2a67["command"] = "BROADCAST", _0x3b2a67["action"] = "Pcl", JSON["stringify"](_0x3b2a67);
  }
  ["layerSelected"](_0x581e45) {
    var _0x45d9be = {};
    return _0x45d9be["command"] = "BROADCAST", _0x45d9be["action"] = "La", _0x45d9be["layer"] = _0x581e45["layer"], JSON["stringify"](_0x45d9be);
  }
  ["penHide"](_0x3f0528) {
    var _0x3252fe = {};
    return _0x3252fe["command"] = "BROADCAST", _0x3252fe["action"] = "Phi", JSON["stringify"](_0x3252fe);
  }
  ["penShow"](_0x1f4772) {
    var _0x5d188e = {};
    return _0x5d188e.command = "BROADCAST", _0x5d188e["action"] = "Psh", JSON["stringify"](_0x5d188e);
  }
  ["keyPress"](_0x5bd071) {
    var _0x4b9a3e = {};
    return _0x4b9a3e["command"] = "BROADCAST", _0x4b9a3e["action"] = "Kp", _0x4b9a3e.key = _0x5bd071["key"], JSON["stringify"](_0x4b9a3e);
  }
  ["modifierDown"](_0x2c7995) {
    var _0x1e15b6 = {};
    return _0x1e15b6.command = "BROADCAST", _0x1e15b6["action"] = "Mfd", _0x1e15b6["code"] = _0x2c7995["code"], JSON["stringify"](_0x1e15b6);
  }
  ["modifierUp"](_0x436992) {
    var _0x1df4e5 = {};
    return _0x1df4e5["command"] = "BROADCAST", _0x1df4e5["action"] = "Mfu", _0x1df4e5["code"] = _0x436992["code"], JSON["stringify"](_0x1df4e5);
  }
  ["brushParameter"](_0x289e3c) {
    var _0x53c2e7 = {};
    return _0x53c2e7["command"] = "BROADCAST", _0x53c2e7["action"] = "Brp", _0x53c2e7["brush"] = _0x289e3c["brush"], _0x53c2e7["parameters"] = _0x289e3c.parameters, JSON.stringify(_0x53c2e7);
  }
  ["userActionRequest"](_0x8261c2) {
    var _0x260ffd = {};
    return _0x260ffd["command"] = "ACTIONREQUEST", _0x260ffd.action = _0x8261c2["action"], _0x260ffd["username"] = _0x8261c2["username"], JSON["stringify"](_0x260ffd);
  }
  ["layerActionRequest"](_0x1935c8) {
    var _0x4fd67f = {};
    return _0x4fd67f["command"] = "ACTIONREQUEST", _0x4fd67f["action"] = _0x1935c8.action, _0x4fd67f["layerFrom"] = _0x1935c8.layerFrom, _0x4fd67f["layerTo"] = _0x1935c8.layerTo, JSON.stringify(_0x4fd67f);
  }
  ["colorChanged"](_0x561510) {
    var _0x21ba03 = {};
    return _0x21ba03["command"] = "BROADCAST", _0x21ba03.action = "Cch", _0x21ba03["color"] = _0x561510.color, JSON["stringify"](_0x21ba03);
  }
  ["brushChanged"](_0x4b8753) {
    var _0x266401 = {};
    return _0x266401["command"] = "BROADCAST", _0x266401.action = "Bch", _0x266401["brush"] = _0x4b8753["brush"], JSON["stringify"](_0x266401);
  }
  ["brushOptionChanged"](_0x3af9b3) {
    var _0x18a28f = {};
    return _0x18a28f["command"] = "BROADCAST", _0x18a28f["action"] = "Bop", _0x18a28f["option"] = _0x3af9b3["option"], _0x18a28f["value"] = _0x3af9b3.value, JSON["stringify"](_0x18a28f);
  }
  ["uploadModeChanged"](_0x453392) {
    var _0x86e89f = {};
    return _0x86e89f.command = "BROADCAST", _0x86e89f.action = "Upm", _0x86e89f.status = _0x453392["status"], JSON["stringify"](_0x86e89f);
  }
  ["silhouetteChanged"](_0x54b64d) {
    var _0x2814fe = {};
    return _0x2814fe.command = "BROADCAST", _0x2814fe["action"] = "Sic", _0x2814fe.x = _0x54b64d.x, _0x2814fe.y = _0x54b64d.y, _0x2814fe["width"] = _0x54b64d["width"], _0x2814fe["height"] = _0x54b64d["height"], _0x2814fe.rotation = _0x54b64d.rotation, JSON["stringify"](_0x2814fe);
  }
  ["usernameChanged"](_0x2fab4e) {
    var _0x1943dc = {};
    return _0x1943dc["command"] = "BROADCAST", _0x1943dc.action = "Uch", _0x1943dc["oldname"] = _0x2fab4e["oldname"], _0x1943dc.newname = _0x2fab4e["newname"], JSON["stringify"](_0x1943dc);
  }
  ["statusChanged"](_0x21760b) {
    var _0x3bf4b5 = {};
    return _0x3bf4b5.command = "BROADCAST", _0x3bf4b5["action"] = "Sch", _0x3bf4b5["status"] = _0x21760b["status"], JSON["stringify"](_0x3bf4b5);
  }
  ["inactiveChanged"](_0x5f539f) {
    var _0x2305e3 = {};
    return _0x2305e3.command = "USERFUNCTIONS", _0x2305e3.action = "Activity", _0x2305e3["status"] = _0x5f539f["status"], JSON["stringify"](_0x2305e3);
  }
  ["inputDeviceChanged"](_0x4191cc) {
    var _0x559213 = {};
    return _0x559213.command = "BROADCAST", _0x559213["action"] = "Dch", _0x559213["inputDevice"] = _0x4191cc["inputDevice"], JSON["stringify"](_0x559213);
  }
  ["execFrame"](_0x34d017) {
    if (_0x34d017["action"] == "Pm") this["user"]["surface"]["penMove"](_0x34d017.x, _0x34d017.y); else {
      if (_0x34d017["action"] == "Pu") this["user"]["surface"].penUp(_0x34d017.x, _0x34d017.y); else {
        if (_0x34d017.action == "Pd") this["user"]["surface"]["penDown"](_0x34d017.x, _0x34d017.y); else {
          if (_0x34d017["action"] == "Pcl") this["user"]["surface"].penCancel(); else {
            if (_0x34d017["action"] == "Cch") this["user"]["surface"]["setColor"](_0x34d017["color"]); else {
              if (_0x34d017.action == "Bch") this.user["surface"]["setBrush"](_0x34d017.brush); else {
                if (_0x34d017["action"] == "Bop") this["user"]["surface"]["setBrushOption"](_0x34d017["option"], _0x34d017.value); else {
                  if (_0x34d017["action"] == "Upm") this["user"]["surface"]["setUploadMode"](_0x34d017["status"]); else {
                    if (_0x34d017["action"] == "Sic") this.user.surface.drawSilhouette(_0x34d017.x, _0x34d017.y, _0x34d017["width"], _0x34d017["height"], _0x34d017["rotation"]); else {
                      if (_0x34d017["action"] == "La") this["user"]["surface"]["setCurrentLayer"](_0x34d017["layer"]); else {
                        if (_0x34d017["action"] == "Kp") this["user"]["surface"].keyPress(_0x34d017["key"]); else {
                          if (_0x34d017["action"] == "Mfd") this["user"]["surface"]["modifierDown"](_0x34d017.code); else {
                            if (_0x34d017.action == "Mfu") this.user["surface"].modifierUp(_0x34d017.code); else {
                              if (_0x34d017.action == "Brp") this["user"]["surface"].brushParameter(_0x34d017.parameters, _0x34d017.brush); else {
                                if (_0x34d017["action"] == "Psh") this.user["surface"]["penShow"](); else {
                                  if (_0x34d017["action"] == "Phi") this["user"].surface.penHide(); else {
                                    if (_0x34d017["action"] == "Sch") this.user["changeStatus"](_0x34d017["status"]); else {
                                      if (_0x34d017["action"] == "Ich") this["user"]["changeInactive"](_0x34d017["status"]); else _0x34d017["action"] == "Dch" && this["user"]["changeInputDevice"](_0x34d017.inputDevice);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
var fixSelectionOptionsStuck = localStorage.getItem("fixSelectionOptionsStuck")
class PenSurface {
  constructor(_0x35d986 = false) {
    this["isMyself"] = _0x35d986, this["penPressed"] = false, this["uploadMode"] = false, this["slate"] = new AdvancedCanvas(room.board["canvasWidth"], room["board"]["canvasHeight"]), this["slate"]["canvas"]["addClass"]("slate " + (this.isMyself ? "myself" : "noMouseInteraction")), this["slateInUse"] = false, room.board["canvasContainer"]["append"](this["slate"]["canvas"]), this["setCurrentLayer"](0), this["drawColor"] = "#000000", this.stepFrom, this["cursor"] = new Cursor(this), this["cursor"]["hide"](), this["lastPenDown"], this["lastPenUp"], this["maxSize"] = 140, this["brushHandler"] = new BrushHandler(this);
    if (fixSelectionOptionsStuck === "true") {
      this.setBrushOptionReadOnly = this.setBrushOptionReadOnlyModified
    }    
    // Set lineSnap feature based on localStorage
    this.lineSnapFeatureEnabled = localStorage.getItem("lineSnappingShift") === "true";
    
    if (fixSelectionOptionsStuck === "true") {
      this.setBrushOptionReadOnly = this.setBrushOptionReadOnlyModified
    }    
    if (_0x35d986) { // Only initialize recording for ourselves
      this.strokes = [];
      this.currentStrokeData = null;
      this.strokeCount = 0;
      this.isReplaying = false;
      
      // Text tool specific tracking
      this.textModeActive = false;
      this.textModeKeyEvents = [];
      this.textModeStartTime = null;
      this.textModeStartPoint = null;
  
      // Make replay accessible from console
      window.replayStroke = (strokeNum) => this.replayStroke(strokeNum);
      window.replayAllStrokes = () => this.replayAllStrokes();
      window.showStrokeToOthers = (strokeNum) => this.showStrokeToOthers(strokeNum);
      this.textInputLock = false;
      this.pendingTextCaptures = [];
      this.lastTextCaptureTime = 0;
      this.textStrokeNumbers = new Set(); // Track assigned stroke numbers

      this.polygonPoints = []; // Store points for polygonal selection
      this.isAddingPolygonPoint = false; // Flag to handle penMove only from penDown
      this.isClosingPolygon = false; // Flag to allow penUp when closing
      this._lastPolygonalPenDownTime = null; // For double-click detection
      this._lastPolygonalPoint = null;
    }
  }

  addPlaceholderTransfer() {
    // Initialize transferHistory if it doesn't exist
    if (!room.board.transferHistory) {
      room.board.transferHistory = [];
    }
    
    // Add minimal placeholder
    const placeholder = {
      timestamp: Date.now(),
      isPlaceholder: true
    };
    
    // Add to history
    room.board.transferHistory.push(placeholder);
  }
  
  ["getDrawerInfo"]() {
    // Get username if available
    let username = "Unknown";
    
    if (this.isMyself) {
      // For our own surface
      username = room.myself ? room.myself.username : "Me";
      return { isMyself: true, username: username };
    } else {
      // For other users, try to find their username
      // The cursor might have the username
      if (this.cursor && typeof this.cursor.getUsername === 'function') {
        username = this.cursor.getUsername();
      } 
      // If the PenSurface is attached to a user object, get username from there
      else if (this._userObj && this._userObj.username) {
        username = this._userObj.username;
      }
      return { isMyself: false, username: username };
    }
  }
  ["imageUploadComplete"](imageData) {
    if (this.isMyself && !this.isReplaying && 
        this.getCurrentBrush() === "selection" && 
        this.currentStrokeData?.isSelectionStroke) {

      this.currentStrokeData.selectionActions.push({
        type: 'imageComplete',
        time: new Date().getTime(),
        imageData: imageData ? true : false // Don't store the actual image data, just record that it completed
      });
    }
  }

  ["showStrokeToOthers"](strokeNum) {
    return new Promise((resolve, reject) => {
      if (!this.isMyself) {

        return reject("Not myself");
      }
      
      // First try to find the stroke directly
      let stroke = this.strokes.find(s => s.strokeNumber === strokeNum);
      
      // If not found, check if there's a mapping from Board strokeId to Surface strokeNumber
      if (!stroke && room.board && room.board.strokeIdMap) {
        const surfaceStrokeNum = room.board.strokeIdMap.get(strokeNum);
        if (surfaceStrokeNum) {

          stroke = this.strokes.find(s => s.strokeNumber === surfaceStrokeNum);
        }
      }
      
      // If still not found, reject
      if (!stroke) {

        return reject(`Stroke #${strokeNum} not found`);
      }
      
      // Add these variable declarations at the beginning of the Promise function
      let transferData = null;
      let hasMoveOrClone = false; // Added this variable declaration here
      
// In the showStrokeToOthers method, update the image upload handling
if (stroke.isImageStroke && stroke.brushName === "imageUpload") {
  // Create a completion tracker
  let isCompleted = false;
  
  // Setup event handler for transfer completion
  const handleTransferComplete = (event, data) => {
    if (isCompleted) return; // Prevent duplicate handling
    
    // Mark as completed and clean up listener
    isCompleted = true;
    $(document).off("transferComplete", handleTransferComplete);
    clearTimeout(safetyTimeout);
    
    // IMPORTANT: Force a mandatory cool-down period after image uploads
    setTimeout(() => {
      // Reset any potential state for clean slate
      if (window.resetAfterStrokeCompletion) {
        window.resetAfterStrokeCompletion();
      }
      
      resolve(); // CRITICAL: Resolve the outer promise
    }, 2000); // 2-second cool-down period
  };
  
  // Listen for ALL transfer completion events
  $(document).on("transferComplete", handleTransferComplete);
  
  // Safety timeout as fallback (30 seconds)
  const safetyTimeout = setTimeout(() => {
    if (isCompleted) return;
    
    isCompleted = true;
    $(document).off("transferComplete", handleTransferComplete);
    
    resolve(); // CRITICAL: Resolve the outer promise
  }, 300000); // 30 second timeout
  
  // Find the corresponding transfer data in transfer history
  let transferIndex = -1;
  
  // IMPROVED LOGIC: First check for a direct mapping
  if (room.board._imageStrokeTransferMap && room.board._imageStrokeTransferMap[strokeNum] !== undefined) {
    transferIndex = room.board._imageStrokeTransferMap[strokeNum];
    }
  // Then try to find by stroke number in transfer history
  else if (room.board.transferHistory && room.board.transferHistory.length > 0) {
    const strokeTime = stroke.end?.time || stroke.start.time;
    
    // First, find transfers that might have this stroke's information
    // CHANGED: For chronological order, stroke number should directly map to the index
    // rather than being subtracted from length
    const expectedIndex = Math.max(0, Math.min(strokeNum - 1, room.board.transferHistory.length - 1));
    const surroundingIndices = [
      expectedIndex, 
      Math.max(0, expectedIndex - 1), 
      Math.min(room.board.transferHistory.length - 1, expectedIndex + 1)
    ];
    
    // Check these priority indices first
    for (const idx of surroundingIndices) {
      const transfer = room.board.transferHistory[idx];
      if (transfer && transfer.type === 'load') {
        transferIndex = idx;
        break;
      }
    }
    
    // If still not found, fall back to the old matching logic
    if (transferIndex === -1) {
      const timeWindow = 5000; // 5 second window for matching
      
      // Look for transfers that match the image parameters
      const matchingTransfers = room.board.transferHistory.filter(t => {
        // Match by timestamp first
        const timeMatch = Math.abs(t.timestamp - strokeTime) < timeWindow;
        
        // Then by position and dimensions if available
        const positionMatch = stroke.imageUploadData && t.position && 
          Math.abs(t.position.x - stroke.imageUploadData.position.x) < 5 && 
          Math.abs(t.position.y - stroke.imageUploadData.position.y) < 5;
          
        const dimensionsMatch = stroke.imageUploadData && t.dimensions && 
          Math.abs(t.dimensions.width - stroke.imageUploadData.dimensions.width) < 5 && 
          Math.abs(t.dimensions.height - stroke.imageUploadData.dimensions.height) < 5;
          
        return timeMatch && (positionMatch || dimensionsMatch);
      });
      
      if (matchingTransfers.length > 0) {
        // Use the most recent matching transfer
        const bestMatch = matchingTransfers[0];
        transferIndex = room.board.transferHistory.indexOf(bestMatch);
        }
    }
  }
  
  // If we found a transfer in history, save the mapping and use it
  if (transferIndex >= 0) {
    // Create and store a persistent mapping for future use
    if (!room.board._imageStrokeTransferMap) {
      room.board._imageStrokeTransferMap = {};
    }
    room.board._imageStrokeTransferMap[strokeNum] = transferIndex;
    
    // Link the stroke to this transfer for tracking
    if (room.board.transferHistory[transferIndex]) {
      room.board.transferHistory[transferIndex]._pendingStrokeNum = strokeNum;
      room.board.transferHistory[transferIndex]._originalStrokeNum = strokeNum;
      }
    
    // Log before and after to verify the index is not changing

    room.board.broadcastTransfer(transferIndex);

  }
  // No matching transfer found, create a new one directly from stroke data
  else if (stroke.imageUploadData) {
    // Create a new Transfer object for broadcasting
    const transfer = new Transfer("BROADCAST", null, 
                               stroke.imageUploadData.uploadType || "load", 
                               Date.now(), true);
    
    // Add our tracking info
    transfer._pendingStrokeNum = strokeNum;
    
    // Listen for native transfer events
    $(transfer).on("transferComplete", () => {

      
      setTimeout(() => {
        // Manually trigger the global event with our stroke ID
        const eventData = {
          strokeId: strokeNum,
          timestamp: Date.now(),
          totalLayers: 1,
          details: { strokeNum: strokeNum }
        };
        
        $(document).trigger("transferComplete", [eventData]);
      }, 100);
    });
    
    $(transfer).on("transferStart transferChunkReady", sendChunk);
    
    // If stroke contains direct image data, use it
    if (stroke.imageUploadData.imageData) {

      
      // Add the image data to the transfer
      transfer.addData(
        stroke.layer,
        stroke.imageUploadData.position.x,
        stroke.imageUploadData.position.y,
        stroke.imageUploadData.dimensions.width,
        stroke.imageUploadData.dimensions.height,
        stroke.imageUploadData.rotation || 0,
        stroke.imageUploadData.imageData
      );
      
      // Send the transfer
      transfer.send();
      room.addTransfer(transfer);
      
      // NOTE: Don't return - let the event handler resolve the outer promise
    }
    // Otherwise use fallback proxy method
    else {
      // Create minimal transfer with position and dimensions
      transfer.addData(
        stroke.layer,
        stroke.imageUploadData.position.x,
        stroke.imageUploadData.position.y,
        stroke.imageUploadData.dimensions.width,
        stroke.imageUploadData.dimensions.height,
        stroke.imageUploadData.rotation || 0,
        "placeholder" // Use placeholder data
      );
      
      // Send the transfer
      transfer.send();
      room.addTransfer(transfer);
      
      // NOTE: Don't return - let the event handler resolve the outer promise
    }
  }
  else {
    // If we get here, we couldn't process the image at all
    // Clean up event listener since we're resolving immediately
    $(document).off("transferComplete", handleTransferComplete);
    clearTimeout(safetyTimeout);
    

    resolve(); // Resolve the outer promise
  }
  
  return; // Just exit this branch and let the event handlers resolve the Promise
}
      // ENHANCEMENT: Check if this is a selection stroke with move or clone action
      // that should use the transfer system instead of direct replay
      if (stroke.brushName === "selection" && stroke.isSelectionStroke && 
        stroke.selectionActions && stroke.selectionActions.length > 0) {
        
      // Check if this is a move/clone operation with delete confirmation
      const isDeleteConfirmation = stroke.confirmMethod === 'delete';
      
      // Find if this stroke has a move or clone action
      hasMoveOrClone = stroke.selectionActions?.some(action => 
        action.type === 'action' && 
        (action.action === 'move' || action.action === 'clone' || 
         action.parameters?.action === 'move' || action.parameters?.action === 'clone')
      );
        
      // Only set up transfer data if this is NOT a delete confirmation
      if (hasMoveOrClone && !isDeleteConfirmation) {
        // IMPROVED LOGIC: First check for direct transfer association
        if (room.board._strokeToTransferMap && room.board._strokeToTransferMap[strokeNum]) {
          // Direct mapping exists between stroke and transfer
          const transferIndex = room.board._strokeToTransferMap[strokeNum];
          transferData = {
            useTransfer: true,
            transferIndex: transferIndex
          };
        }
        // Then fall back to time-based lookup if no direct mapping exists
        else if (room.board.transferHistory && room.board.transferHistory.length > 0) {
          // CHANGED: For chronological order, calculate index directly from stroke number
          // without subtracting from length
          const transferIndex = Math.max(0, Math.min(strokeNum - 1, room.board.transferHistory.length - 1));
          
          // Use transferData instead of state
          transferData = {
            useTransfer: true,
            transferIndex: transferIndex
          };
          
          // STORE THE MAPPING for future use
          if (!room.board._strokeToTransferMap) {
            room.board._strokeToTransferMap = {};
          }
          room.board._strokeToTransferMap[strokeNum] = transferIndex;
          
          // Only proceed if the index is valid
          if (transferIndex >= room.board.transferHistory.length) {
            // Set fallback mode
            transferData = {
              useTransfer: false,
              fallbackMode: true
            };
          }
        }
      }
    }
      
      // Helper function to round to nearest 1/8 (0.125)
      function roundToEighth(val, precision = 2) {
        const factor = 10 ^ precision;
        return parseInt(val * factor) / factor;
      }
      
      const frameBuffer = room.myself.frameBuffer;
      if (!frameBuffer) {

        return reject("Frame buffer not available");
      }
  
      // Generate unique source ID
      const sourceId = `showStrokeToOthers-${strokeNum}-${Date.now()}`;
      frameBuffer.authorizeSource(sourceId);
      
      // SELECTION TOOL: Special handling for selection strokes
// SELECTION TOOL: Special handling for selection strokes
if (stroke.brushName === "selection" && stroke.isSelectionStroke) {
  setTimeout(() => {
    // STEP 1: Initial brush setup

    
    const cmdBrush = frameBuffer.netcode.brushChanged({brush: "selection"});
    frameBuffer.outBuffer(cmdBrush, sourceId);
    
    const cmdColor = frameBuffer.netcode.colorChanged({color: stroke.color});
    frameBuffer.outBuffer(cmdColor, sourceId);
    
    // IMPORTANT: Always set selectiontype and multilayer parameters at start
    if (stroke.start && stroke.start.brushOptions) {
      // Force send critical selection parameters first
      const criticalParams = ['selectiontype', 'multilayer', 'allowedlayers'];
      
      criticalParams.forEach(param => {
        if (stroke.start.brushOptions[param] !== undefined) {
          const cmdOption = frameBuffer.netcode.brushOptionChanged({
            option: param,
            value: stroke.start.brushOptions[param]
          });
          frameBuffer.outBuffer(cmdOption, sourceId);
        }
      });
      
      // Then send remaining options
      this.sendBrushOptionsToNetwork(stroke.start.brushOptions, frameBuffer, sourceId, criticalParams, [], true);    }
    
    // Set layer
    const cmdLayer = frameBuffer.netcode.layerSelected({layer: stroke.layer || 0});
    frameBuffer.outBuffer(cmdLayer, sourceId);
    
    // Make pen visible
    const cmdShow = frameBuffer.netcode.penShow();
    frameBuffer.outBuffer(cmdShow, sourceId);
    frameBuffer.execFrame();
    
// STEP 2: Draw the selection area with pen down/moves/up


// Initial pen down at selection start
const cmdDown = frameBuffer.netcode.penDown({
  x: stroke.start.x,
  y: stroke.start.y
});
frameBuffer.outBuffer(cmdDown, sourceId);
frameBuffer.execFrame();

// Play back any recorded moves
if (stroke.moves && stroke.moves.length > 0) {

  
  // Get base time for calculating delays
  const baseTime = stroke.start.time;
  
  // Process moves with original timing
  stroke.moves.forEach((move, index) => {
    // Calculate delay based on original timing
    // Cap very long delays to 1 second for better playback experience
    const delay = Math.min(move.time - baseTime, 1000);
    
    setTimeout(() => {
      // IMPORTANT: Apply ALL brush options from each move, not just critical ones
      if (move.brushOptions) {
        // console.log(`%c Setting all brush options for move #${index}`, 
        //   'color: #2196F3;');
          
        // Use our improved sendBrushOptionsToNetwork function
        this.sendBrushOptionsToNetwork({
          ...move.brushOptions,
          layer: move.layer || stroke.layer
        }, frameBuffer, sourceId);
      }
      
      // Handle color changes with sendBrushOptionsToNetwork
      if (move.color) {
        this.sendBrushOptionsToNetwork({color: move.color}, frameBuffer, sourceId);
      }
      
      // Send the move
      const cmdMove = frameBuffer.netcode.penMove({
        x: move.x,
        y: move.y
      });
      frameBuffer.outBuffer(cmdMove, sourceId);
      frameBuffer.execFrame();
      
      // If this is the last move, complete the selection area
      if (index === stroke.moves.length - 1) {
        // Add small delay before finalizing to ensure move is processed
        setTimeout(completeSelectionArea, 50);
      }
    }, index * 10);
  });
} else {
      // No moves - just complete the area with end coordinates after a short delay
      setTimeout(() => {
        completeSelectionArea();
      }, 50);
    }
    
    // Function to finalize the selection area
// Inside the selection tool's completeSelectionArea() function, update the brush options handling
const completeSelectionArea = () => {
  // IMPORTANT: Ensure ALL parameters from end.brushOptions are applied before completing the selection
  if (stroke.end && stroke.end.brushOptions) {
    // Force send ALL brush options from the end state individually
    for (const optionName in stroke.end.brushOptions) {
      const optionValue = stroke.end.brushOptions[optionName];
      const cmdOption = frameBuffer.netcode.brushOptionChanged({
        option: optionName,
        value: optionValue
      });
      frameBuffer.outBuffer(cmdOption, sourceId);
    }
    
    // Process all options before continuing
    frameBuffer.execFrame();
    
    // Add a small delay to ensure options are fully processed
    setTimeout(() => {
      finalizePenUp();
    }, 50);
  } else {
    // No end options, just complete immediately
    finalizePenUp();
  }
  
  // Helper function to handle the final pen up event after options are set
  function finalizePenUp() {
    // Determine the best end coordinates to use
    let endX, endY;
    
    if (stroke.moves && stroke.moves.length > 0) {
      // If we have moves, use the last move's coordinates for more accuracy
      const lastMove = stroke.moves[stroke.moves.length - 1];
      endX = lastMove.x;
      endY = lastMove.y;

    } else {
      // Only use the fallback if no moves exist
      endX = stroke.end?.x || stroke.start.x;
      endY = stroke.end?.y || stroke.start.y;

    }
    
    // For move/clone actions, explicitly force multilayer=true one last time
    if (stroke.finalAction === 'move' || stroke.finalAction === 'clone') {
      const cmdForceMultilayer = frameBuffer.netcode.brushOptionChanged({
        option: 'multilayer',
        value: true
      });
      frameBuffer.outBuffer(cmdForceMultilayer, sourceId);
    }
    
    const endColor = stroke.end?.color || stroke.color;

    if (stroke.end?.color) {

      const cmdFinalColor = frameBuffer.netcode.colorChanged({color: stroke.end.color});
      frameBuffer.outBuffer(cmdFinalColor, sourceId);
      frameBuffer.execFrame();
    }

    // Send the final pen up
    const cmdUp = frameBuffer.netcode.penUp({
      x: endX,
      y: endY
    });
    frameBuffer.outBuffer(cmdUp, sourceId);
    frameBuffer.execFrame();
    
    // Wait a bit for selection to be created, then start actions
    setTimeout(() => {
      processSelectionActions();
    }, 200);
  }
};
          
          // STEP 3: Process all selection actions
          const processSelectionActions = () => {
            if (!stroke.selectionActions || stroke.selectionActions.length === 0) {

              cleanupAndResolve();
              return;
            }
            

            
            // Calculate timing between actions (compress for better playback)
            const baseTime = stroke.selectionActions[0].time;
            const actionTimings = stroke.selectionActions.map(action => 
              Math.max(0, action.time - baseTime)  // Ensure no negative times
            );
            
            // Cap maximum delay between actions to 300ms
            const compressedTimings = actionTimings.map(timing => 
              timing > 300 ? 300 + (timing - 300) / 10 : timing
            );
            
            // Flag to track upload mode
            let isUploadMode = false;
            
            // FALLBACK DETECTION: Check if we might need to use fallback mode
            const hasMoveOrCloneAction = stroke.selectionActions.some(action => 
              action.type === 'action' && 
              (action.action === 'move' || action.action === 'clone' ||
               action.parameters?.action === 'move' || action.parameters?.action === 'clone')
            );
            
            // If we have move/clone actions but no transfer or uploader available, use prerendered approach
            const shouldUseFallback = hasMoveOrCloneAction && 
                                      (!transferData?.useTransfer || transferData?.fallbackMode) && 
                                      (!room.board.uploader || transferData?.fallbackMode);
                                      
            if (shouldUseFallback) {
              }
            
            // Process each action in sequence
// Process each action in sequence
// Process each action in sequence
stroke.selectionActions.forEach((action, index) => {
  setTimeout(() => {
    if (action.type === 'action') {

      
      const actionName = action.action || action.parameters?.action;
      const isMoveWithDelete = (actionName === 'move' || actionName === 'clone') && 
                               stroke.confirmMethod === 'delete';
      
      // Skip move/clone actions if in fallback mode, BUT ONLY if not a move+delete combo
      if (shouldUseFallback && 
         (actionName === 'move' || actionName === 'clone') &&
         !isMoveWithDelete) {
        return;
      }

      if (action.color) {

        const cmdActionColor = frameBuffer.netcode.colorChanged({color: action.color});
        frameBuffer.outBuffer(cmdActionColor, sourceId);
        frameBuffer.execFrame();
      }
      
      // CRITICAL ACTIONS: Enhanced handling with proper delays
      const criticalActions = ['clear', 'fill', 'move', 'clone'];
      
      // Store original brush options to restore after action
      const originalMultilayer = stroke.end?.brushOptions?.multilayer !== undefined ? 
        stroke.end.brushOptions.multilayer : 
        stroke.start?.brushOptions?.multilayer;
        
      const originalSelectionType = stroke.end?.brushOptions?.selectiontype !== undefined ?
        stroke.end.brushOptions.selectiontype :
        stroke.start?.brushOptions?.selectiontype;
      
        if (criticalActions.includes(actionName) || isMoveWithDelete) {
          // Get the actual multilayer value from the stroke's end brushOptions, or use stroke.start if end is not available
          const multilayerValue = (stroke.end && stroke.end.brushOptions && stroke.end.brushOptions.multilayer !== undefined) ? 
            stroke.end.brushOptions.multilayer : 
            (stroke.start && stroke.start.brushOptions && stroke.start.brushOptions.multilayer !== undefined) ?
              stroke.start.brushOptions.multilayer : true;
  
          const cmdMultilayer = frameBuffer.netcode.brushOptionChanged({
            option: 'multilayer',
            value: multilayerValue
          });
          frameBuffer.outBuffer(cmdMultilayer, sourceId);
          frameBuffer.execFrame();
        
        // STEP 2: Also set selectiontype explicitly if available
        if (stroke.start?.brushOptions?.selectiontype !== undefined) {
          const cmdSelectionType = frameBuffer.netcode.brushOptionChanged({
            option: 'selectiontype',
            value: stroke.start.brushOptions.selectiontype
          });
          frameBuffer.outBuffer(cmdSelectionType, sourceId);
          frameBuffer.execFrame();
        }
        
        // CRITICAL: Add a 300ms delay to ensure brush options are fully processed
        setTimeout(() => {
          // Refresh multilayer setting right before action to be absolutely certain
          const multilayerValue = (stroke.end && stroke.end.brushOptions && stroke.end.brushOptions.multilayer !== undefined) ? 
            stroke.end.brushOptions.multilayer : 
            (stroke.start && stroke.start.brushOptions && stroke.start.brushOptions.multilayer !== undefined) ?
              stroke.start.brushOptions.multilayer : true;
  
          const cmdMultilayer = frameBuffer.netcode.brushOptionChanged({
            option: 'multilayer',
            value: multilayerValue
          });
          frameBuffer.outBuffer(cmdMultilayer, sourceId);
          frameBuffer.execFrame();
        
          
          // Now execute the actual action
          if (isMoveWithDelete || actionName === 'delete') {
            // Modify parameters to act like clear for both delete and move+delete cases
            const clearParams = {...action.parameters};
            clearParams.action = 'clear';
            
            const cmdParam = frameBuffer.netcode.brushParameter({
              brush: "selection",
              parameters: clearParams
            });
            frameBuffer.outBuffer(cmdParam, sourceId);
          } else {
            // Regular action handling - send the brush parameter action
            const cmdParam = frameBuffer.netcode.brushParameter({
              brush: "selection",
              parameters: action.parameters
            });
            frameBuffer.outBuffer(cmdParam, sourceId);
          }
          frameBuffer.execFrame();

          // if (action.parameters?.action === 'fill') {
          //   console.log(`%c Fill action detected - adding extra processing time`, 
          //     'background: #FF9800; color: white; font-weight: bold; padding: 2px 5px;');
              
          //   // For fill operations, we need to ensure the action completes before proceeding
          //   // Force a longer processing time by adding an artificial delay
          //   const fillDelay = 500; // 500ms extra for fill operations
            
          //   // Wait for fill to complete before proceeding
          //   return new Promise(resolveFill => {
          //     setTimeout(() => {
          //       // After fill delay, force another multilayer refresh to ensure stability
          //       console.log(`%c Post-fill stability refresh`, 'color: #673AB7; font-weight: bold;');
                
          //       const cmdRefreshAfterFill = frameBuffer.netcode.brushOptionChanged({
          //         option: 'multilayer',
          //         value: multilayerValue
          //       });
          //       frameBuffer.outBuffer(cmdRefreshAfterFill, sourceId);
          //       frameBuffer.execFrame();
                
          //       resolveFill();
          //     }, fillDelay);
          //   });
          // }
          
          if (action.parameters?.action === 'fill' || 
            (action.parameters?.action === 'move' && !isMoveWithDelete) ||
            (action.parameters?.action === 'clone' && !isMoveWithDelete)) {
           // Mark that this action requires special handling
           // IMPROVED: Create uploader on-demand if not available
           if (!room.board.uploader && 
               ((action.parameters?.action === 'move' && !isMoveWithDelete) || 
                (action.parameters?.action === 'clone' && !isMoveWithDelete))) {
             // Try to initialize a temporary uploader
             try {
                          if (!room.board._tempUploader) {
                            room.board._tempUploader = new UploaderProxy(room.board);
                          }
                          room.board._tempUploader._replaySource = true;
                        } catch (err) {
                          }
                      }
                      
                      // Try to use the uploader (regular or temporary)
                      const uploader = room.board.uploader || room.board._tempUploader;
                      if (uploader) {
                        uploader._replaySource = true; // Enable network sending for uploader
                      } else {
                        }
                    }
          
          // NEW: Add a delay and restore original brush options after action completes
          setTimeout(() => {
            // Restore original multilayer setting
            if (originalMultilayer !== undefined) {

              const cmdRestoreMultilayer = frameBuffer.netcode.brushOptionChanged({
                option: 'multilayer',
                value: originalMultilayer
              });
              frameBuffer.outBuffer(cmdRestoreMultilayer, sourceId);
              frameBuffer.execFrame();
            }
            
            // Restore original selectiontype if it was changed
            if (originalSelectionType !== undefined) {

              const cmdRestoreSelectionType = frameBuffer.netcode.brushOptionChanged({
                option: 'selectiontype',
                value: originalSelectionType
              });
              frameBuffer.outBuffer(cmdRestoreSelectionType, sourceId);
              frameBuffer.execFrame();
            }
          }, 300); // Wait 300ms after action completes to restore settings
        }, 300); // Critical 300ms delay before executing the action
      } 
      else {        // Non-critical actions can proceed without delay
        const cmdParam = frameBuffer.netcode.brushParameter({
          brush: "selection",
          parameters: action.parameters
        });
        frameBuffer.outBuffer(cmdParam, sourceId);
        frameBuffer.execFrame();
      }
    }                  else if (action.type === 'uploadMode') {

                  isUploadMode = action.status;
                  
                  // Before switching to upload mode, ensure uploader knows this is a replay
                  const uploader = room.board.uploader || room.board._tempUploader;
                  if (uploader && action.status) {
                    uploader._replaySource = true; // Flag uploader to send network commands
                  }
                  
                  const cmdUpload = frameBuffer.netcode.uploadModeChanged({
                    status: action.status
                  });
                  frameBuffer.outBuffer(cmdUpload, sourceId);
                  frameBuffer.execFrame();
                }
                else if (action.type === 'silhouette') {

                  
                  const cmdSilhouette = frameBuffer.netcode.silhouetteChanged({
                    x: action.x,
                    y: action.y,
                    width: action.width,
                    height: action.height,
                    rotation: action.rotation || 0
                  });
                  frameBuffer.outBuffer(cmdSilhouette, sourceId);
                  frameBuffer.execFrame();
                }
                else if (action.type === 'position') {

                  
                  const cmdMove = frameBuffer.netcode.penMove({
                    x: action.x,
                    y: action.y
                  });
                  frameBuffer.outBuffer(cmdMove, sourceId);
                  frameBuffer.execFrame();
                }
                else if (action.type === 'applyToCanvas') {

                  // Make sure uploader knows to submit through network
                  const uploader = room.board.uploader || room.board._tempUploader;
                  if (uploader) {
                    uploader._replaySource = true;
                  }
                }
                
                // If this is the last action or a terminal action, ensure upload mode is cleaned up
                if (index === stroke.selectionActions.length - 1) {
                  setTimeout(() => {
                    // If upload mode is still on, turn it off
                    if (isUploadMode) {

                      
                      const cmdUploadOff = frameBuffer.netcode.uploadModeChanged({
                        status: false
                      });
                      frameBuffer.outBuffer(cmdUploadOff, sourceId);
                      frameBuffer.execFrame();
                    }
                    
                    // Reset uploader settings
                    const uploader = room.board.uploader || room.board._tempUploader;
                    if (uploader) {
                      uploader._replaySource = false;
                    }
                    
                    // Check if this was a critical action (clear, fill, etc.)
                    const lastAction = stroke.selectionActions[stroke.selectionActions.length - 1];
                    const actionName = lastAction?.parameters?.action || lastAction?.action;
                    const criticalActions = ['clear', 'fill', 'move', 'clone'];
                    const isCriticalAction = lastAction?.type === 'action' && criticalActions.includes(actionName);
                    
                    // Use longer delay for critical actions to ensure they complete before cleanup
                    const cleanupDelay = isCriticalAction ? 1000 : 300;
                    
                    // Clean up and resolve with appropriate delay
                    setTimeout(cleanupAndResolve, cleanupDelay);
                  }, 200);
                }
              }, compressedTimings[index]);
            });
          };
          
          // Final cleanup and promise resolution
          const cleanupAndResolve = () => {
            // Check for delete confirmation
            const isDeleteConfirmation = stroke.confirmMethod === 'delete';
            // Check if this was a move/clone operation that needs final brush options
            
            const isMoveCloneOperation = hasMoveOrClone || 
                                       stroke.finalAction === 'move' || 
                                       stroke.finalAction === 'clone' ||
                                       stroke.selectionActions?.some(action => 
                                         action.type === 'action' && 
                                         (action.action === 'move' || action.action === 'clone' ||
                                          action.parameters?.action === 'move' || action.parameters?.action === 'clone')
                                       );
          
            // First set critical brush options if this was a move/clone operation
            if (isMoveCloneOperation && !isDeleteConfirmation) {
              // Only apply these settings for non-delete operations
              const cmdMultilayer = frameBuffer.netcode.brushOptionChanged({
                option: 'multilayer',
                value: true
              });
              frameBuffer.outBuffer(cmdMultilayer, sourceId);
              
              // Make sure selectiontype is set
              if (stroke.start?.brushOptions?.selectiontype !== undefined) {
                const cmdSelectionType = frameBuffer.netcode.brushOptionChanged({
                  option: 'selectiontype',
                  value: stroke.start.brushOptions.selectiontype
                });
                frameBuffer.outBuffer(cmdSelectionType, sourceId);
              }
              
              // Set all end.brushOptions if available
              if (stroke.end?.brushOptions) {
                for (const optionName in stroke.end.brushOptions) {
                  const optionValue = stroke.end.brushOptions[optionName];
                  
                  const cmdOption = frameBuffer.netcode.brushOptionChanged({
                    option: optionName,
                    value: optionValue
                  });
                  frameBuffer.outBuffer(cmdOption, sourceId);
                }
              }
              
              frameBuffer.execFrame();
            }
          
            // Set final color (as was already in the code)
            if (stroke.end?.color) {
              const cmdFinalColor = frameBuffer.netcode.colorChanged({color: stroke.end.color});
              frameBuffer.outBuffer(cmdFinalColor, sourceId);
              frameBuffer.execFrame();
            }
          
            // For delete confirmations, handle similar to clear action with a reasonable delay
            if (isDeleteConfirmation || 
              stroke.selectionActions?.some(action => 
                action.type === 'action' && 
                (action.action === 'delete' || action.parameters?.action === 'delete'))) {
              // Reset uploader settings
              const uploader = room.board.uploader || room.board._tempUploader;
              if (uploader) {
                uploader._replaySource = false;
              }
              
              // CRITICAL FIX: Manually emit a completion message for delete operations
              // This is needed because delete operations don't naturally trigger network completion events
              setTimeout(() => {
                // Create a synthetic completion message
                const completionMsg = {
                  command: 'RESPONSE',
                  action: 'OK',
                  context: `stroke-${strokeNum}`,
                  transferComplete: true,
                  timestamp: Date.now()
                };
                
                // Trigger the event handlers directly
                $(document).trigger('transferComplete', [{
                  strokeId: strokeNum,
                  timestamp: Date.now(),
                  totalLayers: 1,
                  details: { strokeNum: strokeNum },
                  triggerMethod: 'delete-operation'
                }]);
                
                // Also trigger with stroke-specific namespace
                $(document).trigger(`transferComplete.stroke-${strokeNum}`, {
                  strokeId: strokeNum,
                  timestamp: Date.now(),
                  details: completionMsg
                });
                
                // Revoke network authorization and resolve
                frameBuffer.revokeSource(sourceId);
                resolve();
              }, 300); // 300ms delay is enough for clear operations
              
              return; // Exit early to prevent double resolution
            }
          
            // Use transferData instead of state - but ONLY if not a delete confirmation
            if (transferData && transferData.useTransfer && !isDeleteConfirmation) {
              // Add selection operation metadata to the transfer
              if (room.board.transferHistory && room.board.transferHistory[transferData.transferIndex]) {
                const transfer = room.board.transferHistory[transferData.transferIndex];
                transfer.selectionOperation = true;
                transfer.strokeId = strokeNum;
              }
              
              // Apply final brush options one more time before broadcast
              if (isMoveCloneOperation && stroke.end?.brushOptions) {
                // Just apply the most critical options again for reliability
                const criticalOptions = ['multilayer', 'selectiontype', 'allowedlayers'];
                criticalOptions.forEach(option => {
                  if (stroke.end.brushOptions[option] !== undefined) {
                    const cmdOption = frameBuffer.netcode.brushOptionChanged({
                      option: option,
                      value: stroke.end.brushOptions[option]
                    });
                    frameBuffer.outBuffer(cmdOption, sourceId);
                  }
                });
                frameBuffer.execFrame();
              }
              
              // IMPROVED: Look up transfer index using our bidirectional mapping
              let transferIndexToUse = transferData.transferIndex;
              
              // Check if we have a mapping for this stroke
              if (room.board.strokeToTransferMap && room.board.strokeToTransferMap.has(strokeNum)) {
                // Use the mapped transfer index
                const mappedIndex = room.board.strokeToTransferMap.get(strokeNum);
                if (mappedIndex !== undefined) {
                  transferIndexToUse = mappedIndex;
                  console.log(`Using mapped transfer ${mappedIndex} for stroke ${strokeNum}`);
                }
              }
              
              // Log both values to help with debugging
              console.log(`Broadcasting stroke ${strokeNum} using transfer ${transferIndexToUse} (original: ${transferData.transferIndex})`);
              
              const success = room.board.broadcastTransfer(transferIndexToUse);
              console.log(transferIndexToUse, "index here", strokeNum, "stroke number");

              // Only wait for transfer completion if the broadcast was successful
              if (success) {
                // Don't trigger completion immediately - let the receive handler do it
                return; // Important: Don't resolve yet for successful transfers
              }
            } 
            // CRITICAL NEW ADDITION: For fallback mode, try to find a transfer by other means
            else if (hasMoveOrClone && (!transferData || transferData.fallbackMode) && !isDeleteConfirmation) {
              // Apply final brush options again for reliability
              if (isMoveCloneOperation && stroke.end?.brushOptions) {
                // Set multilayer = true explicitly as a safety measure
                const cmdMultilayer = frameBuffer.netcode.brushOptionChanged({
                  option: 'multilayer',
                  value: true
                });
                frameBuffer.outBuffer(cmdMultilayer, sourceId);
                frameBuffer.execFrame();
              }
              
              // More aggressive transfer lookup (up to 30 seconds)
              if (room.board.transferHistory && room.board.transferHistory.length > 0) {
                // Existing emergency lookup code...
                const strokeTime = stroke.end?.time || stroke.start.time;
                const widerWindow = 30000; // 30 second window for desperate matching
                
                // Look for ANY selection-type transfer from recent history
                const transfers = room.board.transferHistory.filter(t => 
                  Math.abs(t.timestamp - strokeTime) < widerWindow && 
                  (t.type === 'selection' || t.uploadType === 'selection')
                );
                
                if (transfers.length > 0) {
                  // Existing emergency transfer broadcast code...
                }
              }
            }
            
            // Reset uploader settings
            const uploader = room.board.uploader || room.board._tempUploader;
            if (uploader) {
              uploader._replaySource = false;
            }
            
            // Final small delay to ensure all settings are processed
            setTimeout(() => {
              // Revoke network authorization
              frameBuffer.revokeSource(sourceId);
              resolve();
            }, 200); // Increased from 0 to 200ms for more reliability
          };
        }, 0);
      }
      // TEXT TOOL: Special handling for text brush
      else if (stroke.brushName === "text" && stroke.isTextStroke) {
        // Existing text tool code (unchanged)
        setTimeout(() => {
          // Get coordinates for text position and round to nearest 1/8
          const rawStartX = stroke.start?.x || stroke.textStart?.x || stroke.finalTextEvent?.x || 400;
          const rawStartY = stroke.start?.y || stroke.textStart?.y || stroke.finalTextEvent?.y || 300;
          
          // Round to nearest 1/8
          const startX = roundToEighth(rawStartX);
          const startY = roundToEighth(rawStartY);
          
          // Initial brush setup
          const cmdBrush = frameBuffer.netcode.brushChanged({brush: stroke.brushName});
          frameBuffer.outBuffer(cmdBrush, sourceId);
          
          const cmdColor = frameBuffer.netcode.colorChanged({color: stroke.color});
          frameBuffer.outBuffer(cmdColor, sourceId);
          
          // Set brush options - prioritize finalTextEvent.brushOptions if available
          const brushOptions = stroke.finalTextEvent?.brushOptions || stroke.end?.brushOptions || 
                               stroke.start?.brushOptions || stroke.textStart?.brushOptions || {};
          if (brushOptions) {
            this.sendBrushOptionsToNetwork({
              ...brushOptions,
              layer: stroke.layer
            }, frameBuffer, sourceId);
          }
          
          // Set layer
          const cmdLayer = frameBuffer.netcode.layerSelected({layer: stroke.layer});
          frameBuffer.outBuffer(cmdLayer, sourceId);
          
          // Make pen visible
          const cmdShow = frameBuffer.netcode.penShow();
          frameBuffer.outBuffer(cmdShow, sourceId);
          frameBuffer.execFrame();
          
          // STEP 2: First click to position text field
          const cmdDown1 = frameBuffer.netcode.penDown({
            x: startX, 
            y: startY
          });
          frameBuffer.outBuffer(cmdDown1, sourceId);
          
          const cmdUp1 = frameBuffer.netcode.penUp({
            x: startX,
            y: startY
          });
          frameBuffer.outBuffer(cmdUp1, sourceId);
          frameBuffer.execFrame();
          
          // Store reference to 'this' for use in inner functions
          const self = this;
          
          // STEP 3: Send key events sequentially to type text
          if (stroke.keyEvents && stroke.keyEvents.length > 0) {
            // Use sequential approach for reliable network transmission
            let keyIndex = 0;
            
            const sendNextKeyEvent = () => {
              if (keyIndex >= stroke.keyEvents.length) {
                // All key events sent, proceed to final placement
                placeFinalText();
                return;
              }
              
              const keyEvent = stroke.keyEvents[keyIndex];
              
              // Send the key event
              let cmd;
              if (keyEvent.type === 'keyPress') {
                cmd = frameBuffer.netcode.keyPress({key: keyEvent.keyCode});
              } else if (keyEvent.type === 'modifierDown') {
                cmd = frameBuffer.netcode.modifierDown({code: keyEvent.keyCode});
              } else if (keyEvent.type === 'modifierUp') {
                cmd = frameBuffer.netcode.modifierUp({code: keyEvent.keyCode});
              }
              
              if (cmd) {
                frameBuffer.outBuffer(cmd, sourceId);
                frameBuffer.execFrame();
                
                // Move to next key after a delay
                keyIndex++;
                setTimeout(sendNextKeyEvent, 50); // 50ms minimum delay between keys
              } else {
                // Skip invalid events
                keyIndex++;
                sendNextKeyEvent();
              }
            };
            
            // Start sending key events
            setTimeout(sendNextKeyEvent, 200);
          } else if (stroke.textContent && stroke.textContent.length > 0) {
            // Alternative: use textContent if keyEvents not available
            // Send characters one by one
            let charIndex = 0;
            
            const sendNextChar = () => {
              if (charIndex >= stroke.textContent.length) {
                // All characters sent, proceed to final placement
                placeFinalText();
                return;
              }
              
              const char = stroke.textContent[charIndex];
              const charCode = char.charCodeAt(0);
              
              // If uppercase letter, send shift modifier
              if (charCode >= 65 && charCode <= 90) {
                const cmdModDown = frameBuffer.netcode.modifierDown({code: 16}); // 16 is shift
                frameBuffer.outBuffer(cmdModDown, sourceId);
                frameBuffer.execFrame();
                
                // Send character
                const cmdKey = frameBuffer.netcode.keyPress({key: charCode});
                frameBuffer.outBuffer(cmdKey, sourceId);
                frameBuffer.execFrame();
                
                // Send modifier up
                const cmdModUp = frameBuffer.netcode.modifierUp({code: 16});
                frameBuffer.outBuffer(cmdModUp, sourceId);
                frameBuffer.execFrame();
              } else {
                // Send character without modifier
                const cmdKey = frameBuffer.netcode.keyPress({key: charCode});
                frameBuffer.outBuffer(cmdKey, sourceId);
                frameBuffer.execFrame();
              }
              
              // Move to next character after delay
              charIndex++;
              setTimeout(sendNextChar, 50);
            };
            
            // Start sending characters
            setTimeout(sendNextChar, 200);
          } else {
            // No text data, just do final placement
            placeFinalText();
          }
          
          // STEP 4: Final placement function - now uses self instead of this
          function placeFinalText() {
            // Round final position coordinates to nearest 1/8
            const rawFinalX = stroke.finalTextEvent?.x || stroke.end?.x || startX;
            const rawFinalY = stroke.finalTextEvent?.y || stroke.end?.y || startY;
            
            const finalX = roundToEighth(rawFinalX);
            const finalY = roundToEighth(rawFinalY);
            
            // Apply final brush options if available before final click
            if (stroke.finalTextEvent?.brushOptions || stroke.end?.brushOptions) {
              const finalBrushOptions = stroke.finalTextEvent?.brushOptions || stroke.end?.brushOptions;
              self.sendBrushOptionsToNetwork(finalBrushOptions, frameBuffer, sourceId);
            }
            
            // Send final placement click
            const cmdDown2 = frameBuffer.netcode.penDown({
              x: finalX,
              y: finalY
            });
            frameBuffer.outBuffer(cmdDown2, sourceId);
            
            const cmdUp2 = frameBuffer.netcode.penUp({
              x: finalX,  
              y: finalY
            });
            frameBuffer.outBuffer(cmdUp2, sourceId);
            frameBuffer.execFrame();
            
            // ADDED: Send another pen down/up sequence after a delay to ensure text mode is fully deactivated
            setTimeout(() => {
              const cmdDown3 = frameBuffer.netcode.penDown({
                x: finalX,
                y: finalY
              });
              frameBuffer.outBuffer(cmdDown3, sourceId);
              
              const cmdUp3 = frameBuffer.netcode.penUp({
                x: finalX,  
                y: finalY
              });
              frameBuffer.outBuffer(cmdUp3, sourceId);
              frameBuffer.execFrame();
              
              // Cleanup and resolve
              setTimeout(() => {
                frameBuffer.revokeSource(sourceId);
                resolve();
              }, 100);
            }, 300); // 300ms delay before extra pen down/up
          }
        }, 0);
      } 
// REGULAR BRUSH: Standard stroke handling
else {
  setTimeout(() => {
    
      // Send brush command once
      const cmdBrush = frameBuffer.netcode.brushChanged({brush: stroke.brushName});
      frameBuffer.outBuffer(cmdBrush, sourceId);
      frameBuffer.execFrame(); // Process brush immediately
      
// Special handling for line, rectangle, ellipse, and pixel tools
// Special handling for pixel tool to properly handle parameter changes during strokes
if (stroke.brushName === "pixel") {
  // Get brush options from the start
  const startBrushOptions = stroke.start.brushOptions || {};
  
  // Force-set color first
  const initialColor = stroke.start?.color || stroke.color;

  const cmdInitialColor = frameBuffer.netcode.colorChanged({color: initialColor});
  frameBuffer.outBuffer(cmdInitialColor, sourceId);
  frameBuffer.execFrame();
  
  // Send brush command
  const cmdBrush = frameBuffer.netcode.brushChanged({brush: stroke.brushName});
  frameBuffer.outBuffer(cmdBrush, sourceId);
  frameBuffer.execFrame();
  
  // First set all start options

  for (const optionName in startBrushOptions) {
    const optionValue = startBrushOptions[optionName];

    const cmdOption = frameBuffer.netcode.brushOptionChanged({
      option: optionName,
      value: optionValue
    });
    frameBuffer.outBuffer(cmdOption, sourceId);
  }
  frameBuffer.execFrame();
  
  // Set layer
  const cmdLayer = frameBuffer.netcode.layerSelected({layer: stroke.layer || 0});
  frameBuffer.outBuffer(cmdLayer, sourceId);
  frameBuffer.execFrame();
  
  // Make pen visible
  const cmdShow = frameBuffer.netcode.penShow();
  frameBuffer.outBuffer(cmdShow, sourceId);
  frameBuffer.execFrame();
  
  // Initial pen down with exact coordinates
  const cmdDown = frameBuffer.netcode.penDown({
    x: stroke.start.x,
    y: stroke.start.y
  });
  frameBuffer.outBuffer(cmdDown, sourceId);
  frameBuffer.execFrame();
  
  // Process all moves with careful parameter tracking
  if (stroke.moves && stroke.moves.length > 0) {
    const baseTime = stroke.start.time;
    
    stroke.moves.forEach((move, index) => {
      setTimeout(() => {
        // CRITICAL: Apply ALL brush options from each move, especially erasermode
        if (move.brushOptions) {
          // Send all brush options individually for each move
          for (const optionName in move.brushOptions) {
            const optionValue = move.brushOptions[optionName];

            
            const cmdOption = frameBuffer.netcode.brushOptionChanged({
              option: optionName,
              value: optionValue
            });
            frameBuffer.outBuffer(cmdOption, sourceId);
          }
          
          // Process options before continuing with move
          frameBuffer.execFrame();
        }

        // Handle color changes
        if (move.color) {

          const cmdMoveColor = frameBuffer.netcode.colorChanged({color: move.color});
          frameBuffer.outBuffer(cmdMoveColor, sourceId);
          frameBuffer.execFrame();
        }
        
        // Send the move
        const cmdMove = frameBuffer.netcode.penMove({
          x: move.x,
          y: move.y
        });
        frameBuffer.outBuffer(cmdMove, sourceId);
        frameBuffer.execFrame();
      }, move.time - baseTime);
    });
    
    // Handle end of stroke
    setTimeout(() => {
      // Apply end brush options
      if (stroke.end && stroke.end.brushOptions) {

        
        for (const optionName in stroke.end.brushOptions) {
          const optionValue = stroke.end.brushOptions[optionName];

          const cmdOption = frameBuffer.netcode.brushOptionChanged({
            option: optionName,
            value: optionValue
          });
          frameBuffer.outBuffer(cmdOption, sourceId);
        }
        frameBuffer.execFrame();
      }
      
      // Set final color
      const finalColor = stroke.end?.color || stroke.color;

      const cmdFinalColor = frameBuffer.netcode.colorChanged({color: finalColor});
      frameBuffer.outBuffer(cmdFinalColor, sourceId);
      frameBuffer.execFrame();
      
      // Finish the stroke
      const cmdUp = frameBuffer.netcode.penUp({
        x: stroke.end.x,
        y: stroke.end.y
      });
      frameBuffer.outBuffer(cmdUp, sourceId);
      frameBuffer.execFrame();
      
      // Clean up
      setTimeout(() => {
        frameBuffer.revokeSource(sourceId);
        resolve();
      }, 100);
    }, stroke.end.time - stroke.start.time);
  } else {
    // No moves, just finish the stroke
    setTimeout(() => {
      // Apply end brush options
      if (stroke.end && stroke.end.brushOptions) {

        
        for (const optionName in stroke.end.brushOptions) {
          const optionValue = stroke.end.brushOptions[optionName];

          const cmdOption = frameBuffer.netcode.brushOptionChanged({
            option: optionName,
            value: optionValue
          });
          frameBuffer.outBuffer(cmdOption, sourceId);
        }
        frameBuffer.execFrame();
      }
      
      // Set final color
      const finalColor = stroke.end?.color || stroke.color;

      const cmdFinalColor = frameBuffer.netcode.colorChanged({color: finalColor});
      frameBuffer.outBuffer(cmdFinalColor, sourceId);
      frameBuffer.execFrame();
      
      const cmdUp = frameBuffer.netcode.penUp({
        x: stroke.end.x || stroke.start.x,
        y: stroke.end.y || stroke.start.y
      });
      frameBuffer.outBuffer(cmdUp, sourceId);
      frameBuffer.execFrame();
      
      // Clean up
      setTimeout(() => {
        frameBuffer.revokeSource(sourceId);
        resolve();
      }, 100);
    }, 100);
  }
}
if (stroke.brushName === "line" || stroke.brushName === "rect" || stroke.brushName === "ellipse") {
  // Get brush options from the best available source
  const startBrushOptions = stroke.start.brushOptions || {};
  const endBrushOptions = stroke.end?.brushOptions || startBrushOptions;
  
  // Force-set color FIRST before any other operations
  const initialColor = stroke.start?.color || stroke.color;

  const cmdInitialColor = frameBuffer.netcode.colorChanged({color: initialColor});
  frameBuffer.outBuffer(cmdInitialColor, sourceId);
  frameBuffer.execFrame();
  
  // Send brush command
  const cmdBrush = frameBuffer.netcode.brushChanged({brush: stroke.brushName});
  frameBuffer.outBuffer(cmdBrush, sourceId);
  frameBuffer.execFrame();
  
  // CRITICAL: Set all brush options explicitly with special attention to size and alpha

  
  // First set the most critical options: size and alpha
  if (startBrushOptions.size !== undefined) {

    const cmdSize = frameBuffer.netcode.brushOptionChanged({
      option: 'size',
      value: startBrushOptions.size
    });
    frameBuffer.outBuffer(cmdSize, sourceId);
    frameBuffer.execFrame();
  }
  
  if (startBrushOptions.alpha !== undefined) {

    const cmdAlpha = frameBuffer.netcode.brushOptionChanged({
      option: 'alpha',
      value: startBrushOptions.alpha
    });
    frameBuffer.outBuffer(cmdAlpha, sourceId);
    frameBuffer.execFrame();
  }
  
  // Then set all remaining options
  for (const optionName in startBrushOptions) {
    if (optionName === 'size' || optionName === 'alpha') continue; // Already set above
    
    const optionValue = startBrushOptions[optionName];

    const cmdOption = frameBuffer.netcode.brushOptionChanged({
      option: optionName,
      value: optionValue
    });
    frameBuffer.outBuffer(cmdOption, sourceId);
  }
  frameBuffer.execFrame();
  
  // Set layer
  const cmdLayer = frameBuffer.netcode.layerSelected({layer: stroke.layer || 0});
  frameBuffer.outBuffer(cmdLayer, sourceId);
  frameBuffer.execFrame();
  
  // Make pen visible
  const cmdShow = frameBuffer.netcode.penShow();
  frameBuffer.outBuffer(cmdShow, sourceId);
  frameBuffer.execFrame();
  
  // Double check size and color before pen down
  if (startBrushOptions.size !== undefined) {

    const cmdSizeConfirm = frameBuffer.netcode.brushOptionChanged({
      option: 'size',
      value: startBrushOptions.size
    });
    frameBuffer.outBuffer(cmdSizeConfirm, sourceId);
    frameBuffer.execFrame();
  }
  

  const cmdPreDownColor = frameBuffer.netcode.colorChanged({color: initialColor});
  frameBuffer.outBuffer(cmdPreDownColor, sourceId);
  frameBuffer.execFrame();
  
  // Small delay to ensure everything is processed
  setTimeout(() => {
    // Initial pen down with exact coordinates
    const cmdDown = frameBuffer.netcode.penDown({
      x: stroke.start.x,
      y: stroke.start.y
    });
    frameBuffer.outBuffer(cmdDown, sourceId);
    frameBuffer.execFrame();
    
    // For shape tools, wait a moment then send the final point
    const timeDiff = Math.min(300, Math.max(100, stroke.end?.time - stroke.start.time || 150));
    
    setTimeout(() => {
      // Apply end brush options with explicit size setting

      
      // First set the most critical options: size and alpha
      if (endBrushOptions.size !== undefined) {

        const cmdEndSize = frameBuffer.netcode.brushOptionChanged({
          option: 'size',
          value: endBrushOptions.size
        });
        frameBuffer.outBuffer(cmdEndSize, sourceId);
        frameBuffer.execFrame();
      }
      
      if (endBrushOptions.alpha !== undefined) {

        const cmdEndAlpha = frameBuffer.netcode.brushOptionChanged({
          option: 'alpha',
          value: endBrushOptions.alpha
        });
        frameBuffer.outBuffer(cmdEndAlpha, sourceId);
        frameBuffer.execFrame();
      }
      
      // Then set all remaining end options
      for (const optionName in endBrushOptions) {
        if (optionName === 'size' || optionName === 'alpha') continue; // Already set above
        
        const optionValue = endBrushOptions[optionName];

        const cmdOption = frameBuffer.netcode.brushOptionChanged({
          option: optionName,
          value: optionValue
        });
        frameBuffer.outBuffer(cmdOption, sourceId);
      }
      frameBuffer.execFrame();
      
      // Set the final color again with MULTIPLE approaches to ensure it's applied
      const finalColor = stroke.end?.color || stroke.color;
      
      // Final color approaches

      const cmdFinalColor = frameBuffer.netcode.colorChanged({color: finalColor});
      frameBuffer.outBuffer(cmdFinalColor, sourceId);
      frameBuffer.execFrame();
      
      // Add a critical delay to ensure all settings are applied
      setTimeout(() => {
        // Double check size and color right before pen up
        if (endBrushOptions.size !== undefined) {

          const cmdSizeFinal = frameBuffer.netcode.brushOptionChanged({
            option: 'size',
            value: endBrushOptions.size
          });
          frameBuffer.outBuffer(cmdSizeFinal, sourceId);
          frameBuffer.execFrame();
        }
        

        const cmdFinalColor3 = frameBuffer.netcode.colorChanged({color: finalColor});
        frameBuffer.outBuffer(cmdFinalColor3, sourceId);
        frameBuffer.execFrame();
        
        // Force send end point with explicit coordinates
        const cmdUp = frameBuffer.netcode.penUp({
          x: stroke.end.x,
          y: stroke.end.y
        });
        frameBuffer.outBuffer(cmdUp, sourceId);
        frameBuffer.execFrame();
        
        // Clean up
        setTimeout(() => {
          frameBuffer.revokeSource(sourceId);
          resolve();
        }, 100);
      }, 100); // Critical delay before final pen up
    }, timeDiff);
  }, 50);
}   // Special handling for blend brush
    else if (stroke.brushName === "blend" && (stroke.hasBlendColors || stroke.blendColors)) {
      setTimeout(() => {
        // Only send brush command ONCE
        const cmdBrush = frameBuffer.netcode.brushChanged({brush: stroke.brushName});
        frameBuffer.outBuffer(cmdBrush, sourceId);
        frameBuffer.execFrame(); // Process brush immediately
        
        // Set all brush options first
        this.sendBrushOptionsToNetwork({
          ...stroke.start.brushOptions,
          layer: stroke.layer 
        }, frameBuffer, sourceId);
        
        // Set layer
        const cmdLayer = frameBuffer.netcode.layerSelected({layer: stroke.layer || 0});
        frameBuffer.outBuffer(cmdLayer, sourceId);
        
        // Make pen visible
        const cmdShow = frameBuffer.netcode.penShow();
        frameBuffer.outBuffer(cmdShow, sourceId);
        frameBuffer.execFrame();
        
        // Initial pen down
        const cmdDown = frameBuffer.netcode.penDown({
          x: stroke.start.x,
          y: stroke.start.y
        });
        frameBuffer.outBuffer(cmdDown, sourceId);
        frameBuffer.execFrame();
        
        // If we have the new blendColors array, use that for precise replay
        if (stroke.blendColors && stroke.blendColors.length > 0) {

          
          let lastX = stroke.start.x;
          let lastY = stroke.start.y;
          let baseTime = stroke.start.time;
          let lastTime = baseTime;
          
          // Play back each blend color point
          stroke.blendColors.forEach((colorPoint, index) => {
            const delay = Math.min((colorPoint.time - lastTime), 500); // Cap max delay
            
            setTimeout(() => {
              // Send the brush parameter with the blended color
              const cmdBlend = frameBuffer.netcode.brushParameter({
                brush: "blend",
                parameters: {
                  type: "plot",
                  color: colorPoint.color,
                  x: colorPoint.x,
                  y: colorPoint.y
                }
              });
              frameBuffer.outBuffer(cmdBlend, sourceId);
              
              // Send the pen move
              const cmdMove = frameBuffer.netcode.penMove({
                x: colorPoint.x,
                y: colorPoint.y
              });
              frameBuffer.outBuffer(cmdMove, sourceId);
              frameBuffer.execFrame();
              
              // Update tracking variables
              lastX = colorPoint.x;
              lastY = colorPoint.y;
              lastTime = colorPoint.time;
              
              // If this is the last point, finish the stroke
              if (index === stroke.blendColors.length - 1) {
                setTimeout(() => {
                  const cmdUp = frameBuffer.netcode.penUp({
                    x: lastX,
                    y: lastY
                  });
                  frameBuffer.outBuffer(cmdUp, sourceId);
                  frameBuffer.execFrame();
                  
                  setTimeout(() => {
                    frameBuffer.revokeSource(sourceId);
                    resolve();
                  }, 100);
                }, 50);
              }
            }, index === 0 ? 0 : delay); // No delay for first point
          });
        }
        // Fall back to the old method if blendColors array isn't available
        else {

          
          // First blend point at start
          if (stroke.start.blendColor) {
            const cmdBlend = frameBuffer.netcode.brushParameter({
              brush: "blend",
              parameters: {
                type: "plot",
                color: stroke.start.blendColor,
                x: stroke.start.x,
                y: stroke.start.y
              }
            });
            frameBuffer.outBuffer(cmdBlend, sourceId);
          }
          
          // Process all move points with blend colors
          if (stroke.moves && stroke.moves.length > 0) {
            const baseTime = stroke.start.time;
            
            stroke.moves.forEach((move, index) => {
              setTimeout(() => {
                // Only send blend parameter if we have a color
                if (move.blendColor) {
                  const cmdBlend = frameBuffer.netcode.brushParameter({
                    brush: "blend",
                    parameters: {
                      type: "plot",
                      color: move.blendColor,
                      x: move.x,
                      y: move.y
                    }
                  });
                  frameBuffer.outBuffer(cmdBlend, sourceId);
                }
                
                // Send the move
                const cmdMove = frameBuffer.netcode.penMove({
                  x: move.x,
                  y: move.y
                });
                frameBuffer.outBuffer(cmdMove, sourceId);
                frameBuffer.execFrame();
                
                // If this is the last move, send pen up
                if (index === stroke.moves.length - 1) {
                  setTimeout(() => {
                    const cmdUp = frameBuffer.netcode.penUp({
                      x: move.x,
                      y: move.y
                    });
                    frameBuffer.outBuffer(cmdUp, sourceId);
                    frameBuffer.execFrame();
                    
                    setTimeout(() => {
                      frameBuffer.revokeSource(sourceId);
                      resolve();
                    }, 100);
                  }, 50);
                }
              }, Math.max(0, move.time - baseTime));
            });
          } else {
            // No moves, just send pen up
            setTimeout(() => {
              const cmdUp = frameBuffer.netcode.penUp({
                x: stroke.end.x || stroke.start.x,
                y: stroke.end.y || stroke.start.y
              });
              frameBuffer.outBuffer(cmdUp, sourceId);
              frameBuffer.execFrame();
              
              setTimeout(() => {
                frameBuffer.revokeSource(sourceId);
                resolve();
              }, 100);
            }, 100);
          }
        }
      }, 0);
      return;  // Make sure we don't continue to the regular brush handling
    }
    if (stroke.brushName === "custom") {

      
      // Get brush options from the best available source
      const brushOptions = (stroke.moves.length === 0 && stroke.end && stroke.end.brushOptions) 
        ? stroke.end.brushOptions 
        : stroke.start.brushOptions;
      
      // First send all options EXCEPT image data
      if (brushOptions) {
        const imageData = brushOptions.image; // Store image data for later
        
        // Send all other options first
        for (const optionName in brushOptions) {
          if (optionName === 'image') continue; // Skip image for now
          
          const optionValue = brushOptions[optionName];
          const cmdOption = frameBuffer.netcode.brushOptionChanged({
            option: optionName,
            value: optionValue
          });
          frameBuffer.outBuffer(cmdOption, sourceId);
        }
        frameBuffer.execFrame();
        
        // Now send image data separately if it exists
        if (imageData) {

          const cmdImage = frameBuffer.netcode.brushOptionChanged({
            option: 'image',
            value: imageData
          });
          frameBuffer.outBuffer(cmdImage, sourceId);
          frameBuffer.execFrame();
          
          // Critical: Wait 500ms after sending image data
          return new Promise(resolveImage => {
            setTimeout(() => {

              continueWithStroke();
              resolveImage();
            }, 500);
          });
        } else {
          continueWithStroke();
        }
      } else {
        continueWithStroke();
      }
      
      function continueWithStroke() {
        // Set layer first
        const cmdLayer = frameBuffer.netcode.layerSelected({layer: stroke.layer});
        frameBuffer.outBuffer(cmdLayer, sourceId);
        frameBuffer.execFrame();
        
        // Make pen visible
        const cmdShow = frameBuffer.netcode.penShow();
        frameBuffer.outBuffer(cmdShow, sourceId);
        frameBuffer.execFrame();
        
        // Set color before first pen move
        const startColor = stroke.start.color || stroke.color;

        const cmdStartColor = frameBuffer.netcode.colorChanged({color: startColor});
        frameBuffer.outBuffer(cmdStartColor, sourceId);
        frameBuffer.execFrame();
        
        // First pen move with original coordinates
        const cmdPenMove1 = frameBuffer.netcode.penMove({
          x: stroke.start.x,
          y: stroke.start.y
        });
        frameBuffer.outBuffer(cmdPenMove1, sourceId);
        frameBuffer.execFrame();
        
        // Second pen move with VISIBLY offset coordinates
        setTimeout(() => {
          // Set color again before second pen move in case it changed
          const moveColor = stroke.start.color || stroke.color;

          const cmdMoveColor = frameBuffer.netcode.colorChanged({color: moveColor});
          frameBuffer.outBuffer(cmdMoveColor, sourceId);
          frameBuffer.execFrame();
          
          // const cmdPenMove2 = frameBuffer.netcode.penMove({
          //   x: stroke.start.x + 0.5,  // More noticeable offset
          //   y: stroke.start.y + 0.5
          // });
          // frameBuffer.outBuffer(cmdPenMove2, sourceId);
          // frameBuffer.execFrame();
          
          // Set rotation value right before pen down
          setTimeout(() => {
            if (brushOptions && brushOptions.rotationvalue !== undefined) {
              const cmdRotation = frameBuffer.netcode.brushOptionChanged({
                option: 'rotationvalue',
                value: brushOptions.rotationvalue
              });
              frameBuffer.outBuffer(cmdRotation, sourceId);
              frameBuffer.execFrame();
            }
            
            // Set color right before pen down
            const downColor = stroke.start.color || stroke.color;

            const cmdDownColor = frameBuffer.netcode.colorChanged({color: downColor});
            frameBuffer.outBuffer(cmdDownColor, sourceId);
            frameBuffer.execFrame();
            
            // Finally do the pen down
            const cmdDown = frameBuffer.netcode.penDown({
              x: stroke.start.x,
              y: stroke.start.y
            });
            frameBuffer.outBuffer(cmdDown, sourceId);
            frameBuffer.execFrame();
            
            // Handle stroke completion
            if (stroke.moves.length > 0) {
              const baseTime = stroke.start.time;
              
              stroke.moves.forEach((move, index) => {
                setTimeout(() => {
                  // Handle custom brushes specially for each move
                  if (move.brushOptions) {
                    // For custom brushes, send each option EXCEPT image data during stroke
                    for (const optionName in move.brushOptions) {
                      // Skip image data during moves to save bandwidth
                      if (optionName === 'image') continue;
                      
                      const optionValue = move.brushOptions[optionName];
                      const cmdOption = frameBuffer.netcode.brushOptionChanged({
                        option: optionName,
                        value: optionValue
                      });
                      frameBuffer.outBuffer(cmdOption, sourceId);
                    }
                  }
                  
                  // Set color for each move if available
                  // if (move.color) {
                  //   console.log(`Setting MOVE color: ${move.color} for move #${index}`);
                  //   const cmdMoveColor = frameBuffer.netcode.colorChanged({color: move.color});
                  //   frameBuffer.outBuffer(cmdMoveColor, sourceId);
                  //   frameBuffer.execFrame();
                  // }
                  
                  const cmdMove = frameBuffer.netcode.penMove({
                    x: move.x,
                    y: move.y
                  });
                  frameBuffer.outBuffer(cmdMove, sourceId);
                  frameBuffer.execFrame();
                }, move.time - baseTime);
              });
              
              setTimeout(() => {
                // Handle end options for custom brushes
                if (stroke.end && stroke.end.brushOptions) {
                  // For custom brushes, send each option EXCEPT image data at end
                  for (const optionName in stroke.end.brushOptions) {
                    // Skip image data during end to save bandwidth
                    if (optionName === 'image') continue;
                    
                    const optionValue = stroke.end.brushOptions[optionName];
                    const cmdOption = frameBuffer.netcode.brushOptionChanged({
                      option: optionName,
                      value: optionValue
                    });
                    frameBuffer.outBuffer(cmdOption, sourceId);
                  }
                }
                
                // Set color right before pen up
                const endColor = stroke.end?.color || stroke.color;

                const cmdEndColor = frameBuffer.netcode.colorChanged({color: endColor});
                frameBuffer.outBuffer(cmdEndColor, sourceId);
                frameBuffer.execFrame();
                
                const cmdUp = frameBuffer.netcode.penUp({
                  x: stroke.end.x,
                  y: stroke.end.y  
                });
                frameBuffer.outBuffer(cmdUp, sourceId);
                frameBuffer.execFrame();
                
                setTimeout(() => {
                  frameBuffer.revokeSource(sourceId);
                  resolve();
                }, 100);
              }, stroke.end.time - stroke.start.time);
            } else {
              setTimeout(() => {
                // Set color right before pen up even without moves
                const endColor = stroke.end?.color || stroke.color;

                const cmdEndColor = frameBuffer.netcode.colorChanged({color: endColor});
                frameBuffer.outBuffer(cmdEndColor, sourceId);
                frameBuffer.execFrame();
                
                const cmdUp = frameBuffer.netcode.penUp({
                  x: stroke.end.x,
                  y: stroke.end.y  
                });
                frameBuffer.outBuffer(cmdUp, sourceId);
                frameBuffer.execFrame();
                
                setTimeout(() => {
                  frameBuffer.revokeSource(sourceId);
                  resolve();
                }, 100);
              }, 100);
            }
          }, 50); // Wait 50ms before rotation and pen down
        }, 50); // Wait 50ms before second move
      }
    }
// For all other non-custom brushes
else {
  // For strokes with no moves, use end brush options if available
  const brushOptions = (stroke.moves.length === 0 && stroke.end && stroke.end.brushOptions) 
    ? stroke.end.brushOptions 
    : stroke.start.brushOptions;
  
  // Check if this is a shape tool to completely skip sending pen moves
  const isShapeTool = stroke.brushName === "line" || 
                      stroke.brushName === "rect" || 
                      stroke.brushName === "ellipse";
  
  // Log what type of tool we're processing
  this.sendBrushOptionsToNetwork({
    ...brushOptions,
    layer: stroke.layer
  }, frameBuffer, sourceId, [], [], true);

  // ADDED: Explicitly set spacing for pen tool
  if (stroke.brushName === "pen" && brushOptions.spacing !== undefined) {
    const cmdSpacing = frameBuffer.netcode.brushOptionChanged({
      option: 'spacing',
      value: brushOptions.spacing
    });
    frameBuffer.outBuffer(cmdSpacing, sourceId);
    frameBuffer.execFrame();
  }
  
  const cmdLayer = frameBuffer.netcode.layerSelected({layer: stroke.layer});
  frameBuffer.outBuffer(cmdLayer, sourceId);
  
  const cmdShow = frameBuffer.netcode.penShow();
  frameBuffer.outBuffer(cmdShow, sourceId);
  
  // CRITICAL FIX: Explicitly set color before pen down
  const startColor = stroke.start?.color || stroke.color;

  const cmdStartColor = frameBuffer.netcode.colorChanged({color: startColor});
  frameBuffer.outBuffer(cmdStartColor, sourceId);
  frameBuffer.execFrame();
  
  const cmdDown = frameBuffer.netcode.penDown({
    x: stroke.start.x,
    y: stroke.start.y
  });
  frameBuffer.outBuffer(cmdDown, sourceId);
  frameBuffer.execFrame();
  
  // SHAPE TOOLS: Skip moves and go straight to pen up after a delay
  if (isShapeTool) {
    // For shape tools, use a reasonable delay before pen up
    const shapeDelay = Math.min(300, Math.max(100, stroke.end?.time - stroke.start.time || 150));
    
    setTimeout(() => {
      // Apply end brush options if available
      if (stroke.end && stroke.end.brushOptions) {
        this.sendBrushOptionsToNetwork(stroke.end.brushOptions, frameBuffer, sourceId);
      }
      
      // Set final color before pen up
      const endColor = stroke.end?.color || stroke.color;

      const cmdEndColor = frameBuffer.netcode.colorChanged({color: endColor});
      frameBuffer.outBuffer(cmdEndColor, sourceId);
      frameBuffer.execFrame();
      
      // Send pen up to complete the shape
      const cmdUp = frameBuffer.netcode.penUp({
        x: stroke.end.x,
        y: stroke.end.y  
      });
      frameBuffer.outBuffer(cmdUp, sourceId);
      frameBuffer.execFrame();
      
      // Clean up and resolve
      setTimeout(() => {
        frameBuffer.revokeSource(sourceId);
        resolve();
      }, 100);
    }, shapeDelay);
  }
  // REGULAR TOOLS: Process all moves normally
  else if (stroke.moves.length > 0) {
    const baseTime = stroke.start.time;
    
    stroke.moves.forEach((move, index) => {
      setTimeout(() => {
        if (move.brushOptions) {
          this.sendBrushOptionsToNetwork({
            ...move.brushOptions,
            layer: move.layer || stroke.layer
          }, frameBuffer, sourceId);
        }
        
        // Handle color changes for regular tools during moves
        if (move.color) {
          this.sendBrushOptionsToNetwork({color: move.color}, frameBuffer, sourceId);
        }
        
        // Send the pen move (only for non-shape tools)
        const cmdMove = frameBuffer.netcode.penMove({
          x: move.x,
          y: move.y
        });
        frameBuffer.outBuffer(cmdMove, sourceId);
        frameBuffer.execFrame();
      }, move.time - baseTime);
    });
    
    setTimeout(() => {
      if (stroke.end && stroke.end.brushOptions) {
        this.sendBrushOptionsToNetwork(stroke.end.brushOptions, frameBuffer, sourceId);
      }
      
      // CRITICAL FIX: Explicitly set color before pen up
      const endColor = stroke.end?.color || stroke.color;

      const cmdEndColor = frameBuffer.netcode.colorChanged({color: endColor});
      frameBuffer.outBuffer(cmdEndColor, sourceId);
      frameBuffer.execFrame();
      
      // ADDED: Check if this is a cancelled eraser stroke
      if (stroke.brushName === "eraser" && stroke.wasCancelled) {
        // Send penCancel instead of penUp
        const cmdCancel = frameBuffer.netcode.penCancel();
        frameBuffer.outBuffer(cmdCancel, sourceId);
        frameBuffer.execFrame();
      }
      else {
        // Normal penUp for non-cancelled strokes
        const cmdUp = frameBuffer.netcode.penUp({
          x: stroke.end.x,
          y: stroke.end.y  
        });
        frameBuffer.outBuffer(cmdUp, sourceId);
        frameBuffer.execFrame();
      }
      
      setTimeout(() => {
        frameBuffer.revokeSource(sourceId);
        resolve();
      }, 100);
    }, stroke.end.time - stroke.start.time);
  } 
  // NO MOVES: Handle strokes without any moves (simple clicks)
  else {
    setTimeout(() => {
      // CRITICAL FIX: Explicitly set color before pen up even without moves
      const endColor = stroke.end?.color || stroke.color;

      const cmdEndColor = frameBuffer.netcode.colorChanged({color: endColor});
      frameBuffer.outBuffer(cmdEndColor, sourceId);
      frameBuffer.execFrame();
      
      // ADDED: Check if this is a cancelled eraser stroke (for no-move case)
      if (stroke.brushName === "eraser" && stroke.wasCancelled) {
        // Send penCancel instead of penUp
        const cmdCancel = frameBuffer.netcode.penCancel();
        frameBuffer.outBuffer(cmdCancel, sourceId);
        frameBuffer.execFrame();
      }
      else {
        // Normal penUp for non-cancelled strokes
        const cmdUp = frameBuffer.netcode.penUp({
          x: stroke.end.x,
          y: stroke.end.y  
        });
        frameBuffer.outBuffer(cmdUp, sourceId);
        frameBuffer.execFrame();
      }
      
      setTimeout(() => {
        frameBuffer.revokeSource(sourceId);
        resolve();
      }, 100);
    }, 100);
  }
}
  }, 0);
}
    });
  }
  ["sendBrushOptionsToNetwork"](options, frameBuffer, sourceId, priorityOptions = [], excludeOptions = [], forceAll = false) {
    if (!options) return;
    
    // Initialize option tracking object if it doesn't exist
    if (!this._lastSentBrushOptions) {
      this._lastSentBrushOptions = {};
    }
    
    // COMPREHENSIVE LAYER DETECTION - With proper fallback mechanisms
    let currentLayer = null;
    let layerSource = "none";
    
    // Debug info about what we're processing
    const optKeys = Object.keys(options);
    console.log(` Options keys: [${optKeys.join(', ')}]`); 
    
    // IMPROVED: Check sources in order of precedence:
    // 1. First try nested objects (start/moves/end)
    if (options.start && options.start.layer !== undefined) {
      currentLayer = options.start.layer;
      layerSource = "options.start.layer";
      console.log(` Layer from start: ${currentLayer}`);
    } 
    else if (options.end && options.end.layer !== undefined) {
      currentLayer = options.end.layer;
      layerSource = "options.end.layer";
      console.log(` Layer from end: ${currentLayer}`);
    }
    else if (options.moves && options.moves.length > 0) {
      for (let i = options.moves.length - 1; i >= 0; i--) {
        if (options.moves[i].layer !== undefined) {
          currentLayer = options.moves[i].layer;
          layerSource = `options.moves[${i}].layer`;
          console.log(` Layer from moves[${i}]: ${currentLayer}`);
          break;
        }
      }
    }
    // 2. Then check direct layer property which is sometimes needed
    else if (options.layer !== undefined) {
      currentLayer = options.layer;
      layerSource = "options.layer";
      console.log(` Layer from direct layer: ${currentLayer}`);
    }
    // 3. Finally, if all else fails, use the stroke's cached layer 
    else if (this._lastSentBrushOptions.layer !== undefined) {
      currentLayer = this._lastSentBrushOptions.layer;
      layerSource = "cached_layer";
      console.log(` Using cached layer: ${currentLayer}`);
    }
    
    // Send layer command if we have a layer value
    if (currentLayer !== null && currentLayer !== undefined) {
      const isDifferent = this._lastSentBrushOptions.layer !== currentLayer;
      
      // Send if different or forcing all options
      if (isDifferent || forceAll) {
        console.log(` SENDING LAYER: ${currentLayer} (${isDifferent ? 'changed' : 'unchanged'}, force=${forceAll}, source=${layerSource})`);
        const cmdLayer = frameBuffer.netcode.layerSelected({layer: currentLayer});
        frameBuffer.outBuffer(cmdLayer, sourceId);
        frameBuffer.execFrame();
        
        // Update the tracking
        this._lastSentBrushOptions.layer = currentLayer;
      } else {
        console.log(` Skipping layer: ${currentLayer} (unchanged, source=${layerSource})`);
      }
    } else {
      console.log(` No layer found in options`);
    }
    
    // Rest of the function remains unchanged
    
    // Handle color separately if provided
    if (options.color && (this._lastSentBrushOptions.color !== options.color || forceAll)) {
      const cmdColor = frameBuffer.netcode.colorChanged({color: options.color});
      frameBuffer.outBuffer(cmdColor, sourceId);
      frameBuffer.execFrame();
      
      // Update the tracking
      this._lastSentBrushOptions.color = options.color;
    }
    
    // Only process the brushOptions object if it exists, not the entire move object
    const brushOptions = options.brushOptions || options;
    if (!brushOptions || typeof brushOptions !== 'object') return;
    
    // Skip non-brush options properties that might be in a move object
    const skipProps = ['x', 'y', 'time', 'color', 'blendColor', 'layer']
    
    // Define critical options that should be processed first
    const criticalOptions = [
      'size', 'alpha', 'multilayer', 'spacing', 'selectiontype', 'allowedlayers',
      ...priorityOptions
    ];
    
    // First process critical options
    criticalOptions.forEach(option => {
      if (brushOptions[option] !== undefined && 
          !excludeOptions.includes(option) && 
          !skipProps.includes(option)) {
        // Send if value has changed OR we're forcing all options
        if (forceAll || this._lastSentBrushOptions[option] !== brushOptions[option]) {
          const cmd = frameBuffer.netcode.brushOptionChanged({
            option: option,
            value: brushOptions[option]
          });
          frameBuffer.outBuffer(cmd, sourceId);
          frameBuffer.execFrame();
          
          // Update the tracking
          this._lastSentBrushOptions[option] = brushOptions[option];
        }
      }
    });
    
    // Then process all remaining options
    for (const option in brushOptions) {
      // Skip if already processed as critical or excluded, or not a brush option
      if (criticalOptions.includes(option) || 
          excludeOptions.includes(option) || 
          skipProps.includes(option)) continue;
      
      const value = brushOptions[option];
      
      // Send if value has changed OR we're forcing all options
      if (forceAll || this._lastSentBrushOptions[option] !== value) {
        const cmd = frameBuffer.netcode.brushOptionChanged({
          option: option,
          value: value
        });
        frameBuffer.outBuffer(cmd, sourceId);
        frameBuffer.execFrame();
        
        // Update the tracking
        this._lastSentBrushOptions[option] = value;
      }
    }
  }
  ["sendInitialBrushSetup"](stroke, frameBuffer, sourceId) {
    // Set brush type
    const cmdBrush = frameBuffer.netcode.brushChanged({brush: stroke.brushName});
    frameBuffer.outBuffer(cmdBrush, sourceId);
    
    // Set color  
    const cmdColor = frameBuffer.netcode.colorChanged({color: stroke.color});
    frameBuffer.outBuffer(cmdColor, sourceId);
    
    // Set brush options
    this.sendBrushOptionsToNetwork({
      ...stroke.start.brushOptions,
      layer: stroke.layer 
    }, frameBuffer, sourceId);
    
    // Set layer
    const cmdLayer = frameBuffer.netcode.layerSelected({layer: stroke.layer});
    frameBuffer.outBuffer(cmdLayer, sourceId);
    
    // Make pen visible
    const cmdShow = frameBuffer.netcode.penShow();
    frameBuffer.outBuffer(cmdShow, sourceId);
    
    // Start stroke
    const cmdDown = frameBuffer.netcode.penDown({
      x: stroke.start.x,
      y: stroke.start.y
    });
    frameBuffer.outBuffer(cmdDown, sourceId);
    frameBuffer.execFrame();
  }
  ["sendMoves"](stroke, frameBuffer, sourceId) {
    const baseTime = stroke.start.time;
    
    stroke.moves.forEach((move) => {
      setTimeout(() => {
        this.sendBrushOptionsToNetwork({
          ...move.brushOptions,
          layer: move.layer || stroke.layer
        }, frameBuffer, sourceId);
        
        const cmdMove = frameBuffer.netcode.penMove({
          x: move.x,
          y: move.y
        });
        frameBuffer.outBuffer(cmdMove, sourceId);
        frameBuffer.execFrame();
      }, move.time - baseTime);
    });
  }
getPressureRange(stroke) {
  if (!stroke || !stroke.moves || stroke.moves.length === 0) return "N/A";
  
  let min = stroke.start.brushOptions.pressure[1];
  let max = min;
  
  stroke.moves.forEach(move => {
    const pressure = move.brushOptions.pressure[1];
    if (pressure < min) min = pressure;
    if (pressure > max) max = pressure;
  });
  
  const endPressure = stroke.end.brushOptions.pressure[1];
  if (endPressure < min) min = endPressure;
  if (endPressure > max) max = endPressure;
  
  return `${min.toFixed(2)} - ${max.toFixed(2)}`;
}
["replayStroke"](strokeNum, step = 'start', autoExecute = false) {
  // Auto-execute when called with just the stroke number
  if (arguments.length === 1) {
    autoExecute = true;
  }
  
  // Initialize replay if we're starting
  if (step === 'start') {
    if (this.isReplaying) {

      return;
    }
    
    const stroke = this.strokes.find(s => s.strokeNumber === strokeNum);
    if (!stroke) {

      return;
    }
    
    // SELECTION TOOL: Special handling for selection brush
    if (stroke.brushName === "selection" && stroke.isSelectionStroke) {
      // Check if this selection had any actual actions
      if (!stroke.hasActions) {
        return;
      }
      
      // Initialize replay state for selection execution
      this.replayState = {
        isReplaying: true,
        stroke: stroke,
        strokeNum: strokeNum,
        originalColor: this.drawColor,
        originalBrushOptions: this.getBrushOptions(),
        originalBrush: this.getCurrentBrush(),
        currentActionIndex: 0,
        autoExecute: autoExecute,
        phase: 'selection', // Starts with selection phase, then moves to 'transform'
        executedButtons: new Set() // Track which buttons we've executed to avoid duplicates
      };
      
      // Set global replay flag to prevent creation of new strokes
      this.isReplaying = true;
      
      // Set the brush that was used for this stroke
      this.setBrush("selection");
      
      this.drawColor = stroke.color;
      
      // Log selection actions overview





      
      // If auto-execute is true, start the sequence immediately
      if (autoExecute) {
        this._executeSelectionReplaySequence(strokeNum);
        return `Started automatic replay of selection stroke #${strokeNum}`;
      }
      
      return `Started command-driven replay of selection stroke #${strokeNum}`;
    }
// TEXT TOOL: Special handling for text brush
else if (stroke.brushName === "text" && stroke.isTextStroke) {
  setTimeout(() => {
    // Get coordinates for text position and round to nearest 1/8
    const rawStartX = stroke.start?.x || stroke.textStart?.x || stroke.finalTextEvent?.x || 400;
    const rawStartY = stroke.start?.y || stroke.textStart?.y || stroke.finalTextEvent?.y || 300;
    
    // Round to nearest 1/8
    const startX = roundToEighth(rawStartX);
    const startY = roundToEighth(rawStartY);
    
    // Initial brush setup
    const cmdBrush = frameBuffer.netcode.brushChanged({brush: stroke.brushName});
    frameBuffer.outBuffer(cmdBrush, sourceId);
    
    // Set brush options - prioritize finalTextEvent.brushOptions if available
    const brushOptions = stroke.finalTextEvent?.brushOptions || stroke.end?.brushOptions || 
                         stroke.start?.brushOptions || stroke.textStart?.brushOptions || {};
    if (brushOptions) {
      this.sendBrushOptionsToNetwork({
        ...brushOptions,
        layer: stroke.layer
      }, frameBuffer, sourceId);
    }
    
    // Set layer
    const cmdLayer = frameBuffer.netcode.layerSelected({layer: stroke.layer});
    frameBuffer.outBuffer(cmdLayer, sourceId);
    
    // Make pen visible
    const cmdShow = frameBuffer.netcode.penShow();
    frameBuffer.outBuffer(cmdShow, sourceId);
    frameBuffer.execFrame();
    
    // STEP 2: First click to position text field - NO COLOR SET HERE

    const cmdDown1 = frameBuffer.netcode.penDown({
      x: startX, 
      y: startY
    });
    frameBuffer.outBuffer(cmdDown1, sourceId);
    
    const cmdUp1 = frameBuffer.netcode.penUp({
      x: startX,
      y: startY
    });
    frameBuffer.outBuffer(cmdUp1, sourceId);
    frameBuffer.execFrame();
    
    // Store reference to 'this' for use in inner functions
    const self = this;
    
    // STEP 3: Send key events sequentially to type text
    if (stroke.keyEvents && stroke.keyEvents.length > 0) {
      // Use sequential approach for reliable network transmission
      let keyIndex = 0;
      
      const sendNextKeyEvent = () => {
        if (keyIndex >= stroke.keyEvents.length) {
          // All key events sent, proceed to final placement
          placeFinalText();
          return;
        }
        
        const keyEvent = stroke.keyEvents[keyIndex];
        
        // Send the key event
        let cmd;
        if (keyEvent.type === 'keyPress') {
          cmd = frameBuffer.netcode.keyPress({key: keyEvent.keyCode});
        } else if (keyEvent.type === 'modifierDown') {
          cmd = frameBuffer.netcode.modifierDown({code: keyEvent.keyCode});
        } else if (keyEvent.type === 'modifierUp') {
          cmd = frameBuffer.netcode.modifierUp({code: keyEvent.keyCode});
        }
        
        if (cmd) {
          frameBuffer.outBuffer(cmd, sourceId);
          frameBuffer.execFrame();
          
          // Move to next key after a delay
          keyIndex++;
          setTimeout(sendNextKeyEvent, 50); // 50ms minimum delay between keys
        } else {
          // Skip invalid events
          keyIndex++;
          sendNextKeyEvent();
        }
      };
      
      // Start sending key events
      setTimeout(sendNextKeyEvent, 200);
    } else if (stroke.textContent && stroke.textContent.length > 0) {
      // Alternative: use textContent if keyEvents not available
      // Send characters one by one
      let charIndex = 0;
      
      const sendNextChar = () => {
        if (charIndex >= stroke.textContent.length) {
          // All characters sent, proceed to final placement
          placeFinalText();
          return;
        }
        
        const char = stroke.textContent[charIndex];
        const charCode = char.charCodeAt(0);
        
        // If uppercase letter, send shift modifier
        if (charCode >= 65 && charCode <= 90) {
          const cmdModDown = frameBuffer.netcode.modifierDown({code: 16}); // 16 is shift
          frameBuffer.outBuffer(cmdModDown, sourceId);
          frameBuffer.execFrame();
          
          // Send character
          const cmdKey = frameBuffer.netcode.keyPress({key: charCode});
          frameBuffer.outBuffer(cmdKey, sourceId);
          frameBuffer.execFrame();
          
          // Send modifier up
          const cmdModUp = frameBuffer.netcode.modifierUp({code: 16});
          frameBuffer.outBuffer(cmdModUp, sourceId);
          frameBuffer.execFrame();
        } else {
          // Send character without modifier
          const cmdKey = frameBuffer.netcode.keyPress({key: charCode});
          frameBuffer.outBuffer(cmdKey, sourceId);
          frameBuffer.execFrame();
        }
        
        // Move to next character after delay
        charIndex++;
        setTimeout(sendNextChar, 50);
      };
      
      // Start sending characters
      setTimeout(sendNextChar, 200);
    } else {
      // No text data, just do final placement
      placeFinalText();
    }
    
    // STEP 4: Final placement function - now uses self instead of this
    function placeFinalText() {
      // Round final position coordinates to nearest 1/8
      const rawFinalX = stroke.finalTextEvent?.x || stroke.end?.x || startX;
      const rawFinalY = stroke.finalTextEvent?.y || stroke.end?.y || startY;
      
      const finalX = roundToEighth(rawFinalX);
      const finalY = roundToEighth(rawFinalY);
      
      // Apply final brush options if available before final click
      if (stroke.finalTextEvent?.brushOptions || stroke.end?.brushOptions) {
        const finalBrushOptions = stroke.finalTextEvent?.brushOptions || stroke.end?.brushOptions;
        self.sendBrushOptionsToNetwork(finalBrushOptions, frameBuffer, sourceId);
      }
      
      // CRITICAL CHANGE: Only set color right before final placement
      const finalColor = stroke.finalTextEvent?.color || stroke.end?.color || stroke.color;
      const cmdFinalColor = frameBuffer.netcode.colorChanged({color: finalColor});
      frameBuffer.outBuffer(cmdFinalColor, sourceId);
      frameBuffer.execFrame();
      
      // Send final placement click

      const cmdDown2 = frameBuffer.netcode.penDown({
        x: finalX,
        y: finalY
      });
      frameBuffer.outBuffer(cmdDown2, sourceId);
      
      const cmdUp2 = frameBuffer.netcode.penUp({
        x: finalX,  
        y: finalY
      });
      frameBuffer.outBuffer(cmdUp2, sourceId);
      frameBuffer.execFrame();
      
      // ADDED: Send another pen down/up sequence after a delay to ensure text mode is fully deactivated
      setTimeout(() => {
        // Set color again before final confirmation click for extra stability

        const cmdConfirmColor = frameBuffer.netcode.colorChanged({color: finalColor});
        frameBuffer.outBuffer(cmdConfirmColor, sourceId);
        frameBuffer.execFrame();
        
        const cmdDown3 = frameBuffer.netcode.penDown({
          x: finalX,
          y: finalY
        });
        frameBuffer.outBuffer(cmdDown3, sourceId);
        
        const cmdUp3 = frameBuffer.netcode.penUp({
          x: finalX,  
          y: finalY
        });
        frameBuffer.outBuffer(cmdUp3, sourceId);
        frameBuffer.execFrame();
        
        // Cleanup and resolve
        setTimeout(() => {
          frameBuffer.revokeSource(sourceId);
          resolve();
        }, 100);
      }, 300); // 300ms delay before extra pen down/up
    }
  }, 0);
}
    // REGULAR BRUSH: Direct replay for non-text strokes
    else {
      this.isReplaying = true;
      
      // Save original settings & restore after replay
      const originalColor = this.drawColor;
      const originalBrushOptions = this.getBrushOptions();
      const originalBrush = this.getCurrentBrush();
      
      // Set the brush that was used for this stroke
      this.setBrush(stroke.brushName);
      this.drawColor = stroke.color;
      
      // Start stroke with initial brush options
      const start = stroke.start;
      // Set full brush options from recorded start
      this.setBrushOptions(start.brushOptions);
      this.penDown(start.x, start.y);
      
      // Calculate relative timings
      const baseTime = stroke.start.time;
      const moveTimings = [0]; // First move is immediate
      
      // Process moves with their original timing
      if (stroke.moves && stroke.moves.length > 0) {
        stroke.moves.forEach((move, i) => {
          if (i > 0) {
            moveTimings.push(move.time - baseTime);
          }
        });
      
        // Add the end timing
        const endTiming = stroke.end.time - baseTime;
      
        // Execute each move with a timeout to simulate original speed
        stroke.moves.forEach((move, i) => {
          setTimeout(() => {
            // Set full brush options for this specific point
            if (move.brushOptions) this.setBrushOptions(move.brushOptions);
            this.penMove(move.x, move.y);
          }, moveTimings[i]);
        });
      
        // End stroke
        setTimeout(() => {
          const end = stroke.end;
          // Set ending brush options
          if (end.brushOptions) this.setBrushOptions(end.brushOptions);
          this.penUp(end.x, end.y);
          
          // Restore original settings
          this.drawColor = originalColor;
          this.setBrushOptions(originalBrushOptions);
          this.setBrush(originalBrush);
          this.isReplaying = false;

        }, endTiming);
      } else {
        // Handle case with no moves (like simple clicks or empty selection strokes)
        if (stroke.end) {
          setTimeout(() => {
            this.penUp(stroke.end.x, stroke.end.y);
            
            // Restore original settings
            this.drawColor = originalColor;
            this.setBrushOptions(originalBrushOptions);
            this.setBrush(originalBrush);
            this.isReplaying = false;

          }, 100); // Short delay for visual feedback
        }
      }
      
      return `Started replaying stroke #${strokeNum}`;
    }
  }
  
  // Handle specific steps based on provided command
  if (!this.replayState || this.replayState.strokeNum !== strokeNum) {
    return;
  }
  
  // Execute the requested step based on the stroke type
  if (this.replayState.stroke.isSelectionStroke) {
    return this._executeSelectionReplayStep(step, strokeNum);
  } else if (this.replayState.stroke.isTextStroke) {
    return this._executeTextReplayStep(step, strokeNum);
  }
}
["_executeSelectionReplaySequence"](strokeNum) {
  // Automatically execute all selection steps in sequence
  setTimeout(() => {
    this._executeSelectionReplayStep('selection', strokeNum);
    
    setTimeout(() => {
      this._executeSelectionReplayStep('transform', strokeNum);
    }, 800); // Wait a bit between selection and transformation
  }, 100);
  
  return "Starting selection replay sequence";
}
["_executeSelectionReplayStep"](step, strokeNum) {
  const state = this.replayState;
  const stroke = state.stroke;
  
  // Create a temporary override for brushParameter to prevent creating new strokes during replay
  if (!this._originalBrushParameter) {
    this._originalBrushParameter = this.brushParameter;
    this.brushParameter = function(params, brushName) {
      // Call the brush handler directly without creating new strokes
      if (brushName === null) {
        brushName = this.brushHandler.currentBrush;
      }
      
      // Execute the brush action directly
      this.brushHandler.brushes[brushName].onBrushParameter(params);
      $(this).triggerHandler(new brushParameterEvent(brushName, params).getEvent());
    };
  }
  
  if (step === 'selection' || step === 'all') {
    // Selection step - draw the initial selection area

    
    const start = stroke.start;
    
    // Apply any brush options from the recorded stroke
    if (start.brushOptions) {
      this.setBrushOptions(start.brushOptions);
    }
    

    this.penDown(start.x, start.y);
    
    // Replay all moves for the selection rectangle if they exist
    if (stroke.moves && stroke.moves.length > 0) {

      
      for (let i = 0; i < stroke.moves.length; i++) {
        const move = stroke.moves[i];
        
        // Apply any brush options if they exist for this specific move
        if (move.brushOptions) {
          this.setBrushOptions(move.brushOptions);
        }
        

        this.penMove(move.x, move.y);
      }
      
      // Complete the selection with the last move point
      const lastMove = stroke.moves[stroke.moves.length - 1];

      this.penUp(lastMove.x, lastMove.y);
    } else {
      // If there are no moves, use the end point

      this.penUp(stroke.end.x, stroke.end.y);
    }
    
    state.phase = 'transform';
    
    if (step === 'all' || state.autoExecute) {
      setTimeout(() => {
        this._executeSelectionReplayStep('transform', strokeNum);
      }, 500); // Give a small delay before starting transformations
    }
    return "Selection area drawn";
  }
  
  if (step === 'transform' || step === 'all') {

    
    // Process all selection actions in order
    if (!stroke.selectionActions || stroke.selectionActions.length === 0) {

      return "No transformation actions found";
    }
    
    // Initialize set for tracking executed buttons
    if (!state.executedButtons) {
      state.executedButtons = new Set();
    }
    
    // Find and mark the confirm button action if it exists
    const confirmActionIndex = stroke.selectionActions.findIndex(action => 
      (action.type === 'toolbarAction' && action.buttonName === 'confirm')
    );
    
    const hasConfirmAction = confirmActionIndex !== -1;
    
    // Mark the actions that should be executed before pausing
    const actionsToExecute = hasConfirmAction ? 
      stroke.selectionActions.slice(0, confirmActionIndex) : 
      stroke.selectionActions;
    
    // Establish relative timing between actions
    const baseTime = actionsToExecute[0]?.time || 0;
    const actionTimings = actionsToExecute.map(action => 
      Math.max(0, action.time - baseTime)  // Ensure no negative times
    );
    
    // Compress time intervals to make replay faster but preserve sequence
    const maxDelay = 300; // Maximum delay between actions in ms
    const compressedTimings = actionTimings.map(timing => 
      timing > maxDelay ? maxDelay + (timing - maxDelay) / 10 : timing
    );
    
    // Play back selection actions up to but not including the confirm button
    let imgActionSent = false;
    
    actionsToExecute.forEach((action, index) => {
      setTimeout(() => {
        // Handle toolbar button actions
        if (action.type === 'toolbarAction') {
          const buttonName = action.buttonName;
          
          // Only execute each button type once to avoid duplications
          if (!state.executedButtons.has(buttonName)) {
            state.executedButtons.add(buttonName);
            

            
            // Execute the actual button action except for confirm
            switch(buttonName) {
              case 'flip':
                if (UI.uploader && UI.uploader.toggleFlip) {

                  UI.uploader.toggleFlip();
                }
                break;
              case 'delete':
                if (UI.uploader) {

                  if (UI.uploader.clear) UI.uploader.clear();
                  if (UI.uploader.hide) UI.uploader.hide();
                }
                break;
              case 'cancel':
                if (UI.uploader) {

                  if (UI.uploader.flipped && UI.uploader.flipImage) 
                    UI.uploader.flipImage(false);
                  if (UI.uploader.selectionToolbar && UI.uploader.selectionToolbar.hide)
                    UI.uploader.selectionToolbar.hide();
                  if (UI.uploader.rotateImage) 
                    UI.uploader.rotateImage(0);
                  if (UI.uploader.moveImage && UI.uploader.originalPosition) 
                    UI.uploader.moveImage(UI.uploader.originalPosition.x, UI.uploader.originalPosition.y);
                  if (UI.uploader.resizeImage && UI.uploader.originalPosition) 
                    UI.uploader.resizeImage(UI.uploader.originalPosition.width, UI.uploader.originalPosition.height);
                  if (UI.uploader.draw)
                    UI.uploader.draw();
                }
                break;
            }
          } else {

          }
        }
        // Handle regular selection actions
        else if (action.type === 'action') {
          // Add special logging for move actions
          if (action.action === 'move') {

          } else {

          }
          
          // Execute the action
          this.brushParameter(action.parameters, 'selection');
        }
        else if (action.type === 'uploadMode') {

          this.setUploadMode(action.status);
        }
        else if (action.type === 'silhouette') {

          this.drawSilhouette(action.x, action.y, action.width, action.height, action.rotation);
        }
        else if (action.type === 'position') {

          this.penMove(action.x, action.y);
        }
        
        // If this is the last action before confirm, prompt user to take manual control
        if (index === actionsToExecute.length - 1 && hasConfirmAction) {
          setTimeout(() => {
            // Show reminder about how to continue with manual control
            // Restore original methods
            if (this._originalBrushParameter) {
              this.brushParameter = this._originalBrushParameter;
              this._originalBrushParameter = null;
            }
            
            // Mark replay as complete but don't restore settings yet to allow manual control
            this.isReplaying = false;
            // Don't reset replayState completely - leave it so we know what stroke was replayed
          }, 500);
        }
        
        // If this is the last action and no confirm button, handle cleanup
        else if (index === actionsToExecute.length - 1 && !hasConfirmAction) {
          setTimeout(() => {
            // Restore original methods
            if (this._originalBrushParameter) {
              this.brushParameter = this._originalBrushParameter;
              this._originalBrushParameter = null;
            }
            
            // Restore original settings
            this.drawColor = state.originalColor;
            this.setBrushOptions(state.originalBrushOptions);
            this.setBrush(state.originalBrush);
            this.isReplaying = false;

            this.replayState = null;
          }, 500);
        }
      }, compressedTimings[index]); 
    });
    
    return hasConfirmAction ? 
      "Replaying transformations, will pause before confirm" : 
      "Started replaying transformation actions";
  }
  
  return `Unknown step: ${step}`;
}

["_executeSelectionReplaySequence"](strokeNum) {
  // Automatically execute all selection steps in sequence
  setTimeout(() => {
    this._executeSelectionReplayStep('selection', strokeNum);
    
    setTimeout(() => {
      this._executeSelectionReplayStep('transform', strokeNum);
    }, 800); // Wait a bit between selection and transformation
  }, 100);
  
  return "Starting selection replay sequence";
}
_executeTextReplayStep(step, strokeNum) {
  if (!this.replayState || this.replayState.strokeNum !== strokeNum) {
    return;
  }
  
  const state = this.replayState;
  const stroke = state.stroke;
  
  // Track if this is an auto-execution for chaining steps
  const isAutoExecute = state.autoExecute === true;
  
  // Set the next step to execute (for auto-execution)
  let nextStep = null;
  let nextStepDelay = 500; // Default delay before next step
  
  switch(step) {
    case 'position':
      // First click to position text field
      
      // If text mode is already enabled, use penMove instead of penDown/penUp
      if (state.isTextAlreadyEnabled) {
        this.penMove(state.startX, state.startY);
        
        
        // Schedule next step immediately for auto execution
        nextStep = 'check';
        nextStepDelay = 100;
      } else {
        // Original behavior for first text - toggle text mode on
        this.penDown(state.startX, state.startY);
        
        setTimeout(() => {
          this.penUp(state.startX, state.startY);
          

          
          // Continue to next step if auto-executing
          if (isAutoExecute) {
            setTimeout(() => {
              this._executeTextReplayStep('check', strokeNum);
            }, 300); // Wait longer after pen up before checking
          } else {
          }
        }, 100);
        
        // No immediate next step since we have async setTimeout above
        nextStep = null;
      }
      break;
      
    case 'check':
      // Check if text field is properly initialized
      const brushTextInstance = this.brushHandler.brush;
      if (!(brushTextInstance instanceof BrushTextModded)) {
        return;
      }
      
      const isTextEnabled = brushTextInstance.enabled === true;
      
      if (!isTextEnabled) {
        // If text mode was supposed to be enabled but isn't, try a different approach
          
        // Try using click at a slightly different position
        const adjustedX = state.startX + 1;
        const adjustedY = state.startY + 1;
        
        this.penDown(adjustedX, adjustedY);
        
        setTimeout(() => {
          this.penUp(adjustedX, adjustedY);
          
          // Try again after a delay
          if (isAutoExecute) {
            setTimeout(() => {
              this._executeTextReplayStep('check', strokeNum);
            }, 300);
          } else {
          }
        }, 100);
        
        // No immediate next step
        nextStep = null;
      } else {
        state.brushTextInstance = brushTextInstance;
        nextStep = 'clear';
        nextStepDelay = 100;
      }
      break;
      
    case 'clear':
      // Clear any existing content
      try {
        if (typeof state.brushTextInstance.setText === 'function') {
          state.brushTextInstance.setText("", false);

        }
      } catch (e) {

      }
      
      if (stroke.keyEvents && stroke.keyEvents.length > 0) {
        // Log key events for debugging

        stroke.keyEvents.forEach((event, index) => {
          const char = event.type === 'keyPress' ? String.fromCharCode(event.keyCode) : '';

        });

        
        nextStep = 'nextkey';
        nextStepDelay = 200;
      } else if (stroke.textContent) {
        nextStep = 'nextchar';
        nextStepDelay = 200;
      } else {
        nextStep = 'finalize';
        nextStepDelay = 100;
      }
      break;
      
    case 'nextkey':
      // Execute the next key event from recorded sequence
      if (!stroke.keyEvents || state.keyIndex >= stroke.keyEvents.length) {

        
        nextStep = 'finalize';
        nextStepDelay = 300;
      } else {
        const keyEvent = stroke.keyEvents[state.keyIndex];
        const char = keyEvent.type === 'keyPress' ? String.fromCharCode(keyEvent.keyCode) : '';
        const emoji = keyEvent.type === 'keyPress' ? '' : (keyEvent.type === 'modifierDown' ? '' : '');
        
        // Simulate the key event
        if (keyEvent.type === 'keyPress') {
          this.keyPress(String(keyEvent.keyCode));
        } else if (keyEvent.type === 'modifierDown') {
          this.modifierDown(String(keyEvent.keyCode));
        } else if (keyEvent.type === 'modifierUp') {
          this.modifierUp(String(keyEvent.keyCode));
        }
        
        // Check current text after key
        setTimeout(() => {
          try {
            if (typeof state.brushTextInstance.getPlainText === 'function') {
              const currentText = state.brushTextInstance.getPlainText();
              }
          } catch (e) {
            // Ignore errors if text can't be retrieved
          }
          
          state.keyIndex++;

          
          // Continue with next key if auto-executing
          if (isAutoExecute) {
            setTimeout(() => {
              this._executeTextReplayStep('nextkey', strokeNum);
            }, 150); // Delay between keys
          } else {

          }
        }, 50);
        
        // No immediate next step
        nextStep = null;
      }
      break;
      
    case 'nextchar':
      // Type the next character from textContent
      const content = stroke.textContent;
      if (!content || state.textIndex >= content.length) {

        
        nextStep = 'finalize';
        nextStepDelay = 300;
      } else {
        const charCode = content.charCodeAt(state.textIndex);
        
        // If uppercase letter, add modifier
        if (charCode >= 65 && charCode <= 90) { // A-Z

          this.modifierDown('16'); // Shift key
          
          setTimeout(() => {

            this.keyPress(String(charCode));
            
            setTimeout(() => {

              this.modifierUp('16');
              
              state.textIndex++;

              
              // Continue with next character if auto-executing
              if (isAutoExecute) {
                setTimeout(() => {
                  this._executeTextReplayStep('nextchar', strokeNum);
                }, 150); // Delay between characters
              } else {

              }
            }, 50);
          }, 50);
        } 
        // Non-capital characters
        else {

          this.keyPress(String(charCode));
          
          setTimeout(() => {
            state.textIndex++;

            
            // Continue with next character if auto-executing
            if (isAutoExecute) {
              setTimeout(() => {
                this._executeTextReplayStep('nextchar', strokeNum);
              }, 150); // Delay between characters
            } else {

            }
          }, 50);
        }
        
        // No immediate next step
        nextStep = null;
      }
      break;
      
    case 'finalize':
      // Final placement click
      const finalX = stroke.finalTextEvent?.x || stroke.end?.x || state.startX;
      const finalY = stroke.finalTextEvent?.y || stroke.end?.y || state.startY;
      
      // Do the final pen down/up to commit the text

      this.penDown(finalX, finalY);
      
      setTimeout(() => {

        this.penUp(finalX, finalY);
        
        if (isAutoExecute) {
          setTimeout(() => {
            this._executeTextReplayStep('cleanup', strokeNum);
          }, 150);
        } else {

        }
      }, 100);
      
      // No immediate next step
      nextStep = null;
      break;
      
    case 'cleanup':
      // Cleanup and restore original settings

      this.drawColor = state.originalColor;
      this.setBrushOptions(state.originalBrushOptions);
      this.setBrush(state.originalBrush);
      
      state.isReplaying = false;
      this.replayState = null;
      this.isReplaying = false;
      break;
      
    default:


  }
  
  // Chain to the next step if auto-executing and we have an immediate next step
  if (isAutoExecute && nextStep) {
    state.autoExecute = true;
    setTimeout(() => {
      this._executeTextReplayStep(nextStep, strokeNum);
    }, nextStepDelay);
  } else if (step === 'position') {
    // Special case for the first step when starting auto execution
    state.autoExecute = true;
  }
  
  return `Executed step '${step}' for stroke #${strokeNum}`;
}
replayTextStroke(strokeNum) {
  return this.replayStroke(strokeNum, 'start', true);
}
placeTextFinal(stroke, originalColor, originalBrushOptions, originalBrush, strokeNum) {
  // Get click position from finalTextEvent or end
  const finalX = stroke.finalTextEvent?.x || stroke.end?.x || stroke.start.x;
  const finalY = stroke.finalTextEvent?.y || stroke.end?.y || stroke.start.y;
  

  
  // Do second click to place text
  this.penDown(finalX, finalY);
  this.penUp(finalX, finalY);
  
  // Cleanup and restore original settings
  setTimeout(() => {
    this.drawColor = originalColor;
    this.setBrushOptions(originalBrushOptions);
    this.setBrush(originalBrush);
    this.isReplaying = false;

  }, 100);
}
replayAllStrokes() {
  if (this.isReplaying) {

    return;
  }
  
  if (this.strokes.length === 0) {

    return;
  }
  

  this.isReplaying = true;
  
  // Save original settings
  const originalColor = this.drawColor;
  const originalBrushOptions = this.getBrushOptions();
  const originalBrush = this.getCurrentBrush();
  
  let currentIndex = 0;
  
  const playNextStroke = () => {
    if (currentIndex >= this.strokes.length) {
      // Restore original settings at the end
      this.drawColor = originalColor;
      this.setBrushOptions(originalBrushOptions);
      this.setBrush(originalBrush);
      this.isReplaying = false;

      return;
    }
    
    const stroke = this.strokes[currentIndex];

    
    // Set brush and color for this stroke
    this.setBrush(stroke.brushName);
    this.drawColor = stroke.color;
    
    // Start stroke with initial brush options
    const start = stroke.start;
    this.setBrushOptions(stroke.start.brushOptions);
    this.penDown(start.x, start.y);
    
    // Calculate relative timings
    const baseTime = stroke.start.time;
    const moveTimings = [0]; // First move is immediate
    
    // Process moves with their original timing
    stroke.moves.forEach((move, i) => {
      if (i > 0) {
        moveTimings.push(move.time - baseTime);
      }
    });
    
    // Add the end timing
    const endTiming = stroke.end.time - baseTime;
    
    // Execute each move with a timeout
    stroke.moves.forEach((move, i) => {
      setTimeout(() => {
        this.setBrushOptions(move.brushOptions);
        this.penMove(move.x, move.y);
      }, moveTimings[i]);
    });
    
    // End stroke and continue to next
    setTimeout(() => {
      const end = stroke.end;
      this.setBrushOptions(stroke.end.brushOptions);
      this.penUp(end.x, end.y);
      currentIndex++;
      setTimeout(playNextStroke, 500); // 500ms delay between strokes
    }, endTiming);
  };
  
  playNextStroke();
  return "Started replaying all strokes";
}
["penDown"](_0x43f1e7, _0x39134a) {
  _0x43f1e7 = formatNumberMod(_0x43f1e7);
  _0x39134a = formatNumberMod(_0x39134a);

  // Only reset snap variables if the feature is enabled and it's my surface
  if (this.lineSnapFeatureEnabled && this.isMyself) {
    // Reset snap direction tracking at the start of a new stroke
    this.snapStartX = undefined;
    this.snapStartY = undefined;
    this.snapDirection = undefined;
    this.snapOrigin = undefined;
    this.snapOriginBoard = undefined;
    this._wasShiftReleased = false; // Reset the SHIFT tracking variable
  }

    const isSelectionTool = this.getCurrentBrush() === "selection";
    const isPolygonalMode = isSelectionTool &&
      this.getBrushOption("polygonalselection") &&
      this.getBrushOption("selectiontype");

    // SNAP CONNECT: Check if we should connect to the last point
    const currentBrush = this.getCurrentBrush();
    const isSnapEnabled = this.lineSnapFeatureEnabled && this.isMyself && UI.holdingSHIFT;
    let connectingPoints = false;
    
    if (isSnapEnabled && (currentBrush !== "rect" && currentBrush !== "line" && currentBrush !== "ellipse") && 
    this.lastSnapPoint && !isSelectionTool && !isPolygonalMode) {
        
        // We have a stored point and snap is on - let's connect the points
        connectingPoints = true;
        
        // Store current coordinates before we modify them
        const targetX = _0x43f1e7;
        const targetY = _0x39134a;

        if (room?.myself?.surface?.setBrushOptions && room?.myself?.surface?.getBrushOptions) {
          const currentPressure = room.myself.surface.getBrushOptions()?.pressure?.[0] ?? 1;
          room.myself.surface.setBrushOptions({ pressure: [currentPressure, 1] });
        }
        
        // Temporarily disable connecting to avoid recursion
        const tempLastPoint = this.lastSnapPoint;
        this.lastSnapPoint = null;
        
        // Start drawing from the previous point
        this.isConnectingPoints = true; // Flag to prevent normal snap during connection
        this.penDown(tempLastPoint.x, tempLastPoint.y);
        
        // Move to the target point (current click)
        this.penMove(targetX, targetY);
        
        // End the connecting line operation
        this.isConnectingPoints = false;
    }

    // If we're in connecting mode, skip the rest of penDown
    if (connectingPoints) return;

    // Special handling for polygonal selection
    if (isPolygonalMode) {
    // Check for double-click (second click within 300ms AND in same location)
    const now = new Date().getTime();
    const isDoubleClick = this._lastPolygonalPenDownTime && 
                          (now - this._lastPolygonalPenDownTime < 300) &&
                          this._lastPolygonalPoint &&
                          arePointsClose({x: _0x43f1e7, y: _0x39134a}, this._lastPolygonalPoint);
    
    // Store current point and time for next check
    this._lastPolygonalPenDownTime = now;
    this._lastPolygonalPoint = {x: _0x43f1e7, y: _0x39134a};
    
    // If double-click detected and we have points, complete the polygon
    if (isDoubleClick && this.polygonPoints && this.polygonPoints.length >= 2) {
      // Complete the polygon by adding a final penMove to the start point
      const startPoint = this.polygonPoints[0];
      this.isAddingPolygonPoint = true;
      this.penMove(startPoint.x, startPoint.y);
      this.isAddingPolygonPoint = false;
      
      // Then execute penUp at the original start point
      this.isClosingPolygon = true;
      this.penUp(startPoint.x, startPoint.y);
      this.isClosingPolygon = false;
      
      // Reset polygon points and double-click tracking
      this.polygonPoints = [];
      this._lastPolygonalPoint = null;
      return;
    }
    
    // If we don't have polygon points yet, this is the first point
    if (!this.polygonPoints || this.polygonPoints.length === 0) {
      // Start a new polygon and continue with normal penDown
      this.polygonPoints = [{x: _0x43f1e7, y: _0x39134a}];
      // Allow normal penDown for first point
    } else {
      // If this point is close to starting point and we have at least 3 points, close the polygon
      if (this.polygonPoints.length >= 3 && 
          arePointsClose({x: _0x43f1e7, y: _0x39134a}, this.polygonPoints[0])) {
        // Complete the polygon by adding a final penMove to the start point
        const startPoint = this.polygonPoints[0];
        this.isAddingPolygonPoint = true;
        this.penMove(startPoint.x, startPoint.y);
        this.isAddingPolygonPoint = false;
        
        // Then execute penUp at the original start point
        this.isClosingPolygon = true;
        this.penUp(startPoint.x, startPoint.y);
        this.isClosingPolygon = false;
        
        // Reset polygon points
        this.polygonPoints = [];
        return;
      } else {
        // Add this point as a line vertex by executing a penMove instead of penDown
        this.isAddingPolygonPoint = true;
        this.penMove(_0x43f1e7, _0x39134a);
        this.isAddingPolygonPoint = false;
        
        this.polygonPoints.push({x: _0x43f1e7, y: _0x39134a});
        return;
      }
    }
  }
  
  // Add logging about who is drawing
  const drawerInfo = this.getDrawerInfo();
  const userType = drawerInfo.isMyself ? " ME" : " OTHER USER";
  // Check if we're using text tool
  const isTextTool = this.getCurrentBrush() === "text";
  const isBlendTool = this.getCurrentBrush() === "blend";

  this.brushHandler.brush.drawingTool &&
    ((this.penPressed = true),
    (this.stepFrom = new Point(_0x43f1e7, _0x39134a)),
    this.brushHandler.brush.drawStart(_0x43f1e7, _0x39134a, this.drawColor),
    (this.lastPenDown = parseInt(new Date().getTime() / 1e3, 10)),
    $(this).triggerHandler(new penDownEvent(_0x43f1e7, _0x39134a).getEvent()));

  // CUSTOM: Record stroke start with full brush options ONLY if it's our own drawing
  if (this.isMyself && !this.isReplaying) {
    if (isTextTool) {
      // If text mode is not active, this is the first click to start text entry
      if (!this.textModeActive) {

        this.textModeActive = true;
        this.textModeKeyEvents = [];
        this.textModeStartTime = new Date().getTime();
        this.textModeStartPoint = { x: _0x43f1e7, y: _0x39134a };

        // Get next sequential stroke number
        let newStrokeNumber;
        if (this.strokes.length === 0) {
          newStrokeNumber = 1;
          this.strokeCount = 1;
        } else {
          const existingNumbers = new Set(this.strokes.map(stroke => stroke.strokeNumber));
          newStrokeNumber = this.strokes.length + 1;
          while (existingNumbers.has(newStrokeNumber)) {
            newStrokeNumber++;
          }
          this.strokeCount = Math.max(this.strokeCount, newStrokeNumber);
        }

        this.currentStrokeData = {
          strokeNumber: newStrokeNumber,
          color: this.drawColor,
          brushName: "text",
          layer: this.currentLayer,
          isTextStroke: true,
          textStart: {
            x: _0x43f1e7,
            y: _0x39134a,
            time: this.textModeStartTime,
            brushOptions: this.getBrushOptions(),
            layer: this.currentLayer  // Add explicit layer to textStart
          },
          keyEvents: [],
          textContent: "",
          finalTextEvent: null,
          start: {
            x: _0x43f1e7,
            y: _0x39134a,
            time: this.textModeStartTime,
            brushOptions: this.getBrushOptions(),
            color: this.drawColor  // Add color to start point
          },
          moves: [],
          end: null,
          textPlacementPhase: false // Track if we're in the text placement phase
        };
      } else {
        // If text mode is already active, this is the second click to place text

        if (this.currentStrokeData && this.currentStrokeData.isTextStroke) {
          // Capture current text content but DON'T finalize yet
          if (this.brushHandler.brush instanceof BrushTextModded) {
            const textContent = this.brushHandler.brush.getPlainText();
            this.currentStrokeData.textContent = textContent;

          }
          
          // Mark that we're in the placement phase, but don't set finalTextEvent
          // CRITICAL FIX: Just mark the placement phase, don't set finalTextEvent yet
          this.currentStrokeData.textPlacementPhase = true;
        }
      }
    } else if (isSelectionTool) {
      // For selection tool - track internally but DON'T add to strokes array yet
      // We'll only finalize strokes when actual selection actions happen
      let newStrokeNumber;
      if (this.strokes.length === 0) {
        newStrokeNumber = 1;
        this.strokeCount = 1;
      } else {
        const existingNumbers = new Set(this.strokes.map(stroke => stroke.strokeNumber));
        newStrokeNumber = this.strokes.length + 1;
        while (existingNumbers.has(newStrokeNumber)) {
          newStrokeNumber++;
        }
        this.strokeCount = Math.max(this.strokeCount, newStrokeNumber);
      }

      this.currentStrokeData = {
        strokeNumber: newStrokeNumber,
        color: this.drawColor,
        brushName: "selection",
        layer: this.currentLayer,
        isSelectionStroke: true,
        hasActions: false, // Initialize as having no actions
        start: {
          x: _0x43f1e7,
          y: _0x39134a,
          time: new Date().getTime(),
          brushOptions: this.getBrushOptions(),
          color: this.drawColor,  // Add color to start point
          layer: this.currentLayer
        },
        moves: [],
        selectionActions: [],
        uploadComplete: false,
        end: null,
      };
      

    } else {
      // For regular drawing tools - use sequential numbering
      let newStrokeNumber;
      if (this.strokes.length === 0) {
        newStrokeNumber = 1;
        this.strokeCount = 1;
      } else {
        const existingNumbers = new Set(this.strokes.map(stroke => stroke.strokeNumber));
        newStrokeNumber = this.strokes.length + 1;
        while (existingNumbers.has(newStrokeNumber)) {
          newStrokeNumber++;
        }
        this.strokeCount = Math.max(this.strokeCount, newStrokeNumber);
      }

      // Create the stroke data with appropriate properties
      this.currentStrokeData = {
        strokeNumber: newStrokeNumber,
        color: this.drawColor,
        brushName: this.getCurrentBrush(),
        layer: this.currentLayer,
        start: {
          x: _0x43f1e7,
          y: _0x39134a,
          time: new Date().getTime(),
          brushOptions: this.getBrushOptions(),
          color: this.drawColor,  // Add color to start point
          layer: this.currentLayer
        },
        moves: [],
        end: null,
      };
      
      // Special handling for blend brush - initialize blend-specific properties
      if (isBlendTool) {
        this.currentStrokeData.blendColors = [];
        this.currentStrokeData.hasBlendColors = true;
        
        // Create a reference to the stroke in the surface object for single-click handling
        this._lastBlendStrokeNumber = newStrokeNumber;
        
        // For blend brush, we need to immediately capture the color at the click point
        try {
          // Get the color at this point via the brush's internal logic
          const brushSize = this.brushHandler.brush.getOption("size") || 1;
          const bgColor = room.board.backgroundColor || '#ffffff';
          
          // Call the color sampling function directly
          const avgColor = getRadialAvg(
            room.board.getImageData(this.currentLayer), 
            _0x43f1e7, 
            _0x39134a, 
            Math.max(brushSize/2, 1),
            bgColor
          );
          
          // If we got a valid color
          if (avgColor && !isNaN(avgColor[0])) {
            // Convert to RGB format
            const rgbaColor = rgba2rgb(avgColor[0], avgColor[1], avgColor[2], avgColor[3] / 255);
            const hexColor = rgb2hex(`rgb(${rgbaColor.r},${rgbaColor.g},${rgbaColor.b})`);
            
            // Add to blend colors array
            this.currentStrokeData.blendColors.push({
              color: hexColor,
              x: _0x43f1e7,
              y: _0x39134a,
              time: new Date().getTime(),
              layer: this.currentLayer  // Add layer to blend color
            });
            
            // Also store in start
            this.currentStrokeData.start.blendColor = hexColor;
            this.currentStrokeData.start.layer = this.currentLayer; // Ensure layer is in start
            
            }
        } catch (error) {

        }
      }
      

    }
  }

  // CUSTOM: External pen down function
  if (typeof window.myPenDownCallback === "function") {
    window.myPenDownCallback(_0x43f1e7, _0x39134a);
  }
}
["penMove"](_0x483505, _0x1c34a6) {
  _0x483505 = formatNumberMod(_0x483505);
  _0x1c34a6 = formatNumberMod(_0x1c34a6);

  const isSelectionTool = this.getCurrentBrush() === "selection";
  const isPolygonalMode = isSelectionTool &&
    this.getBrushOption("polygonalselection") &&
    this.getBrushOption("selectiontype");

  // If feature is disabled or not my surface, ensure all related variables are reset
  if (!this.lineSnapFeatureEnabled || !this.isMyself) {
    // Clear any existing snap state to prevent snapping when disabled
    this.snapDirection = undefined;
    this.snapOrigin = undefined;
    this._wasShiftReleased = false;
    this.lastSnapPoint = null;
  }

  // Only calculate isSnapEnabled if the feature is enabled and it's my surface
  const isSnapEnabled = (this.lineSnapFeatureEnabled && this.isMyself) ? UI.holdingSHIFT : false;
  
  // For polygonal mode, block normal penMove events unless explicitly allowed by isAddingPolygonPoint
  if (isPolygonalMode && this.polygonPoints && this.polygonPoints.length > 0) {
    if (!this.isAddingPolygonPoint) {
      // Update cursor position but don't execute drawing logic
      this.cursor["update"](_0x483505, _0x1c34a6, this["brushHandler"]["getOption"]("size"));
      return;
    }
  }

  // SNAP FEATURE: Implement axis snapping for pen and eraser tools
  const currentBrush = this.getCurrentBrush();

  // Track SHIFT state only if feature enabled and it's my surface
  if (this.lineSnapFeatureEnabled && this.isMyself && this.penPressed && (currentBrush !== "rect" && currentBrush !== "line" && currentBrush !== "ellipse")) {
    if (isSnapEnabled && this._wasShiftReleased) {
      this.snapDirection = undefined;
      this.snapOrigin = undefined;
      this._wasShiftReleased = false;
    } else if (!isSnapEnabled && this.snapDirection !== undefined) {
      this._wasShiftReleased = true;
    }
  }

  if (this.lineSnapFeatureEnabled && this.isMyself &&
    this.penPressed && isSnapEnabled &&
    (currentBrush !== "rect" && currentBrush !== "line" && currentBrush !== "ellipse") &&
    !this.isConnectingPoints) {

    if (!this.snapOrigin) {
      const boardOrigin = UI.boardToScreen(this.stepFrom.x, this.stepFrom.y);
      this.snapOrigin = { x: boardOrigin.x, y: boardOrigin.y };
    }

    const screenCurrent = UI.boardToScreen(_0x483505, _0x1c34a6);
    const screenVectorX = screenCurrent.x - this.snapOrigin.x;
    const screenVectorY = screenCurrent.y - this.snapOrigin.y;
    const totalDistance = Math.sqrt(screenVectorX * screenVectorX + screenVectorY * screenVectorY);

    if (this.snapDirection === undefined && totalDistance >= 4) {
      this.snapDirection = Math.abs(screenVectorX) >= Math.abs(screenVectorY) ? "horizontal" : "vertical";
    }

    if (this.snapDirection !== undefined) {
      let snappedScreenX, snappedScreenY;
      if (this.snapDirection === "horizontal") {
        snappedScreenX = this.snapOrigin.x + screenVectorX;
        snappedScreenY = this.snapOrigin.y;
      } else {
        snappedScreenX = this.snapOrigin.x;
        snappedScreenY = this.snapOrigin.y + screenVectorY;
      }
      const snappedBoard = UI.screenToBoard(snappedScreenX, snappedScreenY);
      _0x483505 = snappedBoard.x;
      _0x1c34a6 = snappedBoard.y;
    }
  } 

  var _0xac501a = new Point(_0x483505, _0x1c34a6);  
  if (this["penPressed"]) {
      // Only log the first move and then periodically to avoid console spam
    if (!this._lastMoveLog || new Date().getTime() - this._lastMoveLog > 500) {
      const drawerInfo = this.getDrawerInfo();
      const userType = drawerInfo.isMyself ? " ME" : " OTHER USER";
      // console.log(`%c${userType} [${drawerInfo.username}] penMove at (${_0x483505}, ${_0x1c34a6})`, 
      //   `color: ${drawerInfo.isMyself ? "blue" : "green"}`);
      this._lastMoveLog = new Date().getTime();
    }
    
    this["brushHandler"]["brush"]["drawStep"](this["stepFrom"], _0xac501a, this["drawColor"]);
    this.stepFrom = new Point(_0x483505, _0x1c34a6);
    
    // CUSTOM: Record stroke movement with full brush options ONLY if it's our own drawing
    if (this.isMyself && this.currentStrokeData && !this.isReplaying) {
      this.currentStrokeData.moves.push({
        x: _0x483505,
        y: _0x1c34a6,
        time: new Date().getTime(),
        brushOptions: this.getBrushOptions(),
        color: this.drawColor,  // Add color to each move point
        layer: this.currentLayer  // Add current layer to each move point
      });
    }
  } else {
    this["brushHandler"]["brush"]["cursorMove"](this["stepFrom"], _0xac501a);
    this.stepFrom = new Point(_0x483505, _0x1c34a6);
    
    // Also record moves for selection tool when not pressed (for resizing/positioning)
    if (this.isMyself && !this.isReplaying && 
        this.getCurrentBrush() === "selection" && 
        this.currentStrokeData?.isSelectionStroke && 
        this.uploadMode) {

      this.currentStrokeData.selectionActions.push({
        type: 'position',
        x: _0x483505, 
        y: _0x1c34a6,
        time: new Date().getTime(),
        layer: this.currentLayer  // Add current layer to selection actions
      });
    }
  }
  
  this.cursor["update"](_0x483505, _0x1c34a6, this["brushHandler"]["getOption"]("size")); 
  $(this)["triggerHandler"](new penMoveEvent(_0x483505, _0x1c34a6).getEvent());
}
["penUp"](_0x59374c, _0x1e768a) {
  _0x59374c = formatNumberMod(_0x59374c);
  _0x1e768a = formatNumberMod(_0x1e768a);

  const isSelectionTool = this.getCurrentBrush() === "selection";
  const isPolygonalMode = isSelectionTool &&
    this.getBrushOption("polygonalselection") &&
    this.getBrushOption("selectiontype");

  const currentBrush = this.getCurrentBrush();

  // Only calculate isSnapEnabled if the feature is enabled and it's my surface
  const isSnapEnabled = (this.lineSnapFeatureEnabled && this.isMyself) ? UI.holdingSHIFT : false;

  // Only perform snapping operations if the feature is enabled and it's my surface
  if (this.lineSnapFeatureEnabled && this.isMyself && 
    this.penPressed && isSnapEnabled &&
    (currentBrush !== "rect" && currentBrush !== "line" && currentBrush !== "ellipse") &&
    this.snapOrigin && !this.isConnectingPoints) {
      if (this.snapDirection) {
        const screenCurrent = UI.boardToScreen(_0x59374c, _0x1e768a);
        const screenVectorX = screenCurrent.x - this.snapOrigin.x;
        const screenVectorY = screenCurrent.y - this.snapOrigin.y;
        let snappedScreenX, snappedScreenY;
        if (this.snapDirection === "horizontal") {
          snappedScreenX = this.snapOrigin.x + screenVectorX;
          snappedScreenY = this.snapOrigin.y;
        } else {
          snappedScreenX = this.snapOrigin.x;
          snappedScreenY = this.snapOrigin.y + screenVectorY;
        }
        const snappedBoard = UI.screenToBoard(snappedScreenX, snappedScreenY);
        _0x59374c = snappedBoard.x;
        _0x1e768a = snappedBoard.y;
      }
  }

  if (this.lineSnapFeatureEnabled && this.isMyself) {
    this.snapDirection = undefined;
    this.snapStartX = undefined;
    this.snapStartY = undefined;
    this.snapOrigin = undefined;
    this.snapThreshold = undefined;
  }

  // Store last point only if feature enabled and it's my surface
  if (this.lineSnapFeatureEnabled && this.isMyself &&
    (currentBrush !== "rect" && currentBrush !== "line" && currentBrush !== "ellipse") &&
    !isSelectionTool && !this.isConnectingPoints) {
    this.lastSnapPoint = {
      x: _0x59374c,
      y: _0x1e768a,
      time: Date.now()
    };
  } else {
    // Always clear lastSnapPoint when feature is disabled
    this.lastSnapPoint = null;
  }

  // For polygonal mode, block normal penUp unless closing polygon
  if (isPolygonalMode && this.polygonPoints && this.polygonPoints.length > 0) {
    if (!this.isClosingPolygon) {
      return; // Block penUp for polygonal mode unless explicitly closing
    }
  }
  if (this.penPressed) {
    const drawerInfo = this.getDrawerInfo();
    const userType = drawerInfo.isMyself ? " ME" : " OTHER USER";
    }
  
  // Execute original penUp behavior
  if (this.penPressed && this.brushHandler.brush.drawingTool) {
    // Capture text content BEFORE calling drawEnd if we're in placement phase
    const isTextTool = this.getCurrentBrush() === "text";
    let capturedTextContent = null;
    if (isTextTool && this.isMyself && this.currentStrokeData && this.currentStrokeData.textPlacementPhase) {
      const textBrush = this.brushHandler.brush;
      if (textBrush instanceof BrushTextModded) {
        capturedTextContent = textBrush.getPlainText();

        
        // Strip HTML tags from the captured text
        let stripped = capturedTextContent.replace(/<[^>]+>/g, '').trim();
        // More precise check: if the stripped text begins with the default disabled markup,
        // then ignore the captured content.
        if (stripped.indexOf('CLICK') === 0 && capturedTextContent.indexOf('<span class="disabledCursor">') === 0) {

          capturedTextContent = "";
        }
      }
    }
    
    // Perform the standard drawEnd and update pen state
    this.brushHandler.brush.drawEnd(_0x59374c, _0x1e768a, this.drawColor);
    this.stepFrom = new Point(_0x59374c, _0x1e768a);
    this.penPressed = false;
    this.lastPenUp = parseInt(new Date().getTime() / 1000);
    $(this).triggerHandler(new penUpEvent(_0x59374c, _0x1e768a).getEvent());
    room.board.layerChanged(this.currentLayer);
    if (!this.cursor.isVisible() && !this.brushHandler.brush.isUsingSlate() && !this.uploadMode) {
      this.setSlateUse(false);
    }
    
    // CUSTOM: Record stroke end with full brush options
    if (this.isMyself && this.currentStrokeData && !this.isReplaying) {
        const isTextTool = this.getCurrentBrush() === "text";
        const isCustomBrush = this.getCurrentBrush() === "custom";
      // Record the end point
      this.currentStrokeData.end = {
        x: _0x59374c,
        y: _0x1e768a,
        time: new Date().getTime(),
        brushOptions: this.getBrushOptions(),
        color: this.drawColor,
        layer: this.currentLayer  // Explicitly add layer to end point
      };
      if (isTextTool && this.textModeActive) {
        if (this.currentStrokeData.textPlacementPhase) {
          // Second click (placement phase): save only if nonempty text exists.
          if (capturedTextContent && capturedTextContent.trim() !== "") {
            this.currentStrokeData.textContent = capturedTextContent;
            this.currentStrokeData.finalTextEvent = {
              x: _0x59374c,
              y: _0x1e768a,
              time: new Date().getTime(),
              brushOptions: this.getBrushOptions(),
              layer: this.currentLayer  // Add layer to finalTextEvent
            };
            // Ensure the stroke itself has the layer
            this.currentStrokeData.layer = this.currentLayer;
            this.strokes.push(this.currentStrokeData);
            this.addPlaceholderTransfer()
          } else {

          }
          // Reset text mode so new text strokes can start fresh
          this.textModeActive = false;
          this.currentStrokeData = null;
        } else {
          // First penUp: mark that we're now waiting for a placement click
          this.currentStrokeData.textPlacementPhase = true;

        }
      } else if (this.getCurrentBrush() === "selection") {
        this.currentStrokeData.end = {
          x: _0x59374c,
          y: _0x1e768a,
          time: new Date().getTime(),
          brushOptions: this.getBrushOptions(),
          color: this.drawColor  // Add color to end point
        };
        
        // If the stroke has actions, save it
        if (this.currentStrokeData.hasActions) {
          this.strokes.push(this.currentStrokeData);
          this.addPlaceholderTransfer()
          // Reset after saving
          this.currentStrokeData = null;
        } else {
          // Keep the stroke for future actions

        }
      } else {
        // Regular (non-text, non-selection) tools
        this.currentStrokeData.end = {
          x: _0x59374c,
          y: _0x1e768a,
          time: new Date().getTime(),
          brushOptions: this.getBrushOptions(),
          color: this.drawColor  // Add color to end point
        };
        
        // CHECK FOR CUSTOM BRUSH WITHOUT IMAGE - skip if hadImageAtStart is false
        if (isCustomBrush && this.brushHandler.brush && this.brushHandler.brush.hadImageAtStart === false) {

          this.currentStrokeData = null;
          return;
        }
        
        this.strokes.push(this.currentStrokeData);
        this.addPlaceholderTransfer()
        this.currentStrokeData = null;
      }
    }
  }
  // CUSTOM: External pen up function
  if (typeof window.myPenUpCallback === "function") {
    window.myPenUpCallback(_0x59374c, _0x1e768a);
  }
}
["keyPress"](_0x2a6874) {
  const keyCode = _0x2a6874;
  const keyChar = String.fromCharCode(keyCode);


  // Continue original
  this.brushHandler.brush.onKeyPress(_0x2a6874);
  $(this).triggerHandler(new keyPressEvent(_0x2a6874).getEvent());

  // CUSTOM text-entry logic
  if (this.isMyself && !this.isReplaying) {
    const isTextTool = this.getCurrentBrush() === "text";
    if (isTextTool) {
      // If we are not actively in text mode but start typing, create a new text stroke
      if (!this.textModeActive) {

        this.textModeActive = true;

        // Similar to your penDown code for text stroke initialization:
        let newStrokeNumber;
        if (this.strokes.length === 0) {
          newStrokeNumber = 1;
          this.strokeCount = 1;
        } else {
          const existingNumbers = new Set(this.strokes.map(s => s.strokeNumber));
          newStrokeNumber = this.strokes.length + 1;
          while (existingNumbers.has(newStrokeNumber)) {
            newStrokeNumber++;
          }
          this.strokeCount = Math.max(this.strokeCount, newStrokeNumber);
        }

        this.currentStrokeData = {
          strokeNumber: newStrokeNumber,
          color: this.drawColor,
          brushName: "text",
          layer: this.currentLayer,
          isTextStroke: true,
          textStart: {
            x: 0, // Unknown until penDown
            y: 0,
            time: new Date().getTime(),
            brushOptions: this.getBrushOptions(),
          },
          keyEvents: [],
          textContent: "",
          finalTextEvent: null,
          start: {
            x: 0,
            y: 0,
            time: new Date().getTime(),
            brushOptions: this.getBrushOptions(),
            color: this.drawColor
          },
          moves: [],
          end: null,
          textPlacementPhase: false
        };
      }

      // Now record the key event
      if (this.currentStrokeData) {
        this.currentStrokeData.keyEvents.push({
          type: "keyPress",
          keyCode: keyCode,
          time: new Date().getTime()
        });

        // Small timeout to capture updated text
        setTimeout(() => {
          if (this.currentStrokeData && this.brushHandler.brush instanceof BrushTextModded) {
            const textContent = this.brushHandler.brush.getPlainText();
            if (textContent !== undefined) {
              this.currentStrokeData.textContent = textContent;

            }
          }
        }, 0);
      }
    }
  }
}

// Add a helper function to verify stroke integrity before finalizing
["_verifyStrokeBeforeSaving"](stroke) {
  if (!stroke) return false;
  
  // Make sure this stroke number is tracked
  if (stroke.strokeNumber && !this.textStrokeNumbers.has(stroke.strokeNumber)) {
    this.textStrokeNumbers.add(stroke.strokeNumber);
  }
  
  // Double check text content from brush if it's a text stroke
  if (stroke.isTextStroke && this.brushHandler.brush instanceof BrushTextModded) {
    const currentText = this.brushHandler.brush.getPlainText();
    if (currentText && currentText.trim() !== "") {
      stroke.textContent = currentText;
    }
  }
  
  return true;
}
["modifierDown"](_0x28b048) {
const keyCode = _0x28b048;
const keyChar = String.fromCharCode(keyCode);


// CUSTOM: Handle text tool recording
if (this.isMyself && !this.isReplaying) {
    const isTextTool = this.getCurrentBrush() === "text";
    
    // If text tool is selected but not active, the user is trying to type without clicking first
    if (isTextTool && !this.textModeActive) {
        // Auto-initialize a new text entry at the cursor position

        
        const cursorPos = { 
            x: this.cursor.x || 400, // Default to center if no cursor pos
            y: this.cursor.y || 300
        };
        
        // Start text entry
        this.textModeActive = true;
        if (!this.brushHandler.brush.enabled && this.textModeActive) {
          this.brushHandler.brush.enable();
        }
        this.textModeKeyEvents = [];
        this.textModeStartTime = new Date().getTime();
        this.textModeStartPoint = { x: cursorPos.x, y: cursorPos.y };
        
        // Create a new stroke
        this.currentStrokeData = {
            strokeNumber: ++this.strokeCount,
            color: this.drawColor,
            brushName: "text",
            layer: this.currentLayer,
            isTextStroke: true,
            textStart: {
                x: cursorPos.x,
                y: cursorPos.y,
                time: this.textModeStartTime,
                brushOptions: this.getBrushOptions()
            },
            keyEvents: [],
            textContent: "",
            finalTextEvent: null,
            start: {
                x: cursorPos.x,
                y: cursorPos.y,
                time: this.textModeStartTime,
                brushOptions: this.getBrushOptions()
            },
            moves: [],
            end: null
        };
        
        // Simulate penDown/penUp to initialize the text field
        this.penDown(cursorPos.x, cursorPos.y);
        this.penUp(cursorPos.x, cursorPos.y);
    }
    
    // Now record the modifier event if we're in text mode
    if (isTextTool && this.textModeActive && this.currentStrokeData) {
        this.currentStrokeData.keyEvents.push({
            type: 'modifierDown',
            keyCode: keyCode,
            time: new Date().getTime()
        });
        
        // If Enter key - might be completing text entry
        if (keyCode === 13) {
            setTimeout(() => {
                if (this.brushHandler.brush instanceof BrushTextModded) {
                    this.currentStrokeData.textContent = this.brushHandler.brush.getPlainText();
                }
            }, 0);
        }
    }
}

this["brushHandler"].brush["onModifierDown"](_0x28b048);
$(this)["triggerHandler"](new modifierDownEvent(_0x28b048)["getEvent"]());
}
["modifierUp"](_0x3561bd) {
if (this.isMyself && !this.isReplaying) {
    const isTextTool = this.getCurrentBrush() === "text";
    
    if (isTextTool && this.textModeActive && this.currentStrokeData) {
        this.currentStrokeData.keyEvents.push({
            type: 'modifierUp',
            keyCode: _0x3561bd,
            time: new Date().getTime()
        });

    }
}

this["brushHandler"]["brush"].onModifierUp(_0x3561bd);
$(this)["triggerHandler"](new modifierUpEvent(_0x3561bd).getEvent());
}
["setUserObject"](userObj) {
  this._userObj = userObj;
  
  // If the user object has a username, store it for the cursor too
  if (userObj && userObj.username && this.cursor) {
    this.cursor.setUsername(userObj.username);
  }
}
["setBrush"](_0x1857f8) {
  // Reset polygonal selection mode when switching away from selection tool
  if (
    this.isMyself && 
    this.getCurrentBrush() === "selection" && 
    _0x1857f8 !== "selection" &&
    this.brushHandler?.brush?.polygonPoints
  ) {
    // Reset all polygon-related properties
    this.polygonPoints = [];
    this.isAddingPolygonPoint = false;
    this.isClosingPolygon = false;
    this._lastPolygonalPenDownTime = null; // Reset double-click timer
    this._lastPolygonalPoint = null; // Reset double-click point
  }  
  // If switching away from text while an active text stroke exists, discard it.
  if (
    this.isMyself &&
    this.getCurrentBrush() === "text" &&
    _0x1857f8 !== "text" &&
    this.textModeActive &&
    this.currentStrokeData &&
    this.currentStrokeData.isTextStroke
  ) {

    this.lastEmptyTextStrokeNumber = this.currentStrokeData.strokeNumber;
    this.strokeCount--;
    this.textModeActive = false;
    this.currentStrokeData = null;
    this.textModeKeyEvents = [];
    this.textModeStartTime = null;
    this.textModeStartPoint = null;
  }

  // CUSTOM: Start recording selection tool activity  ensure sequential numbering
  if (this.isMyself && !this.isReplaying && _0x1857f8 === "selection" && this.getCurrentBrush() !== "selection") {

    
    // Initialize stroke counter if needed
    if (typeof this.strokeCount !== 'number') {
      this.strokeCount = 0;
    }
    
    // Create new sequential stroke number
    let newStrokeNumber;
    if (this.strokes.length === 0) {
      newStrokeNumber = 1;
      this.strokeCount = 1;

    } else {
      const existingNumbers = new Set(this.strokes.map(stroke => stroke.strokeNumber));
      newStrokeNumber = this.strokes.length + 1;
      while (existingNumbers.has(newStrokeNumber)) {
        newStrokeNumber++;
      }
      this.strokeCount = Math.max(this.strokeCount, newStrokeNumber);

    }
    
    this.currentStrokeData = {
      strokeNumber: newStrokeNumber,
      color: this.drawColor,
      brushName: "selection",
      layer: this.currentLayer,
      isSelectionStroke: true,
      hasActions: false, // Flag to track if this stroke gets actions
      start: {
        x: this.cursor?.x || 0,
        y: this.cursor?.y || 0,
        time: new Date().getTime(),
        brushOptions: this.getBrushOptions()
      },
      moves: [],
      selectionActions: [],
      uploadComplete: false,
      end: null
    };
    

  }

  // If the new brush differs from the current brush, handle the switch.
  if (this.brushHandler.currentBrush != _0x1857f8) {
    let wasPressed = false;
    if (this.penPressed) {
      // If pen is pressed, finish the stroke with a penUp call.
      this.penUp(this.stepFrom.x, this.stepFrom.y);
      wasPressed = true;
    }
    this.brushHandler.setBrush(_0x1857f8);
    $(this).triggerHandler(new brushChangedEvent(_0x1857f8).getEvent());
    if (wasPressed) {
      this.penDown(this.stepFrom.x, this.stepFrom.y);
    }
  }
}
["penCancel"]() {
  // CUSTOM BRUSH HANDLING - FIXED FOR PARAMETER CHANGES
  if (this.penPressed && this.isMyself && 
      this.brushHandler.currentBrush === "custom") {
  
    // Basic checks
    const customBrush = this.brushHandler.brush;
    const hasMoved = customBrush.hasMadeFirstMove === true;
    const hadImage = customBrush.hadImageAtStart === true;
    
    // Record if we have moves - but don't require this for parameter-only changes
    const hasRecordedMoves = this.currentStrokeData && 
                            this.currentStrokeData.moves && 
                            this.currentStrokeData.moves.length > 0;
    
    // Get both current and initial brush options for comparison
    const initialOptions = this.currentStrokeData?.start?.brushOptions || {};
    const currentOptions = this.getBrushOptions();
    
    // NEW: Check for parameter changes directly between start and current state
    // This works even without moves for click-and-change scenarios
    let hasSignificantChanges = false;
    const significantChanges = [];
    
    // Compare initial to current options - useful for no-move scenarios
    for (const key in currentOptions) {
      if (key !== 'rotationvalue' && initialOptions[key] !== currentOptions[key]) {
        hasSignificantChanges = true;
        significantChanges.push({
          param: key,
          from: initialOptions[key],
          to: currentOptions[key],
          type: 'direct-change'
        });
        }
    }
    
    // If we have moves, also check for changes throughout the stroke
    if (hasRecordedMoves && !hasSignificantChanges) {
      // Start with the initial brush options
      let previousOptions = {...initialOptions};
      
      // Look through each move for option changes
      for (let i = 0; i < this.currentStrokeData.moves.length; i++) {
        const move = this.currentStrokeData.moves[i];
        
        // Skip moves without brush options
        if (!move.brushOptions) continue;
        
        // Check each parameter for changes
        for (const key in move.brushOptions) {
          // Skip rotationvalue changes
          if (key === 'rotationvalue') continue;
          
          // If this parameter changed
          if (previousOptions[key] !== move.brushOptions[key]) {
            hasSignificantChanges = true;
            significantChanges.push({
              index: i,
              param: key,
              from: previousOptions[key],
              to: move.brushOptions[key],
              type: 'move-change'
            });
            }
        }
        
        // Update previous options for next comparison
        previousOptions = {...move.brushOptions};
      }
    }
    
    // IMPROVED: Save if we have significant changes AND an image - movement now optional
    if (this.currentStrokeData && hasSignificantChanges && hadImage) {
      // Ensure the stroke has a proper end point - use last move or cursor position
      if (!this.currentStrokeData.end) {
        if (hasRecordedMoves && this.currentStrokeData.moves.length > 0) {
          const lastMove = this.currentStrokeData.moves[this.currentStrokeData.moves.length - 1];
          this.currentStrokeData.end = {
            x: lastMove.x,
            y: lastMove.y,
            time: new Date().getTime(),
            brushOptions: currentOptions, // Use latest options
            color: this.currentStrokeData.color
          };
        } else {
          // For no movement - use start position but with updated options
          this.currentStrokeData.end = {
            x: this.currentStrokeData.start.x,
            y: this.currentStrokeData.start.y,
            time: new Date().getTime(),
            brushOptions: currentOptions, // Use latest options
            color: this.currentStrokeData.color
          };
        }
      }
      
      // Record the significant changes in the stroke for reference
      this.currentStrokeData.significantChanges = significantChanges;
      this.currentStrokeData.parameterChangeOnly = !hasMoved && hasSignificantChanges;
      
      // Add to strokes array BEFORE calling cancel
      this.strokes.push({...this.currentStrokeData});
      this.addPlaceholderTransfer()
      // Call the brush's cancel method to create undo entries
      customBrush.cancel();
    } else {
      let reason = "unknown reason";
      if (!hasSignificantChanges) reason = "no significant parameter changes";
      else if (!hadImage) reason = "no image at stroke start";
      
      // Just call cancel without saving
      customBrush.cancel();
    }
    
    // Clean up other state
    this.penPressed = false;
    $(this).triggerHandler(new penCancelEvent().getEvent());
    
    // Reset current stroke data
    this.currentStrokeData = null;
    
    return; // Exit the function early after proper handling
  }

// ERASER HANDLING - MODIFIED FOR PROPER CANCEL BEHAVIOR
if (this.penPressed && this.isMyself && 
  this.brushHandler.currentBrush === "eraser") {

const isMultilayerEraser = this.brushHandler.brush.getOption && 
                         this.brushHandler.brush.getOption("multilayer") === true;

// Get initial and current brush options
const initialOptions = this.currentStrokeData?.start?.brushOptions || {};
const currentOptions = this.getBrushOptions();

// Check for ANY brush option changes
let hasOptionChange = false;
const changedOptions = [];

for (const key in currentOptions) {
  if (initialOptions[key] !== currentOptions[key]) {
    hasOptionChange = true;
    changedOptions.push({
      option: key, 
      from: initialOptions[key], 
      to: currentOptions[key]
    });
  }
}

// Log information about the cancel action
const eraserType = isMultilayerEraser ? 'Multilayer' : 'Standard';
if (this.currentStrokeData) {
  // Get the current timestamp and cursor position at cancel time
  const cancelTime = new Date().getTime();
  const cancelX = this.cursor?.x || (this.currentStrokeData.start?.x || 0);
  const cancelY = this.cursor?.y || (this.currentStrokeData.start?.y || 0);
  
  // Check if we have moves to trim
  const hasRecordedMoves = this.currentStrokeData?.moves?.length > 0;
  
  // REMAKE THE STROKE: Remove any moves that might have occurred after the cancel
  // This is a safeguard, though typically all moves are already recorded
  if (hasRecordedMoves) {

    
    // Keep original moves array for reference
    this.currentStrokeData.originalMoves = [...this.currentStrokeData.moves];
    
    // Get the current time for comparison
    const now = cancelTime;
    
    // Filter out any moves that might have come after the cancel time
    // This is extra protection in case penMove events fire after cancel begins
    const trimmedMoves = this.currentStrokeData.moves.filter(move => 
      move.time <= now); 
    
    // Update moves array with trimmed version
    this.currentStrokeData.moves = trimmedMoves;
    
    if (trimmedMoves.length !== this.currentStrokeData.originalMoves.length) {
      }
  }
  
  // Save logic: ANY option change or no movement or multilayer
  const noMovement = !hasRecordedMoves || this.currentStrokeData.moves.length === 0;
  
  if (noMovement || isMultilayerEraser || hasOptionChange) {
    // Create appropriate log message
    let reason = noMovement ? "single-click" : 
                 isMultilayerEraser ? "multilayer eraser" : 
                 "brush option changes";
    
    // Set stroke end to the cancel position
    this.currentStrokeData.end = {
      x: cancelX,
      y: cancelY,
      time: cancelTime,
      brushOptions: currentOptions,
      isCancelPoint: true  // Mark this as the cancel point
    };
    
    // Add cancel metadata to the stroke
    this.currentStrokeData.wasCancelled = true;
    this.currentStrokeData.cancelTime = cancelTime;
    
    // Add option change info if any
    if (hasOptionChange) {
      this.currentStrokeData.optionChanges = changedOptions;
    }
    
    // Save the stroke
    this.strokes.push(JSON.parse(JSON.stringify(this.currentStrokeData))); // Clone to avoid reference issues
    this.addPlaceholderTransfer()
  } else {
    }
}

// Proceed with standard eraser cancellation 
this.penPressed = false;
this.brushHandler.brush.cancel();
$(this).triggerHandler(new penCancelEvent().getEvent());

// Reset current stroke data
this.currentStrokeData = null;
return;
}

  // SPECIAL EXCEPTION: For multilayer eraser, preserve the stroke before canceling
  if (this.penPressed && this.isMyself && 
      this.brushHandler.currentBrush === "eraser" && 
      this.brushHandler.brush.getOption && 
      this.brushHandler.brush.getOption("multilayer") === true) {
    
    // Save the current stroke data to strokes array before canceling
    if (this.currentStrokeData) {
      // Ensure the stroke has a proper end point
      if (!this.currentStrokeData.end && this.currentStrokeData.moves && this.currentStrokeData.moves.length > 0) {
        const lastMove = this.currentStrokeData.moves[this.currentStrokeData.moves.length - 1];
        this.currentStrokeData.end = {
          x: lastMove.x,
          y: lastMove.y,
          time: lastMove.time,
          brushOptions: lastMove.brushOptions || this.currentStrokeData.start.brushOptions
        };
      }
      
      // Add to strokes array
      this.strokes.push({...this.currentStrokeData});
      this.addPlaceholderTransfer()
      }
    
    // Now proceed with standard cancellation
    this.penPressed = false;
    this.brushHandler.brush.cancel();
    $(this).triggerHandler(new penCancelEvent().getEvent());
    
    // Reset current stroke data after cancellation
    this.currentStrokeData = null;
    return;
  }
  
  // SHAPE TOOLS HANDLING (rect, ellipse, line)
  // These tools have different behavior than stroke-based tools
  if (this.penPressed && this.isMyself && 
     (this.brushHandler.currentBrush === "rect" || 
      this.brushHandler.currentBrush === "ellipse" || 
      this.brushHandler.currentBrush === "line")) {
      
    // Unlike pen strokes, shapes don't have "partial" cancellation
    // They're either drawn completely or not at all
    this.penPressed = false;
    this.brushHandler.brush.cancel();
    $(this).triggerHandler(new penCancelEvent().getEvent());
    
    // Reset current stroke data
    this.currentStrokeData = null;
    return;
  }
  
  // Regular handling for pen/pencil based brushes
  if (this.penPressed && this.isMyself && this.currentStrokeData && 
      this.currentStrokeData.moves && this.currentStrokeData.moves.length > 0) {
    
    // CRITICAL FIX: Skip parameter check completely for custom brushes
    // This is a secondary safety check in case the first one doesn't catch it
    if (this.currentStrokeData.brushName === "custom") {
      this.penPressed = false;
      this.brushHandler.brush.cancel();
      $(this).triggerHandler(new penCancelEvent().getEvent());
      this.currentStrokeData = null;
      return;
    }
    
    // Variables to track parameter changes
    let lastParameterChangeIndex = -1;
    let moveBeforeLastChange = null;
    
    // Track which parameters changed and when
    let parameterChanges = [];
    
    // Compare each move's brush options against the previous move
    let previousOptions = this.currentStrokeData.start.brushOptions || {};
    
    // Find all parameter changes throughout the stroke
    for (let i = 0; i < this.currentStrokeData.moves.length; i++) {
      const move = this.currentStrokeData.moves[i];
      
      // Skip moves without brush options
      if (!move.brushOptions) continue;
      
      // Check for parameter changes
      const changedParams = [];
      for (const key in move.brushOptions) {
        if (previousOptions[key] !== move.brushOptions[key]) {
          changedParams.push({
            name: key,
            from: previousOptions[key],
            to: move.brushOptions[key]
          });
        }
      }
      
      if (changedParams.length > 0) {
        // Record this change point
        parameterChanges.push({
          index: i,
          move: move,
          params: changedParams
        });
        
        // Update our tracking of the last change
        lastParameterChangeIndex = i;
        // The move BEFORE the change is the last good one
        moveBeforeLastChange = i > 0 ? this.currentStrokeData.moves[i-1] : this.currentStrokeData.start;
        
        }
      
      // Update previous options for next comparison
      previousOptions = move.brushOptions;
    }
    
    // If we found parameter changes, keep everything up to but NOT including the last change
    // CRITICAL FIX: Add another check to prevent saving custom brush strokes
    if (lastParameterChangeIndex >= 0 && this.currentStrokeData.brushName !== "custom") {
      // Create a copy of the current stroke with just the moves up to BUT NOT INCLUDING the last parameter change
      const validStroke = {
        ...this.currentStrokeData,
        // Keep moves up to BUT NOT INCLUDING the last parameter change
        moves: lastParameterChangeIndex > 0 ? this.currentStrokeData.moves.slice(0, lastParameterChangeIndex) : [],
        // End at the move BEFORE the parameter change
        end: {
          x: moveBeforeLastChange.x,
          y: moveBeforeLastChange.y,
          time: moveBeforeLastChange.time,
          brushOptions: moveBeforeLastChange.brushOptions || this.currentStrokeData.start.brushOptions
        }
      };
      
      // Only save the stroke if there's something meaningful to save AND it's not a custom brush
      if ((validStroke.moves.length > 0 || 
          validStroke.brushName === 'line' || 
          validStroke.brushName === 'rect' || 
          validStroke.brushName === 'ellipse') && 
          validStroke.brushName !== 'custom') {
        
        // Add the valid part to strokes array
        this.strokes.push(validStroke);
        this.addPlaceholderTransfer()
        } else {
        }
      
      // Reset the current stroke
      this.currentStrokeData = null;
      this.penPressed = false;
      
      // Call original cancel behavior
      this.brushHandler.brush.cancel();
      $(this).triggerHandler(new penCancelEvent().getEvent());
      
      return; // Exit the function
    }
  }
  
  // Default behavior for normal cancellation
  if (this.penPressed || this.brushHandler.currentBrush == "text") {
    this.penPressed = false;
    this.brushHandler.brush.cancel();
    $(this).triggerHandler(new penCancelEvent().getEvent());
    
    // CRITICAL FIX: Always ensure custom brush strokes are completely removed
    if (this.currentStrokeData && 
        (this.currentStrokeData.brushName === "custom" || 
         this.brushHandler.currentBrush === "custom")) {
      this.currentStrokeData = null;
    }
  }
}
  ["penHide"]() {
    if (this["cursor"]["isVisible"]()) return this["cursor"].hide(), $(this)["triggerHandler"](new penHideEvent()["getEvent"]()), !this["penPressed"] && !this.brushHandler["brush"]["isUsingSlate"]() && !this["uploadMode"] && this["setSlateUse"](false), true;
    return false;
  }
  ["penShow"]() {
    if (!this.cursor["isVisible"]()) return this["cursor"]["show"](), $(this)["triggerHandler"](new penShowEvent().getEvent()), this["setSlateUse"](true), true;
    return false;
  }
  ["drawSilhouette"](_0x4ef618, _0xc059f0, _0x4a5d45, _0x404a0e, _0x4e036b = 0) {
    if (this["uploadMode"]) {
      // CUSTOM: Record silhouette data for selection tool
      if (this.isMyself && !this.isReplaying && 
          this.getCurrentBrush() === "selection" && 
          this.currentStrokeData?.isSelectionStroke) {

        this.currentStrokeData.selectionActions.push({
          type: 'silhouette',
          x: _0x4ef618,
          y: _0xc059f0,
          width: _0x4a5d45,
          height: _0x404a0e,
          rotation: _0x4e036b,
          time: new Date().getTime()
        });
      }
  
      var _0x57170c = this["cursor"]["graphic"]["find"](".uploadCanvasPreview");
      _0x57170c["length"] == 0 && (_0x57170c = $("<div />"), _0x57170c["addClass"]("uploadCanvasPreview"), _0x57170c["text"](this.cursor["label"].text()), this["cursor"]["graphic"].append(_0x57170c), this["cursor"]["graphic"]["addClass"]("uploading"));
      
      _0x57170c["css"]({
        width: _0x4a5d45,
        height: _0x404a0e,
        "transform-origin": "center center 0px",
        transform: "rotate(" + _0x4e036b + "deg)"
      });
      
      this["penMove"](_0x4ef618, _0xc059f0);
      $(this).triggerHandler(new silhouetteChangedEvent(_0x4ef618, _0xc059f0, _0x4a5d45, _0x404a0e, _0x4e036b)["getEvent"]());
    }
  }
  ["modifierClick"](_0x17856b) {
    this["modifierDown"](_0x17856b), this["modifierUp"](_0x17856b);
  }
  ["setUploadMode"](_0x4af005) {
    if (this["uploadMode"] != _0x4af005) {
      // CUSTOM: Record upload mode changes for selection tool
      if (this.isMyself && !this.isReplaying && 
          this.getCurrentBrush() === "selection" && 
          this.currentStrokeData?.isSelectionStroke) {
        

        
        // Record the upload mode change
        this.currentStrokeData.selectionActions.push({
          type: 'uploadMode',
          status: _0x4af005,
          time: new Date().getTime()
        });
        
        // CRITICAL FIX: When exiting upload mode, this is a signal that the operation completed
        if (this.uploadMode && !_0x4af005) {

          
          // Record that we applied the selection to the canvas
          this.currentStrokeData.selectionActions.push({
            type: 'applyToCanvas',
            time: new Date().getTime()
          });
          
          this.currentStrokeData.uploadComplete = true;
          this.currentStrokeData.end = {
            x: this.cursor?.x || 0,
            y: this.cursor?.y || 0,
            time: new Date().getTime(),
            brushOptions: this.getBrushOptions()
          };
          
          // CRITICAL FIX: If the stroke was canceled, don't save it
          if (this.currentStrokeData._canceled) {

          } else {
            // Check if it's in the pending array
            if (this._pendingSelectionStrokes) {
              const pendingIdx = this._pendingSelectionStrokes.findIndex(s => 
                s.strokeNumber === this.currentStrokeData.strokeNumber);
              
              if (pendingIdx >= 0) {
                // Move from pending to main strokes array - it's completed!
                const strokeToMove = this._pendingSelectionStrokes[pendingIdx];
                this._pendingSelectionStrokes.splice(pendingIdx, 1);
                
                this.strokes.push(strokeToMove);
                this.addPlaceholderTransfer()
              } else {
                // If not in pending, add directly to strokes
                this.strokes.push(this.currentStrokeData);
                this.addPlaceholderTransfer()
              }
            } else {
              // If no pending array, add directly to strokes
              this.strokes.push(this.currentStrokeData);
              this.addPlaceholderTransfer()
            }
            


          }
          
          // Reset current stroke data
          this.currentStrokeData = null;
        }
      }
  
      // Original code for handling upload mode UI
      if (!_0x4af005) {
        var _0x47c96b = this["cursor"].graphic.find(".uploadCanvasPreview");
        _0x47c96b["length"] > 0 && (this["cursor"]["graphic"].removeClass("uploading"), _0x47c96b["remove"]());
      }
      
      !this.penPressed && !this.brushHandler.brush["isUsingSlate"]() && !_0x4af005 && this["setSlateUse"](false);
      this["uploadMode"] = _0x4af005;
      $(this)["triggerHandler"](new uploadModeChangedEvent(_0x4af005)["getEvent"]());
    }
  }
// Updated brushParameter method with duplicate prevention
// Inside the brushParameter method, where action type is processed
["brushParameter"](_0x40cde3, _0x5a5aad = null) {
  this.polygonPoints = [];
  this.isAddingPolygonPoint = false;
  this.isClosingPolygon = false;
  this._lastPolygonalPenDownTime = null; // Reset double-click timer
  this._lastPolygonalPoint = null; // Reset double-click point

  _0x5a5aad == null && (_0x5a5aad = this["brushHandler"].currentBrush);
  
  // NEW IMPROVED: Record blend tool color information
  if (this.isMyself && !this.isReplaying && 
      (_0x5a5aad === "blend" || this.getCurrentBrush() === "blend") &&
      this.currentStrokeData && _0x40cde3.type === "plot" && _0x40cde3.color) {
    
    try {
      // Get current stroke data
      const blendStroke = this.currentStrokeData;
      
      // Make sure blendColors array exists
      if (!blendStroke.blendColors) {
        blendStroke.blendColors = [];
      }
      
      // Add this color point to the blend colors array
      blendStroke.blendColors.push({
        color: _0x40cde3.color,
        x: _0x40cde3.x,
        y: _0x40cde3.y,
        time: new Date().getTime()
      });
      
      // Flag the stroke as having blend colors
      blendStroke.hasBlendColors = true;
      
      // Also still store it in the move or start for compatibility
      if (!blendStroke.moves || blendStroke.moves.length === 0) {
        // First blend point, store in start
        if (!blendStroke.start) {
          blendStroke.start = {};
        }
        blendStroke.start.blendColor = _0x40cde3.color;
      } else if (blendStroke.moves.length > 0) {
        // Store in the latest move
        const lastMove = blendStroke.moves[blendStroke.moves.length - 1];
        lastMove.blendColor = _0x40cde3.color;
      }
      


    } catch (error) {

    }
  }
  
  // CUSTOM: Record selection tool actions 
  if (this.isMyself && !this.isReplaying && 
      (this.getCurrentBrush() === "selection" || _0x5a5aad === "selection") &&
      this.currentStrokeData) { // Only process if we have a current stroke
    
    // Get or create a selection stroke
    let selectionStroke = this.currentStrokeData;
    
    // Get action type
    const actionType = _0x40cde3.action || 'unknown';
    
    // Cancel handling
    if (actionType === 'cancel') {

      selectionStroke._canceled = true;
      this.currentStrokeData = null;
      
      // Continue with original function call
      this["brushHandler"]["brushes"][_0x5a5aad].onBrushParameter(_0x40cde3);
      $(this).triggerHandler(new brushParameterEvent(_0x5a5aad, _0x40cde3).getEvent());
      return;
    }
    
    // Record the action
    try {
      // Record this action in the current selection stroke with current color
      selectionStroke.selectionActions.push({
        type: 'action',
        action: actionType,
        parameters: JSON.parse(JSON.stringify(_0x40cde3)), // Deep copy to avoid reference issues
        time: new Date().getTime(),
        color: this.drawColor // Add current color at the time of action
      });
      
      // Mark that this stroke has actions - FIXED: Include ALL action types
      selectionStroke.hasActions = true;
      selectionStroke.finalAction = actionType; // Record final action type
      

    } catch (error) {

    }
    
    // For actions that should finalize the stroke
    if (actionType === 'clear' || actionType === 'apply' || 
        actionType === 'fill' || actionType === 'move' || actionType === 'clone') {      
      
      // Finalize the stroke
      selectionStroke.end = {
        x: this.cursor?.x || 0,
        y: this.cursor?.y || 0,
        time: new Date().getTime(),
        brushOptions: this.getBrushOptions(),
        color: this.drawColor // Add color to end point
      };
      
      // Mark as finalized
      selectionStroke.finalized = true;
      
      // Check if we should store it
      const shouldStore = selectionStroke.selectionActions && 
                        selectionStroke.selectionActions.length > 0 && 
                        selectionStroke.hasActions &&
                        !selectionStroke._canceled;
      
      // KEY CHANGE: Only store in pending array, never directly in strokes
      if (shouldStore) {
        // Create pending strokes array if it doesn't exist
        if (!this._pendingSelectionStrokes) {
          this._pendingSelectionStrokes = [];
        }
        
        // Store this stroke as pending until user confirms
        const existingPendingIdx = this._pendingSelectionStrokes.findIndex(
          s => s.strokeNumber === selectionStroke.strokeNumber
        );
        
        if (existingPendingIdx >= 0) {
          // Update existing pending stroke
          this._pendingSelectionStrokes[existingPendingIdx] = selectionStroke;
        } else {
          // Add as new pending stroke
          this._pendingSelectionStrokes.push(selectionStroke);
        }
        
        // NEW: For 'clear' and 'fill' actions, also directly save to final strokes
        // These actions don't need the uploadMode change confirmation
        if (actionType === 'clear' || actionType === 'fill') {
          // Copy the stroke directly to the main strokes array
          this.strokes.push(JSON.parse(JSON.stringify(selectionStroke)));
          this.addPlaceholderTransfer()
          }
      } else {
        // If we're not storing, free up the stroke number
        if (this.strokeCount >= selectionStroke.strokeNumber) {
          this.strokeCount--;

        }
      }
      
      // Reset current stroke for next operation
      this.currentStrokeData = null;
    }
  }
  
  // Original function call
  this["brushHandler"]["brushes"][_0x5a5aad].onBrushParameter(_0x40cde3);
  $(this).triggerHandler(new brushParameterEvent(_0x5a5aad, _0x40cde3).getEvent());
}
  ["getBrushSync"]() {
    return this["brushHandler"].brush.getSync();
  }
  ["setBrushSync"](_0x28b1e2) {
    this.brushHandler["brush"].setSync(_0x28b1e2);
  }
  ["getBrushesOptions"]() {
    return this["brushHandler"]["getBrushesOptions"]();
  }
  ["getBrushOptions"]() {
    return this.brushHandler["getOptions"]();
  }
  ["setBrushOptions"](_0x290e35) {
    var _0x5e9e3e = this;
    $["each"](_0x290e35, function (_0x2b696b, _0x353271) {
      var _0x332fc4 = _0x5e9e3e.brushHandler["getOption"](_0x2b696b);
      !matches(_0x332fc4, _0x353271) && (_0x5e9e3e["brushHandler"]["setOption"](_0x2b696b, _0x353271), $(_0x5e9e3e)["triggerHandler"](new brushOptionChangedEvent(_0x2b696b, _0x353271)["getEvent"]()));
    });
  }
  ["setBrushesOptions"](_0x3ebabd) {
    var _0x1f1bfa = this;
    $["each"](_0x3ebabd, function (_0x578a8a, _0x39ae6c) {
      $["each"](_0x39ae6c, function (_0x29a588, _0x5188da) {
        // Check if blur should be disabled based on localStorage
        if (_0x29a588 === "blur" && localStorage.getItem("disableBlur") === "true") {
          _0x5188da = 0;
        }
        var _0x26a009 = _0x1f1bfa["brushHandler"].getBrushOption(_0x578a8a, _0x29a588);
        !matches(_0x26a009, _0x5188da) && (_0x1f1bfa["brushHandler"].setBrushOption(_0x578a8a, _0x29a588, _0x5188da), _0x1f1bfa["brushHandler"]["currentBrush"] == _0x578a8a && $(_0x1f1bfa)["triggerHandler"](new brushOptionChangedEvent(_0x29a588, _0x5188da)["getEvent"]()));
      });
    });
  }
  ["hasBrushOption"](_0x4e80ad) {
    return this["brushHandler"]["hasOption"](_0x4e80ad);
  }
  ["isBrushOptionReadOnly"](_0x41efda) {
    return this.brushHandler.isOptionReadOnly(_0x41efda);
  }
  ["setBrushOptionReadOnlyModified"](_0xa3b88c, _0x1742ab) {
  }
  ["setBrushOptionReadOnly"](_0xa3b88c, _0x1742ab) {
    var _0x133865 = this["brushHandler"].setOptionReadOnly(_0xa3b88c, _0x1742ab);
    return $(this)["triggerHandler"](new brushOptionReadOnlyEvent(_0xa3b88c, _0x1742ab)["getEvent"]()), _0x133865;
  }
  ["getBrushOptionObject"](_0x4b77f8) {
    return this["brushHandler"].getOptionObject(_0x4b77f8);
  }
  ["getBrushOption"](_0x5d4d70) {
    return this["brushHandler"]["getOption"](_0x5d4d70);
  }
  ["setBrushOption"](_0x40439a, _0x1abc63) {
    // Check if blur should be disabled based on localStorage
    if (_0x40439a === "blur" && localStorage.getItem("disableBlur") === "true") {
      _0x1abc63 = 0;
    }
    
    // Reset polygon selection state when toggling polygonal selection
    if (_0x40439a === "polygonalselection") {
      this.polygonPoints = [];
      this.isAddingPolygonPoint = false;
      this.isClosingPolygon = false;
      this._lastPolygonalPenDownTime = null; // Reset double-click timer
      this._lastPolygonalPoint = null; // Reset double-click point
    }

    var _0x1e95ec = this.brushHandler["getOption"](_0x40439a);
    if (!matches(_0x1e95ec, _0x1abc63)) {
      if (_0x40439a == "size") {
        if (_0x1abc63 <= 0 || _0x1abc63 > this["maxSize"]) return;
      }
      this["brushHandler"].setOption(_0x40439a, _0x1abc63), $(this)["triggerHandler"](new brushOptionChangedEvent(_0x40439a, _0x1abc63)["getEvent"]());
    }
  }
  ["setColor"](_0x1532b2) {
    _0x1532b2["toUpperCase"]()["includes"]("NAN") && (_0x1532b2 = "#000000"), this.drawColor != _0x1532b2 && (this["brushHandler"]["brush"]["colorChange"](_0x1532b2), this["drawColor"] = _0x1532b2, this["brushHandler"]["brush"].colorChanged(_0x1532b2), $(this)["triggerHandler"](new colorChangedEvent(_0x1532b2).getEvent()));
  }
  ["setCurrentLayer"](_0x5e29dc) {
    _0x5e29dc = parseInt(_0x5e29dc), this["currentLayer"] != _0x5e29dc && (this["currentLayer"] = _0x5e29dc, this["setSlatePriority"](room.board.getLayerZIndex(_0x5e29dc) + 1), $(this)["triggerHandler"](new layerSelectedEvent(_0x5e29dc).getEvent()));
  }
  ["setSlatePriority"](_0x83b64a) {
    var _0x5eb077 = parseInt(this["slate"]["canvas"]["css"]("z-index"));
    _0x5eb077 != _0x83b64a && (this["slate"]["canvas"]["css"]("z-index", _0x83b64a), $(this)["triggerHandler"](new slatePriorityChangedEvent(_0x83b64a).getEvent()));
  }
  ["setSlateUse"](_0x15ed92) {
    this["slateInUse"] != _0x15ed92 && (this["slateInUse"] = _0x15ed92, _0x15ed92 ? this.slate["canvas"]["show"]() : this["slate"]["canvas"]["hide"](), $(this)["triggerHandler"](new slateUseChangedEvent(_0x15ed92).getEvent()));
  }
  ["clearSlate"]() {
    this.slate.clear();
  }
  ["userRequestAction"](_0x439a96, _0x796759) {
    $(this)["triggerHandler"](new userActionRequestEvent(_0x439a96, _0x796759).getEvent());
  }
  ["layerRequestAction"](_0x547a65, _0x10f798, _0x23c839 = null) {
    $(this)["triggerHandler"](new layerActionRequestEvent(_0x547a65, _0x10f798, _0x23c839).getEvent());
  }
  ["setUsername"](_0x332c86) {
    this["cursor"]["setUsername"](_0x332c86);
  }
  ["currentLayerContext"]() {
    return room["board"]["getContext"](this["currentLayer"]);
  }
  ["getCurrentBrush"]() {
    return this["brushHandler"].currentBrush;
  }
  ["getBrushShowPen"]() {
    return this["brushHandler"]["brush"].showPen;
  }
  ["getBrushDrawingTool"]() {
    return this.brushHandler["brush"]["drawingTool"];
  }
  ["delete"]() {
    this["cursor"]["delete"](), this["slate"]["remove"]();
  }
}
class Point {
  constructor(_0x392ee9, _0x204c2b) {
    this.x = _0x392ee9, this.y = _0x204c2b;
  }
}
class Size {
  constructor(_0x426efe, _0x71d64d) {
    this["width"] = _0x426efe, this["height"] = _0x71d64d;
  }
}
class Rect {
  constructor(_0x2102cd, _0x202302, _0xdaf523, _0x21464e) {
    this.x = _0x2102cd, this.y = _0x202302, this["width"] = _0xdaf523, this.height = _0x21464e;
  }
}
class ButtonType {
  constructor(_0x21b3d2, _0x47e6b4, _0x174c3e = "", _0x5f5048 = "") {
    this["name"] = _0x21b3d2, this.caption = _0x47e6b4, this["style"] = _0x174c3e, this["icon"] = _0x5f5048;
  }
}
class Room {
  constructor(_0x141cfd, _0x2c08c4, _0x2e5b89 = "L", _0x35f491 = 3, _0x386876 = "LG") {
    this.name = _0x2c08c4, this["type"] = _0x2e5b89, this["numLayers"] = _0x35f491, this.size = _0x386876, this.session = 0, this["description"] = "", this.privileges = {}, this["users"] = {}, this["myself"] = null, this["connected"] = false, this["loading"] = false, this["bans"] = {}, this["mutetime"] = 7200, this["bantime"] = 86400, this["password"] = "", this["mute"] = "N", this["knownproxy"] = "N", this.hidden = true, this["backgroundColor"] = "#FFFFFF", this.bottomTransparency = true, this["animRows"] = 3, this["animCols"] = 3, this["canvasWidth"] = 1280, this["canvasHeight"] = 720, this.transfers = new Array(), this["sizes"] = {}, this.sizes["1P"] = new Size(1, 1), this["sizes"].SM = new Size(640, 360), this["sizes"].MD = new Size(854, 480), this["sizes"].LG = new Size(1280, 720);
    
    // Check if extended board is enabled
    if (localStorage.getItem("extendedBoardByDefault") === "true") {
      this.sizes.XL = new Size(1920, 2160);  // Extended XL size
    } else {
      this.sizes.XL = new Size(1920, 1080);  // Default XL size
    }
    
    var _0x4d4604 = this["sizes"][_0x386876];
    this["board"] = new Board(_0x141cfd, _0x4d4604["width"], _0x4d4604["height"], 1, this["backgroundColor"], this["bottomTransparency"]), this["changeSize"](_0x386876, true), this["changeType"](_0x2e5b89, true), this["changeLayers"](_0x35f491, true);
  }
  ["createSession"]() {
    this["session"] = Math.floor(Math.random() * 999999 + 1);
  }
  ["change"](_0x1dc7a4) {
    if (this["name"] != _0x1dc7a4) {
      var _0xa089a6 = this["name"];
      this["name"] = _0x1dc7a4, $(this)["triggerHandler"](new roomChangedEvent(this["name"], _0xa089a6)["getEvent"]());
    }
  }
  ["changeSize"](_0x3931e2, _0x280f7d = false) {
    if (this.size != _0x3931e2 || _0x280f7d) {
      this["size"] = _0x3931e2;
      var _0x5b1fd8 = this["sizes"][_0x3931e2];
      this["board"]["changeSize"](_0x5b1fd8["width"], _0x5b1fd8["height"]);
    }
  }
  ["changeType"](_0x29d5d2, _0x571207 = false) {
    if (this["type"] != _0x29d5d2 || _0x571207) {
      var _0x396208 = this.type;
      this["type"] = _0x29d5d2, $(this)["triggerHandler"](new roomTypeChangedEvent(this["type"], _0x396208)["getEvent"]());
    }
  }
  ["changeLayers"](_0x375a09, _0x5071eb = false) {
    (this["numLayers"] != _0x375a09 || _0x5071eb) && (this.numLayers = _0x375a09, this["board"]["changeLayers"](_0x375a09));
  }
  ["changeTransparency"](_0x19f7f3) {
    this["bottomTransparency"] = Boolean(_0x19f7f3), this.board["changeTransparency"](Boolean(_0x19f7f3));
  }
  ["changeBackground"](_0x4746eb, _0x484982 = false) {
    this.backgroundColor = _0x4746eb, this.board.changeBackground(_0x4746eb, _0x484982);
  }
  ["changeAnimationOptions"](_0x38f697, _0x122a9d) {
    this["animRows"] = _0x38f697, this.animCols = _0x122a9d, $(this)["triggerHandler"](new animationFrameChangedEvent(_0x38f697, _0x122a9d).getEvent());
  }
  ["createMyself"](_0x17c583, _0x2b77f2 = "UU") {
    this["myself"] == null ? this.myself = new User(_0x17c583, _0x2b77f2, "", "", "", true) : (this.myself.username = _0x17c583, this.myself["rank"] = _0x2b77f2);
  }
  ["can"](_0x5053eb) {
    return this.privileges[_0x5053eb];
  }
  ["setConnected"](_0x5a804b) {

    var _0x312d60 = this;
    
    // Static flag to track if this is the first connection
    if (!this.constructor._hasInitiatedReplay && _0x5a804b) {
        this.constructor._hasInitiatedReplay = true;
        // Call the external replay function
        setupCombinedTransferSystem(); // Assuming this function exists elsewhere
        setupSelectionToolbarRecording();
        setupPolygonalSelectionShortcut();
    }
    
    this["connected"] = _0x5a804b, _0x5a804b ? $(this)["triggerHandler"](new roomConnectedEvent(this["name"], this["type"], this["description"])["getEvent"]()) : $(this).triggerHandler(new roomDisconnectedEvent(this["name"], this["type"], this["description"])["getEvent"]());
  }
  ["addUser"](_0xd7a062, _0x526680 = false) {
    !this["users"] && (this["users"] = {});
    this["users"][_0xd7a062["username"]] = _0xd7a062;
    var _0x4d1516 = this;
    $(_0xd7a062).on("usernameChanged.userEvents", function (_0x2c320b) {
      $(_0x4d1516)["triggerHandler"](new usernameChangedEvent(_0x2c320b.newname, _0x2c320b["oldname"])["getEvent"]());
    }), $(this)["triggerHandler"](new userJoinedEvent(_0xd7a062.username, _0x526680)["getEvent"]());
  }
  ["removeUser"](_0x501a19, _0x11954d = null) {
    this["users"][_0x501a19] && ($(this).triggerHandler(new userLeavingEvent(_0x501a19, _0x11954d)["getEvent"]()), this.users[_0x501a19]["surface"]["delete"](), $(this["users"][_0x501a19])["off"](".userEvents"), delete this.users[_0x501a19], $(this)["triggerHandler"](new userLeftEvent(_0x501a19, _0x11954d)["getEvent"]()));
  }
  ["kickUser"](_0x12827d) {
    this["isMyself"](_0x12827d) ? (socket["disconnect"](true), $(this["myself"])["triggerHandler"](new userUnwantedEvent("kick").getEvent())) : this["removeUser"](_0x12827d, "KICK");
  }
  ["banUser"](_0xe25993) {
    this["isMyself"](_0xe25993) ? (socket["disconnect"](true), $(this["myself"])["triggerHandler"](new userUnwantedEvent("ban")["getEvent"]())) : this["removeUser"](_0xe25993, "BAN");
  }
  ["connectionIssues"](_0x313ed4, _0x21fbe7) {
    this["users"][_0x313ed4] && this["users"][_0x313ed4]["changeConnectionIssue"](_0x21fbe7);
  }
  ["banList"](_0x97a382) {
    this.bans = _0x97a382;
  }
  ["muteUser"](_0x41ccb2, _0x541241 = 0) {
    this["isMyself"](_0x41ccb2) ? (this["myself"].mute(), $(this)["triggerHandler"](new muteTimerStartedEvent(_0x541241)["getEvent"]())) : this.users[_0x41ccb2]["mute"]();
  }
  ["unmuteUser"](_0x3a8a79) {
    this["isMyself"](_0x3a8a79) ? this["myself"]["unmute"]() : this.users[_0x3a8a79]["unmute"]();
  }
  ["silenceUser"](_0x29aac3) {
    this["isMyself"](_0x29aac3) ? this["myself"]["silence"]() : this.users[_0x29aac3]["silence"]();
  }
  ["unsilenceUser"](_0xf91c3a) {
    this["isMyself"](_0xf91c3a) ? this["myself"]["unsilence"]() : this["users"][_0xf91c3a]["unsilence"]();
  }
  ["ignoreUser"](_0x31f791) {
    this["userExists"](_0x31f791) && (this.users[_0x31f791]["ignore"](), $(this)["triggerHandler"](new userIgnoredEvent(_0x31f791).getEvent()));
  }
  ["unignoreUser"](_0x2a977c) {
    this["userExists"](_0x2a977c) && (this["users"][_0x2a977c]["unignore"](), $(this)["triggerHandler"](new userUnignoredEvent(_0x2a977c)["getEvent"]()));
  }
  ["toggleIgnoreUser"](_0x53a4b7) {
    this["userExists"](_0x53a4b7) && (!this["users"][_0x53a4b7]["ignored"] ? this.ignoreUser(_0x53a4b7) : this.unignoreUser(_0x53a4b7));
  }
  ["userExists"](_0x2f398f) {
    return _0x2f398f in this["users"];
  }
  ["changeUsername"](_0x355b60, _0x682520) {
    if (!this["isMyself"](_0x355b60)) {
      this["users"][_0x355b60]["changeUsername"](_0x682520);
      var _0x470828 = this["users"][_0x355b60];
      delete this["users"][_0x355b60], this["users"][_0x682520] = _0x470828;
    }
  }
  ["rankUser"](_0x315ae4, _0x27c2f3) {
    !this["isMyself"](_0x315ae4) && this.users[_0x315ae4].changeRank(_0x27c2f3);
  }
  ["setPrivileges"](_0x3a3077) {
    this["privileges"] = _0x3a3077, $(this)["triggerHandler"](new roomPrivilegesChangedEvent(_0x3a3077)["getEvent"]());
  }
  ["setTools"](_0x44c5c0) {
    this["tools"] = _0x44c5c0, $(this).triggerHandler(new roomToolsChangedEvent(_0x44c5c0)["getEvent"]());
  }
  ["isMyself"](_0x501010) {
    if (!this.users[_0x501010] && this["myself"]["username"] == _0x501010) return true;
    return false;
  }
  ["addTransfer"](_0x361c14) {
    _0x361c14["ttype"] == "sync" && !_0x361c14.sending && this["cancelTransfers"]("sync", false), this["transfers"]["push"](_0x361c14);
  }
  ["getTransferId"](_0x54fc4c, _0x4fa56e, _0x5cfc93) {
    var _0x36b483 = null;
    return $["each"](this.transfers, function (_0x1b036a, _0x4b4918) {
      _0x4b4918["matches"](_0x54fc4c, _0x4fa56e, _0x5cfc93) && (_0x36b483 = _0x1b036a);
    }), _0x36b483;
  }
  ["findTransfer"](_0x91c35b, _0x5f4940, _0x3042e7, _0x48b3f2) {
    var _0x15c7cc = null;
    return $["each"](this["transfers"], function (_0x1876f4, _0x1085fc) {
      _0x1085fc["matches"](_0x91c35b, _0x5f4940, _0x3042e7, _0x48b3f2) && (_0x15c7cc = _0x1085fc);
    }), _0x15c7cc;
  }
  ["deleteTransfer"](_0x266b8a, _0x4993bc, _0x582b36) {
    var _0x3c9340 = this["getTransferId"](_0x266b8a, _0x4993bc, _0x582b36);
    _0x3c9340 != null && room["transfers"]["splice"](_0x3c9340, 1);
  }
  ["cancelTransfers"](_0x21a8da = "*", _0x1b91ff = "*") {
    var _0x132e13 = this;
    $["each"](this["transfers"], function (_0x1ac61c, _0x3d283e) {
      (_0x21a8da == "*" || _0x3d283e["ttype"] == _0x21a8da) && (_0x1b91ff == "*" || _0x3d283e["sending"] == _0x1b91ff) && _0x132e13["deleteTransfer"](_0x3d283e.username, _0x3d283e["type"], _0x3d283e["timestamp"]);
    }), this["transfers"] = new Array();
  }
  ["userRenamed"](_0x24d786, _0x3a45cd, _0x5ab94f, _0x177f86) {
    this["changeUsername"](_0x3a45cd, _0x177f86), this.rankUser(_0x177f86, _0x5ab94f), $(this).triggerHandler(new userRenamedEvent(_0x24d786, _0x3a45cd, _0x5ab94f, _0x177f86).getEvent());
  }
  ["leave"]() {
    var _0x2b4a9f = this;
    $["each"](this["users"], function (_0xd2686b, _0x2df69d) {
      _0x2b4a9f.removeUser(_0xd2686b);
    }), this["cancelTransfers"](), this["setConnected"](false), this["board"]["clearLayers"](), $(this)["triggerHandler"](new youLeftEvent(this["myself"]["username"], this.name)["getEvent"]());
  }
}

var dc_boardpos_x = UI?.viewLeft - UI?.drawingArea.offset().left
var dc_boardpos_y = UI?.viewTop - UI?.drawingArea.offset().top
var dc_zoom = room?.board?.scale
var dc_color = room?.myself?.surface?.drawColor
var dc_tool = room?.myself?.surface?.getCurrentBrush()
var dc_tool_settings = room?.myself?.surface?.getBrushOptions()

const UserStateManager = {
  userPositions: new Map(),
  penStates: new Map(),
  speedHistory: new Map(), // New map to store speed records: array of { time, distance }
  originalRanks: new Map(),
  lastDrawTime: new Map(),

  setPenState(user, isDown) {
    this.penStates.set(user, isDown);
  },

  updatePosition(user, newPos) {
    const now = Date.now();
    if (this.userPositions.has(user)) {
      const lastPos = this.userPositions.get(user);
      const distance = Math.sqrt(
        Math.pow(newPos.x - lastPos.x, 2) +
        Math.pow(newPos.y - lastPos.y, 2)
      );
      if (this.penStates.get(user) === true) {
        if (!this.speedHistory.has(user)) {
          this.speedHistory.set(user, []);
        }
        // Record new speed sample.
        this.speedHistory.get(user).push({ time: now, distance });
      }
    }
    this.userPositions.set(user, newPos);
  },

  // Clean old entries from speed history (older than 500ms)
  cleanSpeedHistory(user, currentTime) {
    if (!this.speedHistory.has(user)) return;
    const records = this.speedHistory.get(user);
    // Keep only records within the last 500ms.
    this.speedHistory.set(user, records.filter(rec => currentTime - rec.time <= 500));
  }
};


class Socket {
  constructor(_0x3f70ff) {
    this.tm = null, this["secPing"] = 30, this["secTimeout"] = 30, this.intervalPing = null, this["canReconnect"] = true, this.ws = null, this["URL"] = _0x3f70ff, this["outBuffer"] = new Array(), this["outPending"] = new Array(), this["connected"] = false, this.encryption = "none", this["negotiated"] = false, this["firstResponse"] = false, this["supportedEncryptions"] = new Array("rot13", "none"), this["flag"] = null, this["connect"]();
    this.activeTransfers = new Set(); // Tracks currently in-progress transfers
    this.transferChunksInProgress = new Map(); // Track chunks per transfer
    this.isTransferInProgress = false; // NEW: Global flag for active transfers
  }
  ["connect"]() {
    var _0xa47ba9 = this;
    this.ws && (this.ws["onopen"] = null, this.ws.onerror = null, this.ws["onclose"] = null, this.ws["onmessage"] = null, this.ws["close"]()), this.ws = new WebSocket(this["URL"]), this.ws["onopen"] = function () {
      $(_0xa47ba9)["triggerHandler"](new socketConnectedEvent()["getEvent"]()), _0xa47ba9.connected = true, _0xa47ba9["IntervalPing"] && clearTimeout(_0xa47ba9["intervalPing"]), _0xa47ba9.intervalPing = setInterval(function () {
        _0xa47ba9["ping"]();
      }, _0xa47ba9["secPing"] * 1e3);
    }, this.ws.onerror = function (_0x1c181c) {
      clearInterval(_0xa47ba9["intervalPing"]), _0xa47ba9["disconnect"](), $(_0xa47ba9)["triggerHandler"](new socketErrorEvent(_0xa47ba9["firstResponse"])["getEvent"]());
    }, this.ws["onclose"] = function () {
      clearInterval(_0xa47ba9.intervalPing), _0xa47ba9.disconnect();
    }, this.ws["onmessage"] = function (_0x4f7d3b) {
      _0xa47ba9["receive"](_0x4f7d3b);
    };
  }
  ["disconnect"](_0x1c426d = false) {
    socket.isTransferInProgress = false;
    UI.firstSyncEnabled = true
    this["encryption"] = "none", $(this)["triggerHandler"](new socketDisconnectedEvent(_0x1c426d, room && room.connected)["getEvent"]()), this.connected = false, this.setNegotiated(false), this["firstResponse"] = false, clearTimeout(this["intervalPing"]);
    dc_boardpos_x = UI?.viewLeft - UI?.drawingArea.offset().left
    dc_boardpos_y = UI?.viewTop - UI?.drawingArea.offset().top
    dc_zoom = room?.board?.scale
    dc_color = room?.myself?.surface?.drawColor
    dc_tool = room?.myself?.surface?.getCurrentBrush()
    dc_tool_settings = room?.myself?.surface?.getBrushOptions()
    UI.recommendedSync()
  }
  ["ping"]() {
    var _0x3ad465 = this;
    if (UI.inRoom) {
      var _0x4d904d = {};
      _0x4d904d["command"] = "PROTOCOL", _0x4d904d.option = "PING", _0x4d904d["time"] = new Date()["getTime"]() / 1e3, this["send"](_0x4d904d, true);
    }
    this["clearTimeout"](), this.tm = setTimeout(function () {
      _0x3ad465.timeout();
    }, _0x3ad465["secTimeout"] * 1e3);
  }
  ["pong"](_0x46eb70) {
    this["clearTimeout"]();
    if (UI.inRoom) {
      var _0x5c72d2 = {};
      _0x5c72d2["command"] = "PROTOCOL", _0x5c72d2["option"] = "PONG", _0x5c72d2["ping"] = _0x46eb70, this["send"](_0x5c72d2, true);
    }
  }
  ["timeout"]() {
    this["disconnect"]();
  }
  ["clearTimeout"]() {
    this.tm && clearTimeout(this.tm);
  }
  ["reconnect"]() {
    !this.connected && this["canReconnect"] && this["connect"]();
  }
  ["setNegotiated"](_0x365d88) {
    if (this["negotiated"] != _0x365d88) {
      this["negotiated"] = _0x365d88;
      if (_0x365d88) {
        $(this)["triggerHandler"](new socketNegotiatedEvent()["getEvent"]());
        while (this["outPending"]["length"] > 0) {
          this.send(this["outPending"].shift());
        }
      }
    }
  }
  ["send"](_0x2f8243, _0x421fd1 = false, _0x1dbf16 = false) {
    // console.log('Data sent:', _0x2f8243)
    if (_0x2f8243 && typeof _0x2f8243 === 'object') {
      // Check if this is a transfer chunk
      if (_0x2f8243.command === 'IMG' && _0x2f8243.action === 'PARTIAL') {
        // Track all active layer transfers
        if (!window._layerTransfers) {
          window._layerTransfers = {}; 
        }
        
        // Create unique ID for this transfer (combination of timestamp and layer)
        const transferId = `${_0x2f8243.timestamp}_${_0x2f8243.layer}`;
        
        // Initialize tracking for this transfer if it's the first chunk
        if (_0x2f8243.position === 1) {

          
          this.isTransferInProgress = true;

          // Track this layer transfer
          window._layerTransfers[transferId] = {
            layer: _0x2f8243.layer,
            maxLayer: _0x2f8243.layerCount,
            chunks: _0x2f8243.max,
            timestamp: _0x2f8243.timestamp,
            completed: false
          };
          
          // Create a progress bar in the UI if it doesn't exist
          if (!document.querySelector('.transfer-progress')) {
            const progressBar = document.createElement('div');
            progressBar.className = 'transfer-progress';
            progressBar.innerHTML = '<div class="progress-inner"></div><div class="progress-text">0%</div>';
            progressBar.style.position = 'fixed';
            progressBar.style.bottom = '0';
            progressBar.style.left = '0';
            progressBar.style.width = '100%';
            progressBar.style.height = '4px';
            progressBar.style.backgroundColor = 'rgba(0,0,0,0.2)';
            progressBar.style.zIndex = '9999';
            
            const inner = progressBar.querySelector('.progress-inner');
            inner.style.backgroundColor = '#0078d7'; // Blue color
            inner.style.height = '100%';
            inner.style.width = '0%';
            inner.style.transition = 'width 0.2s';
            
            const text = progressBar.querySelector('.progress-text');
            text.style.position = 'absolute';
            text.style.right = '10px';
            text.style.top = '-20px';
            text.style.fontSize = '12px';
            text.style.color = '#0078d7';
            
            document.body.appendChild(progressBar);
          }
        }
        
        // Calculate overall progress across all layers
        const currentTransfer = window._layerTransfers[transferId];
        if (currentTransfer) {
          // Update this layer's progress
          const layerProgress = _0x2f8243.position / _0x2f8243.max;
          
          // Mark as completed if this is the final chunk for this layer
          if (_0x2f8243.position === _0x2f8243.max) {
            currentTransfer.completed = true;

          }
          
          // Calculate the total progress across all tracked layers
          let totalLayers = 0;
          let completedLayers = 0;
          let partialProgress = 0;
          
          for (const id in window._layerTransfers) {
            const transfer = window._layerTransfers[id];
            if (transfer.timestamp === _0x2f8243.timestamp) {
              totalLayers++;
              if (transfer.completed) {
                completedLayers++;
                partialProgress += 1; // 100% for completed layers
              } else if (id === transferId) {
                partialProgress += layerProgress; // Partial progress for current layer
              }
            }
          }
          
          const overallProgress = totalLayers > 0 ? partialProgress / Math.max(totalLayers, _0x2f8243.layerCount) : 0;
          const progressPercent = Math.min(overallProgress * 100, 100);
          
          // Update the progress bar
          const progressBar = document.querySelector('.transfer-progress');
          if (progressBar) {
            const inner = progressBar.querySelector('.progress-inner');
            inner.style.width = `${progressPercent}%`;
            
            const text = progressBar.querySelector('.progress-text');
            text.textContent = `${Math.round(progressPercent)}% - Layer ${_0x2f8243.layer}/${_0x2f8243.layerCount}`;
          }
          
          // Check if this is the final chunk of the final layer
          const isLastLayer = _0x2f8243.layer === _0x2f8243.layerCount;
          const isLastChunk = _0x2f8243.position === _0x2f8243.max;
          
          if (isLastLayer && isLastChunk) {

            
            // Create a custom event with data for better debugging
            const eventData = {
              timestamp: Date.now(),
              originalTimestamp: _0x2f8243.timestamp,
              totalLayers: _0x2f8243.layerCount,
              details: _0x2f8243
            };
            

            // Schedule the transfer flag reset after 2 seconds

            setTimeout(() => {
              this.isTransferInProgress = false;

            }, 2000);
            // Fire the event immediately
            try {
              // Trigger the event with additional data

              $(document).trigger("transferComplete", [eventData]);

            } catch (err) {

            }
            
            // Clear the tracking for this timestamp
            for (const id in window._layerTransfers) {
              if (window._layerTransfers[id].timestamp === _0x2f8243.timestamp) {
                delete window._layerTransfers[id];
              }
            }
            
            // Remove the progress bar after a delay
            setTimeout(() => {
              const progressBar = document.querySelector('.transfer-progress');
              if (progressBar) {
                progressBar.style.opacity = '0';
                setTimeout(() => progressBar.remove(), 500);
              }
            }, 600);
          } else if (completedLayers >= _0x2f8243.layerCount) {
            // ADDITIONAL CHECK: If all layers are complete but the event wasn't triggered yet

            
            const eventData = {
              timestamp: Date.now(),
              originalTimestamp: _0x2f8243.timestamp,
              totalLayers: _0x2f8243.layerCount,
              details: _0x2f8243,
              triggerMethod: "secondary-check"
            };
            

            $(document).trigger("transferComplete", [eventData]);

            
            // FIX: Set flag to false after a 2-second delay instead of immediately

            setTimeout(() => {
              this.isTransferInProgress = false;

            }, 2000);
            // Clear the tracking for this timestamp
            for (const id in window._layerTransfers) {
              if (window._layerTransfers[id].timestamp === _0x2f8243.timestamp) {
                delete window._layerTransfers[id];
              }
            }
            
            // Remove the progress bar after a delay
            setTimeout(() => {
              const progressBar = document.querySelector('.transfer-progress');
              if (progressBar) {
                progressBar.style.opacity = '0';
                setTimeout(() => progressBar.remove(), 500);
              }
            }, 600);
          } else if (isLastChunk) {

          } else {

          }
        }
      }
    }
    // Rest of the method remains unchanged
    _0x2f8243 !== undefined && (!this.connected && this["reconnect"](), _0x421fd1 && (_0x2f8243 = JSON["stringify"](_0x2f8243)), this.negotiated || _0x1dbf16 ? (_0x2f8243 = encryptMessage(_0x2f8243, this["encryption"]), this.outBuffer["push"](_0x2f8243)) : this["outPending"]["push"](_0x2f8243));
}
// Update the receive method to properly handle all transfer completions
["checkSelectionTransferCompletion"](selectionTransferId) {
  if (!this.selectionTransfers || !this.selectionTransfers.has(selectionTransferId)) {
    return;
  }
  
  const transferInfo = this.selectionTransfers.get(selectionTransferId);
  
  // If we have a timeout scheduled, clear it
  if (transferInfo.completionTimeout) {
    clearTimeout(transferInfo.completionTimeout);
    transferInfo.completionTimeout = null;
  }
  
  // Check if we should process completion now
  const enoughChunksReceived = transferInfo.expectedChunks ? 
      (transferInfo.receivedChunks >= transferInfo.expectedChunks) : 
      (transferInfo.receivedChunks > 0);
      
  const inactiveForTooLong = (Date.now() - transferInfo.lastActivity) > 2000;
  
  if (transferInfo.manuallyCompleted && (enoughChunksReceived || inactiveForTooLong)) {

    
    // Process the stored completion message or create a synthetic one
    const completionMessage = transferInfo.pendingCompletionMessage || {
      command: 'RESPONSE',
      action: 'OK',
      context: `stroke-${transferInfo.strokeId}`,
      _isCompletionMessage: true,
      _selectionTransferComplete: true
    };
    
    // Mark as fully completed
    transferInfo.isCompleted = true;
    
    // Re-trigger the receive method with this message to properly complete the transfer
    if (completionMessage) {
      // Remove the skip flag so it will be processed
      delete completionMessage._skipCompletionProcessing;
      
      // Create a synthetic websocket message
      const syntheticMessage = {
        data: JSON.stringify(completionMessage)
      };
      

      this.receive(syntheticMessage);
    }
  } else if (!transferInfo.completionTimeout) {
    // If we didn't complete but cleared the timeout, reschedule it

    
    transferInfo.completionTimeout = setTimeout(() => {
      this.checkSelectionTransferCompletion(selectionTransferId);
    }, 3000);
  }
}
["receive"](_0x159026) {
  var _0x5a28fe = this,
  _0x5b8390 = $.parseJSON(decryptMessage(_0x159026.data, this.encryption));
      // console.log('RECIEVING:')
      // console.log(_0x5b8390)

      // Check if undo history is enabled
      const undoHistoryEnabled = UI?.undoHistoryEnabled

      // Get current username for consistent use
      const currentUsername = room?.myself?.username;
      const isFromCurrentUser = 
          (_0x5b8390?.from === currentUsername) || 
          (_0x5b8390?.source === currentUsername);
      
      // SELECTION FIX: Check if this is a selection operation transfer to handle specially
      const isSelectionOperation = 
          (_0x5b8390?.selectionOperation === true) ||
          (_0x5b8390?.uploadType === 'selection') || 
          (_0x5b8390?.type === 'selection');
          
      // CRITICAL FIX: Create transfer ID earlier for more accurate logging
      let transferId = _0x5b8390.session;
      if (!transferId && _0x5b8390) {
        if (_0x5b8390.command === 'IMG') {
          transferId = `img-${_0x5b8390.timestamp || Date.now()}-${_0x5b8390.layer || 0}`;
          
          // SELECTION FIX: Mark selection operation transfers specially
          if (isSelectionOperation && _0x5b8390.strokeId) {
            transferId = `selection-img-${_0x5b8390.timestamp || Date.now()}-stroke-${_0x5b8390.strokeId}`;
          }
        } else if (_0x5b8390.command === 'DIRECT') {
          transferId = `direct-${_0x5b8390.timestamp || Date.now()}-${_0x5b8390.from || ''}-${_0x5b8390.to || ''}`;
          
          // SELECTION FIX: Mark selection operation transfers specially
          if (isSelectionOperation && _0x5b8390.strokeId) {
            transferId = `selection-direct-${_0x5b8390.timestamp || Date.now()}-stroke-${_0x5b8390.strokeId}`;
          }
        } else if (_0x5b8390.command === 'RESPONSE' && _0x5b8390.context?.startsWith('stroke-')) {
          // Create meaningful IDs for stroke response messages
          transferId = `stroke-response-${_0x5b8390.context || Date.now()}`;
        }
      }
      
      // CRITICAL FIX: More robust check for completion messages
      const isCompletionMessage = 
          (_0x5b8390?.command === 'IMG' && _0x5b8390?.action === 'COMPLETE') ||
          (_0x5b8390?.command === 'DIRECT' && _0x5b8390?.action === 'APPLY') ||
          // Add more specific pattern matching for completion responses
          (_0x5b8390?.command === 'RESPONSE' && _0x5b8390?.action === 'OK' && 
           _0x5b8390?.context && _0x5b8390?.context.includes('stroke-')) ||
          // Additional patterns that might indicate completion
          (_0x5b8390?.command === 'RESPONSE' && _0x5b8390?.action === 'OK' && 
           _0x5b8390?.transferComplete === true);
      
      // CRITICAL FIX: Check if this is a selection/move message that should be allowed through
      const isSelectionRelated = 
          (_0x5b8390?.type === 'selection') || 
          (_0x5b8390?.uploadType === 'selection') ||
          (_0x5b8390?.action === 'COMPLETE' && transferId && transferId.includes('selection')) ||
          (_0x5b8390?.source === 'selection') ||
          (_0x5b8390?.selectionId != null) ||
          isSelectionOperation;
      // CRITICAL FIX 1: Pre-filter check - immediately drop own IMG/DIRECT messages with undo history
      // BUT allow selection-related messages and completion messages
      if (isFromCurrentUser && (_0x5b8390.command === 'IMG' || _0x5b8390.command === 'DIRECT')) {
        if (undoHistoryEnabled) {
            // When undo history is enabled
            if (true) {
                

                return; // Drop our own transfer messages
            }
        } else {
            // When undo history is disabled
            if (!isSelectionRelated && !isCompletionMessage && 
                room?.board?.needToUnblockMessagesWhenComplete === true) {
                

                return; // Drop our own transfer messages
            }
        }
    }
      
      // SELECTION FIX: Start tracking preparation messages for selection operations
      if (isSelectionOperation && 
          ((_0x5b8390.command === 'IMG' && _0x5b8390.action === 'PREPARE') ||
           (_0x5b8390.command === 'DIRECT' && _0x5b8390.action === 'PREPARE'))) {
           
        // Initialize selection transfers tracking if needed
        if (!this.selectionTransfers) {
          this.selectionTransfers = new Map();
        }
        
        // Generate a tracking ID
        const strokeId = _0x5b8390.strokeId || 
                         (_0x5b8390.context ? parseInt(_0x5b8390.context.match(/stroke-(\d+)/)?.[1]) : null);
        
        if (strokeId) {
          const selectionTransferId = `selection-stroke-${strokeId}`;
          

          
          this.selectionTransfers.set(selectionTransferId, {
            startTime: Date.now(),
            strokeId: strokeId,
            transferId: transferId,
            expectedChunks: _0x5b8390.totalChunks || _0x5b8390.parts || 0,
            receivedChunks: 0,
            isCompleted: false,
            manuallyCompleted: false,
            lastActivity: Date.now()
          });
          
          // Store reference on message for future chunk tracking
          _0x5b8390._selectionTransferId = selectionTransferId;
        }
      }
      
      // CRITICAL FIX: Better handling for completion messages 
      if (isCompletionMessage) {
          // Extract stroke ID from context field if present (for RESPONSE messages)
          if (_0x5b8390?.context) {
              const contextMatch = _0x5b8390.context.match(/stroke-(\d+)/);
              if (contextMatch && contextMatch[1]) {
                  const strokeId = parseInt(contextMatch[1]);
                  if (!isNaN(strokeId)) {
                      // Create a synthetic transfer ID for stroke completion
                      transferId = `stroke-${strokeId}-complete`;

                      
                      // SELECTION FIX: Mark the selection transfer as manually completed
                      if (this.selectionTransfers) {
                          const selectionTransferId = `selection-stroke-${strokeId}`;
                          const transferInfo = this.selectionTransfers.get(selectionTransferId);
                          
                          if (transferInfo) {

                              transferInfo.manuallyCompleted = true;
                              transferInfo.lastActivity = Date.now();
                              
                              // Check if we should process completion now or wait
                              const chunksStillInProgress = transferInfo.receivedChunks < transferInfo.expectedChunks;
                              const hasRecentActivity = (Date.now() - transferInfo.lastActivity) < 1000;
                              
                              if (chunksStillInProgress && hasRecentActivity) {

                                  
                                  // Save this message for later processing
                                  transferInfo.pendingCompletionMessage = _0x5b8390;
                                  
                                  // Schedule a check to force completion if chunks stop coming
                                  if (!transferInfo.completionTimeout) {
                                      transferInfo.completionTimeout = setTimeout(() => {
                                          this.checkSelectionTransferCompletion(selectionTransferId);
                                      }, 3000);
                                  }
                                  
                                  // Set a flag to skip normal completion processing
                                  _0x5b8390._skipCompletionProcessing = true;
                              }
                          }
                      }
                  }
              }
          }
          
          // Only log and flag if we're not skipping completion
          if (!_0x5b8390._skipCompletionProcessing) {

              // Set a flag to indicate this message is a completion
              _0x5b8390._isCompletionMessage = true;
          }
      }

      // Handle transfer tracking for non-filtered messages
      if (_0x5b8390 && typeof _0x5b8390 === 'object') {
        // Detect chunk-based transfers (IMG PARTIAL or DIRECT PARTIALNEXT)
        const isTransferChunk = (
          (_0x5b8390.command === 'IMG' && _0x5b8390.action === 'PARTIAL') ||
          (_0x5b8390.command === 'DIRECT' && _0x5b8390.action === 'PARTIALNEXT')
        );
        
        // Detect start of transfer preparation phase
        const isTransferPrep = (
          (_0x5b8390.command === 'IMG' && _0x5b8390.action === 'PREPARE') ||
          (_0x5b8390.command === 'DIRECT' && _0x5b8390.action === 'PREPARE')
        );
        
        // Track non-local transfers or transfers that made it past filtering
        if (!isFromCurrentUser || !undoHistoryEnabled || isSelectionRelated || isCompletionMessage) {
          // Always track the first chunk of any transfer as a starting point
          if (isTransferChunk) {
            // For IMG transfers, part 0 indicates the first chunk
            const isFirstChunk = _0x5b8390.command === 'IMG' ? 
              (_0x5b8390.part === 0) : false;
              
            // For tracking chunks in progress
            if (transferId) {
              // Get or initialize chunk count
              if (!this.transferChunksInProgress) {
                this.transferChunksInProgress = new Map();
              }
              
              let chunkCount = this.transferChunksInProgress.get(transferId) || 0;
              
              // First chunk or prep phase - consider this a new transfer
              if (isFirstChunk || isTransferPrep || chunkCount === 0) {

                if (!this.activeTransfers) {
                  this.activeTransfers = new Set();
                }
                this.activeTransfers.add(transferId);
                chunkCount = 1;
              } else {
                // Increment chunk count
                chunkCount++;
              }
              
              this.transferChunksInProgress.set(transferId, chunkCount);

              
              // SELECTION FIX: Update the selection transfer tracking if applicable
              const strokeId = _0x5b8390.strokeId || 
                              (_0x5b8390.context ? parseInt(_0x5b8390.context.match(/stroke-(\d+)/)?.[1]) : null);
              
              if (isSelectionOperation && strokeId && this.selectionTransfers) {
                const selectionTransferId = `selection-stroke-${strokeId}`;
                const transferInfo = this.selectionTransfers.get(selectionTransferId);
                
                if (transferInfo) {
                  transferInfo.receivedChunks++;
                  transferInfo.lastActivity = Date.now();
                  

                  
                  // Check if this transfer was previously marked as completed but was waiting for chunks
                  if (transferInfo.manuallyCompleted && 
                      transferInfo.receivedChunks >= transferInfo.expectedChunks) {
                      
                      this.checkSelectionTransferCompletion(selectionTransferId);
                  }
                }
              }
            }
          }
          
          // CRITICAL FIX: More robust completion detection
          if (!_0x5b8390._skipCompletionProcessing && 
              (_0x5b8390._isCompletionMessage || isCompletionMessage) && transferId) {

            
            // CRITICAL FIX: Extract stroke ID from transferId or context if available
            let associatedStrokeId = null;
            
            // Try to extract stroke ID from context
            if (_0x5b8390.context && _0x5b8390.context.includes('stroke-')) {
              const contextMatch = _0x5b8390.context.match(/stroke-(\d+)/);
              if (contextMatch && contextMatch[1]) {
                associatedStrokeId = parseInt(contextMatch[1]);
              }
            }
            
            // If not found in context, check transfer ID
            if (!associatedStrokeId && transferId.includes('stroke-')) {
              const transferMatch = transferId.match(/stroke-(\d+)/);
              if (transferMatch && transferMatch[1]) {
                associatedStrokeId = parseInt(transferMatch[1]);
              }
            }
            
            // Also check if strokeId is directly in the message
            if (!associatedStrokeId && _0x5b8390.strokeId) {
              associatedStrokeId = parseInt(_0x5b8390.strokeId);
            }
            
            // Notify the board of transfer completion
            if (room?.board?.handleTransferComplete) {
              room.board.handleTransferComplete(transferId, {
                command: _0x5b8390.command,
                action: _0x5b8390.action,
                context: _0x5b8390.context,
                strokeId: associatedStrokeId,
                timestamp: Date.now()
              });
            }
            
            // Clean up transfer tracking
            if (this.activeTransfers) {
              this.activeTransfers.delete(transferId);
            }
            if (this.transferChunksInProgress) {
              this.transferChunksInProgress.delete(transferId);
            }
            
            // CRITICAL FIX: Trigger multiple event variants to ensure handlers catch it
            if (associatedStrokeId) {
              // Trigger stroke-specific completion event

              
              // Trigger standard transferComplete event
              $(document).trigger('transferComplete', {
                strokeId: associatedStrokeId,
                timestamp: Date.now(),
                originalTimestamp: _0x5b8390.timestamp,
                totalLayers: 1,
                details: _0x5b8390,
                triggerMethod: 'context-detection'
              });
              
              // Also trigger with stroke-specific namespace
              $(document).trigger(`transferComplete.stroke-${associatedStrokeId}`, {
                strokeId: associatedStrokeId,
                timestamp: Date.now(),
                details: _0x5b8390
              });
              
              // And trigger strokeComplete event for alternative handlers
              $(document).trigger('strokeComplete', {
                strokeId: associatedStrokeId,
                timestamp: Date.now()
              });
              
              // SELECTION FIX: Clean up selection transfer tracking if applicable
              if (this.selectionTransfers) {
                const selectionTransferId = `selection-stroke-${associatedStrokeId}`;
                if (this.selectionTransfers.has(selectionTransferId)) {
                  const transferInfo = this.selectionTransfers.get(selectionTransferId);
                  
                  // Clear any pending timeout
                  if (transferInfo.completionTimeout) {
                    clearTimeout(transferInfo.completionTimeout);
                  }
                  
                  // Remove from tracking
                  this.selectionTransfers.delete(selectionTransferId);

                }
              }
            } else {
              // Trigger generic completion event

              $(document).trigger('transferComplete', {
                transferId: transferId,
                timestamp: Date.now(),
                details: _0x5b8390,
                triggerMethod: 'general-completion'
              });
            }
            
            // NEW: Special handling for move/clone operations
            // If this is a RESPONSE message with OK status and stroke- context, 
            // it's very likely related to a move/clone operation
            if (_0x5b8390.command === 'RESPONSE' && _0x5b8390.action === 'OK' && 
                _0x5b8390.context && _0x5b8390.context.includes('stroke-')) {

              
              // Force trigger an event for any stroke handlers
              $(document).trigger('globalStrokeComplete', {
                message: _0x5b8390,
                transferId: transferId,
                timestamp: Date.now()
              });
            }
          }
        }
      }
    if (!UserStateManager.userPositions.size) {
        // Start the periodic average speed detection interval
        setInterval(() => {
            const currentTime = Date.now();
            
            // Convenient configuration variables
            const detectTrolling = localStorage.getItem('detectTrolling') === 'true';
            const GRIEF_SPEED_THRESHOLD = 25000;   // pixels per second threshold
            const SAFE_SPEED_THRESHOLD = 15000;
            const SPEED_WINDOW = 40;            // window in milliseconds over which to compute average speed
            const IDLE_TIMEOUT = 10000;           // ms threshold to consider user stopped drawing

            // Process each user's speedHistory
            UserStateManager.speedHistory.forEach((records, user) => {
                // Clean up old records
                UserStateManager.cleanSpeedHistory(user, currentTime);

                // Sum the distances in the last SPEED_WINDOW
                const totalDistance = records.reduce((sum, rec) => sum + rec.distance, 0);
                // Compute average speed: totalDistance / (SPEED_WINDOW in seconds)
                const avgSpeed = totalDistance / (SPEED_WINDOW / 1000);

                // Log current average speed.
                // console.log(`[${new Date().toLocaleTimeString()}] ${user}: Avg Speed ${avgSpeed.toFixed(2)} pixels/second`);

                // Determine if user is drawing (pen down and recent records exist)
                const isDrawing = records.length > 0 && UserStateManager.penStates.get(user) === true;
                if (isDrawing) {
                    UserStateManager.lastDrawTime.set(user, currentTime);
                }

                if (detectTrolling) {
                    if (isDrawing && avgSpeed > GRIEF_SPEED_THRESHOLD) {
                        const userObj = Object.values(room.users).find(u => u.username === user);
                        if (!userObj) return;
                        // Only apply WU rank to users who have RU or UU rank
                        if (!UserStateManager.originalRanks.has(user) && (userObj.rank === 'RU' || userObj.rank === 'UU')) {
                            UserStateManager.originalRanks.set(user, userObj.rank);
                            userObj.changeRank('WU');
                            const trollSound = localStorage.getItem(config.localStorageKeys.trollSound) || "nosound";
                            UI?.soundSystem?.play(trollSound);
                        }
                    }
                    if (UserStateManager.originalRanks.has(user)) {
                      if (!UserStateManager.slowStartTime) {
                          UserStateManager.slowStartTime = new Map();
                      }
                      const slowStart = UserStateManager.slowStartTime.get(user) || 0;
              
                      // Track time spent under safe speed, regardless of pen state
                      if (avgSpeed < SAFE_SPEED_THRESHOLD) {
                          if (!slowStart) {
                              // Mark the start of safe-drawing
                              UserStateManager.slowStartTime.set(user, currentTime);
                          } else if (currentTime - slowStart >= IDLE_TIMEOUT) {
                              // If they've been under threshold for long enough, revert rank
                              const userObj = Object.values(room.users).find(u => u.username === user);
                              if (userObj) {
                                  userObj.changeRank(UserStateManager.originalRanks.get(user) || userObj.rank);
                                  UserStateManager.originalRanks.delete(user);
                                  UserStateManager.lastDrawTime.delete(user);
                              }
                              UserStateManager.slowStartTime.delete(user);
                          }
                      } else {
                          // Reset if they're back above safe speed
                          if (slowStart) {
                              UserStateManager.slowStartTime.delete(user);
                          }
                      }
              
                      // Also revert if user is fully idle for IDLE_TIMEOUT
                      const lastActive = UserStateManager.lastDrawTime.get(user) || 0;
                      const idleTime = currentTime - lastActive;
                      if (!isDrawing && idleTime >= IDLE_TIMEOUT) {
                          const userObj = Object.values(room.users).find(u => u.username === user);
                          if (userObj) {
                              userObj.changeRank(UserStateManager.originalRanks.get(user) || userObj.rank);
                              UserStateManager.originalRanks.delete(user);
                              UserStateManager.lastDrawTime.delete(user);
                          }
                      }
                  }
               }
            });
        }, 200); // Interval for checking average speed
    }

    // Check broadcast for pen state and new positions
    if (_0x5b8390.command === 'BROADCAST') {
        const user = _0x5b8390.from;
        if (_0x5b8390.action === 'Pd') {
            UserStateManager.setPenState(user, true);
        } else if (_0x5b8390.action === 'Pu') {
            UserStateManager.setPenState(user, false);
        }

        if (_0x5b8390.x && _0x5b8390.y) {
            const newPos = { x: _0x5b8390.x, y: _0x5b8390.y, time: Date.now() };
            UserStateManager.updatePosition(user, newPos);
        }
    }

    if (_0x5b8390["command"] == "CONNECTION") {
      if (_0x5b8390["option"] == "HELLO") {
        var _0x56b2b9 = {};
        _0x56b2b9["command"] = "CONNECTION", _0x56b2b9["option"] = "HI", _0x56b2b9.clientId = UI["clientId"], _0x56b2b9["client"] = UI["client"], _0x56b2b9["version"] = UI["version"], _0x56b2b9["supportedencryptions"] = this["supportedEncryptions"], this.send(_0x56b2b9, true, true);
      } else {
        if (_0x5b8390["option"] == "LETSTALK") {
          var _0x60ed66;
          this["supportedEncryptions"]["indexOf"](_0x5b8390.suggestedencryption) > -1 ? _0x60ed66 = _0x5b8390["suggestedencryption"] : _0x60ed66 = firstMatch(_0x5b8390.supportedencryptions, this["supportedEncryptions"]);
          if (_0x60ed66) {
            _0x5b8390["clientip"] && (device.ip = device["getIPAddressInfo"](_0x5b8390.clientip));
            var _0x56b2b9 = {};
            _0x56b2b9["command"] = "CONNECTION", _0x56b2b9.option = "READY", _0x56b2b9["encryption"] = _0x60ed66, _0x56b2b9["string"] = encryptMessage(_0x5b8390["string"], _0x60ed66), this.send(_0x56b2b9, true, true);
          } else this["disconnect"](true);
        } else {
          if (_0x5b8390["option"] == "SUCCESS") {
            this["encryption"] = _0x5b8390.encryption, UI.timeDiff = parseInt(new Date()["getTime"]() / 1e3) - _0x5b8390["servertime"];
            var _0x56b2b9 = {};
            _0x56b2b9["command"] = "CONNECTION", _0x56b2b9["option"] = "WHOIAM", _0x56b2b9["clientId"] = UI.clientId, _0x56b2b9["client"] = UI.client, _0x56b2b9["version"] = UI["version"], _0x56b2b9["url"] = window.location["href"], _0x56b2b9["time"] = new Date().getTime(), _0x56b2b9.diff = UI["timeDiff"], _0x56b2b9["flag"] = this["flag"];
            var _0x4165ab = {};
            _0x4165ab["country"] = device.ip["countrycode"], _0x4165ab["proxy"] = device.ip["proxy"], _0x4165ab["hosting"] = device.ip["hosting"], _0x56b2b9.ip = _0x4165ab, _0x56b2b9["serv"] = device["getString"](), _0x56b2b9["bst"] = device["getBotString"](), _0x56b2b9["tst"] = device["getTimeString"](), _0x56b2b9["hid"] = device["getUniqueID"](), _0x56b2b9.cid = storage["cid"], _0x56b2b9.fp = device.getCanvasId(), this["send"](_0x56b2b9, true, true);
          } else {
            if (_0x5b8390["option"] == "FAIL") {
              if (_0x5b8390["reason"] == "OUTDATED") UI["hideScreen"](textManager["getString"]("alerts.txtOutdatedApp"), false, 1), this["canReconnect"] = false; else {
                if (_0x5b8390["reason"] == "MAXCONNECTIONS") UI["dialogHandler"].showAlert(textManager["getString"]("alerts.txtTooManyConnections")), this["canReconnect"] = false; else _0x5b8390["reason"] == "ENCRYPTIONFAILED" && (UI["dialogHandler"]["showAlert"](textManager["getString"]("alerts.txtNegotiationFailed")), this["canReconnect"] = false);
              }
              this["disconnect"](true);
            } else _0x5b8390["option"] == "WELCOME" && (this["setNegotiated"](true), setTimeout(function () {
              $(".splashScreen")["remove"]();
            }, 3e3));
          }
        }
      }
    } else {
      if (_0x5b8390["command"] == "PROTOCOL") {
        if (_0x5b8390["option"] == "PONG") this.pong(_0x5b8390["ping"]); else {
          if (_0x5b8390["option"] == "MOVE") UI["leaveRoom"](), UI["loginDialog"]["forceJoin"](_0x5b8390.room, _0x5b8390["password"]); else {
            if (_0x5b8390["option"] == "SERVERCHANGE") this.disconnect(true), this.URL = _0x5b8390["server"], this["connect"](); else _0x5b8390["option"] == "FLAG" && (this["flag"] = _0x5b8390["flag"]);
          }
        }
      } else {
        if (_0x5b8390["command"] == "GLOBALMESSAGE") room && room["connected"] ? UI["chatDialog"]["registerGlobalMessage"](_0x5b8390["text"]) : UI.dialogHandler.showAlert(_0x5b8390["text"], 15); else {
          if (_0x5b8390.command == "GLOBALALERT") room && room["connected"] ? UI.chatDialog["registerGlobalMessage"](new Icon("fa-exclamation-triangle")["html"]() + " " + _0x5b8390["text"]) : UI["dialogHandler"]["showAlert"](_0x5b8390.text); else {
            if (_0x5b8390["command"] == "OFFROOM") {
              if (_0x5b8390.option == "ROOMLIST") UI["loginDialog"].roomList(_0x5b8390), UI.dialogHandler.getActiveDialogName() != "LoginDialog" && (UI["dialogHandler"]["hideAll"](), UI["dialogHandler"]["showDialog"]("login")); else {
                if (_0x5b8390["option"] == "CANTENTER") {
                  if (_0x5b8390["code"] == "MUSTLOG") UI["dialogHandler"].showAlert(new Icon("fa-exclamation-triangle")["html"]() + " " + textManager["getString"]("alerts.roomEnter.txtAccountRestricted")); else {
                    if (_0x5b8390.code == "PWDREQUIRED") UI.loginDialog["roomPassword"](); else {
                      if (_0x5b8390["code"] == "PWDWRONG") UI["dialogHandler"]["showAlert"](new Icon("fa-exclamation-triangle")["html"]() + " " + textManager["getString"]("alerts.roomEnter.txtWrongPassword")), UI["loginDialog"]["roomPassword"](); else {
                        if (_0x5b8390["code"] == "ROOMBANNED") UI["dialogHandler"]["showAlert"](new Icon("fa-exclamation-triangle")["html"]() + " " + textManager["getString"]("alerts.roomEnter.txtYouAreBanned")); else {
                          if (_0x5b8390.code == "REDIRECT") this["disconnect"](true), cm["actionTarget"] = "JOINROOM", this.URL = _0x5b8390["server"], this.connect(); else {
                            if (_0x5b8390["code"] == "ROOMFULL") UI["dialogHandler"].showAlert(new Icon("fa-exclamation-triangle")["html"]() + " " + textManager["getString"]("alerts.roomEnter.txtRoomIsFull")); else {
                              if (_0x5b8390["code"] == "TOOMANYCONNECTIONS") UI["dialogHandler"]["showAlert"](new Icon("fa-exclamation-triangle")["html"]() + " " + textManager["getString"]("alerts.roomEnter.txtTooManyConnections")); else {
                                if (_0x5b8390["code"] == "INVALIDUSERNAME") UI["dialogHandler"].showAlert(new Icon("fa-exclamation-triangle")["html"]() + " " + textManager["getString"]("alerts.roomEnter.txtUsernameNotValid")); else _0x5b8390["code"] == "NOPROXY" && UI["dialogHandler"]["showAlert"](new Icon("fa-exclamation-triangle")["html"]() + " " + textManager["getString"]("alerts.roomEnter.txtProxyNotAllowed"));
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  UI["loginDialog"]["loading"](false);
                } else {
                  if (_0x5b8390["option"] == "YOURTHUMB") UI["loginDialog"]["roomThumb"](_0x5b8390["room"], _0x5b8390["thumbnail"]); else _0x5b8390.option == "ACCOUNTRESPONSE" && UI["loginDialog"]["registerResponse"](_0x5b8390.status);
                }
              }
            } else {
              if (_0x5b8390?.command === "MESSENGERNEW") {
                try {
                    const blockedUsers = JSON.parse(localStorage.getItem("blockedUsers")) || []; // Get blocked users list
                    const fromUsername = _0x5b8390?.message?.fromUsername; // Safely access fromUsername
                    
                    // if (!fromUsername) {
                    //     return; // Skip processing if 'fromUsername' is undefined or null
                    // }
            
                    if (blockedUsers.includes(fromUsername)) {
                        return; // Do nothing if the sender is in the blocked users list
                    }
            
                    // Process the message as usual if the sender is not blocked
                    UI["messengerDialog"]["setUnreadMessages"](_0x5b8390["unread"]);
                    
                    if (_0x5b8390?.message) {
                        UI["messengerDialog"]["newMessage"](_0x5b8390["message"]);
                    }
            
                    if (_0x5b8390?.unread > 0 && UI["dialogHandler"]["getActiveDialogName"]() !== "MessengerDialog") {
                        UI["chatDialog"]["registerEvent"](
                            new Icon("fa-envelope")["html"]() + " " + textManager.getString("events.txtUnreadMessenger", _0x5b8390["unread"], false)
                        );
                    }
                } catch (error) {

                }
            } else {            
                            if (_0x5b8390.command == "MUTETIME") UI.muteTime(parseInt(_0x5b8390.seconds)); else {
                  if (_0x5b8390.command == "THUMBNAIL") {
                    var _0x56b2b9 = {};
                    _0x56b2b9["command"] = "USERFUNCTIONS", _0x56b2b9["option"] = "ROOMTHUMB", _0x56b2b9["layers"] = UI["getThumbnail"](), this["send"](_0x56b2b9, true);
                  } else {
                    if (_0x5b8390["command"] == "GB") { } else {
                      if (_0x5b8390["command"] == "DEBUG") {
                        var _0x171599 = parseInt(new Date()["getTime"]() / 1e3),
                          _0x71f642 = {};
                        _0x71f642["Active Dialog"] = UI["dialogHandler"].getActiveDialogName(), _0x71f642["Tool"] = room["myself"]["surface"]["getCurrentBrush"](), _0x71f642["Tool size"] = room["myself"]["surface"]["brushHandler"]["getOption"]("size"), _0x71f642["Selected layer"] = parseInt(room["myself"]["surface"]["currentLayer"]) + 1, _0x71f642["Primary color"] = UI.sidebar["colorBox"].primaryColor, _0x71f642["Secondary color"] = UI["sidebar"].colorBox["secondaryColor"], _0x71f642["Last pen down"] = room["myself"]["surface"].lastPenDown ? formatSeconds(_0x171599 - room.myself["surface"]["lastPenDown"]) + " ago" : "Never", _0x71f642["Last pen up"] = room.myself["surface"]["lastPenUp"] ? formatSeconds(_0x171599 - room.myself["surface"]["lastPenUp"]) + " ago" : "Never", _0x71f642.Zoom = parseInt(room.board["scale"] * 100) + "%", _0x71f642["URL"] = window["location"]["href"], _0x71f642["Theme"] = UI.userPreferences.getProperty("theme", "dark"), _0x71f642["Client ID"] = UI["clientId"], _0x71f642["Language"] = textManager.getLocale(), $.each(device["navigator"], function (_0x1fcf03, _0x40169c) {
                          _0x71f642["navigator." + _0x1fcf03] = _0x40169c;
                        }), $["each"](device["screen"], function (_0x5977ed, _0x1fc590) {
                          _0x71f642["screen." + _0x5977ed] = _0x1fc590;
                        }), $.each(device.webgl, function (_0x4fe94b, _0x21e537) {
                          _0x71f642["webgl." + _0x4fe94b] = _0x21e537;
                        });
                        var _0x56b2b9 = {};
                        _0x56b2b9.command = "USERFUNCTIONS", _0x56b2b9.option = "DEBUGRESPONSE", _0x56b2b9["params"] = _0x71f642, this["send"](_0x56b2b9, true);
                      } else {
                        if (_0x5b8390.command == "ENTERED") room["connected"] && (room["connected"] = false), room.createMyself(_0x5b8390["you"].name, _0x5b8390["you"]["rank"]), !UI["configured"] && (UI["configured"] = true, UI["setupControls"](), UI["bindEvents"]()), room["capacity"] = _0x5b8390["capacity"], room["description"] = unescapeHTML(_0x5b8390["description"]), room["changeSize"](_0x5b8390["size"]), room["changeTransparency"](_0x5b8390["bottomtransparency"]), room.changeType(_0x5b8390.type), room["changeLayers"](_0x5b8390["numlayers"]), 
                        (UI.customBgActive || room.changeBackground(_0x5b8390["background"], true)), 
                        room["changeAnimationOptions"](_0x5b8390["animrows"], _0x5b8390["animcols"]), room.change(_0x5b8390["room"]), _0x5b8390["usercount"] > 0 && room["board"]["clearLayers"](), room["myself"].changeMute(_0x5b8390["you"].muted), room.myself["changeSilence"](_0x5b8390.you["silenced"]), room["setPrivileges"](_0x5b8390.you["privileges"]), room["setTools"](_0x5b8390["you"]["tools"]), room.myself.uid = _0x5b8390["you"]["uid"], _0x5b8390["you"]["muted"] && _0x5b8390["you"]["mutetime"] && UI["muteTime"](parseInt(_0x5b8390["you"]["mutetime"])), "registered" in _0x5b8390 && (_0x5b8390["registered"] ? UI["bottombar"].hideButton("registerButton") : UI["bottombar"]["showButton"]("registerButton")), UI["setupScreenSize"](UI.getScreenSize()), UI["showAllLayers"](), UI.inRoom = true, setTimeout(function (_0x3484e1) {
                          UI["fitToScreen"](), UI["boardContainer"].fadeIn(1500);
                        }, 1e3), $.each(_0x5b8390.lockedlayers, function (_0x42cdea, _0x10c152) {
                          room.board["lockLayer"](_0x10c152);
                        }), room["setConnected"](true), UI["sidebar"].layerPreview["updatePreviews"](); else {
                          if (_0x5b8390["command"] == "JOINED") {
                            var _0x4165ab = "",
                              _0x26be5c = "",
                              _0x5b3f3c = false;
                            _0x5b8390.ip && (_0x4165ab = _0x5b8390.ip);
                            _0x5b8390["country"] && (_0x26be5c = escapeHTML(_0x5b8390["country"]["substring"](0, 2)));
                            _0x5b8390.proxy && (_0x5b3f3c = _0x5b8390.proxy);
                            var _0x4158cb = new User(_0x5b8390["username"], _0x5b8390["rank"], _0x4165ab, _0x26be5c, _0x5b3f3c);
                            _0x4158cb["changeMute"](_0x5b8390["muted"]), _0x4158cb["changeSilence"](_0x5b8390.silenced), _0x4158cb["changeConnectionIssue"](_0x5b8390.connectionissues), room["addUser"](_0x4158cb), UI["syncBrushes"](_0x5b8390["username"]);
                          } else {
                            if (_0x5b8390["command"] == "YOULEFT") room["leave"](); else {
                              if (_0x5b8390.command == "LEFT") room["removeUser"](_0x5b8390.username, _0x5b8390["reason"]); else {
                                if (_0x5b8390["command"] == "INTHEROOM") $["each"](_0x5b8390["users"], function (_0x24ffbf, _0x288b1d) {
                                  var _0x47151d = "",
                                    _0x3b7999 = "",
                                    _0x37e87b = false;
                                  _0x288b1d.ip && (_0x47151d = _0x288b1d.ip);
                                  _0x288b1d["country"] && (_0x3b7999 = _0x288b1d["country"]);
                                  _0x288b1d["proxy"] && (_0x37e87b = _0x288b1d.proxy);
                                  var _0x3c4f22 = new User(_0x288b1d["username"], _0x288b1d["rank"], _0x47151d, _0x3b7999, _0x37e87b);
                                  _0x3c4f22["changeMute"](_0x288b1d["muted"]), _0x3c4f22["changeSilence"](_0x288b1d["silenced"]), room["addUser"](_0x3c4f22, true);
                                }), UI["syncBrushes"](), _0x5b8390.recommendedSync && UI["recommendedSync"](_0x5b8390["recommendedSync"]), _0x5b8390.users["length"] == 0 && (room["loading"] = false); else {
                                  if (_0x5b8390["command"] == "CONNECTIONISSUES") room["connectionIssues"](_0x5b8390.username, _0x5b8390.issues); else {
                                    if (_0x5b8390["command"] == "GLOBALRESPONSE") {
                                      if (_0x5b8390["option"] == "DEBUG") UI["debugDialog"]["name"] = _0x5b8390.target, UI["debugDialog"]["table"].clear(), $.each(_0x5b8390["user"], function (_0x4b37fb, _0x3da98c) {
                                        UI["debugDialog"]["table"]["addRow"]([_0x4b37fb, escapeHTML(_0x3da98c)], false);
                                      }), UI["debugDialog"].table.updated(), UI.dialogHandler["showDialog"]("debug"); else _0x5b8390.option == "DEBUGCLIENT" && UI["dialogHandler"].getActiveDialogName() == "DebugDialog" && UI["debugDialog"].name == _0x5b8390["target"] && ($["each"](_0x5b8390["params"], function (_0x4d7b87, _0x23e1f7) {
                                        UI.debugDialog["table"]["addRow"]([_0x4d7b87, escapeHTML(_0x23e1f7)], false);
                                      }), UI.debugDialog["name"] = "", UI["debugDialog"]["table"]["updated"]());
                                    } else {
                                      if (_0x5b8390["command"] == "CHATMSG") {
                                        if (_0x5b8390["from"] in room.users) {
                                          var _0x4158cb = room.users[_0x5b8390["from"]];
                                          UI["chatDialog"]["createMessage"](_0x5b8390["chatname"], _0x5b8390["chattype"], "MSG", _0x5b8390["message"], _0x4158cb.username);
                                        }
                                      } else {
                                        if (_0x5b8390["command"] == "RELOGGED") UI["chatDialog"]["registerEvent"](textManager["getString"]("events.txtNowKnown", [UI.userRank(_0x5b8390["beforerank"]), _0x5b8390["beforeusername"], UI["userRank"](_0x5b8390["afterrank"]), _0x5b8390["afterusername"]], false)), room["userRenamed"](_0x5b8390.beforerank, _0x5b8390["beforeusername"], _0x5b8390["afterrank"], _0x5b8390["afterusername"]); else {
                                          if (_0x5b8390["command"] == "YOURELOGGED") room["myself"].changeUsername(_0x5b8390.afterusername), room.myself["changeRank"](_0x5b8390["afterrank"]), room["myself"]["uid"] = _0x5b8390["uid"], _0x5b8390.privileges && room["setPrivileges"](_0x5b8390.privileges), _0x5b8390["tools"] && room["setTools"](_0x5b8390["tools"]), UI.chatDialog.registerEvent(textManager.getString("events.txtYouNowKnown", [UI["userRank"](_0x5b8390["afterrank"]), _0x5b8390["afterusername"]], false)); else {
                                            if (_0x5b8390.command == "DIRECT") {
                                              if (_0x5b8390["action"] == "SYNC") _0x5b8390["from"] in room.users && (room["users"][_0x5b8390.from]["status"] = _0x5b8390.status, room["users"][_0x5b8390["from"]]["inactive"] = _0x5b8390["inactive"], room["users"][_0x5b8390["from"]].surface.cursor.x = _0x5b8390.x, room["users"][_0x5b8390["from"]]["surface"]["cursor"].y = _0x5b8390.y, room["users"][_0x5b8390.from]["surface"]["setBrush"](_0x5b8390["brush"]), room["users"][_0x5b8390["from"]]["surface"].setColor(_0x5b8390["color"]), room["users"][_0x5b8390.from]["surface"]["setBrushesOptions"](_0x5b8390["options"]), _0x5b8390["layer"] && room["users"][_0x5b8390["from"]]["surface"].setCurrentLayer(_0x5b8390["layer"]), _0x5b8390.brushSync && (room["users"][_0x5b8390.from]["surface"]["penPressed"] = _0x5b8390.penPressed, room["users"][_0x5b8390["from"]].surface.setBrushSync(_0x5b8390["brushSync"])), _0x5b8390.visible && room["users"][_0x5b8390["from"]].surface["penShow"]()); else {
                                                if (_0x5b8390["action"] == "GETBOARD") {
                                                  var _0x44b81e = new Transfer("DIRECT", _0x5b8390["from"], "sync", new Date()["getTime"](), true);
                                                  $(_0x44b81e).on("transferStart transferChunkReady", sendChunk);
                                                  for (var _0x3c2634 = 0; _0x3c2634 < room.board["nLayers"]; _0x3c2634++) {
                                                    _0x44b81e["addData"](_0x3c2634, 0, 0, room["board"]["canvasWidth"], room["board"].canvasHeight, 0, btoa(room["board"]["getLayerData"](_0x3c2634)));
                                                  }
                                                  _0x44b81e["send"](), room["addTransfer"](_0x44b81e);
                                                } else {
                                                  if (_0x5b8390["action"] == "PARTIAL") UI["acceptingSync"](_0x5b8390["from"]) ? processTransfer(_0x5b8390) : rejectTransfer(_0x5b8390); else {
                                                    if (_0x5b8390["action"] == "PARTIALNEXT") $["each"](room["transfers"], function (_0x4bd3de, _0x2c555e) {
                                                      _0x2c555e["matches"](_0x5b8390["targettype"], _0x5b8390["from"], _0x5b8390["ttype"], _0x5b8390.timestamp) && !_0x2c555e["completed"] && !_0x2c555e["failed"] && _0x2c555e["nextPart"]();
                                                    }); else _0x5b8390.action == "NOTHANKS" && $.each(room["transfers"], function (_0x94418e, _0x22d16b) {
                                                      _0x22d16b["matches"](_0x5b8390.targettype, _0x5b8390.from, _0x5b8390["ttype"], _0x5b8390["timestamp"]) && !_0x22d16b.completed && !_0x22d16b["failed"] && _0x22d16b.fail();
                                                    });
                                                  }
                                                }
                                              }
                                            } else {
                                              if (_0x5b8390["command"] == "IMG") _0x5b8390["action"] == "PARTIAL" && processTransfer(_0x5b8390); else {
                                                if (_0x5b8390["command"] == "RANKCHANGE") room["myself"]["rank"] != _0x5b8390["rank"] && room.myself["changeRank"](_0x5b8390["rank"]), _0x5b8390["privileges"] && room["setPrivileges"](_0x5b8390["privileges"]), _0x5b8390["tools"] && room["setTools"](_0x5b8390["tools"]); else {
                                                  if (_0x5b8390["command"] == "ROOMCHANGE") room["description"] != _0x5b8390["description"] && (room.description = _0x5b8390["description"], _0x5b8390["description"]["trim"]() != "" && UI.chatDialog.createMessage("public", "room", "MOTD", escapeHTML(_0x5b8390["description"]))), room["capacity"] = _0x5b8390["capacity"], room["changeSize"](_0x5b8390["size"]), room["changeType"](_0x5b8390["type"]), room["changeLayers"](_0x5b8390["numlayers"]), room.changeTransparency(_0x5b8390.bottomtransparency), 
                                                  (UI.customBgActive || room["changeBackground"](_0x5b8390.background)), 
                                                  room["changeAnimationOptions"](_0x5b8390["animrows"], _0x5b8390["animcols"]); else {
                                                    if (_0x5b8390["command"] == "ROOMSTATUS") _0x5b8390.registered ? UI["bottombar"]["hideButton"]("registerButton") : UI["bottombar"].showButton("registerButton"); else {
                                                      if (_0x5b8390["command"] == "STAFFACTION") {
                                                        "layer" in _0x5b8390 && (_0x5b8390.layer = parseInt(_0x5b8390.layer));
                                                        if (_0x5b8390["option"] == "Cl") room.board["clearLayer"](_0x5b8390.layer), UI["chatDialog"]["registerEvent"](textManager["getString"]("events.txtLayer", [_0x5b8390["layer"] + 1, _0x5b8390["from"]], false)); else {
                                                          if (_0x5b8390.option == "Flh") room.board.flipLayer(_0x5b8390["layer"], true, false), UI["chatDialog"].registerEvent(textManager["getString"]("events.txtFlipH", [_0x5b8390.layer + 1, _0x5b8390["from"]], false)); else {
                                                            if (_0x5b8390["option"] == "Flv") room["board"].flipLayer(_0x5b8390["layer"], false, true), UI["chatDialog"]["registerEvent"](textManager["getString"]("events.txtFlipV", [_0x5b8390.layer + 1, _0x5b8390["from"]], false)); else {
                                                              if (_0x5b8390["option"] == "Lkl") room.board.lockLayer(_0x5b8390["layer"]), UI["chatDialog"].registerEvent(textManager["getString"]("events.txtLock", [_0x5b8390.layer + 1, _0x5b8390["from"]], false)); else {
                                                                if (_0x5b8390["option"] == "Ukl") room.board.unlockLayer(_0x5b8390["layer"]), UI.chatDialog["registerEvent"](textManager["getString"]("events.txtUnlock", [_0x5b8390["layer"] + 1, _0x5b8390["from"]], false)); else {
                                                                  if (_0x5b8390["option"] == "Mgl") room["board"]["mergeLayer"](_0x5b8390.layerFrom, _0x5b8390["layerTo"]), UI.chatDialog["registerEvent"](textManager["getString"]("events.txtMerge", [parseInt(_0x5b8390.layerFrom) + 1, parseInt(_0x5b8390["layerTo"]) + 1, _0x5b8390["from"]], false)); else {
                                                                    if (_0x5b8390["option"] == "Afc") {
                                                                      var _0xf6c999 = room["board"]["canvasWidth"] / room.animCols,
                                                                        _0x3a1875 = room["board"]["canvasHeight"] / room["animRows"],
                                                                        _0x16717b = Math["floor"](parseInt(_0x5b8390["source"]) / room.animCols),
                                                                        _0xd7c1ef = parseInt(_0x5b8390["source"]) % room["animCols"];
                                                                      room["board"]["partiallyClearLayer"](_0x5b8390["layer"], null, _0xf6c999 * _0xd7c1ef, _0x3a1875 * _0x16717b, _0xf6c999, _0x3a1875), UI["chatDialog"].registerEvent(textManager["getString"]("events.txtAnimationFrameClear", [_0x5b8390["layer"], parseInt(_0x5b8390["source"]) + 1, _0x5b8390.from], false));
                                                                    } else {
                                                                      if (_0x5b8390["option"] == "Afd") {
                                                                        var _0xf6c999 = room.board["canvasWidth"] / room["animCols"],
                                                                          _0x3a1875 = room["board"].canvasHeight / room.animRows,
                                                                          _0x16717b = Math["floor"](parseInt(_0x5b8390["source"]) / room.animCols),
                                                                          _0xd7c1ef = parseInt(_0x5b8390.source) % room["animCols"],
                                                                          _0x216a0f = Math["floor"](parseInt(_0x5b8390.target) / room["animCols"]),
                                                                          _0x4e2e20 = parseInt(_0x5b8390["target"]) % room["animCols"];
                                                                        let _0x100363 = room.board["layers"][_0x5b8390["layer"]]["advCanvas"]["getImageData"](_0xf6c999 * _0xd7c1ef, _0x3a1875 * _0x16717b, _0xf6c999, _0x3a1875);
                                                                        var _0x427112 = new AdvancedCanvas(_0xf6c999, _0x3a1875);
                                                                        _0x427112["putImageData"](_0x100363);
                                                                        var _0x44b21d = new Image();
                                                                        _0x44b21d["onload"] = function () {
                                                                          room["board"].partiallyClearLayer(_0x5b8390["layer"], null, _0xf6c999 * _0x4e2e20, _0x3a1875 * _0x216a0f, _0xf6c999, _0x3a1875), room["board"]["layers"][_0x5b8390["layer"]]["advCanvas"].setCanvasProperties({
                                                                            alpha: _0x5b8390["opacity"]
                                                                          }), room["board"]["layers"][_0x5b8390["layer"]]["advCanvas"].drawImage(this, _0xf6c999 * _0x4e2e20, _0x3a1875 * _0x216a0f, _0xf6c999, _0x3a1875);
                                                                        }, _0x44b21d.src = _0x427112["getData"](), _0x427112["remove"](), UI.chatDialog.registerEvent(textManager["getString"]("events.txtAnimationFrameClone", [_0x5b8390["layer"], parseInt(_0x5b8390["source"]) + 1, parseInt(_0x5b8390["target"]) + 1, _0x5b8390["from"]], false));
                                                                      } else {
                                                                        if (_0x5b8390.option == "Kck") room["kickUser"](_0x5b8390.username), UI["chatDialog"]["registerEvent"](textManager.getString("events.txtKick", [_0x5b8390["username"], _0x5b8390["from"]], false)); else {
                                                                          if (_0x5b8390["option"] == "Bn") room["banUser"](_0x5b8390["username"]), UI.chatDialog["registerEvent"](textManager["getString"]("events.txtBan", [_0x5b8390["username"], _0x5b8390["from"]], false)); else {
                                                                            if (_0x5b8390["option"] == "Muu") room["muteUser"](_0x5b8390["username"], _0x5b8390["mutetime"]), _0x5b8390["from"] ? UI["chatDialog"]["registerEvent"](textManager["getString"]("events.txtMute", [_0x5b8390["username"], _0x5b8390["from"]], false)) : UI.chatDialog.registerEvent(textManager["getString"]("events.txtMute2", [_0x5b8390["username"]], false)); else {
                                                                              if (_0x5b8390.option == "Umu") room.unmuteUser(_0x5b8390.username), _0x5b8390["from"] ? UI["chatDialog"].registerEvent(textManager["getString"]("events.txtUnmute", [_0x5b8390.username, _0x5b8390["from"]], false)) : UI["chatDialog"].registerEvent(textManager["getString"]("events.txtUnmute2", [_0x5b8390["username"]], false)); else {
                                                                                if (_0x5b8390["option"] == "Siu") room["silenceUser"](_0x5b8390["username"]), UI["chatDialog"].registerEvent(textManager["getString"]("events.txtSilence", [_0x5b8390["username"], _0x5b8390["from"]], false)); else {
                                                                                  if (_0x5b8390["option"] == "Usi") room["unsilenceUser"](_0x5b8390["username"]), UI.chatDialog["registerEvent"](textManager["getString"]("events.txtUnsilence", [_0x5b8390["username"], _0x5b8390["from"]], false)); else _0x5b8390["option"] == "Chr" && (_0x5b8390["online"] && room["rankUser"](_0x5b8390.username, _0x5b8390["rank"]), UI["chatDialog"]["registerEvent"](textManager.getString("events.txtRankUpdate", [_0x5b8390["username"], _0x5b8390["from"]], false)));
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      } else {
                                                        if (_0x5b8390["command"] == "USERRESPONSE") {
                                                          if (_0x5b8390["option"] == "Msgm") {
                                                            if (_0x5b8390.perform == "list") UI["messengerDialog"].conversationList(_0x5b8390["conversations"]); else {
                                                              if (_0x5b8390.perform == "read") UI["messengerDialog"]["messageList"](_0x5b8390["withUID"], _0x5b8390.withUsername, _0x5b8390["messages"]); else {
                                                                if (_0x5b8390.perform == "insert") UI.messengerDialog.messageReceived(_0x5b8390["msgid"], _0x5b8390["tempid"]); else {
                                                                  if (_0x5b8390["perform"] == "find") UI["messengerDialog"].userFound(_0x5b8390.status, _0x5b8390["user"]); else {
                                                                    if (_0x5b8390.perform == "remove") UI["messengerDialog"].conversationRemoved(_0x5b8390["status"], _0x5b8390.uid); else _0x5b8390.perform == "delete" && UI["messengerDialog"]["deleteMessage"](_0x5b8390["status"], _0x5b8390.id);
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          } else {
                                                            if (_0x5b8390["option"] == "Por") UI["profileDialog"].ownedRoomsList(_0x5b8390["rooms"]); else {
                                                              if (_0x5b8390.option == "Prr") UI["profileDialog"]["roomRankList"](_0x5b8390["rooms"]); else _0x5b8390["option"] == "Ugi" && UI.userGalleryDialog["galleryImages"](_0x5b8390["target"], Math.ceil(_0x5b8390["total"] / _0x5b8390.perPage), _0x5b8390.images);
                                                            }
                                                          }
                                                        } else {
                                                          if (_0x5b8390["command"] == "ROOMRESPONSE") {
                                                            if (_0x5b8390["option"] == "Rbn") UI.roomManagerDialog["banList"](_0x5b8390["bans"]); else {
                                                              if (_0x5b8390.option == "Rse") room["bantime"] = _0x5b8390["bantime"], room["mutetime"] = _0x5b8390.mutetime, room["mute"] = _0x5b8390["mute"], room.knownproxy = _0x5b8390.knownproxy, room["hidden"] = _0x5b8390["hidden"], room["password"] = _0x5b8390.password, UI.roomManagerDialog["roomSettings"](); else {
                                                                if (_0x5b8390["option"] == "Rst") UI["roomManagerDialog"]["staffList"](_0x5b8390.staff); else {
                                                                  if (_0x5b8390["option"] == "Rpr") UI["roomManagerDialog"]["privilegeList"](_0x5b8390.ranks, _0x5b8390["privileges"]); else {
                                                                    if (_0x5b8390["option"] == "Rto") UI["roomManagerDialog"]["toolList"](_0x5b8390["ranks"], _0x5b8390["tools"]); else {
                                                                      if (_0x5b8390["option"] == "Rer") _0x5b8390.status == "OK" ? UI["dialogHandler"]["showAlert"](textManager.getString("alerts.txtRoomRegistered")) : UI["dialogHandler"]["showAlert"]("ERROR: " + _0x5b8390["status"]); else _0x5b8390["option"] == "Urr" && (_0x5b8390["status"] == "OK" ? UI["roomManagerDialog"]["hide"]() : (UI["roomManagerDialog"]["loading"](false), UI["dialogHandler"]["showAlert"]("ERROR: " + _0x5b8390["status"])));
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          } else {
                                                            if (_0x5b8390["command"] == "GALLERYRESPONSE") {
                                                              if (_0x5b8390["option"] == "Gig") UI["galleryImageDialog"].gotResponse(_0x5b8390); else {
                                                                if (_0x5b8390["option"] == "Gis") UI["galleryImageDialog"].gotUpdated(_0x5b8390); else {
                                                                  if (_0x5b8390["option"] == "Comment") {
                                                                    if (_0x5b8390["perform"] == "add") UI["galleryImageDialog"]["addedComment"](_0x5b8390.newId, _0x5b8390.tempId); else _0x5b8390["perform"] == "delete" && UI["galleryImageDialog"].deletedComment(_0x5b8390.status, _0x5b8390.id);
                                                                  }
                                                                }
                                                              }
                                                            } else {
                                                              if (_0x5b8390["command"] == "ROOMREQRESPONSE") UI.roomManagerDialog.gotResponse(_0x5b8390); else {
                                                                if (_0x5b8390.command == "ADMINRESPONSE") {
                                                                  if (_0x5b8390["option"] == "Ssm") UI.adminConsoleDialog["summary"](_0x5b8390); else {
                                                                    if (_0x5b8390["option"] == "Sin") UI["adminConsoleDialog"]["serverInfo"](_0x5b8390); else {
                                                                      if (_0x5b8390.option == "Sst") UI["adminConsoleDialog"]["serverStats"](_0x5b8390["cpu"], _0x5b8390.ram); else {
                                                                        if (_0x5b8390.option == "Arl") UI.adminConsoleDialog.roomList(_0x5b8390["rooms"]); else {
                                                                          if (_0x5b8390["option"] == "Afl") UI["adminConsoleDialog"]["feedbackList"](_0x5b8390.feedback); else {
                                                                            if (_0x5b8390["option"] == "Acl") UI.adminConsoleDialog["clientList"](_0x5b8390["clients"]); else {
                                                                              if (_0x5b8390["option"] == "Abl") UI["adminConsoleDialog"]["banList"](_0x5b8390.bans); else {
                                                                                if (_0x5b8390["option"] == "Ael") UI["adminConsoleDialog"]["eventList"](_0x5b8390["events"]); else _0x5b8390["option"] == "Aci" && UI["adminConsoleDialog"]["accountInfo"](_0x5b8390["account"], _0x5b8390["rooms"]);
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                } else {
                                                                  if (_0x5b8390["command"] == "ADMINREQRESPONSE") UI["adminConsoleDialog"]["gotResponse"](_0x5b8390); else {
                                                                    if (_0x5b8390["command"] == "BROADCAST") _0x5b8390["from"] in room["users"] && room.users[_0x5b8390["from"]]["pushNetCode"](_0x5b8390); else _0x5b8390.command == "BYE" && this.disconnect(true);
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ["execFrame"]() {
    if (this.ws["readyState"] === this.ws["OPEN"]) while (this["outBuffer"]["length"] > 0) {
      this.ws["send"](this["outBuffer"]["shift"]());
    }
  }
}
class ConnectionManager {
  constructor(_0x4b1209) {
    this["connection"] = _0x4b1209, this.connectTries = 0, this["maxTries"] = localStorage.getItem("unlimitedReconnect") === "true" ? 1000000 : 10, this["actionTarget"] = "SHOWROOMS";
    var _0x595f77 = this;
    $(this["connection"]).on("socketConnected", function (_0xc922bb) {
      UI["warningContainer"]["empty"](), UI["statusContainer"]["empty"]();
    }), $(this["connection"]).on("socketError", function (_0x1b72e0) {
      socket.canReconnect && _0x595f77.reconnect();
    }), $(this.connection).on("socketDisconnected", function (_0x3637de) {
      UI["inRoom"] && (_0x595f77.actionTarget = "SHOWROOMS", !_0x3637de.intentional && (_0x595f77.actionTarget = "JOINROOM"), room.setConnected(false), _0x595f77.reconnect()), UI.statusContainer["html"]("<div class=\"warningItem\">" + new Icon("fa-unlink")["html"]() + " ...</div>");
    }), $(this.connection).on("socketNegotiated", function (_0x3c7d3a) {
      _0x595f77.noContactCount = 0;
      if (_0x595f77["actionTarget"] == "JOINROOM") UI["loginDialog"]["doLogin"](); else {
        var _0x2501a2 = {};
        _0x2501a2["command"] = "OFFROOM", _0x2501a2["option"] = "ROOMS", socket["send"](_0x2501a2, true);
      }
    });
  }
  ["reconnect"](_0xadc437 = 5) {
    var _0x2d5bd6 = this;
    setTimeout(function () {
      !_0x2d5bd6["connection"]["connected"] && (socket["canReconnect"] ? ++_0x2d5bd6.connectTries >= _0x2d5bd6.maxTries ? (UI["loadingScreen"]["setText"](textManager["getString"]("alerts.txtServerDown"), new Icon("fa-exclamation-triangle")["html"]()), socket["canReconnect"] = false) : (_0x2d5bd6["connection"]["reconnect"](), _0x2d5bd6["reconnect"]()) : UI["warningContainer"]["html"]('<div class="warningItem">' + new Icon("fa-exclamation-triangle").html() + " " + textManager.getString("alerts.txtConnectionLost") + "<br /><div class=\"d-grid\"><a href=\"#\" class=\"btn btn-xs btn-primary mt-2\" name=\"socketReconnect\">" + textManager["getString"]("alerts.btnReconnect") + "</a></div></div>"));
    }, _0xadc437 * 1e3);
  }
  ["reset"]() {
    socket["canReconnect"] = true, this["connectTries"] = 0;
  }
}
class User {
  constructor(_0x11ddb0, _0xc6a5d7, _0x582e8f = "", _0x405509 = "XX", _0x13fa8e = false, _0x1dafb5 = false) {
    this.username = _0x11ddb0, this["rank"] = _0xc6a5d7, this["status"] = "", this.ip = _0x582e8f, this["country"] = _0x405509, this["proxy"] = _0x13fa8e, this.uid, this["muted"] = false, this["silenced"] = false, this["ignored"] = false, this.inactive = false, this["connectionIssues"] = false, this.chatMessages = 0, this["lastMessage"] = parseInt(new Date().getTime() / 1e3), this["inputDevice"] = "mouse", this["surface"] = new PenSurface(_0x1dafb5), this["surface"]["setUsername"](this["username"]), this.frameBuffer = new FrameBuffer(this);
  }
  ["isStaff"]() {
    return this["rank"] == "GM" || this["rank"] == "RO" || this["rank"] == "CO" || this.rank == "LM" || this.rank == "FM" || this["rank"] == "TU";
  }
  ["isLogged"]() {
    return this["rank"] != "UU";
  }
  ["changeInputDevice"](_0x3f4588) {
    this["inputDevice"] != _0x3f4588 && (this["inputDevice"] = _0x3f4588, $(this)["triggerHandler"](new inputDeviceChangedEvent(_0x3f4588)["getEvent"]()));
  }
  ["changeInactive"](_0xc5302a) {
    this["inactive"] != _0xc5302a && (this["inactive"] = _0xc5302a, $(this)["triggerHandler"](new inactiveChangedEvent(_0xc5302a)["getEvent"]()));
  }
  ["changeStatus"](_0x1f55ae) {
    this["status"] != _0x1f55ae && (this["status"] = _0x1f55ae, $(this)["triggerHandler"](new statusChangedEvent(_0x1f55ae)["getEvent"]()));
  }
  ["changeConnectionIssue"](_0x3e0726) {
    this["connectionIssues"] != _0x3e0726 && (this["connectionIssues"] = _0x3e0726, $(this)["triggerHandler"](new connectionIssueChangedEvent(_0x3e0726)["getEvent"]()));
  }
  ["changeUsername"](_0x351821) {
    if (this["username"] != _0x351821) {
      var _0x16b23a = this["username"];
      this["username"] = _0x351821, this.surface["setUsername"](this["username"]), $(this).triggerHandler(new usernameChangedEvent(_0x351821, _0x16b23a)["getEvent"]());
    }
  }
  ["changeRank"](_0x19f16a) {
    this.rank != _0x19f16a && (this["rank"] = _0x19f16a, $(this)["triggerHandler"](new rankChangedEvent(_0x19f16a)["getEvent"]()));
  }
  ["mute"]() {
    !this.muted && (this.muted = true, this["surface"].penCancel(), this["surface"]["penHide"](), $(this)["triggerHandler"](new muteChangedEvent(true)["getEvent"]()));
  }
  ["unmute"]() {
    this["muted"] && (this["muted"] = false, this["surface"].penShow(), $(this).triggerHandler(new muteChangedEvent(false)["getEvent"]()));
  }
  ["changeMute"](_0x25f308) {
    _0x25f308 ? this["mute"]() : this["unmute"]();
  }
  ["silence"]() {
    !this["silenced"] && (this["silenced"] = true, $(this)["triggerHandler"](new silenceChangedEvent(true).getEvent()));
  }
  ["unsilence"]() {
    this["silenced"] && (this["silenced"] = false, $(this).triggerHandler(new silenceChangedEvent(false)["getEvent"]()));
  }
  ["changeSilence"](_0x42b536) {
    _0x42b536 ? this["silence"]() : this["unsilence"]();
  }
  ["ignore"]() {
    !this.ignored && (this.ignored = true, $(this)["triggerHandler"](new ignoreChangedEvent(true).getEvent()));
  }
  ["unignore"]() {
    this["ignored"] && (this.ignored = false, $(this)["triggerHandler"](new ignoreChangedEvent(false)["getEvent"]()));
  }
  ["toggleIgnore"]() {
    this["ignored"] ? this.unignore() : this["ignore"]();
  }
  ["hasIP"]() {
    return !(this.ip == "" || this.ip == "-");
  }
  ["alone"](_0x510b7a) {
    this.frameBuffer["alone"](_0x510b7a);
  }
  ["pushNetCode"](_0x3b6d5a) {
    this["frameBuffer"]["pushNetCode"](_0x3b6d5a);
  }
}
const ScrollCounter = (() => {
  let tickCount = 0;
  let lastLogTime = Date.now();
  let scrollsPerSecond = 0;

  // Event listener to count scroll ticks
  window.addEventListener('wheel', () => {
      tickCount++;
  });

  // Update scrolls per second every 250ms for faster feedback
  setInterval(() => {
      const now = Date.now();
      const elapsedTime = (now - lastLogTime) / 1000; // Time in seconds
      const smoothingFactor = 0.7; // Smoothing factor for gradual adjustments

      const currentScrolls = tickCount / elapsedTime; // Calculate current scrolls per second
      scrollsPerSecond = scrollsPerSecond * smoothingFactor + currentScrolls * (1 - smoothingFactor); // Smoothed value

      tickCount = 0; // Reset tick count
      lastLogTime = now; // Update time
  }, 250); // Update every 250ms

  return {
      getScrollsPerSecond: () => Math.min(scrollsPerSecond, 6) // Cap at 6
  };
})();

const mouseWheelMode = localStorage.getItem("mouseWheelMode") || "vanillaFM";
const positionAwareMirroring = localStorage.getItem("positionAwareMirroring") === "true";
const rmbActionFix = localStorage.getItem("rmbActionFix") === "true";
const persistentBoardSync = localStorage.getItem('persistentBoardSync');

const reconnectAwareSync = localStorage.getItem('reconnectAwareSync');

// Shared state tracking
let counter = 0;
let lastDisconnectedTime = null;
let mustSync = false;
let firstSyncDone = false;
let syncMade = false;

// Function to return whether syncing is required
function shouldSync() {
    return mustSync;
}

function hasSyncBeenMade() {
  return syncMade
}

function isSyncedNow() {
  return hasSyncBeenMade() && !shouldSync();
}

// IIFE that checks connection state every 10ms
function monitorConnection() {
  setInterval(() => {
      counter++; // Increment counter (for tracking, not used in logic)

      // Only track disconnection time if we're actually in a room (not in Lobby Browser)
      if (!room?.name || room.name === "Lobby Browser") {
          lastDisconnectedTime = null;
          mustSync = false;
          return;
      }

      if (!room.connected) {
          if (lastDisconnectedTime === null) {
              lastDisconnectedTime = Date.now();
          }
          if (Date.now() - lastDisconnectedTime > 20000) {
              mustSync = true;
          }
      } else {
          if (lastDisconnectedTime !== null && Date.now() - lastDisconnectedTime <= 20000) {
              mustSync = false;
          }
          lastDisconnectedTime = null;
      }
  }, 50);
}

monitorConnection();

// ...existing code...

let isConnected = false;
let isStableConnection = false;
let lastConnectionChangeTime = null;

function monitorRoomConnection() {
  setInterval(() => {
    const now = Date.now();

    if (room?.connected) {
      if (!isConnected) {
        // Connection just went from false to true
        isConnected = true;
        lastConnectionChangeTime = now;
      }
      // Check if 5 seconds have passed since connection
      if (now - lastConnectionChangeTime >= 1200) {
        isStableConnection = true;
      }
    } else {
      if (isConnected) {
        // Connection just went from true to false
        isConnected = false;
        isStableConnection = false;
        lastConnectionChangeTime = now;
      }
    }
  }, 100);
}

monitorRoomConnection();
class UserInterface {
  constructor() {
    this["initialized"] = false, this["configured"] = false, this["pointerSupport"] = window["PointerEvent"], this["userPreferences"], this["clientId"] = Math.floor(Math.random() * 999999 + 1), this["clientName"] = "FlockMod", this["client"] = "FMH5C", this.version = "13.4.0+0", this["account"] = new Account("Anonymous", ""), this["baseURL"] = "https://" + domain, this.baseDir = "/draw/", this["hasSetCustomBrush"] = false, this["firstSyncEnabled"] = false, this.firstSyncProgress = false, this["firstSyncUser"] = null, this["firstSyncFailed"] = [], this["firstSyncOrder"] = [], this["manualSync"] = null, this["content"], this["drawingArea"], this["boardContainer"], this["warningContainer"], this["statusContainer"], this["uploader"], this["dragRotation"] = 0, this["dragInitialRotation"] = 0, this["dragPoint"] = null, this.timeDiff = 0, this.warnExit = false, this.pinching = false, this["hovering"] = false, this["draggingMode"] = false, this["preDraggingMode"] = false, this["gesturesSize"] = 1, this["gesturesPreAngle"] = 0, this["gesturesRotateAngle"] = 0, this.gesturesCurrentAngle, this["resizeTimeout"] = undefined, this["viewLeft"], this["viewTop"], this["viewWidth"], this.viewHeight, this["limitedViewSize"] = false, this.viewOffset = new Point(0, 0), this["screenWidth"], this["screenHeight"], this["flipX"] = false, this["pixelSmoothing"] = true, this["savedOption"] = {}, this["drawingWithPointer"] = null, this["onFocus"] = true, this["focusTimer"], this.focusedElement = null, this.uploadMode = false, this.muteInterval = null, this["muteSeconds"] = 0, this["topbar"], this["bottombar"], this.sidebar, this["mousePointer"], this["hammer"], this["overBoard"] = false, this.holdingCTRL = false, this.holdingALT = false, this["holdingSHIFT"] = false, this.soundSystem, this["dialogHandler"], this["chatDialog"], this["configDialog"], this["loginDialog"], this["undoDialog"], this["saveDialog"], this["uploadDialog"], this["brushDesignerDialog"], this["brushGalleryDialog"], this["debugDialog"], this["profileDialog"], this.colorDialog, this["helpDialog"], this["feedbackDialog"], this["animationDialog"], this["messengerDialog"], this["galleryImageDialog"], this["userGalleryDialog"], this["shortcutManager"], this["tooltips"], this.selectionToolbar, this.userRanks = ["UU", "RU", "TU", "RM", "FM", "LM", "CO", "RO", "GM"], this["userPrivileges"] = ["roommanager", "changeprivileges", "addmod", "rmstaff", "mute", "kick", "silence", "ban", "roombans", "unbanothers", "changetools", "mergelayer", "clearlayer", "fliplayer", "locklayers", "drawlockedlayers", "modmessageuse", "pload", "pundo", "seehigherips", "seelowerips", "seesameips", "bypasspwd", "bypassfull", "manageframes"], this["toolbarSide"], this["defaultBrush"] = "pen", this["defaultColor"] = "#000000", this["inRoom"] = false, this["preferredLanguage"] = navigator["language"].split("-")[0], this["_tmp"];
    
    // Line interpolation feature - initialize based on localStorage
    this.lineInterpolationEnabled = localStorage.getItem("lineInterpolation") === "true";
    
    if (reconnectAwareSync === 'true') {
      this.recommendedSync = this.recommendedSyncModified;
    }
    else {this.recommendedSync = this.recommendedSyncDefault}
    if (persistentBoardSync === 'true') {
      this.fitToScreen = this.fitToScreenModified
      this.centerBoard = this.centerBoardModified
      this.bindEventsRoom = this.bindEventsRoomModified
    }
    if (mouseWheelMode === "cap") { 
      this.onWheelMove = this.onWheelMoveCap;
    } else if (mouseWheelMode === "fasterScroll") {
      this.onWheelMove = this.onWheelMoveFaster;
    }
      else {
        this.onWheelMove = this.onWheelMoveDefault
      }
    if (positionAwareMirroring === true) { // Directly compare it as a boolean
      this.flipView = this.flipViewEnabled;
    } else {
      this.flipView = this.flipViewDisabled;
    }
    if (rmbActionFix === true) { // Directly compare it as a boolean
      this.bindEventsBoard = this.bindEventsBoardEnabled;
    } else {
      this.bindEventsBoard = this.bindEventsBoardDisabled;
    }

    this.undoHistoryEnabled = false; // Default enabled
    if (localStorage.getItem("undoHistoryEnabled") === "false") {
      this.undoHistoryEnabled = false;
    }
    // Ensure localStorage is set on initialization
    localStorage.setItem("undoHistoryEnabled", this.undoHistoryEnabled.toString());
  }
  

  ["buildContextMenu"]() {
    var _0x245d50 = this;
    $["contextMenu"]({
      selector: ".boardMenu",
      trigger: "none",
      build: function (_0x3da98d) {
        var _0x43e3e0 = {
          callback: function (_0x18cdfa, _0x1c70bb) {
            if (_0x18cdfa == "zoomin") {
              var _0x2d6238 = _0x245d50["drawingArea"]["width"](),
                _0x45495b = _0x245d50.drawingArea["height"](),
                _0x1293b8 = _0x245d50["drawingArea"].offset();
              _0x245d50["zoomToScreenPoint"](_0x2d6238 / 2 + _0x1293b8["left"], _0x45495b / 2 + _0x1293b8["top"], "zoomIn");
            } else {
              if (_0x18cdfa == "zoomout") {
                var _0x2d6238 = _0x245d50["drawingArea"]["width"](),
                  _0x45495b = _0x245d50["drawingArea"]["height"](),
                  _0x1293b8 = _0x245d50["drawingArea"].offset();
                _0x245d50["zoomToScreenPoint"](_0x2d6238 / 2 + _0x1293b8["left"], _0x45495b / 2 + _0x1293b8["top"], "zoomOut");
              } else {
                if (_0x18cdfa == "resetzoom") room.board["changeScale"](1), _0x245d50["centerBoard"](); else {
                  if (_0x18cdfa == "rotatereset") room["board"]["changeRotation"](0); else {
                    if (_0x18cdfa == "rotate45left") room["board"].changeRotation(room["board"]["rotation"] - 45); else {
                      if (_0x18cdfa == "rotate45right") room["board"]["changeRotation"](room["board"].rotation + 45); else {
                        if (_0x18cdfa == "centerboard") _0x245d50["centerBoard"](); else {
                          if (_0x18cdfa == "fittoscreen") _0x245d50["fitToScreen"](); else _0x18cdfa == "fliphorizontally" && _0x245d50["flipView"](!_0x245d50.flipX);
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          items: {
            resetzoom: {
              name: "Reset zoom",
              icon: "fa-magnifying-glass"
            },
            zoomin: {
              name: "Zoom in",
              icon: "fa-magnifying-glass-plus"
            },
            zoomout: {
              name: "Zoom out",
              icon: "fa-magnifying-glass-minus"
            },
            "-": {
              type: "cm_separator"
            },
            rotatereset: {
              name: "Reset rotation",
              icon: "fa-rotate"
            },
            rotate45left: {
              name: "Rotate left",
              icon: "fa-rotate-left"
            },
            rotate45right: {
              name: "Rotate right",
              icon: "fa-rotate-right"
            },
            fliphorizontally: {
              name: "Flip horizontally",
              icon: "fa-arrows-alt-h"
            },
            "-2": {
              type: "cm_separator"
            },
            fittoscreen: {
              name: "Fit to screen",
              icon: "fa-expand-arrows-alt"
            },
            centerboard: {
              name: "Center board",
              icon: "fa-bullseye"
            }
          }
        };
        return $.each(_0x43e3e0.items, function (_0x8f82b1, _0x5eae7e) {
          _0x43e3e0["items"][_0x8f82b1]["name"] && (_0x43e3e0["items"][_0x8f82b1].name = function () {
            return textManager["getString"]("menu.boardMenu." + _0x8f82b1, null, false);
          });
        }), _0x43e3e0;
      }
    });
  }
  ["moveSidebar"](_0x779d35) {
    if (this.toolbarSide != _0x779d35) {
      let _0x5e40f9 = _0x779d35["toLowerCase"]() == "right";
      $(".contentScreen")["removeClass"](_0x5e40f9 ? "leftSidebar" : "rightSidebar")["addClass"](_0x5e40f9 ? "rightSidebar" : "leftSidebar"), this["dialogHandler"]["alertManager"].changeSide(_0x5e40f9), this["updateViewLimits"](), this["toolbarSide"] = _0x779d35;
    }
  }
  ["loadTheme"](_0x29b285, _0xbb5546 = true) {
    _0xbb5546 && this["hideScreen"]();
    $("head link[name=\"currentTheme\"]")["attr"]("href", this["baseDir"] + "themes/" + _0x29b285 + ".css?v=" + UI["version"]);
    if (_0xbb5546) {
      var _0x3c4c20 = this;
      setTimeout(function () {
        _0x3c4c20["showScreen"]();
      }, 1500);
    }
  }
    ["applyCustomBackgroundColor"]() {
    // Initialize the state tracking property if it doesn't exist
    if (this.customBgActive === undefined) {
      this.customBgActive = false;
    }
    
    // Get the saved color from localStorage
    const savedColor = localStorage.getItem(config.localStorageKeys.backgroundColor) || "#000000";
    
    // Check if custom background is active
    if (this.customBgActive) {
      // Custom BG is currently active, so deactivate it and restore original color
      if (this.savedBgColor) {
        room.changeBackground(this.savedBgColor);
      }
      
      // Update UI state
      this.bottombar.unselectButton("customBgColorButton");
      this.boardContainer.removeClass("customBgEnabled");
      this.customBgActive = false;
    } else {
      // Custom BG is not active, so activate it and apply custom color
      
      // Save the current background color
      this.savedBgColor = room.board.backgroundColor;
      
      // Change to custom background color
      if (savedColor && savedColor !== "undefined") {
        room.changeBackground(savedColor);
      }
      
      // Update UI state
      this.bottombar.selectButton("customBgColorButton");
      this.boardContainer.addClass("customBgEnabled");
      this.customBgActive = true;
    }
  }
  ["setup"](_0x23ec5e) {
    if (!this["initialized"]) {
      var _0x4f7d6d = $("<div />");
      $(".contentScreen")["append"](_0x4f7d6d), this["loadingScreen"] = new LoadingScreen(_0x4f7d6d), this.loadingScreen["show"](), this["screenWidth"] = window["screen"]["width"], this["screenHeight"] = window["screen"]["height"], this["userPreferences"] = new UserPreferences(storage), this.soundSystem = new SoundSystem(), this["content"] = _0x23ec5e, this["drawingArea"] = _0x23ec5e.find("#DrawingArea"), this.boardContainer = _0x23ec5e["find"](".boardContainer"), this["warningContainer"] = $("#warningContainer"), this["statusContainer"] = $("#statusContainer"), this["boardContainer"]["empty"]();
      var _0x262c5d = this;
      this["content"].on(UI["pointerEvent"]("dragstart"), function (_0x3255ce) {
        _0x3255ce["preventDefault"]();
      }), this["pip"] = new PIP($("#pip")), this["pip"]["hide"](), this["dialogHandler"] = new DialogHandler($("#dialogContainer"), $("#confirmationContainer"), $("#alertContainer")), $(this["dialogHandler"]).on("dialogOpened", function (_0x262c11) {
        _0x262c5d["setCurrentPointer"](null);
      }), this["mousePointer"] = new MousePointer($("body")), this["createShortcutManager"](), this["tooltips"] = new Tooltip(this.dialogHandler["container"]), this["drawingArea"].on("wheel", this["onWheelMove"]), this["buildContextMenu"](), this["bindEventsDocument"](), this["createBrushSelectionToolbar"](), this["loadTheme"](this["userPreferences"]["getProperty"]("theme", "dark"), false), this.moveSidebar(this["userPreferences"]["getProperty"]("toolbarside", "right")), this.radialMenu = new RadialMenu($("#tabletMenu")), this.radialMenu["addOption"]("size", textManager["getString"]("[html]radialMenu.lblSize")), this["radialMenu"].addOption("nexttool", textManager["getString"]("[html]radialMenu.lblNextTool")), this["radialMenu"].addOption("swapcolors", textManager["getString"]("[html]radialMenu.lblSwapColors")), this["radialMenu"]["addOption"]("pan", textManager.getString("[html]radialMenu.lblPan")), this["radialMenu"]["addOption"]("swaperaser", textManager["getString"]("[html]radialMenu.lblSwapEraser")), this["radialMenu"].addOption("prevtool", textManager["getString"]("[html]radialMenu.lblPreviousTool")), this["radialMenu"]["hide"](), !this["userPreferences"].hasProperty("language") && textManager["isSupportedLanguage"](this["preferredLanguage"]) && this["userPreferences"]["setProperty"]("language", this.preferredLanguage), this["hammer"] = new Hammer(_0x262c5d["boardContainer"][0]), this["hammer"].get("pinch")["set"]({
        enable: true
      }), this["hammer"].on("pinchstart", function (_0x5621d9) {
        _0x262c5d["pinching"] = true, _0x262c5d["gesturesPreAngle"] = 0, _0x262c5d["gesturesRotateAngle"] = room["board"]["rotation"], _0x262c5d.gesturesSize = _0x262c5d.boardContainer[0].getBoundingClientRect().width / _0x262c5d["boardContainer"][0]["offsetWidth"], room.myself.surface["penCancel"]();
      }), this["hammer"].on("pinchmove", function (_0x210d41) {
        _0x262c5d["gesturesPreAngle"] == 0 ? _0x262c5d.gesturesPreAngle = Math["round"](_0x210d41["rotation"]) : (_0x262c5d["gesturesCurrentAngle"] = _0x262c5d.gesturesRotateAngle + Math["round"](_0x210d41["rotation"]) - _0x262c5d["gesturesPreAngle"], _0x262c5d.boardContainer["css"]({
          transform: "scale(" + _0x262c5d["gesturesSize"] * _0x210d41["scale"] + ") rotate(" + _0x262c5d.gesturesCurrentAngle + "deg)"
        }));
      }), this["hammer"].on("pinchcancel", function (_0x2b2634) {
        _0x262c5d["pinching"] = false, room.board["changeScale"](100), room.board["changeRotation"](0);
      }), this["hammer"].on("pinchend", function (_0x5964e7) {
        _0x262c5d["pinching"] = false;
        !isNaN(_0x262c5d.gesturesCurrentAngle) && room["board"]["changeRotation"](_0x262c5d["gesturesCurrentAngle"]);
        let _0x3a0885 = _0x262c5d["gesturesSize"] * _0x5964e7["scale"];
        !isNaN(_0x3a0885) && room["board"]["changeScale"](_0x3a0885);
      }), $(this).on("firstSyncStarted", function (_0x1a425d) {
        _0x262c5d["firstSyncUser"] = _0x1a425d["username"], _0x262c5d.firstSyncEnabled = true, _0x262c5d["firstSyncProgress"] = false, _0x262c5d["hideScreen"](_0x1a425d["username"], true, 0.7);
        
        // Check if skipSyncing is enabled
        const skipSyncingEnabled = localStorage.getItem("skipSyncing") === "true";
        
        // Build text based on skipSyncing setting
        let loadingText = textManager["getString"]("global.lblRequestingBoard", _0x1a425d["username"], false);
        
        // If skipSyncing is true, always show the skip button visible
        if (skipSyncingEnabled) {
          loadingText += "<br /><br /><a href=\"#\" name=\"skipUserSync\">" + textManager["getString"]("global.lblSkipUserSync") + "</a>";
        }
        
        // Always add the leave room button
        loadingText += "<br /><a href=\"#\" name=\"leaveRoom\">" + textManager.getString("global.lblCancelAndLeave") + "</a>";
        
        _0x262c5d["loadingScreen"].setText(loadingText);
        room["loading"] = true;
        
        var _0x56f712 = 15;
        setTimeout(function () {
          !_0x262c5d["firstSyncProgress"] && room["session"] == _0x1a425d.roomsession && $(_0x262c5d)["triggerHandler"](new firstSyncEndedEvent(_0x1a425d["username"], true).getEvent());
        }, _0x56f712 * 1e3);
      }), $(this).on("firstSyncProgress", function (_0x32f9fc) {
        !_0x262c5d.firstSyncProgress && (
          function() {
            // Check if skipSyncing is enabled
            const skipSyncingEnabled = localStorage.getItem("skipSyncing") === "true";
            
            // Build text based on skipSyncing setting
            let progressText = textManager["getString"]("global.lblSyncingWith", _0x32f9fc["username"], false);
            
            // If skipSyncing is true, always show the skip button visible
            if (skipSyncingEnabled) {
              progressText += '<br /><a href="#" name="skipUserSync">' + textManager["getString"]("global.lblSkipUserSync") + "</a>";
            } else {
              // Original behavior - hidden skip button that fades in
              progressText += '<br /><a href="#" class="skipSyncLink" style="opacity: 0" name="skipUserSync">' + textManager["getString"]("global.lblSkipUserSync") + "</a>";
            }
            
            // Always add the leave room button
            progressText += "<br /><a href=\"#\" name=\"leaveRoom\">" + textManager["getString"]("global.lblCancelAndLeave") + "</a>";
            
            _0x262c5d["loadingScreen"]["setText"](progressText);
            
            // Only do the animation if skipSyncing is false (original behavior)
            if (!skipSyncingEnabled) {
              setTimeout(function () {
                _0x262c5d.firstSyncFailed["length"] < Object["keys"](room["users"]).length - 1 && _0x262c5d["loadingScreen"].container["find"]('[name="skipUserSync"]')["animate"]({
                  opacity: 1
                }, 2e3);
              }, 3e3);
            }
          }()
        ), _0x262c5d["firstSyncProgress"] = true, _0x262c5d["loadingScreen"]["showProgress"](_0x32f9fc["progress"]);
      }), $(this).on("firstSyncEnded", function (_0x372916) {
        _0x262c5d.firstSyncUser = null, _0x262c5d["firstSyncEnabled"] = false, room.loading = false;
        if (_0x372916.failed) {
          _0x262c5d.firstSyncFailed["push"](_0x372916["username"]);
          var _0x111529 = false;
          room["connected"] && $["each"](_0x262c5d["firstSyncOrder"], function (_0x1b0da6, _0x47ab8f) {
            !inArray(_0x47ab8f, _0x262c5d.firstSyncFailed) && (_0x262c5d["syncBoard"](_0x47ab8f, true), _0x111529 = true);
          }), !_0x111529 && _0x262c5d["showScreen"]();
        } else _0x262c5d.firstSyncFailed = [], _0x262c5d["showScreen"]();
      }), $(this.radialMenu).on("penMove", function (_0x4afe1b) {        
        if (_0x262c5d["radialMenu"]["pressedButton"] == "size") {
          if (!room.myself["surface"].brushHandler["isOptionReadOnly"]("size")) {
            var _0x258613 = _0x262c5d["mousePointer"].position.y - _0x262c5d.radialMenu["position"].y,
              _0x23d740 = 125,
              _0x347c06 = (_0x23d740 - _0x258613) * 100 / _0x23d740;
            _0x262c5d["radialMenu"]["setSlider"]("size", _0x347c06), room["myself"]["surface"]["setBrushOption"]("size", parseInt(_0x347c06 * room["myself"].surface["maxSize"] / 100));
          }
        }
      }), $(this.radialMenu).on("buttonPressed", function (_0x43d897) {
        if (_0x43d897.id == "nexttool") _0x262c5d["sidebar"]["toolbar"]["selectNextTool"](); else {
          if (_0x43d897.id == "prevtool") _0x262c5d["sidebar"]["toolbar"]["selectPreviousTool"](); else {
            if (_0x43d897.id == "swaperaser") room["myself"]["surface"]["getCurrentBrush"]() == "eraser" ? _0x262c5d["sidebar"]["toolbar"]["selectPreviouslyUsed"]() : _0x262c5d["sidebar"]["toolbar"]["select"]("eraser"); else {
              if (_0x43d897.id == "swapcolors") _0x262c5d.sidebar["colorBox"]["swap"](); else {
                if (_0x43d897.id == "size") {
                  if (!room.myself.surface.brushHandler["isOptionReadOnly"]("size")) {
                    var _0x5d1037 = _0x262c5d["mousePointer"].position.y - _0x262c5d.radialMenu["position"].y,
                      _0x36e786 = 125,
                      _0x5e2a17 = (_0x36e786 - _0x5d1037) * 100 / _0x36e786;
                    _0x262c5d.radialMenu["setSlider"]("size", _0x5e2a17), room["myself"]["surface"]["setBrushOption"]("size", parseInt(_0x5e2a17 * room.myself["surface"].maxSize / 100));
                  }
                } else _0x43d897.id == "pan" && (room["myself"]["surface"]["getCurrentBrush"]() == "drag" ? _0x262c5d.sidebar["toolbar"]["selectPreviouslyUsed"]() : _0x262c5d.sidebar.toolbar["select"]("drag"));
              }
            }
          }
        }
      }), this["topbar"] = new Topbar($("#topbar"), this["clientName"], this["version"]), $(this["topbar"]).on("buttonPressed", function (_0xdad40d) {
        if (_0xdad40d.id == "fullscreenButton") _0x262c5d.toggleFullscreen(); else {
          if (_0xdad40d.id == "chatButton") _0x262c5d["dialogHandler"]["showDialog"]("chat"); else {
            if (_0xdad40d.id == "configButton") _0x262c5d["dialogHandler"].showDialog("config"); else {
              if (_0xdad40d.id == "leaveButton") {
                var _0x111bdd = _0x262c5d["dialogHandler"]["createConfirmation"](textManager.getString("messages.lblLeaveRoom"));
                _0x111bdd.on("confirmationClosed", function (_0x1b8ad2) {
                  if (_0x1b8ad2["response"] == "ok") {
                    _0x262c5d["leaveRoom"]();
                    window.clearUndoHistory();
                    dc_boardpos_x = undefined;
                    dc_boardpos_y = undefined;
                    dc_zoom = undefined;
                    dc_color = undefined;
                    dc_tool = undefined;
                    dc_tool_settings = undefined;
                    // console.log('left room')
                    firstSyncDone = false;
                    room.name = "Lobby Browser";
                  }
                  _0x262c5d["dialogHandler"]["destroyConfirmation"]();
                });
              }
            }
          }
        }
        _0xdad40d.element && _0xdad40d["element"]["blur"]();
      }), this.bottombar = new Bottombar($("#bottombar"));
// ...existing code...
// Initialize UI state for socket buttons


// Ensure socket buttons are hidden by default
this.bottombar.hideButton('socketConnectButton');
this.bottombar.hideButton('socketDisconnectButton');

// Get socket button visibility preferences from localStorage
const socketConnectVisible = localStorage.getItem(config.localStorageKeys.socketConnectVisible) === "true";
const socketDisconnectVisible = localStorage.getItem(config.localStorageKeys.socketDisconnectVisible) === "true";

// Show buttons based on preferences
if (socketConnectVisible) {
  this.bottombar.showButton('socketConnectButton');

}

if (socketDisconnectVisible) {
  this.bottombar.showButton('socketDisconnectButton');

}

const backgroundColorButtonVisible = localStorage.getItem(config.localStorageKeys.backgroundColorEnabled) === "true";

if (backgroundColorButtonVisible) {
  this.bottombar.showButton('customBgColorButton');
} else {
  this.bottombar.hideButton('customBgColorButton');
}

// Initialize UI state based on default undo history behavior setting


// First, ensure all buttons are hidden by default
this.bottombar.hideButton('toggleUndoHistoryButton');
this.bottombar.hideButton('commitUndoHistoryButton');
this.bottombar.hideButton('clearUndoHistoryButton');
this.bottombar.hideButton('executeUndoAction');
this.bottombar.hideButton('executeRedoAction');

// Get button visibility preferences
const toggleUndoHistory = localStorage.getItem("toggleUndoHistory") === "true";
const commitUndoHistory = localStorage.getItem("commitUndoHistory") === "true";
const clearUndoHistory = localStorage.getItem("clearUndoHistory") === "true";
const undoAction = localStorage.getItem("undoAction") === "true";
const redoAction = localStorage.getItem("redoAction") === "true";

// Get the default behavior setting - default to "disabled" if undefined
const undoHistoryDefault = localStorage.getItem("undoHistoryDefault") || "disabled";


// Determine initial enabled state based on default setting
if (undoHistoryDefault === "enabled") {
  // Always enable on start
  this.undoHistoryEnabled = true;
  // Save this state to localStorage for "recorded" option
  localStorage.setItem("undoHistoryEnabled", "true");

} else if (undoHistoryDefault === "disabled") {
  // Always disable on start
  this.undoHistoryEnabled = false;
  // Save this state to localStorage for "recorded" option
  localStorage.setItem("undoHistoryEnabled", "false");

} else {
  // "recorded" - Use the last recorded state or default to DISABLED
  const lastRecordedState = localStorage.getItem("undoHistoryEnabled");
  this.undoHistoryEnabled = lastRecordedState === "true"; // Only true if explicitly "true"
  // If no recorded state existed, save the default (false)
  if (lastRecordedState === null) {
    localStorage.setItem("undoHistoryEnabled", "false");
  }
}

// Show buttons based on preferences (only if explicitly true)
if (toggleUndoHistory === true) {
  this.bottombar.showButton('toggleUndoHistoryButton');
}

if (commitUndoHistory) {
  this.bottombar.showButton('commitUndoHistoryButton');

}

if (clearUndoHistory) {
  this.bottombar.showButton('clearUndoHistoryButton');

}

if (undoAction) {
  this.bottombar.showButton('executeUndoAction');

}

if (redoAction) {
  this.bottombar.showButton('executeRedoAction');

}

// Update UI to match the enabled state
if (this.undoHistoryEnabled) {
  // When enabled: button should be SELECTED
  this.bottombar.selectButton("toggleUndoHistoryButton");
} else {
  // When disabled: button should be UNSELECTED and class added
  this.boardContainer.addClass("undoHistoryDisabled");
  this.bottombar.unselectButton("toggleUndoHistoryButton");
}; $(this["bottombar"]).on("buttonPressed", function (_0x39019f) {
        if (_0x39019f.id == "flipXButton") _0x262c5d.flipView(!_0x262c5d.flipX); else {
          if (_0x39019f.id == "uploadButton") _0x262c5d["dialogHandler"]["showDialog"]("upload"); else {
            if (_0x39019f.id == "undoButton") _0x262c5d["dialogHandler"].showDialog("undo"); else {
              if (_0x39019f.id == "messengerButton") _0x262c5d["dialogHandler"].showDialog("messenger"); else {
                if (_0x39019f.id == "roomManagerButton") _0x262c5d["dialogHandler"]["showDialog"]("roommanager"); else {
                  if (_0x39019f.id == "adminConsoleButton") _0x262c5d["dialogHandler"]["showDialog"]("adminconsole"); else {
                    if (_0x39019f.id == "feedbackButton") _0x262c5d["dialogHandler"].showDialog("feedback"); else {
                      if (_0x39019f.id == "saveButton") _0x262c5d.dialogHandler["showDialog"]("save"); else {
                        if (_0x39019f.id == "modsButton") _0x262c5d.dialogHandler["showDialog"]("mods"); else {
                          if (_0x39019f.id == "socketModButton") _0x262c5d.dialogHandler["showDialog"]("socketmod"); else {
                            if (_0x39019f.id == "socketConnectButton") socket.connect(); else {
                              if (_0x39019f.id == "socketDisconnectButton") socket.disconnect(); else {
                                if (_0x39019f.id == "commitUndoHistoryButton") {
                                  // Check if uploader is active before allowing commit
                                  if (UI.uploader && UI.uploader.isVisible()) {
                                    _0x262c5d.dialogHandler.showAlert("Cannot commit step back while image transform is in progress. Please confirm or cancel the image operation first.");
                                  } else {
                                    // Find the board instance and commit all changes
                                    if (room && room.board) {
                                      room.board.commitAllPendingChanges();
                                    } else {

                                    }
                                  }
                                }  else {
                                  if (_0x39019f.id == "clearUndoHistoryButton") {
                                    window.clearUndoHistory();
                                  } else {
                                    if (_0x39019f.id == "toggleUndoHistoryButton") {
                                      // Check if uploader is active before allowing toggle
                                      if (UI.uploader && UI.uploader.isVisible()) {
                                        _0x262c5d.dialogHandler.showAlert("Cannot toggle step back while image transform is in progress. Please confirm or cancel the image operation first.");
                                      }
                                      // NEW: Use the dedicated transfer flag
                                      else if (socket && socket.isTransferInProgress) {
                                        _0x262c5d.dialogHandler.showAlert("Cannot toggle step back while board transfer is in progress. Please wait for all transfers to complete.");
                                      }
                                      // NEW: Check if there's an active selection
                                      else if (room.myself && room.myself.surface && 
                                              room.myself.surface.brushHandler.currentBrush === "selection" && 
                                              room.myself.surface.brushHandler.brush && 
                                              room.myself.surface.brushHandler.brush.isUsingSlate()) {
                                        _0x262c5d.dialogHandler.showAlert("Cannot toggle step back while a selection is active. Please complete or cancel your selection first.");
                                      }
                                      else {
                                        _0x262c5d["toggleUndoHistory"]();
                                      }
                                    } else if (_0x39019f.id == "executeUndoAction") {
                                      if (room && room.board) {
                                        room.board.undo();
                                      } else {

                                      }
                                    } else if (_0x39019f.id == "executeRedoAction") {
                                      if (room && room.board) {
                                        room.board.redo();
                                      } else {

                                      }
                                    } 
                                    else if (_0x39019f.id == "customBgColorButton") {
                                        _0x262c5d.applyCustomBackgroundColor();
                                    }
                                    else {
                                if (_0x39019f.id == "zoominButton") {
                                  var _0x46b911 = _0x262c5d["drawingArea"]["width"](),
                                    _0x8dde7d = _0x262c5d["drawingArea"]["height"](),
                                    _0x93d56b = _0x262c5d.drawingArea["offset"]();
                                  _0x262c5d["zoomToScreenPoint"](_0x46b911 / 2 + _0x93d56b["left"], _0x8dde7d / 2 + _0x93d56b["top"], "zoomIn");
                                } else {
                                  if (_0x39019f.id == "zoomoutButton") {
                                    var _0x46b911 = _0x262c5d["drawingArea"]["width"](),
                                      _0x8dde7d = _0x262c5d["drawingArea"]["height"](),
                                      _0x93d56b = _0x262c5d.drawingArea["offset"]();
                                    _0x262c5d["zoomToScreenPoint"](_0x46b911 / 2 + _0x93d56b["left"], _0x8dde7d / 2 + _0x93d56b["top"], "zoomOut");
                                  } else {
                                    if (_0x39019f.id == "centerButton") _0x262c5d.centerBoard(); else {
                                      if (_0x39019f.id == "fitButton") _0x262c5d.fitToScreen(); else {
                                        if (_0x39019f.id == "scaleLink") room["board"].changeScale(1), _0x262c5d["centerBoard"](); else {
                                          if (_0x39019f.id == "rotationLink") room["board"]["changeRotation"](0); else {
                                            if (_0x39019f.id == "toggleSmoothingButton") _0x262c5d["togglePixelSmoothing"](); else {
                                              if (_0x39019f.id == "registerButton") {
                                                var _0x52594b = {};
                                                _0x52594b["command"] = "ROOMREQUEST", _0x52594b["action"] = "Register", socket.send(_0x52594b, true);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
        }
        _0x39019f.element && _0x39019f["element"]["blur"]();
      }), $(textManager).on("localeChanged", function (_0x55b14e) {
        _0x262c5d["sidebar"] && _0x262c5d["sidebar"].layerPreview && _0x262c5d.sidebar["layerPreview"]["updateLayerCount"](true), UI["userPreferences"]["setProperty"]("language", _0x55b14e["current"]);
      }), this.setupDialogs(), this.initialized = true;
    }
  }
  ["rankToIndex"](_0x2051c0) {
    return this.userRanks["indexOf"](_0x2051c0);
  }
  ["indexToRank"](_0x7dbab5) {
    return this.userRanks[_0x7dbab5];
  }
  ["userRank"](_0x5689df, _0x36bb2f = true) {
    return textManager["getString"]("global.rank." + _0x5689df, null, _0x36bb2f);
  }
  ["userPrivilege"](_0x2ecf90, _0x88903f = true) {
    return textManager["getString"]("roommanager.privilege." + _0x2ecf90, null, _0x88903f);
  }
  ["createShortcutManager"]() {
    this.shortcutManager = new ShortcutManager(storage);
    var _0x207886 = this;
    $(this.shortcutManager).on("shortcutPressed shortcutReleased", function (_0x252a63) {
      if (_0x252a63["type"] == "shortcutPressed" && (_0x252a63["eventType"] == "keydown" || _0x252a63["eventType"] == "holdable")) {
        if (_0x252a63["stype"] == "tool") _0x207886["isToolAvailable"](_0x252a63.id) && _0x207886["sidebar"]["toolbar"].select(_0x252a63.id); else {
          if (_0x252a63["stype"] == "dialog") _0x252a63.id == "color" ? _0x207886["dialogHandler"]["getActiveDialogName"]() == "ColorDialog" ? _0x207886["colorDialog"]["hide"]() : ($(_0x207886["colorDialog"]).on("colorChanged.colorbox", function (_0x1735d5) {
            _0x207886["colorChange"](_0x1735d5["color"]), $(_0x207886.colorDialog)["off"](".colorbox");
          }), $(_0x207886["colorDialog"]).on("dialogClosed.colorbox", function (_0x41fb22) {
            $(_0x207886["colorDialog"])["off"](".colorbox");
          }), _0x207886.colorDialog["show"](_0x207886.sidebar["colorBox"]["primaryColor"])) : _0x207886.dialogHandler["toggleDialog"](_0x252a63.id); else {
            if (_0x252a63.stype == "coloroption") {
              var _0x237acc = _0x252a63.id["substr"](1),
                _0x4d57e1 = _0x252a63.id[0] == "+" ? 5 : -5,
                _0x12b152 = _0x207886["sidebar"]["colorBox"]["primaryColor"];
              _0x12b152[0] != "#" && (_0x12b152 = rgb2hex(_0x12b152));
              var _0x9cff0b = hex2rgb(_0x12b152),
                _0x28c499 = rgb2hsv(_0x9cff0b.r, _0x9cff0b.g, _0x9cff0b.b),
                _0x5a876b,
                _0x3c8802 = _0x237acc == "h" || _0x237acc == "s" || _0x237acc == "v";
              if (_0x3c8802) {
                if (_0x237acc == "h") _0x28c499.h = _0x28c499.h + _0x4d57e1; else {
                  if (_0x237acc == "s") _0x28c499.s = _0x28c499.s + _0x4d57e1; else _0x237acc == "v" && (_0x28c499.v = _0x28c499.v + _0x4d57e1);
                }
                var _0x2b39a7 = hsv2rgb(loopValue(_0x28c499.h, 360), loopValue(_0x28c499.s, 100), loopValue(_0x28c499.v, 100));
                _0x5a876b = "rgb(" + _0x2b39a7.r + "," + _0x2b39a7.g + "," + _0x2b39a7.b + ")";
              } else {
                if (_0x237acc == "r") _0x9cff0b.r = _0x9cff0b.r + _0x4d57e1; else {
                  if (_0x237acc == "g") _0x9cff0b.g = _0x9cff0b.g + _0x4d57e1; else _0x237acc == "b" && (_0x9cff0b.b = _0x9cff0b.b + _0x4d57e1);
                }
                _0x5a876b = "rgb(" + Math["min"](Math["max"](_0x9cff0b.r, 0), 255) + "," + Math.min(Math["max"](_0x9cff0b.g, 0), 255) + "," + Math.min(Math.max(_0x9cff0b.b, 0), 255) + ")";
              }
              room.myself["surface"]["setColor"](_0x5a876b);
            } else {
              if (_0x252a63["stype"] == "slideroption") {
                var _0x237acc = _0x252a63.id["substr"](1),
                  _0x4d26fe = room["myself"].surface["getBrushOptionObject"](_0x237acc),
                  _0x4d57e1 = _0x252a63.id[0] == "+" ? _0x4d26fe["step"] : _0x4d26fe["step"] * -1;
                if (room["myself"].surface["hasBrushOption"](_0x237acc)) {
                  if (!room["myself"]["surface"]["isBrushOptionReadOnly"](_0x237acc)) {
                    var _0xa2bade = room.myself["surface"]["getBrushOption"](_0x237acc);
                    room.myself["surface"]["setBrushOption"](_0x237acc, Math["max"](Math["min"](_0xa2bade + _0x4d57e1, _0x4d26fe["max"]), _0x4d26fe["min"]));
                  }
                }
              } else {
                if (_0x252a63.stype == "userlist") {
                  let _0x17d09f = _0x207886["sidebar"]["userList"]["getSelected"]();
                  if (_0x17d09f && _0x17d09f != room["myself"]["username"]) {
                    if (_0x252a63.id == "kickuser") room["myself"].surface["userRequestAction"]("Kck", _0x17d09f); else {
                      if (_0x252a63.id == "banuser") room["myself"].surface["userRequestAction"]("Bn", _0x17d09f); else {
                        if (_0x252a63.id == "muteuser") room.myself["surface"].userRequestAction("Muu", _0x17d09f); else {
                          if (_0x252a63.id == "unmuteuser") room["myself"]["surface"].userRequestAction("Umu", _0x17d09f); else {
                            if (_0x252a63.id == "silenceuser") room["myself"]["surface"].userRequestAction("Siu", _0x17d09f); else {
                              if (_0x252a63.id == "unsilenceuser") room["myself"].surface["userRequestAction"]("Usi", _0x17d09f); else _0x252a63.id == "toggleignoreuser" && room["toggleIgnoreUser"](_0x17d09f);
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (_0x252a63["stype"] == "slidercheckoption") {
                    var _0x2f20f3 = _0x252a63.id[0],
                      _0x237acc = _0x252a63.id["substr"](1);
                    if (room["myself"]["surface"]["hasBrushOption"](_0x237acc)) {
                      if (!room.myself["surface"]["isBrushOptionReadOnly"](_0x237acc)) {
                        if (room["myself"]["surface"]["brushHandler"]["brush"]["options"][_0x237acc]["isCompatible"](room["type"], room["board"]["nLayers"])) {
                          var _0xa2bade = room["myself"]["surface"].getBrushOption(_0x237acc),
                            _0x5badd9;
                          if (_0x2f20f3 == "+") _0x5badd9 = true; else {
                            if (_0x2f20f3 == "-") _0x5badd9 = false; else _0x2f20f3 == "!" && (_0x5badd9 = !_0xa2bade[0]);
                          }
                          room.myself["surface"]["setBrushOption"](_0x237acc, [_0x5badd9, _0xa2bade[1]]);
                        }
                      }
                    }
                  } else {
                    if (_0x252a63["stype"] == "checkboxoption") {
                      var _0x2f20f3 = _0x252a63.id[0],
                        _0x237acc = _0x252a63.id["substr"](1);
                      if (room["myself"].surface["hasBrushOption"](_0x237acc)) {
                        if (!room["myself"]["surface"].isBrushOptionReadOnly(_0x237acc)) {
                          if (room.myself.surface.brushHandler["brush"]["options"][_0x237acc]["isCompatible"](room.type, room["board"]["nLayers"])) {
                            var _0x5badd9;
                            if (_0x2f20f3 == "+") _0x5badd9 = true; else {
                              if (_0x2f20f3 == "-") _0x5badd9 = false; else {
                                if (_0x2f20f3 == "!") {
                                  var _0xa2bade = room["myself"]["surface"].getBrushOption(_0x237acc);
                                  _0x5badd9 = !_0xa2bade;
                                }
                              }
                            }
                            room.myself["surface"]["setBrushOption"](_0x237acc, _0x5badd9);
                          }
                        }
                      }
                    } else {
                      if (_0x252a63["stype"] == "listoption") {
                        var _0x2f20f3 = _0x252a63.id[0],
                          _0x237acc = _0x252a63.id.substr(1);
                        if (room["myself"]["surface"]["hasBrushOption"](_0x237acc)) {
                          if (!room.myself.surface["isBrushOptionReadOnly"](_0x237acc)) {
                            if (room["myself"].surface["brushHandler"]["brush"]["options"][_0x237acc]["isCompatible"](room["type"], room["board"]["nLayers"])) {
                              var _0x32178a = Object["keys"](room.myself["surface"]["brushHandler"]["brush"]["options"][_0x237acc].list),
                                _0xa2bade = room["myself"]["surface"]["getBrushOption"](_0x237acc),
                                _0x21efde = _0x32178a["indexOf"](_0xa2bade),
                                _0x42c455;
                              _0x2f20f3 == "-" ? _0x21efde + 1 > _0x32178a["length"] - 1 ? _0x42c455 = 0 : _0x42c455 = _0x21efde + 1 : _0x21efde - 1 < 0 ? _0x42c455 = _0x32178a["length"] - 1 : _0x42c455 = _0x21efde - 1, room.myself.surface["setBrushOption"](_0x237acc, _0x32178a[_0x42c455]);
                            }
                          }
                        }
                      } else {
                        if (_0x252a63["stype"] == "custom") {
                          if (_0x252a63.id == "moveboard") _0x207886.preDrag(true); else {
                            if (_0x252a63.id == "changeprimarycolor") _0x207886["sidebar"].colorBox.changePrimary(); else {
                              if (_0x252a63.id == "changesecondarycolor") _0x207886.sidebar["colorBox"]["changeSecondary"](); else {
                                if (_0x252a63.id == "swapcolors") _0x207886["sidebar"]["colorBox"]["swap"](); else {
                                  if (_0x252a63.id == "nexttool") _0x207886["sidebar"]["toolbar"].selectNextTool(); else {
                                    if (_0x252a63.id == "previoustool") _0x207886["sidebar"]["toolbar"]["selectPreviousTool"](); else {
                                      if (_0x252a63.id == "switchprev") _0x207886["sidebar"]["toolbar"].selectPreviouslyUsed(); else {
                                        if (_0x252a63.id == "fullscreen") _0x207886.toggleFullscreen(); else {
                                          if (_0x252a63.id == "zoomin") {
                                            var _0x17525a = _0x207886["drawingArea"]["width"](),
                                              _0xdd028 = _0x207886.drawingArea["height"](),
                                              _0x1d3ca7 = _0x207886["drawingArea"].offset();
                                            _0x207886["zoomToScreenPoint"](_0x17525a / 2 + _0x1d3ca7["left"], _0xdd028 / 2 + _0x1d3ca7.top, "zoomIn");
                                          } else {
                                            if (_0x252a63.id == "zoomout") {
                                              var _0x17525a = _0x207886.drawingArea.width(),
                                                _0xdd028 = _0x207886["drawingArea"].height(),
                                                _0x1d3ca7 = _0x207886["drawingArea"]["offset"]();
                                              _0x207886["zoomToScreenPoint"](_0x17525a / 2 + _0x1d3ca7["left"], _0xdd028 / 2 + _0x1d3ca7["top"], "zoomOut");
                                            } else {
                                              if (_0x252a63.id == "nextlayerup") _0x207886.sidebar["layerPreview"]["nextLayerUp"](); else {
                                                if (_0x252a63.id == "nextlayerdown") _0x207886["sidebar"]["layerPreview"]["nextLayerDown"](); else {
                                                  if (_0x252a63.id == "closedialog") _0x207886["dialogHandler"].activeDialog && _0x207886["dialogHandler"]["activeDialog"]["closable"] && (_0x207886.dialogHandler["activeDialog"]["hasModal"]() ? _0x207886["dialogHandler"]["activeDialog"]["disableModal"]() : _0x207886.dialogHandler["activeDialog"]["hide"]()); else {
                                                    if (_0x252a63.id == "maximizedialog") _0x207886["dialogHandler"]["activeDialog"] && _0x207886["dialogHandler"]["activeDialog"]["toggleMaximize"](); else {
                                                      if (_0x252a63.id == "radialmenu") {
                                                        if (_0x207886["overBoard"]) {
                                                          var _0x2841e2 = room["myself"]["surface"]["brushHandler"]["getOption"]("size");
                                                          _0x207886["radialMenu"]["setSlider"]("size", _0x2841e2 * 100 / room["myself"]["surface"].maxSize), _0x207886["radialMenu"].move(_0x207886.mousePointer["position"].x, _0x207886.mousePointer["position"].y), _0x207886["radialMenu"]["show"]();
                                                        }
                                                      } else {
                                                        if (_0x252a63.id == "leaveroom") _0x207886["leaveRoom"](); else {
                                                          if (_0x252a63.id == "rotatereset") room.board["changeRotation"](0); else {
                                                            if (_0x252a63.id == "rotate45left") room.board["changeRotation"](room.board.rotation - 45); else {
                                                              if (_0x252a63.id == "rotate45right") room["board"]["changeRotation"](room["board"]["rotation"] + 45); else {
                                                                if (_0x252a63.id == "resetzoom") room["board"]["changeScale"](1), _0x207886["centerBoard"](); else {
                                                                  if (_0x252a63.id == "fittoscreen") _0x207886["fitToScreen"](); else {
                                                                    if (_0x252a63.id == "centerboard") _0x207886["centerBoard"](); else {
                                                                      if (_0x252a63.id == "viewflip") _0x207886["flipView"](!_0x207886["flipX"]); else {
                                                                        if (_0x252a63.id == "pixelsmoothing") _0x207886.togglePixelSmoothing(); else {
                                                                          if (_0x252a63.id == "cancelstroke") room["myself"]["surface"].penCancel(); else {
                                                                            if (_0x252a63.id == "rightclick") {
                                                                              if (room["myself"]["surface"]["brushHandler"]["hasOption"]("rightclick")) {
                                                                                var _0x1a15ab = room["myself"]["surface"].brushHandler.getOption("rightclick");
                                                                                _0x207886["rightClick"](_0x1a15ab);
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (_0x252a63["stype"] == "color") {
                            var _0x5c0a85 = parseInt(_0x252a63.id["replace"]("pickcolor", ""));
                            _0x207886.bottombar.colorBubbles["loadBubble"](_0x5c0a85 - 1);
                          } else {
                            if (_0x252a63["stype"] == "preset") {
                              var _0x5c0a85 = parseInt(_0x252a63.id["replace"]("loadpreset", ""));
                              _0x207886["sidebar"]["presets"]["loadBubble"](_0x5c0a85 - 1);
                            } else _0x252a63.stype == "blendmode" && room["myself"].surface["hasBrushOption"]("blendmode") && !room["myself"].surface["isBrushOptionReadOnly"]("blendmode") && room.myself["surface"]["setBrushOption"]("blendmode", _0x252a63.id);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if (_0x252a63.type == "shortcutReleased" && (_0x252a63["eventType"] == "keyup" || _0x252a63.eventType == "holdable")) {
          if (_0x252a63.stype == "tool") _0x252a63["eventType"] == "holdable" && _0x252a63["heldFor"] > 0.3 && _0x207886["sidebar"]["toolbar"]["selectPreviouslyUsed"](); else {
            if (_0x252a63.id == "radialmenu") _0x207886.radialMenu["hide"](); else _0x252a63.stype == "custom" && _0x252a63.id == "moveboard" && _0x207886.preDrag(false);
          }
        }
      }
    });
  }
  ["playSound"](_0xb952ee) {
    this["soundSystem"] && this["soundSystem"].play(_0xb952ee);
  }
  ["leaveRoom"](_0x1ebb92 = false) {
    var _0x18dd9c = true;
    this["dialogHandler"].activeDialog && !this["dialogHanlder"]["activeDialog"].closable && (_0x18dd9c = false), (_0x18dd9c || _0x1ebb92) && (window["history"].pushState("", "FlockMod", this["baseDir"]), this["dialogHandler"].hideAll(), this["dialogHandler"]["showDialog"]("login"), this["loginDialog"]["refresh"]()), this.inRoom = false;
  }
  ["toggleFullscreen"]() {
    var _0x172522 = $(document.body)[0];
    document["fullscreenEnabled"] && (!document.fullscreenElement ? _0x172522.requestFullscreen && _0x172522["requestFullscreen"]() : document["exitFullscreen"] && document.exitFullscreen());
  }
  ["createBrushSelectionToolbar"]() {
    this.selectionToolbar = new FloatingToolbar(this["dialogHandler"]["container"]);
    this.selectionToolbar["clearButtons"]();
    this.selectionToolbar.addButton("clear", textManager["getString"]("toolbar.btnClear"), "fa-eraser");
    this.selectionToolbar["addButton"]("fill", textManager["getString"]("toolbar.btnFill"), "fa-fill-drip");
    this.selectionToolbar.addButton("move", textManager["getString"]("toolbar.btnMove"), "fa-arrows-alt");
    this["selectionToolbar"]["addButton"]("clone", textManager.getString("toolbar.btnClone"), "fa-clone");
    this.selectionToolbar["addButton"]("save", textManager["getString"]("toolbar.btnSave"), "fa-save", "btn-primary");
    this["selectionToolbar"]["addButton"]("undo", textManager["getString"]("toolbar.btnUndo"), "fa-undo", "btn-primary");
    this["selectionToolbar"]["addButton"]("sync", "Sync Selection", "fa-sync", "btn-primary");
    this.selectionToolbar["addButton"]("custom", textManager["getString"]("toolbar.btnCustomBrush"), "fa-paint-roller");
    this["selectionToolbar"]["addButton"]("cancel", textManager["getString"]("toolbar.btnCancel"), "fa-times", "btn-secondary");
    
    var _0x651fd7 = this;
    $(this["selectionToolbar"]).on("optionSelected", function (_0x1e4726) {
        var _0x158a2e = room["myself"]["surface"]["brushHandler"]["brush"];
        if (_0x1e4726["option"] == "move" || _0x1e4726["option"] == "clone") {
            var _0xb9f96d = new Array();
            if (_0x158a2e.getOption("multilayer")) {
                for (var _0x1c05ac = 0; _0x1c05ac < _0x158a2e["getOption"]("allowedlayers")["length"]; _0x1c05ac++) {
                    _0xb9f96d["push"](_0x158a2e["getOption"]("allowedlayers")[_0x1c05ac]);
                }
            } else {
                _0xb9f96d["push"](room["myself"]["surface"]["currentLayer"]);
            }
            
            if (_0xb9f96d["length"] > 0) {
                var _0x5e5bdb = 4,
                    _0x23d41a = 0;
                _0x651fd7["uploader"]["clearLayers"]();
                $.each(_0xb9f96d, function (_0x577326, _0x9afa41) {
                    var _0x37c59b = _0x158a2e.getSelectedImage(_0x9afa41);
                    _0x37c59b.then(function (_0x157187) {
                        // Fix resize offset
                        var fixResizingShift = localStorage.getItem('fixResizingShift');
                        if (fixResizingShift === 'true') {
                        var newX = _0x157187.position.x - 4.5; 
                        var newY = _0x157187.position.y - 4.5;
                        }
                        else {
                        var newX = _0x157187.position.x; 
                        var newY = _0x157187.position.y;
                        }
                        _0x651fd7["uploader"]["addLayer"](_0x157187["layer"], _0x157187.img, newX, newY, _0x5e5bdb);
                        
                        ++_0x23d41a >= _0xb9f96d["length"] && (room["myself"]["surface"]["brushParameter"]({
                            action: _0x1e4726["option"]
                        }), _0x651fd7["selectionToolbar"].hide(), _0x651fd7["uploader"]["show"]("selection", _0x1e4726["option"] == "move"));
                    });
                });
            }
        }

else if (_0x1e4726.option == "sync") {
      // Check for conditions that prevent undo
      if (socket && socket.isTransferInProgress) {
        UI.dialogHandler.showAlert("Cannot perform sync while board transfer is in progress. Please wait for all transfers to complete.");
      } else if (UI.undoHistoryEnabled) {
        UI.dialogHandler.showAlert("Cannot perform sync while step back is enabled. Please disable step back first.");
      } else if (UI.uploader && UI.uploader.isVisible()) {
        UI.dialogHandler.showAlert("Cannot perform sync while image transform is in progress. Please confirm or cancel the image operation first.");
      } else if (room && room.board && (room.board.isProcessingCommit)) {
        UI.dialogHandler.showAlert("Cannot perform sync while stroke commits are in progress. Please wait for all strokes to finish processing.");
      } else {
        // Execute the undo sync for the selection
        UI.undoDialog.undoCurrentCanvasFromConsole();
        // Hide the toolbar after sync is initiated
        this.hide();
      }
    }
    
 else {
        if (_0x1e4726.option == "custom") $(_0x651fd7.saveDialog).on("imageLoaded.toolbarSelection", function (_0x4b1f7d) {
          _0x651fd7["brushDesignerDialog"]["previewCanvas"](_0x651fd7["saveDialog"]["canvas"]["canvas"][0]), _0x651fd7["brushDesignerDialog"]["show"](), $(_0x651fd7.saveDialog)["off"](".toolbarSelection"), _0x651fd7["sidebar"]["toolbar"]["select"]("custom");
        }), _0x651fd7["saveDialog"].getBrushSelection(), this.hide(); else _0x1e4726["option"] == "save" ? (_0x651fd7["saveDialog"].show("selection"), this["hide"]()) : (_0x1e4726["option"] == "undo" && (_0x651fd7["undoDialog"].show(), _0x651fd7["undoDialog"]["changePartialSelection"]("lasso"), _0x651fd7["undoDialog"]["selection"]["setClicks"](_0x158a2e["getCoords"]()), _0x651fd7["undoDialog"]["selection"]["redraw"]()), room["myself"].surface["brushParameter"]({
          action: _0x1e4726["option"]
        }), this["hide"]());
      }
    }), $(this["selectionToolbar"]).on("floatingToolbarOpened floatingToolbarClosed", function (_0x1af45c) {
      _0x1af45c["type"] == "floatingToolbarOpened" && (_0x651fd7["isToolAvailable"]("custom") ? _0x651fd7.selectionToolbar["showButton"]("custom") : _0x651fd7["selectionToolbar"].hideButton("custom")), room["myself"]["surface"].getCurrentBrush() == "selection" && room["myself"]["surface"]["setBrushOptionReadOnly"]("selectiontype", _0x1af45c.type == "floatingToolbarOpened");
    });
  }
  ["setupDialogs"]() {
    this["chatDialog"] = this["dialogHandler"].createDialog("chat"), this["configDialog"] = this["dialogHandler"].createDialog("config"), this["loginDialog"] = this.dialogHandler.createDialog("login"), this["undoDialog"] = this.dialogHandler["createDialog"]("undo"), this["roomManagerDialog"] = this.dialogHandler["createDialog"]("roommanager"), this["saveDialog"] = this["dialogHandler"]["createDialog"]("save"), this["uploadDialog"] = this["dialogHandler"]["createDialog"]("upload"), this.brushDesignerDialog = this.dialogHandler["createDialog"]("brushdesigner"), this["brushGalleryDialog"] = this.dialogHandler["createDialog"]("brushgallery"), this.debugDialog = this["dialogHandler"]["createDialog"]("debug"), this["profileDialog"] = this.dialogHandler["createDialog"]("profile"), this["colorDialog"] = this["dialogHandler"].createDialog("color"), this.helpDialog = this["dialogHandler"]["createDialog"]("help"), this.modsDialog = this["dialogHandler"]["createDialog"]("mods"), this["adminConsoleDialog"] = this["dialogHandler"]["createDialog"]("adminconsole"), this["feedbackDialog"] = this.dialogHandler["createDialog"]("feedback"), this["animationDialog"] = this["dialogHandler"]["createDialog"]("animation"), this["messengerDialog"] = this["dialogHandler"].createDialog("messenger"), this["galleryImageDialog"] = this.dialogHandler["createDialog"]("galleryimage"), this.userGalleryDialog = this["dialogHandler"]["createDialog"]("usergallery");
    // this.socketModDialog = this["dialogHandler"]["createDialog"]("socketmod");
    var _0x3b5ec4 = this;
    $(this["loginDialog"]).on("dialogOpened", function (_0x90e80f) {
      _0x3b5ec4["showScreen"]();
    }), $(this.chatDialog).on("unreadMessages", function (_0x4865f2) {
      var _0x5f42ed = "danger";
      if (_0x4865f2["messagetype"] == "events") _0x5f42ed = "default"; else _0x4865f2["messagetype"] == "pm" && (_0x5f42ed = "secondary");
      _0x3b5ec4["topbar"].setCounter("chatButton", _0x4865f2["messages"], _0x5f42ed);
    }), $(this["messengerDialog"]).on("unreadMessages", function (_0x4f55d4) {
      _0x3b5ec4.bottombar["setCounter"]("messengerButton", _0x4f55d4["messages"]);
    });
  }
  ["showScreen"]() {
    this["loadingScreen"]["hide"]();
  }
  ["hideScreen"](_0x689a07 = "", _0x5aa5ab = false, _0x15f3ae = 1, _0x35a5ce = "fa-cog") {
    this["loadingScreen"]["show"](_0x689a07, _0x5aa5ab, _0x15f3ae, _0x35a5ce);
  }
  ["showSelectionToolbar"]() {
    var _0x32f15c = room["myself"]["surface"]["brushHandler"].brush;
    // Check for either BrushSelection or BrushSelectionModded
    if (_0x32f15c["constructor"].name == "BrushSelection" || _0x32f15c["constructor"].name == "BrushSelectionModded") {
      var _0x39d20e, _0x35037c;
      _0x32f15c["getOption"]("selectiontype") ? (_0x39d20e = getLimits(_0x32f15c["clickX"]), _0x35037c = getLimits(_0x32f15c["clickY"])) : (_0x39d20e = getLimits(new Array(_0x32f15c["start"].x, _0x32f15c["end"].x)), _0x35037c = getLimits(new Array(_0x32f15c["start"].y, _0x32f15c["end"].y)));
      var _0x4d27b0 = 5,
        _0x2afca3 = room["board"]["offset"](),
        _0x1e583e = this["selectionToolbar"].toolbar["outerHeight"](),
        _0x562cf8 = Math["max"](Math["min"](_0x39d20e.x, room.board.canvasWidth), 0) + this.viewOffset.x,
        _0x5303ff = Math["max"](Math["min"](_0x35037c.x, room["board"]["canvasHeight"]), 0) + this["viewOffset"].y,
        _0x19a4bf = this["boardToScreen"](_0x562cf8, _0x5303ff);
      this["selectionToolbar"]["visible"]() ? this.selectionToolbar["position"](_0x19a4bf.x - _0x4d27b0, _0x19a4bf.y - _0x1e583e - _0x4d27b0) : (room["can"]("pundo") ? this["selectionToolbar"].showButton("undo") : this["selectionToolbar"]["hideButton"]("undo"), this["selectionToolbar"]["show"](_0x19a4bf.x - _0x4d27b0, _0x19a4bf.y - _0x1e583e - _0x4d27b0));
    }
  }
  ["resetViewSize"]() {
    this["setViewSize"](room["board"]["canvasWidth"], room["board"]["canvasHeight"]), this.setViewOffset(0, 0), this["updateViewLimits"]();
  }
  ["setViewSize"](_0x4b5282, _0x50f854) {
    var _0x364dd5 = !(_0x4b5282 == room["board"]["canvasWidth"] && _0x50f854 == room.board["canvasHeight"]);
    this["limitedViewSize"] != _0x364dd5 && (this["limitedViewSize"] = _0x364dd5, $(this).triggerHandler(new viewSizeChangedEvent(_0x364dd5, _0x4b5282, _0x50f854).getEvent())), this.boardContainer["css"]({
      width: _0x4b5282,
      height: _0x50f854
    });
  }
  ["setViewOffset"](_0x56a61b, _0x22aa07) {
    this["viewOffset"] = new Point(_0x56a61b, _0x22aa07), this.updateTransform();
  }
  ["bindEventsRoomModified"]() {
    var _0x4136b7 = this;
    $(room).on("roomChanged", function (_0x2fa037) {
      _0x4136b7["chatDialog"]["reset"](), room["board"]["clearLayers"]();
    }), $(room).on("roomConnected", function (_0x5479dc) {
      _0x4136b7["loginDialog"]["active"] && _0x4136b7["loginDialog"].hide(), room.createSession(), _0x4136b7["firstSyncFailed"] = [], _0x4136b7["firstSyncOrder"] = [], _0x4136b7.sidebar["userList"].addMyself(), room["myself"].surface["setUsername"](room["myself"].username), _0x4136b7.userPreferences["getGroupOption"]("graphics", "showusername", true) ? room.myself["surface"]["cursor"]["showUsername"]() : room["myself"].surface.cursor.hideUsername(), window.history["pushState"]("", _0x5479dc["room"], "/r/" + _0x5479dc["room"]), _0x4136b7.topbar["setText"]("", UI["baseURL"] + "/r/" + _0x5479dc.room), _0x4136b7["chatDialog"]["bindRoomEvents"](), _0x5479dc.description["trim"]() != "" && _0x4136b7["chatDialog"]["createMessage"]("public", "room", "MOTD", escapeHTML(_0x5479dc["description"])), $(document)["prop"]("title", "#" + _0x5479dc["room"] + " - FlockMod"), _0x4136b7["sidebar"]["userList"]["refresh"](), _0x4136b7["sidebar"]["layerPreview"].updateLayerCount(), _0x4136b7["sidebar"]["layerPreview"].highlight(room.myself["surface"]["currentLayer"]), _0x4136b7["sidebar"]["toolbar"]["highlight"](room["myself"]["surface"].getCurrentBrush()), _0x4136b7["topbar"]["showButton"]("chatButton"), $(room["myself"].surface).triggerHandler(new brushChangedEvent(_0x4136b7["defaultBrush"])["getEvent"]()), $(room["myself"]["surface"])["triggerHandler"](new colorChangedEvent(_0x4136b7["defaultColor"]).getEvent()), _0x4136b7["sidebar"]["toolbar"]["select"](_0x4136b7["defaultBrush"]), room["myself"]["surface"]["setColor"](_0x4136b7["defaultColor"]), _0x4136b7["warnExit"] = true;
       setTimeout(function (_0x5be726) {
        _0x4136b7.updateViewLimits(), _0x4136b7["centerBoard"]();
      }, 1e3);
      if (!isNaN(dc_boardpos_x) && dc_boardpos_x !== undefined && !isNaN(dc_boardpos_y) && dc_boardpos_y !== undefined) {
        UI?.moveBoard(dc_boardpos_x, dc_boardpos_y);
    }
    if (!isNaN(dc_zoom) && dc_zoom !== undefined && room?.board) {
        room?.board?.setZoom(dc_zoom);
    }
    if (dc_color !== undefined && room?.myself?.surface) {
        room?.myself?.surface?.setColor(dc_color);
    } else {
      // room?.myself?.surface?.setColor(defaultColor);
    }
    if (dc_tool !== undefined && room?.myself?.surface) {
        UI.sidebar.toolbar.select(dc_tool);
    } else {
        UI.sidebar.toolbar.select(UI?.defaultBrush);
    }
    if (dc_tool_settings !== undefined && room?.myself?.surface) {
        room.myself.surface.setBrushOptions(dc_tool_settings);
    };
    }), $(room).on("roomDisconnected", function (_0x2cfaa1) {
      $(document)["prop"]("title", "FlockMod"), _0x4136b7["selectionToolbar"]["visible"]() && _0x4136b7.selectionToolbar.hide(), _0x4136b7["chatDialog"]["unbindRoomEvents"](), _0x4136b7["undoDialog"]["pause"](), _0x4136b7.uploader["cancel"](), _0x4136b7.sidebar["layerPreview"]["reset"](), _0x4136b7.warnExit = false, _0x4136b7["topbar"]["hideButton"]("chatButton"), $["each"](room["users"], function (_0x357e7f, _0x34547c) {
        room.removeUser(_0x357e7f);
      }), _0x4136b7["sidebar"]["userList"]["clear"](), room.myself["surface"].clearSlate();
    }), $(room).on("youLeft", function (_0x28ea92) {
      _0x4136b7["topbar"]["setText"]("", "Welcome to FlockMod"), _0x4136b7.boardContainer["fadeOut"](400), _0x4136b7["sidebar"]["collapse"](), _0x4136b7["firstSyncFailed"] = [], _0x4136b7.firstSyncOrder = [], room["session"] = 0;
    }), $(room).on("roomTypeChanged", function (_0x5bc1e6) {
      _0x5bc1e6["newType"] == "A" ? (room["board"].drawGrid(room["animRows"], room["animCols"]), _0x4136b7["sidebar"]["showComponent"]("Animation")) : (room["board"]["clearGrid"](), _0x4136b7.sidebar["hideComponent"]("Animation"), _0x4136b7["limitedViewSize"] && (_0x4136b7.resetViewSize(), _0x4136b7.fitToScreen()));
    }), $(room).on("animationFrameChanged", function (_0x36bafe) {
      room["type"] == "A" && (room["board"]["drawGrid"](_0x36bafe["rows"], _0x36bafe["cols"]), _0x4136b7["limitedViewSize"] && (_0x4136b7["resetViewSize"](), _0x4136b7["fitToScreen"]()));
    }), $(room).on("userJoined", function (_0x29eb8d) {
      _0x4136b7["sidebar"]["userList"].addUser(_0x29eb8d), _0x4136b7["sidebar"]["userList"]["sort"]();
      var _0x39e720 = room["users"][_0x29eb8d.username];
      _0x39e720.surface["slate"]["canvas"]["hide"](), room["myself"]["alone"](room["users"]["length"] > 0), $(_0x39e720.surface).on("penShow", function (_0x52177d) {
        _0x39e720["surface"]["getCurrentBrush"]() == "text" && _0x39e720["surface"]["brushHandler"]["brush"]["positionText"]();
      });
      var _0x3f9ea5,
        _0x20bd22 = _0x4136b7["userRank"](_0x39e720["rank"], false),
        _0xa0990b = _0x39e720["username"],
        _0x46ada6 = (_0x39e720["country"] ? " <img class=\"flagIcon\" src=\"" + UI.baseDir + "images/flags/" + _0x39e720["country"] + '.png" alt="' + _0x39e720.country + "\" data-tooltip=\"" + _0x39e720["country"] + "\" />" : "") + (_0x39e720["proxy"] ? " <span data-tooltip=\"" + textManager["getString"]("events.txtProxy", null, false) + '">' + new Icon("fa-network-wired")["html"]() + "</span>" : "") + (_0x39e720["hasIP"]() ? " (" + _0x39e720.ip + ")" : "");
      _0x29eb8d["wasintheroom"] ? _0x3f9ea5 = textManager["getString"]("events.txtUserInRoom", [_0x20bd22, _0xa0990b, _0x46ada6], false) : _0x3f9ea5 = textManager["getString"]("events.txtUserEnters", [_0x20bd22, _0xa0990b, _0x46ada6], false), _0x4136b7["chatDialog"]["createMessage"]("public", "room", "EVENT", _0x3f9ea5), _0x4136b7["chatDialog"]["existsChannel"](_0x39e720["username"], "user") && _0x4136b7["chatDialog"]["createMessage"](_0x39e720["username"], "user", "EVENT", _0x3f9ea5);
    }), $(room).on("userLeft", function (_0x1f3ced) {
      room["myself"]["alone"](room.users.length > 0);
    }), $(room).on("userLeaving", function (_0x170668) {
      var _0x54fabe = room["users"][_0x170668["username"]],
        _0x3dc0aa = _0x4136b7["userRank"](_0x54fabe["rank"], false),
        _0x423a82 = _0x54fabe.username,
        _0x1f4896 = (_0x54fabe["country"] ? ' <img class="flagIcon" src="' + UI.baseDir + "images/flags/" + _0x54fabe.country + ".png\" alt=\"" + _0x54fabe["country"] + "\" data-tooltip=\"" + _0x54fabe.country + "\" />" : "") + (_0x54fabe.proxy ? " <span data-tooltip=\"Proxy\">" + new Icon("fa-network-wired")["html"]() + "</span>" : "") + (_0x54fabe["hasIP"]() ? " (" + _0x54fabe.ip + ")" : ""),
        _0x42be29 = _0x170668["reason"] && _0x170668["reason"] != "LEAVE" ? " (" + _0x170668["reason"] + ")" : "",
        _0x16dddb = textManager["getString"]("events.txtUserLeaves", [_0x3dc0aa, _0x423a82, _0x1f4896, _0x42be29], false);
      _0x4136b7["chatDialog"]["createMessage"]("public", "room", "EVENT", _0x16dddb), _0x4136b7["chatDialog"]["existsChannel"](_0x54fabe["username"], "user") && _0x4136b7["chatDialog"]["createMessage"](_0x54fabe["username"], "user", "EVENT", _0x16dddb), _0x4136b7["sidebar"].userList["removeUser"](_0x170668), $.each(room["transfers"], function (_0x233f86, _0xe04f27) {
        _0xe04f27["username"] == _0x170668["username"] && !_0xe04f27["completed"] && !_0xe04f27["failed"] && _0xe04f27["fail"]();
      });
    }), $(room).on("muteTimerStarted", function (_0x5f50b5) {
      _0x4136b7.muteTime(_0x5f50b5["time"]);
    }), $(room).on("roomPrivilegesChanged", function (_0x4a2679) {
      _0x4136b7["setupPrivileges"](room["privileges"]);
    }), $(room).on("roomToolsChanged", function (_0x1c2a5d) {
      _0x4136b7.setupTools(room["tools"]);
    }), $(room["myself"]).on("muteChanged", function (_0x551627) {
      !_0x551627["status"] && (_0x4136b7["syncBrushes"](), _0x4136b7["clearMuteTime"](), _0x4136b7["bottombar"]["setText"](""));
    }), $(room["myself"]).on("rankChanged", function (_0x1aef4c) {
      _0x4136b7.setupPrivileges(room["privileges"]), _0x4136b7["setupTools"](room["tools"]), _0x4136b7["profileDialog"]["checkAccountType"]();
    }), $(room.myself.surface).on("colorChanged", function (_0x38efff) {
      _0x4136b7["sidebar"]["colorBox"]["setPrimary"](_0x38efff["color"]), _0x4136b7.sidebar["colorWheel"]["setColor"](_0x38efff["color"]);
    }), $(room["myself"]["surface"]).on("brushOptionChanged", function (_0x190c48) {
      _0x4136b7["savedOption"][_0x190c48["option"]] = _0x190c48["value"];
    }), $(room["myself"]["surface"]).on("penDown", function (_0x17cae8) {
      room["myself"].surface.getCurrentBrush() == "selection" && _0x4136b7.selectionToolbar["visible"]() && _0x4136b7["selectionToolbar"]["hide"]();
    }), $(room.myself["surface"]).on("penUp", function (_0x4c358a) {
      if (room.myself["surface"].getCurrentBrush() == "selection") {
        var _0x3f9c7e = room["myself"]["surface"]["brushHandler"].brush;
        _0x3f9c7e["moved"] && _0x4136b7["showSelectionToolbar"]();
      }
    }), $(room["myself"].surface).on("brushChanged", function (_0x572c5b) {
      _0x4136b7.setCurrentPointer(null);
      room["myself"].surface["getCurrentBrush"]() != "selection" && _0x4136b7["selectionToolbar"].visible() && _0x4136b7["selectionToolbar"]["hide"]();
      $["each"](room["myself"].surface["getBrushOptions"](), function (_0x23bd07, _0x2b339b) {
        _0x4136b7["userPreferences"]["getGroupOption"]("syncedoptions", _0x23bd07) && _0x23bd07 in _0x4136b7["savedOption"] && !room.myself["surface"]["isBrushOptionReadOnly"](_0x23bd07) && room["myself"].surface.setBrushOption(_0x23bd07, _0x4136b7["savedOption"][_0x23bd07]);
      });
      if (_0x4136b7["radialMenu"]["isVisible"]()) {
        var _0x1d11b8 = room["myself"].surface["brushHandler"]["getOption"]("size");
        _0x4136b7["radialMenu"].setSlider("size", _0x1d11b8 * 100 / room.myself["surface"].maxSize);
      }
    }), $(room["myself"]).on("userUnwanted", function (_0xb38fa1) {
      setTimeout(function () {
        socket["disconnect"](true), socket = null;
        if (_0xb38fa1["reason"] == "ban") UI["hideScreen"](textManager["getString"]("alerts.txtYouHaveBeenBanned"), false, 1, "fa-radiation-alt"); else _0xb38fa1["reason"] == "kick" && UI["hideScreen"](textManager["getString"]("alerts.txtYouHaveBeenKicked"), false, 1, "fa-exclamation-circle");
      }, 1e3);
    }), $(room["board"]).on("backgroundColorChanged", function (_0x4aea6c) {
      _0x4136b7["boardContainer"]["css"]("background-color", _0x4aea6c.newColor);
    }), $(room.board).on("canvasSizeChanged", function (_0x3a6b3a) {
      _0x4136b7["boardContainer"]["css"]({
        width: _0x3a6b3a["newWidth"],
        height: _0x3a6b3a["newHeight"]
      }), room["myself"]["surface"]["slate"]["changeSize"](_0x3a6b3a["newWidth"], _0x3a6b3a["newHeight"]), $["each"](room["users"], function (_0x1d94a9, _0x3da2bd) {
        _0x3da2bd["surface"]["slate"].changeSize(_0x3a6b3a["newWidth"], _0x3a6b3a["newHeight"]);
      }), _0x4136b7["undoDialog"]["reset"](), _0x4136b7.sidebar["layerPreview"]["updatePreviewSize"](), _0x4136b7["fitToScreen"](), _0x4136b7["centerBoard"]();
      _0x4136b7["uploader"]["isVisible"]() && _0x4136b7["uploader"]["isOutOfBounds"]() && _0x4136b7["uploader"]["resetPosition"]();
      for (var _0xaa3331 = 0; _0xaa3331 < room["board"]["nLayers"]; _0xaa3331++) {
        _0xaa3331 in _0x4136b7["_tmp"] && room["board"]["putLayerData"](_0xaa3331, _0x4136b7["_tmp"][_0xaa3331], 0, 0, _0x3a6b3a["newWidth"], _0x3a6b3a["newHeight"]);
      }
      _0x4136b7["_tmp"] = null;
    }), $(_0x4136b7).on("viewFlipped", function (_0x5ccda7) {
      room["myself"]["surface"]["getCurrentBrush"]() == "selection" && _0x4136b7["selectionToolbar"]["visible"]() && _0x4136b7.showSelectionToolbar();
    });
  }
  ["bindEventsRoom"]() {
    var _0x4136b7 = this;
    $(room).on("roomChanged", function (_0x2fa037) {
      _0x4136b7["chatDialog"]["reset"](), room["board"]["clearLayers"]();
    }), $(room).on("roomConnected", function (_0x5479dc) {
      _0x4136b7["loginDialog"]["active"] && _0x4136b7["loginDialog"].hide(), room.createSession(), _0x4136b7["firstSyncFailed"] = [], _0x4136b7["firstSyncOrder"] = [], _0x4136b7.sidebar["userList"].addMyself(), room["myself"].surface["setUsername"](room["myself"].username), _0x4136b7.userPreferences["getGroupOption"]("graphics", "showusername", true) ? room.myself["surface"]["cursor"]["showUsername"]() : room["myself"].surface.cursor.hideUsername(), window.history["pushState"]("", _0x5479dc["room"], "/r/" + _0x5479dc["room"]), _0x4136b7.topbar["setText"]("", UI["baseURL"] + "/r/" + _0x5479dc.room), _0x4136b7["chatDialog"]["bindRoomEvents"](), _0x5479dc.description["trim"]() != "" && _0x4136b7["chatDialog"]["createMessage"]("public", "room", "MOTD", escapeHTML(_0x5479dc["description"])), $(document)["prop"]("title", "#" + _0x5479dc["room"] + " - FlockMod"), _0x4136b7["sidebar"]["userList"]["refresh"](), _0x4136b7["sidebar"]["layerPreview"].updateLayerCount(), _0x4136b7["sidebar"]["layerPreview"].highlight(room.myself["surface"]["currentLayer"]), _0x4136b7["sidebar"]["toolbar"]["highlight"](room["myself"]["surface"].getCurrentBrush()), _0x4136b7["topbar"]["showButton"]("chatButton"), $(room["myself"].surface).triggerHandler(new brushChangedEvent(_0x4136b7["defaultBrush"])["getEvent"]()), $(room["myself"]["surface"])["triggerHandler"](new colorChangedEvent(_0x4136b7["defaultColor"]).getEvent()), _0x4136b7["sidebar"]["toolbar"]["select"](_0x4136b7["defaultBrush"]), room["myself"]["surface"]["setColor"](_0x4136b7["defaultColor"]), _0x4136b7["warnExit"] = true, setTimeout(function (_0x5be726) {
        _0x4136b7.updateViewLimits(), _0x4136b7["centerBoard"]();
      }, 1e3);
    }), $(room).on("roomDisconnected", function (_0x2cfaa1) {
      $(document)["prop"]("title", "FlockMod"), _0x4136b7["selectionToolbar"]["visible"]() && _0x4136b7.selectionToolbar.hide(), _0x4136b7["chatDialog"]["unbindRoomEvents"](), _0x4136b7["undoDialog"]["pause"](), _0x4136b7.uploader["cancel"](), _0x4136b7.sidebar["layerPreview"]["reset"](), _0x4136b7.warnExit = false, _0x4136b7["topbar"]["hideButton"]("chatButton"), $["each"](room["users"], function (_0x357e7f, _0x34547c) {
        room.removeUser(_0x357e7f);
      }), _0x4136b7["sidebar"]["userList"]["clear"](), room.myself["surface"].clearSlate();
    }), $(room).on("youLeft", function (_0x28ea92) {
      _0x4136b7["topbar"]["setText"]("", "Welcome to FlockMod"), _0x4136b7.boardContainer["fadeOut"](400), _0x4136b7["sidebar"]["collapse"](), _0x4136b7["firstSyncFailed"] = [], _0x4136b7.firstSyncOrder = [], room["session"] = 0;
    }), $(room).on("roomTypeChanged", function (_0x5bc1e6) {
      _0x5bc1e6["newType"] == "A" ? (room["board"].drawGrid(room["animRows"], room["animCols"]), _0x4136b7["sidebar"]["showComponent"]("Animation")) : (room["board"]["clearGrid"](), _0x4136b7.sidebar["hideComponent"]("Animation"), _0x4136b7["limitedViewSize"] && (_0x4136b7.resetViewSize(), _0x4136b7.fitToScreen()));
    }), $(room).on("animationFrameChanged", function (_0x36bafe) {
      room["type"] == "A" && (room["board"]["drawGrid"](_0x36bafe["rows"], _0x36bafe["cols"]), _0x4136b7["limitedViewSize"] && (_0x4136b7["resetViewSize"](), _0x4136b7["fitToScreen"]()));
    }), $(room).on("userJoined", function (_0x29eb8d) {
      _0x4136b7["sidebar"]["userList"].addUser(_0x29eb8d), _0x4136b7["sidebar"]["userList"]["sort"]();
      var _0x39e720 = room["users"][_0x29eb8d.username];
      _0x39e720.surface["slate"]["canvas"]["hide"](), room["myself"]["alone"](room["users"]["length"] > 0), $(_0x39e720.surface).on("penShow", function (_0x52177d) {
        _0x39e720["surface"]["getCurrentBrush"]() == "text" && _0x39e720["surface"]["brushHandler"]["brush"]["positionText"]();
      });
      var _0x3f9ea5,
        _0x20bd22 = _0x4136b7["userRank"](_0x39e720["rank"], false),
        _0xa0990b = _0x39e720["username"],
        _0x46ada6 = (_0x39e720["country"] ? " <img class=\"flagIcon\" src=\"" + UI.baseDir + "images/flags/" + _0x39e720["country"] + '.png" alt="' + _0x39e720.country + "\" data-tooltip=\"" + _0x39e720["country"] + "\" />" : "") + (_0x39e720["proxy"] ? " <span data-tooltip=\"" + textManager["getString"]("events.txtProxy", null, false) + '">' + new Icon("fa-network-wired")["html"]() + "</span>" : "") + (_0x39e720["hasIP"]() ? " (" + _0x39e720.ip + ")" : "");
      _0x29eb8d["wasintheroom"] ? _0x3f9ea5 = textManager["getString"]("events.txtUserInRoom", [_0x20bd22, _0xa0990b, _0x46ada6], false) : _0x3f9ea5 = textManager["getString"]("events.txtUserEnters", [_0x20bd22, _0xa0990b, _0x46ada6], false), _0x4136b7["chatDialog"]["createMessage"]("public", "room", "EVENT", _0x3f9ea5), _0x4136b7["chatDialog"]["existsChannel"](_0x39e720["username"], "user") && _0x4136b7["chatDialog"]["createMessage"](_0x39e720["username"], "user", "EVENT", _0x3f9ea5);
    }), $(room).on("userLeft", function (_0x1f3ced) {
      room["myself"]["alone"](room.users.length > 0);
    }), $(room).on("userLeaving", function (_0x170668) {
      var _0x54fabe = room["users"][_0x170668["username"]],
        _0x3dc0aa = _0x4136b7["userRank"](_0x54fabe["rank"], false),
        _0x423a82 = _0x54fabe.username,
        _0x1f4896 = (_0x54fabe["country"] ? ' <img class="flagIcon" src="' + UI.baseDir + "images/flags/" + _0x54fabe.country + ".png\" alt=\"" + _0x54fabe["country"] + "\" data-tooltip=\"" + _0x54fabe.country + "\" />" : "") + (_0x54fabe.proxy ? " <span data-tooltip=\"Proxy\">" + new Icon("fa-network-wired")["html"]() + "</span>" : "") + (_0x54fabe["hasIP"]() ? " (" + _0x54fabe.ip + ")" : ""),
        _0x42be29 = _0x170668["reason"] && _0x170668["reason"] != "LEAVE" ? " (" + _0x170668["reason"] + ")" : "",
        _0x16dddb = textManager["getString"]("events.txtUserLeaves", [_0x3dc0aa, _0x423a82, _0x1f4896, _0x42be29], false);
      _0x4136b7["chatDialog"]["createMessage"]("public", "room", "EVENT", _0x16dddb), _0x4136b7["chatDialog"]["existsChannel"](_0x54fabe["username"], "user") && _0x4136b7["chatDialog"]["createMessage"](_0x54fabe["username"], "user", "EVENT", _0x16dddb), _0x4136b7["sidebar"].userList["removeUser"](_0x170668), $.each(room["transfers"], function (_0x233f86, _0xe04f27) {
        _0xe04f27["username"] == _0x170668["username"] && !_0xe04f27["completed"] && !_0xe04f27["failed"] && _0xe04f27["fail"]();
      });
    }), $(room).on("muteTimerStarted", function (_0x5f50b5) {
      _0x4136b7.muteTime(_0x5f50b5["time"]);
    }), $(room).on("roomPrivilegesChanged", function (_0x4a2679) {
      _0x4136b7["setupPrivileges"](room["privileges"]);
    }), $(room).on("roomToolsChanged", function (_0x1c2a5d) {
      _0x4136b7.setupTools(room["tools"]);
    }), $(room["myself"]).on("muteChanged", function (_0x551627) {
      !_0x551627["status"] && (_0x4136b7["syncBrushes"](), _0x4136b7["clearMuteTime"](), _0x4136b7["bottombar"]["setText"](""));
    }), $(room["myself"]).on("rankChanged", function (_0x1aef4c) {
      _0x4136b7.setupPrivileges(room["privileges"]), _0x4136b7["setupTools"](room["tools"]), _0x4136b7["profileDialog"]["checkAccountType"]();
    }), $(room.myself.surface).on("colorChanged", function (_0x38efff) {
      _0x4136b7["sidebar"]["colorBox"]["setPrimary"](_0x38efff["color"]), _0x4136b7.sidebar["colorWheel"]["setColor"](_0x38efff["color"]);
    }), $(room["myself"]["surface"]).on("brushOptionChanged", function (_0x190c48) {
      _0x4136b7["savedOption"][_0x190c48["option"]] = _0x190c48["value"];
    }), $(room["myself"]["surface"]).on("penDown", function (_0x17cae8) {
      room["myself"].surface.getCurrentBrush() == "selection" && _0x4136b7.selectionToolbar["visible"]() && _0x4136b7["selectionToolbar"]["hide"]();
    }), $(room.myself["surface"]).on("penUp", function (_0x4c358a) {
      if (room.myself["surface"].getCurrentBrush() == "selection") {
        var _0x3f9c7e = room["myself"]["surface"]["brushHandler"].brush;
        _0x3f9c7e["moved"] && _0x4136b7["showSelectionToolbar"]();
      }
    }), $(room["myself"].surface).on("brushChanged", function (_0x572c5b) {
      _0x4136b7.setCurrentPointer(null);
      room["myself"].surface["getCurrentBrush"]() != "selection" && _0x4136b7["selectionToolbar"].visible() && _0x4136b7["selectionToolbar"]["hide"]();
      $["each"](room["myself"].surface["getBrushOptions"](), function (_0x23bd07, _0x2b339b) {
        _0x4136b7["userPreferences"]["getGroupOption"]("syncedoptions", _0x23bd07) && _0x23bd07 in _0x4136b7["savedOption"] && !room.myself["surface"]["isBrushOptionReadOnly"](_0x23bd07) && room["myself"].surface.setBrushOption(_0x23bd07, _0x4136b7["savedOption"][_0x23bd07]);
      });
      if (_0x4136b7["radialMenu"]["isVisible"]()) {
        var _0x1d11b8 = room["myself"].surface["brushHandler"]["getOption"]("size");
        _0x4136b7["radialMenu"].setSlider("size", _0x1d11b8 * 100 / room.myself["surface"].maxSize);
      }
    }), $(room["myself"]).on("userUnwanted", function (_0xb38fa1) {
      setTimeout(function () {
        socket["disconnect"](true), socket = null;
        if (_0xb38fa1["reason"] == "ban") UI["hideScreen"](textManager["getString"]("alerts.txtYouHaveBeenBanned"), false, 1, "fa-radiation-alt"); else _0xb38fa1["reason"] == "kick" && UI["hideScreen"](textManager["getString"]("alerts.txtYouHaveBeenKicked"), false, 1, "fa-exclamation-circle");
      }, 1e3);
    }), $(room["board"]).on("backgroundColorChanged", function (_0x4aea6c) {
      _0x4136b7["boardContainer"]["css"]("background-color", _0x4aea6c.newColor);
    }), $(room.board).on("canvasSizeChanged", function (_0x3a6b3a) {
      _0x4136b7["boardContainer"]["css"]({
        width: _0x3a6b3a["newWidth"],
        height: _0x3a6b3a["newHeight"]
      }), room["myself"]["surface"]["slate"]["changeSize"](_0x3a6b3a["newWidth"], _0x3a6b3a["newHeight"]), $["each"](room["users"], function (_0x1d94a9, _0x3da2bd) {
        _0x3da2bd["surface"]["slate"].changeSize(_0x3a6b3a["newWidth"], _0x3a6b3a["newHeight"]);
      }), _0x4136b7["undoDialog"]["reset"](), _0x4136b7.sidebar["layerPreview"]["updatePreviewSize"](), _0x4136b7["fitToScreen"](), _0x4136b7["centerBoard"]();
      _0x4136b7["uploader"]["isVisible"]() && _0x4136b7["uploader"]["isOutOfBounds"]() && _0x4136b7["uploader"]["resetPosition"]();
      for (var _0xaa3331 = 0; _0xaa3331 < room["board"]["nLayers"]; _0xaa3331++) {
        _0xaa3331 in _0x4136b7["_tmp"] && room["board"]["putLayerData"](_0xaa3331, _0x4136b7["_tmp"][_0xaa3331], 0, 0, _0x3a6b3a["newWidth"], _0x3a6b3a["newHeight"]);
      }
      _0x4136b7["_tmp"] = null;
    }), $(_0x4136b7).on("viewFlipped", function (_0x5ccda7) {
      room["myself"]["surface"]["getCurrentBrush"]() == "selection" && _0x4136b7["selectionToolbar"]["visible"]() && _0x4136b7.showSelectionToolbar();
    });
  }
  ["bindEventsDocument"]() {
    var _0x1de768 = this;
    $(window).on("beforeunload", function () {
      if (_0x1de768["warnExit"]) return true;
    }), $(this).on("windowFocused", function (_0x1b656e) {
      _0x1de768["onFocus"] = true;
    }), $(this).on("windowBlurred", function (_0x2a06fc) {
      _0x1de768["onFocus"] = false, _0x1de768["shortcutManager"]["releaseShortcuts"](_0x1de768["dialogHandler"]["openedDialogs"] > 0);
    }), $(document).on("paste", function (_0x1f8cb8) {
      if (room && room["myself"]) {
        var _0x5b16ef = room.myself["surface"].getCurrentBrush() == "text" && room["myself"]["surface"]["brushHandler"]["brush"]["enabled"];
        if (_0x5b16ef && !UI["dialogHandler"]["activeDialog"]) {
          _0x1f8cb8.preventDefault();
          var _0xca4f0c = _0x1f8cb8["originalEvent"].clipboardData["getData"]("text");
          for (var _0x18df02 = 0; _0x18df02 < Math["min"](_0xca4f0c["length"], room.myself["surface"]["brushHandler"]["brush"]["maxLength"] - room["myself"].surface["brushHandler"]["brush"]["getCurrentLength"]()); _0x18df02++) {
            _0xca4f0c[_0x18df02]["charCodeAt"](0) != 10 && room["myself"].surface["keyPress"](_0xca4f0c[_0x18df02].charCodeAt(0));
          }
        }
      }
 }), $(document).on(this.pointerEvent("move", "ui"), function (_0x32c21d) {
      if (!_0x1de768["onFocus"]) return;
      if (_0x1de768["pinching"]) return;
      if (!_0x1de768["isCurrentPointer"](_0x32c21d["pointerId"])) return;
      var _0x4512f6 = _0x1de768["getInputPosition"](_0x32c21d);
      if (_0x1de768["mousePointer"] && _0x1de768["mousePointer"]["position"] && _0x1de768["mousePointer"]["position"].x == _0x4512f6.x && _0x1de768["mousePointer"]["position"].y == _0x4512f6.y) return;
      _0x1de768["mousePointer"]["move"](_0x4512f6.x, _0x4512f6.y), _0x1de768["overBoard"] = _0x1de768["mouseOverBoard"](), _0x1de768.updateCursor();
      // _0x32c21d["originalEvent"]["pressure"] && (_0x32c21d["pointerType"] == "mouse" ? _0x1de768["updatePressure"](1) : (_0x1de768["updatePressure"]((Math.round(_0x32c21d["originalEvent"]["pressure"] * 1000) / 1000))));
      var enable1000PressureLevels = localStorage.getItem('enable1000PressureLevels') === 'true';
      if (enable1000PressureLevels) {
      _0x32c21d["originalEvent"]["pressure"] && ((_0x32c21d["pointerType"] == "mouse" && room?.myself?.surface?.penPressed) ? _0x1de768["updatePressure"](1) : (room?.myself?.surface?.penPressed ? _0x1de768["updatePressure"]((Math.round(_0x32c21d["originalEvent"]["pressure"] * 1000) / 1000)) : null));
      }
      else {
        _0x32c21d["originalEvent"]["pressure"] && ((_0x32c21d["pointerType"] == "mouse" && room?.myself?.surface?.penPressed) ? _0x1de768["updatePressure"](1) : (room?.myself?.surface?.penPressed ? _0x1de768["updatePressure"]((Math.round(_0x32c21d["originalEvent"]["pressure"] * 10) / 10)) : null));
      }
      var _0x3a7d24;
      room && room["myself"] && (_0x3a7d24 = room["myself"]["surface"]["getCurrentBrush"]());
      if (_0x1de768["dialogHandler"]["draggingDialog"]() || _0x1de768["dialogHandler"]["resizingDialog"]()) _0x1de768.dialogHandler.mouseMove(_0x4512f6.x, _0x4512f6.y); else {
        if (_0x3a7d24 == "drag" || _0x1de768["draggingMode"]) {
          if (_0x1de768["dragPoint"] && !_0x1de768["pinching"]) {
            var _0x2f59f7 = _0x1de768["drawingArea"]["offset"]();
            _0x1de768["moveBoard"](_0x4512f6.x - _0x2f59f7["left"] - _0x1de768["dragPoint"].x, _0x4512f6.y - _0x2f59f7.top - _0x1de768["dragPoint"].y);
          }
        } else {
          if (_0x3a7d24 == "rotate") {
            if (_0x1de768["dragPoint"] && !_0x1de768["pinching"]) {
              var _0x360a5e = Math["atan2"](_0x4512f6.x - _0x1de768["boardContainer"]["width"]() / 2, _0x4512f6.y - _0x1de768["boardContainer"]["height"]() / 2),
                _0x5d47a4 = _0x360a5e * (180 / Math.PI) * -1 + 90;
              _0x5d47a4 = _0x1de768.dragRotation + _0x5d47a4 - _0x1de768["dragInitialRotation"], _0x1de768.holdingSHIFT && (_0x5d47a4 = angleSnap(_0x5d47a4)), room["board"]["changeRotation"](_0x5d47a4);
            }
          } else {
            if (!_0x1de768["uploadMode"]) {
              if (room && room["myself"]) {
                if (_0x1de768["drawingAllowed"]() && room["myself"]["surface"]["getBrushShowPen"]()) {
                  if (_0x1de768["overBoard"] || room["myself"]["surface"]["penPressed"]) {
                    var _0x4b0410 = _0x1de768["screenToBoard"](_0x4512f6.x, _0x4512f6.y);
                    room["myself"]["surface"].penMove(parseInt(_0x4b0410.x * 100) / 100, parseInt(_0x4b0410.y * 100) / 100);
                  }
                }
                _0x1de768["overBoard"] && room.myself["surface"]["getBrushShowPen"]() ? _0x1de768["showPen"]() : _0x1de768.hidePen();
              }
            } else _0x1de768.uploader["mouseMove"](_0x4512f6.x, _0x4512f6.y);
          }
        }
      }
    }), $(document).on(this["pointerEvent"]("up", "ui"), function (_0x1c0c9e) {
      if (!_0x1de768["isCurrentPointer"](_0x1c0c9e["pointerId"])) return; else _0x1de768["setCurrentPointer"](null);
      _0x1c0c9e["preventDefault"]();
      if (!_0x1de768["draggingMode"] && (!_0x1c0c9e["which"] || _0x1c0c9e["which"] == 1)) {
        var _0x1764ef = _0x1de768.getInputPosition(_0x1c0c9e);
        _0x1c0c9e["type"] == "touchend" && (_0x1764ef = new Point(_0x1de768["mousePointer"].position.x, _0x1de768["mousePointer"]["position"].y));
        _0x1de768.mousePointer["move"](_0x1764ef.x, _0x1764ef.y);
        if (!_0x1de768["onFocus"]) return;
        _0x1de768.hovering = false;
        if (_0x1de768["dialogHandler"]["draggingDialog"]() || _0x1de768["dialogHandler"].resizingDialog()) _0x1de768["dialogHandler"]["mouseUp"](_0x1764ef.x, _0x1764ef.y); else {
          if (room && room["myself"]) {
            if (room.myself["surface"]["getCurrentBrush"]() == "picker") {
              if (_0x1de768["mouseOverBoard"]()) {
                var _0x509586 = 5,
                  _0x591abe = room.myself["surface"].brushHandler["getOption"]("size"),
                  _0x59d9b0 = room["myself"]["surface"].brushHandler["getOption"]("areaaverage") && _0x591abe > _0x509586;
                if (!_0x59d9b0) {
                  var _0x4a593f = _0x1de768["screenToBoard"](_0x1764ef.x, _0x1764ef.y),
                    _0x42f5ac = room["board"]["getPixelAllLayers"](_0x4a593f.x, _0x4a593f.y),
                    _0x55eaf6 = "rgb(" + _0x42f5ac[0] + "," + _0x42f5ac[1] + "," + _0x42f5ac[2] + ")";
                  _0x1de768["colorChange"](_0x55eaf6);
                } else {
                  var _0x4a593f = _0x1de768["screenToBoard"](_0x1764ef.x, _0x1764ef.y),
                    _0x1dec9f = room["board"]["getAllLayers"](_0x4a593f.x - _0x591abe / 2, _0x4a593f.y - _0x591abe / 2, _0x591abe, _0x591abe);
                  _0x1dec9f["then"](function (_0x4bf728) {
                    var _0x203e1a = new AdvancedCanvas(_0x591abe, _0x591abe),
                      _0x1ff7f1 = Object.keys(_0x4bf728)["length"],
                      _0x2fae89 = {},
                      _0x589073 = 0;
                    $["each"](_0x4bf728, function (_0x319e55, _0x2620ae) {
                      var _0x11def8 = new Image();
                      _0x2fae89[_0x319e55] = _0x11def8, _0x11def8["onload"] = function () {
                        if (++_0x589073 == _0x1ff7f1) {
                          for (var _0x14902b = 0; _0x14902b < room["board"]["nLayers"]; _0x14902b++) {
                            _0x14902b in _0x2fae89 && _0x203e1a["drawImage"](_0x2fae89[_0x14902b], 0, 0);
                          }
                          var _0x1a90c8 = getRadialAvg(_0x203e1a["getImageData"](), _0x591abe / 2, _0x591abe / 2, _0x591abe / 2, room["board"]["backgroundColor"]);
                          _0x1a90c8 = rgba2rgb(_0x1a90c8[0], _0x1a90c8[1], _0x1a90c8[2], _0x1a90c8[3] / 255);
                          var _0x462eb0 = "rgb(" + _0x1a90c8.r + "," + _0x1a90c8.g + "," + _0x1a90c8.b + ")";
                          _0x1de768["colorChange"](_0x462eb0), _0x203e1a["remove"]();
                        }
                      }, _0x11def8["src"] = _0x2620ae;
                    });
                  });
                }
                _0x1de768.userPreferences["getGroupOption"]("tools", "colorpickerswitch", false) && _0x1de768["sidebar"].toolbar["selectPreviouslyUsed"]();
              }
            } else {
              if (room["myself"]["surface"].penPressed) {
                var _0x4a593f = _0x1de768["screenToBoard"](_0x1764ef.x, _0x1764ef.y);
                room["myself"].surface["penUp"](parseInt(_0x4a593f.x * 100) / 100, parseInt(_0x4a593f.y * 100) / 100);
              }
            }
            room["myself"]["surface"]["getCurrentBrush"]() == "custom" && _0x1de768["mouseOverBoard"]() && !_0x1de768.hasSetCustomBrush && _0x1de768.dialogHandler["showAlert"](textManager["getString"]("alerts.txtSetCustomBrush")), _0x1de768["uploadMode"] && _0x1de768.uploader["mouseUp"](_0x1764ef.x, _0x1764ef.y);
          }
        }
      }
      _0x1de768.dragPoint = null, _0x1de768["dragRotation"] = 0, _0x1de768.dragInitialRotation = 0, _0x1de768.drag(false), _0x1de768.pip.hide();
    }), $(document).on("fullscreenchange", function (_0x1f7665) {
      _0x1de768["fitToScreen"](), _0x1de768["centerBoard"]();
    }), $(window).on("resize", function (_0x2eac59) {
      room && room["board"] && (_0x1de768["drawingArea"]["height"]() < _0x1de768.boardContainer["height"]() * room["board"]["scale"] || _0x1de768.drawingArea["width"]() < _0x1de768["boardContainer"]["width"]() * room["board"]["scale"]) && _0x1de768["fitToScreen"](), _0x1de768["centerBoard"](), _0x1de768.resizeTimeout === undefined ? $(_0x1de768).triggerHandler(new windowResizingStartedEvent()["getEvent"]()) : clearTimeout(_0x1de768.resizeTimeout), _0x1de768["resizeTimeout"] = setTimeout(_0x1de768["windowResizeEnded"], 500);
    }), $(window).on("focus", function (_0x2cbd1a) {
      this["focusTimer"] = setTimeout(function () {
        $(_0x1de768)["triggerHandler"](new windowFocusedEvent()["getEvent"]());
      }, 250);
    }), $(window).on("blur", function (_0x28d2d0) {
      this.focusTimer && clearTimeout(this["focusTimer"]), $(_0x1de768)["triggerHandler"](new windowBlurredEvent()["getEvent"]());
    }), $(document).on("visibilitychange", function (_0x1fc26b) {
      room && room["myself"] && room["myself"]["changeInactive"](document["visibilityState"] == "hidden");
    }), $(this.boardContainer).on(this["pointerEvent"]("over"), function (_0x3b2ef5) {
      _0x1de768["hovering"] = true;
    }), $(this["boardContainer"]).on(this["pointerEvent"]("out"), function (_0x1f2b77) {
      _0x1de768.hovering = false;
    }), $(document).on(this["pointerEvent"]("click"), '[name="leaveRoom"]', function (_0x48e2e4) {
      _0x48e2e4["preventDefault"](), _0x1de768["topbar"].pressButton("leaveButton");
    }), $(document).on(this["pointerEvent"]("click"), "[name=\"skipUserSync\"]", function (_0x32cfb1) {
      _0x32cfb1["preventDefault"]();
      
      // Check if skipSyncing is enabled
      const skipSyncingEnabled = localStorage.getItem("skipSyncing") === "true";
      
      // Mark current sync attempt as failed
      $.each(room.transfers, function (_0x1c23f0, _0x3491a8) {
        if (_0x3491a8["ttype"] == "sync" && !_0x3491a8["sending"] && !_0x3491a8["completed"] && !_0x3491a8.failed) {
          _0x3491a8["fail"]();
        }
      });
      
      if (skipSyncingEnabled) {
        // Enhanced behavior when skipSyncing is enabled - continue to next user
        // Add the current user to failed syncs
        const currentSyncUser = _0x1de768.firstSyncUser;
        if (currentSyncUser) {
          if (!_0x1de768.firstSyncFailed) _0x1de768.firstSyncFailed = [];
          if (!_0x1de768.firstSyncFailed.includes(currentSyncUser)) {
            _0x1de768.firstSyncFailed.push(currentSyncUser);
          }
        }
        
        // Trigger the firstSyncEnded event to move to next user
        $(_0x1de768).triggerHandler(new firstSyncEndedEvent(currentSyncUser, true).getEvent());
      } else {
        // Original behavior - just hide the button
        _0x1de768["loadingScreen"]["container"].find("[name=\"skipUserSync\"]").hide();
      }
    }), $(document).on(this["pointerEvent"]("click"), "[name=\"socketReconnect\"]", function (_0x566559) {      _0x566559.preventDefault(), $("#warningContainer")["empty"](), cm["reset"](), cm["reconnect"](1);
    }), $(document).on("keypress", this.onKeyPressed), $(document).on("keydown", this.onKeyDown), $(document).on("keyup", this["onKeyUp"]);
  }
  ["showPen"]() {
    room && !room["myself"]["muted"] && room["myself"]["surface"]["penShow"]() && room["myself"]["surface"]["getCurrentBrush"]() == "text" && room.myself.surface.brushHandler["brush"]["positionText"]();
  }
  ["hidePen"]() {
    room["myself"]["surface"]["penHide"]();
  }
  ["setUploadMode"](_0x36a644) {
    this["uploadMode"] = _0x36a644, room["myself"]["surface"]["setUploadMode"](_0x36a644);
  }
  ["pointerEvent"](_0x263901, _0x5af64d = null) {
    var _0x56f24b = new Array();
    if (_0x263901 == "move") this.pointerSupport ? _0x56f24b["push"]("pointermove") : (_0x56f24b["push"]("touchmove"), _0x56f24b.push("mousemove")); else {
      if (_0x263901 == "up") this.pointerSupport ? _0x56f24b["push"]("pointerup") : (_0x56f24b["push"]("touchend"), _0x56f24b["push"]("mouseup")); else {
        if (_0x263901 == "down") this["pointerSupport"] ? _0x56f24b["push"]("pointerdown") : (_0x56f24b["push"]("touchstart"), _0x56f24b["push"]("mousedown")); else {
          if (_0x263901 == "over") this["pointerSupport"] ? _0x56f24b.push("pointerover") : _0x56f24b["push"]("mouseover"); else {
            if (_0x263901 == "out") this["pointerSupport"] ? _0x56f24b["push"]("pointerout") : _0x56f24b["push"]("mouseout"); else {
              if (_0x263901 == "click") this["pointerSupport"] ? _0x56f24b["push"]("click") : (_0x56f24b["push"]("touchend"), _0x56f24b["push"]("click")); else {
                if (_0x263901 == "dblclick") _0x56f24b["push"]("dblclick"); else _0x263901 == "dragstart" && _0x56f24b["push"]("dragstart");
              }
            }
          }
        }
      }
    }
    var _0x514485 = "";
    return $["each"](_0x56f24b, function (_0x276c4e, _0x508615) {
      _0x514485 += _0x508615 + (_0x5af64d ? "." + _0x5af64d : "") + " ";
    }), _0x514485;
  }
  ["windowResizeEnded"]() {
    clearTimeout(UI["resizeTimeout"]), UI["resizeTimeout"] = undefined, this["screenWidth"] = window.screen["width"], this["screenHeight"] = window["screen"]["height"], $(UI)["triggerHandler"](new windowResizingEndedEvent()["getEvent"]()), UI["sidebar"] && UI["sidebar"]["adaptToolbar"]();
  }
  ["updateInputDevice"](_0x1b8767) {
    var _0x4bccdc = "mouse";
    if (_0x1b8767["type"] == "pointerdown") _0x4bccdc = _0x1b8767.pointerType; else _0x1b8767["type"] == "touchstart" && (_0x4bccdc = "touch");
    room["myself"]["changeInputDevice"](_0x4bccdc);
  }
  ["updatePressure"](_0xe21787) {
    if (room && room["myself"]) {
      if (room.myself["surface"]["hasBrushOption"]("pressure")) {
        var _0x7d8af8 = room.myself["surface"].getBrushOption("pressure");
        !_0x7d8af8[0] && (_0xe21787 = 1);
        var _0x4ee48f = [_0x7d8af8[0], _0xe21787];
        !matches(_0x4ee48f, _0x7d8af8) && room.myself.surface["setBrushOption"]("pressure", _0x4ee48f);
      }
    }
  }["updateCursor"]() {
  let _0x4771d3;
  if (room && room.myself) {
    _0x4771d3 = room.myself.surface.getCurrentBrush();
  }

  // Flag: Counter-Strike Cursor mode (csCursor)
  const csCursorEnabled =
    localStorage.getItem(
      (window.config && window.config.localStorageKeys && window.config.localStorageKeys.csCursor) || "csCursor"
    ) === "true";

  if (!this.overBoard) {
    this.mousePointer.cursor("auto");
    return;
  }

  if (!this.drawingAllowed()) {
    if (!room.connected) {
      this.mousePointer.cursor("not-allowed", textManager.getString("cursor.txtNotConnected"));
    } else if (room.loading) {
      this.mousePointer.cursor("not-allowed", textManager.getString("cursor.txtLoading"));
    } else if (room.myself.muted) {
      if (room.board && room.board.commitProgress && room.board.commitProgress.active) {
        // Processing progress replaces normal cursor
        this.mousePointer.processingCursor(
          room.board.commitProgress.processed,
          room.board.commitProgress.total
        );
      } else if (room.myself.zoomMuted) {
        this.mousePointer.cursor("zoom");
      } else {
        this.mousePointer.cursor("not-allowed", textManager.getString("cursor.txtYouAreMuted"));
      }
    } else if (this.layerIsLocked(room.myself.surface.currentLayer) && !room.can("drawlockedlayers")) {
      this.mousePointer.cursor("not-allowed", textManager.getString("cursor.txtLayerIsLocked"));
    } else if (!this.layerIsVisible(room.myself.surface.currentLayer)) {
      this.mousePointer.cursor("not-allowed", textManager.getString("cursor.txtLayerIsInvisible"));
    } else {
      this.mousePointer.cursor("not-allowed");
    }
    return;
  }

  // Drawing allowed
  if (this.uploadMode) {
    this.mousePointer.cursor("auto");
  } else if (_0x4771d3 === "rotate") {
    this.mousePointer.cursor("rotate");
  } else if (_0x4771d3 === "drag") {
    this.mousePointer.cursor("move");
  } else if (room.myself.zoomMuted) {
    this.mousePointer.cursor("none");
  } else {
    if (csCursorEnabled) {
      // Modified behavior: always use the "simple" custom crosshair cursor
      this.mousePointer.cursor("simple");
    } else {
      // Original behavior
      if (UI.userPreferences.getGroupOption("graphics", "showmouse")) {
        this.mousePointer.cursor("auto");
      } else {
        this.mousePointer.cursor("none");
      }
    }
  }
}
  ["getInputPosition"](_0x2089a4) {
    var _0x33d86a = undefined,
      _0x204198 = undefined;
    return _0x2089a4.pageX !== undefined && (_0x33d86a = _0x2089a4["pageX"]), _0x2089a4["pageY"] !== undefined && (_0x204198 = _0x2089a4.pageY), _0x2089a4["originalEvent"] && _0x2089a4.originalEvent["touches"] && _0x2089a4["originalEvent"]["touches"]["length"] > 0 && (_0x33d86a = _0x2089a4["originalEvent"]["touches"][0]["pageX"], _0x204198 = _0x2089a4["originalEvent"]["touches"][0]["pageY"]), new Point(_0x33d86a, _0x204198);
  }
  ["bindEventsBoardEnabled"]() {
    var _0x10486a = this;
    this.drawingArea.on("dragover dragenter", function (_0xd32801) {
      _0xd32801["preventDefault"](), _0x10486a["boardContainer"]["css"]("outline", "3px solid red");
    }), this.drawingArea.on("dragleave", function (_0x1df044) {
      _0x1df044.preventDefault(), _0x10486a["boardContainer"]["css"]("outline", "3px solid #505050");
    }), this.drawingArea.on("drop", function (_0x17e3f6) {
      _0x17e3f6.preventDefault(), _0x10486a["boardContainer"]["css"]("outline", "3px solid #505050"), _0x10486a["uploader"]["uploadFile"](_0x17e3f6["originalEvent"].dataTransfer["files"]);
    }), this["drawingArea"]["contextmenu"](function (_0x453f30) {
      if (room && room["myself"]) {
        if (room.myself.inputDevice === "mouse") { // Check if the input device is "mouse"
            if (room.myself.surface["brushHandler"]["hasOption"]("rightclick")) {
                var _0x4cae37 = room["myself"].surface["brushHandler"]["getOption"]("rightclick");
                _0x10486a.rightClick(_0x4cae37);
            }
        }
    }
    
    }), this["drawingArea"].on(this["pointerEvent"]("down", "ui"), function (_0x234e5f) {
      if (!_0x10486a["onFocus"]) return;
      if (!_0x10486a["isCurrentPointer"](_0x234e5f["pointerId"])) return; else _0x10486a["setCurrentPointer"](_0x234e5f["pointerId"]);
      var _0x115dd0 = _0x10486a["getInputPosition"](_0x234e5f);
      _0x10486a["mousePointer"].move(_0x115dd0.x, _0x115dd0.y);
      if (_0x10486a["preDraggingMode"] || _0x234e5f["which"] && _0x234e5f.which == 2) _0x234e5f["preventDefault"](), _0x10486a["drag"](true), !_0x10486a["dragPoint"] && (_0x10486a["dragPoint"] = new Point(_0x10486a["mousePointer"].position.x - _0x10486a["viewLeft"], _0x10486a["mousePointer"]["position"].y - _0x10486a["viewTop"])), _0x10486a["pip"]["show"](_0x10486a["getThumbnail"](), room["board"]["backgroundColor"]); else {
        if (!_0x234e5f["which"] || _0x234e5f.which == 1) {
          _0x234e5f["preventDefault"]();
          var _0x28f81f;
          room && room.myself && (_0x28f81f = room["myself"]["surface"]["getCurrentBrush"]());
          if (_0x28f81f == "drag") !_0x10486a["dragPoint"] && (_0x10486a.dragPoint = new Point(_0x10486a.mousePointer["position"].x - _0x10486a["viewLeft"], _0x10486a["mousePointer"]["position"].y - _0x10486a["viewTop"])), _0x10486a["pip"]["show"](_0x10486a["getThumbnail"](), room["board"]["backgroundColor"]); else {
            if (_0x28f81f == "rotate") {
              if (!_0x10486a["dragPoint"]) {
                _0x10486a["dragPoint"] = new Point(0, 0);
                var _0x264faa = Math["atan2"](_0x115dd0.x - _0x10486a["boardContainer"]["width"]() / 2, _0x115dd0.y - _0x10486a.boardContainer["height"]() / 2);
                _0x10486a["dragInitialRotation"] = _0x264faa * (180 / Math.PI) * -1 + 90, _0x10486a.dragRotation = room.board["rotation"];
              }
            }
          }
        }
      }
    }), this["boardContainer"]["find"](".slate.myself").on(this["pointerEvent"]("down", "ui"), function (_0x171670) {
      if (!_0x10486a["onFocus"]) return;
      if (!_0x10486a["isCurrentPointer"](_0x171670["pointerId"])) return;
      if (!_0x10486a["preDraggingMode"] && (!_0x171670["which"] || _0x171670["which"] == 1)) {
        _0x171670.preventDefault();
        var _0x3792e3 = _0x10486a["getInputPosition"](_0x171670);
        _0x10486a["mousePointer"].move(_0x3792e3.x, _0x3792e3.y), _0x10486a["hovering"] = true, _0x10486a.updateInputDevice(_0x171670);
        var _0x19d78d;
        room && room["myself"] && (_0x19d78d = room["myself"].surface["getCurrentBrush"]());
        if (_0x10486a.drawingAllowed()) {
          if (!_0x10486a["uploadMode"] || _0x10486a["uploadMode"] && !room["myself"]["surface"].getBrushDrawingTool()) {
            var _0x211446 = _0x10486a["screenToBoard"](_0x3792e3.x, _0x3792e3.y);
            room["myself"]["surface"]["penDown"](parseInt(_0x211446.x * 100) / 100, parseInt(_0x211446.y * 100) / 100);
          }
        }
        room && room["myself"] && (_0x10486a.overBoard && room["myself"]["surface"]["getBrushShowPen"]() ? _0x10486a["showPen"]() : _0x10486a["hidePen"]());
      }
    }), $(room["board"]["canvasContainer"]).on("mouseleave pointerleave", function (_0x1ed5c2) {
      _0x10486a.mousePointer["cursor"]("auto");
    }), $(room["board"]).on("scaleChanged", function (_0x45454f) {
      _0x10486a.updateViewLimits(), _0x10486a["bottombar"]["setScale"](parseInt(_0x45454f["scale"] * 1000) / 10), _0x45454f["center"] && _0x10486a["centerBoard"](), room["myself"]["surface"]["getCurrentBrush"]() == "selection" && _0x10486a.selectionToolbar["visible"]() && _0x10486a.showSelectionToolbar(), $("body")["get"](0).style["setProperty"]("--ui-scale", _0x45454f["scale"]);
    }), $(room["board"]).on("layerLocked layerUnlocked", function (_0x2075cb) {
      _0x10486a["setupLayerPrivileges"]();
    }), $(room["board"]).on("rotationChanged", function (_0x300e3d) {
      _0x10486a.updateViewLimits(), _0x10486a.bottombar["setRotation"](parseInt(_0x300e3d["rotation"]));
      if (_0x10486a.pip["isVisible"]()) {
        var _0x5a206f = _0x10486a.drawingArea["offset"](),
          _0x123a35 = _0x10486a["screenToBoard"](_0x5a206f["left"], _0x5a206f.top);
        _0x10486a["pip"]["setView"](_0x123a35.x, _0x123a35.y, UI["drawingArea"].width(), UI["drawingArea"].height(), room["board"]["scale"], room.board["rotation"]);
      }
    }), $(room["board"]).on("layerCountChange", function (_0x59d00d) {
      _0x10486a._tmp = [];
      for (var _0x4a98ba = 0; _0x4a98ba < _0x59d00d["oldLayers"]; _0x4a98ba++) {
        _0x4a98ba in room["board"].layers && _0x10486a["_tmp"]["push"](room["board"]["layers"][_0x4a98ba].getData());
      }
      $(room["myself"].surface)["triggerHandler"](new brushChangedEvent(room.myself.surface["getCurrentBrush"]())["getEvent"]()), _0x10486a["undoDialog"]["reset"](), _0x10486a["sidebar"].layerPreview["updatePreviews"](), room["myself"]["surface"]["currentLayer"] >= room.board.nLayers && room["myself"].surface["setCurrentLayer"](0);
    }), $(room["board"]).on("canvasSizeChange", function (_0x746546) {
      _0x10486a["_tmp"] = [];
      for (var _0x17eba7 = 0; _0x17eba7 < room["board"]["nLayers"]; _0x17eba7++) {
        _0x10486a["_tmp"]["push"](room["board"]["layers"][_0x17eba7]["getData"]());
      }
    }), $(room.board).on("layerCountChanged", function (_0x5c5bab) {
      var _0x590a12 = 0,
        _0x2e35ff = _0x10486a["_tmp"]["length"];
      for (var _0x4b433c = 0; _0x4b433c < _0x5c5bab["layers"]; _0x4b433c++) {
        _0x4b433c in _0x10486a._tmp && room["board"].layers[_0x4b433c].putData(_0x10486a._tmp[_0x4b433c])["then"](function () {
          ++_0x590a12 == _0x2e35ff && _0x10486a.sidebar.layerPreview["updatePreviews"]();
        });
      }
      if (_0x5c5bab["layers"] < _0x5c5bab["oldLayers"]) for (var _0x4b433c = _0x5c5bab.layers; _0x4b433c < _0x5c5bab["oldLayers"]; _0x4b433c++) {
        room.board.layers[_0x5c5bab["layers"] - 1]["putData"](_0x10486a["_tmp"][_0x4b433c]).then(function () {
          _0x10486a["sidebar"]["layerPreview"]["updatePreview"](_0x5c5bab["layers"] - 1);
        });
      }
      _0x10486a["sidebar"].layerPreview["updateLayerCount"](), _0x10486a["_tmp"] = null, _0x10486a.setupLayerPrivileges();
    }), $(this.uploader).on("imageChanged", function (_0x25602b) {
      room && room["myself"] && (_0x10486a.showPen(), room["myself"].surface["drawSilhouette"](_0x25602b.x, _0x25602b.y, _0x25602b.width, _0x25602b["height"], _0x25602b["rotation"]));
    }), $(this.uploader).on("uploaderOpened uploaderClosed", function (_0x53b750) {
      room["myself"]["surface"].getCurrentBrush() == "selection" && room["myself"].surface.setBrushOptionReadOnly("multilayer", _0x53b750["type"] == "uploaderOpened");
    });
  }
  ["bindEventsBoardDisabled"]() {
    var _0x10486a = this;
    this.drawingArea.on("dragover dragenter", function (_0xd32801) {
      _0xd32801["preventDefault"](), _0x10486a["boardContainer"]["css"]("outline", "3px solid red");
    }), this.drawingArea.on("dragleave", function (_0x1df044) {
      _0x1df044.preventDefault(), _0x10486a["boardContainer"]["css"]("outline", "3px solid #505050");
    }), this.drawingArea.on("drop", function (_0x17e3f6) {
      _0x17e3f6.preventDefault(), _0x10486a["boardContainer"]["css"]("outline", "3px solid #505050"), _0x10486a["uploader"]["uploadFile"](_0x17e3f6["originalEvent"].dataTransfer["files"]);
    }), this["drawingArea"]["contextmenu"](function (_0x453f30) {
      if (room && room["myself"]) {
        if (room.myself.surface["brushHandler"]["hasOption"]("rightclick")) {
          var _0x4cae37 = room["myself"].surface["brushHandler"]["getOption"]("rightclick");
          _0x10486a.rightClick(_0x4cae37);
        }
      }
    }), this["drawingArea"].on(this["pointerEvent"]("down", "ui"), function (_0x234e5f) {
      if (!_0x10486a["onFocus"]) return;
      if (!_0x10486a["isCurrentPointer"](_0x234e5f["pointerId"])) return; else _0x10486a["setCurrentPointer"](_0x234e5f["pointerId"]);
      var _0x115dd0 = _0x10486a["getInputPosition"](_0x234e5f);
      _0x10486a["mousePointer"].move(_0x115dd0.x, _0x115dd0.y);
      if (_0x10486a["preDraggingMode"] || _0x234e5f["which"] && _0x234e5f.which == 2) _0x234e5f["preventDefault"](), _0x10486a["drag"](true), !_0x10486a["dragPoint"] && (_0x10486a["dragPoint"] = new Point(_0x10486a["mousePointer"].position.x - _0x10486a["viewLeft"], _0x10486a["mousePointer"]["position"].y - _0x10486a["viewTop"])), _0x10486a["pip"]["show"](_0x10486a["getThumbnail"](), room["board"]["backgroundColor"]); else {
        if (!_0x234e5f["which"] || _0x234e5f.which == 1) {
          _0x234e5f["preventDefault"]();
          var _0x28f81f;
          room && room.myself && (_0x28f81f = room["myself"]["surface"]["getCurrentBrush"]());
          if (_0x28f81f == "drag") !_0x10486a["dragPoint"] && (_0x10486a.dragPoint = new Point(_0x10486a.mousePointer["position"].x - _0x10486a["viewLeft"], _0x10486a["mousePointer"]["position"].y - _0x10486a["viewTop"])), _0x10486a["pip"]["show"](_0x10486a["getThumbnail"](), room["board"]["backgroundColor"]); else {
            if (_0x28f81f == "rotate") {
              if (!_0x10486a["dragPoint"]) {
                _0x10486a["dragPoint"] = new Point(0, 0);
                var _0x264faa = Math["atan2"](_0x115dd0.x - _0x10486a["boardContainer"]["width"]() / 2, _0x115dd0.y - _0x10486a.boardContainer["height"]() / 2);
                _0x10486a["dragInitialRotation"] = _0x264faa * (180 / Math.PI) * -1 + 90, _0x10486a.dragRotation = room.board["rotation"];
              }
            }
          }
        }
      }
    }), this["boardContainer"]["find"](".slate.myself").on(this["pointerEvent"]("down", "ui"), function (_0x171670) {
      if (!_0x10486a["onFocus"]) return;
      if (!_0x10486a["isCurrentPointer"](_0x171670["pointerId"])) return;
      if (!_0x10486a["preDraggingMode"] && (!_0x171670["which"] || _0x171670["which"] == 1)) {
        _0x171670.preventDefault();
        var _0x3792e3 = _0x10486a["getInputPosition"](_0x171670);
        _0x10486a["mousePointer"].move(_0x3792e3.x, _0x3792e3.y), _0x10486a["hovering"] = true, _0x10486a.updateInputDevice(_0x171670);
        var _0x19d78d;
        room && room["myself"] && (_0x19d78d = room["myself"].surface["getCurrentBrush"]());
        if (_0x10486a.drawingAllowed()) {
          if (!_0x10486a["uploadMode"] || _0x10486a["uploadMode"] && !room["myself"]["surface"].getBrushDrawingTool()) {
            var _0x211446 = _0x10486a["screenToBoard"](_0x3792e3.x, _0x3792e3.y);
            room["myself"]["surface"]["penDown"](parseInt(_0x211446.x * 100) / 100, parseInt(_0x211446.y * 100) / 100);
          }
        }
        room && room["myself"] && (_0x10486a.overBoard && room["myself"]["surface"]["getBrushShowPen"]() ? _0x10486a["showPen"]() : _0x10486a["hidePen"]());
      }
    }), $(room["board"]["canvasContainer"]).on("mouseleave pointerleave", function (_0x1ed5c2) {
      _0x10486a.mousePointer["cursor"]("auto");
    }), $(room["board"]).on("scaleChanged", function (_0x45454f) {
      _0x10486a.updateViewLimits(), _0x10486a["bottombar"]["setScale"](parseInt(_0x45454f["scale"] * 100)), _0x45454f["center"] && _0x10486a["centerBoard"](), room["myself"]["surface"]["getCurrentBrush"]() == "selection" && _0x10486a.selectionToolbar["visible"]() && _0x10486a.showSelectionToolbar(), $("body")["get"](0).style["setProperty"]("--ui-scale", _0x45454f["scale"]);
    }), $(room["board"]).on("layerLocked layerUnlocked", function (_0x2075cb) {
      _0x10486a["setupLayerPrivileges"]();
    }), $(room["board"]).on("rotationChanged", function (_0x300e3d) {
      _0x10486a.updateViewLimits(), _0x10486a.bottombar["setRotation"](parseInt(_0x300e3d["rotation"]));
      if (_0x10486a.pip["isVisible"]()) {
        var _0x5a206f = _0x10486a.drawingArea["offset"](),
          _0x123a35 = _0x10486a["screenToBoard"](_0x5a206f["left"], _0x5a206f.top);
        _0x10486a["pip"]["setView"](_0x123a35.x, _0x123a35.y, UI["drawingArea"].width(), UI["drawingArea"].height(), room["board"]["scale"], room.board["rotation"]);
      }
    }), $(room["board"]).on("layerCountChange", function (_0x59d00d) {
      _0x10486a._tmp = [];
      for (var _0x4a98ba = 0; _0x4a98ba < _0x59d00d["oldLayers"]; _0x4a98ba++) {
        _0x4a98ba in room["board"].layers && _0x10486a["_tmp"]["push"](room["board"]["layers"][_0x4a98ba].getData());
      }
      $(room["myself"].surface)["triggerHandler"](new brushChangedEvent(room.myself.surface["getCurrentBrush"]())["getEvent"]()), _0x10486a["undoDialog"]["reset"](), _0x10486a["sidebar"].layerPreview["updatePreviews"](), room["myself"]["surface"]["currentLayer"] >= room.board.nLayers && room["myself"].surface["setCurrentLayer"](0);
    }), $(room["board"]).on("canvasSizeChange", function (_0x746546) {
      _0x10486a["_tmp"] = [];
      for (var _0x17eba7 = 0; _0x17eba7 < room["board"]["nLayers"]; _0x17eba7++) {
        _0x10486a["_tmp"]["push"](room["board"]["layers"][_0x17eba7]["getData"]());
      }
    }), $(room.board).on("layerCountChanged", function (_0x5c5bab) {
      var _0x590a12 = 0,
        _0x2e35ff = _0x10486a["_tmp"]["length"];
      for (var _0x4b433c = 0; _0x4b433c < _0x5c5bab["layers"]; _0x4b433c++) {
        _0x4b433c in _0x10486a._tmp && room["board"].layers[_0x4b433c].putData(_0x10486a._tmp[_0x4b433c])["then"](function () {
          ++_0x590a12 == _0x2e35ff && _0x10486a.sidebar.layerPreview["updatePreviews"]();
        });
      }
      if (_0x5c5bab["layers"] < _0x5c5bab["oldLayers"]) for (var _0x4b433c = _0x5c5bab.layers; _0x4b433c < _0x5c5bab["oldLayers"]; _0x4b433c++) {
        room.board.layers[_0x5c5bab["layers"] - 1]["putData"](_0x10486a["_tmp"][_0x4b433c]).then(function () {
          _0x10486a["sidebar"]["layerPreview"]["updatePreview"](_0x5c5bab["layers"] - 1);
        });
      }
      _0x10486a["sidebar"].layerPreview["updateLayerCount"](), _0x10486a["_tmp"] = null, _0x10486a.setupLayerPrivileges();
    }), $(this.uploader).on("imageChanged", function (_0x25602b) {
      room && room["myself"] && (_0x10486a.showPen(), room["myself"].surface["drawSilhouette"](_0x25602b.x, _0x25602b.y, _0x25602b.width, _0x25602b["height"], _0x25602b["rotation"]));
    }), $(this.uploader).on("uploaderOpened uploaderClosed", function (_0x53b750) {
      room["myself"]["surface"].getCurrentBrush() == "selection" && room["myself"].surface.setBrushOptionReadOnly("multilayer", _0x53b750["type"] == "uploaderOpened");
    });
  }
  ["isCurrentPointer"](_0xd36145) {
    return this["drawingWithPointer"] == null || this.drawingWithPointer == _0xd36145;
  }
  ["setCurrentPointer"](_0x238fca) {
    this["drawingWithPointer"] != _0x238fca && (this["drawingWithPointer"] = _0x238fca);
  }
  ["rightClick"](_0x462edb = "donothing") {
    if (_0x462edb == "cancelstroke") room["myself"]["surface"].penCancel(); else {
      if (_0x462edb == "showmenu") try {
        $(".boardMenu").contextMenu({
          x: this.mousePointer["position"].x,
          y: this["mousePointer"].position.y
        });
      } catch (_0x31c619) { } else {
        if (_0x462edb == "swapcolors") this["sidebar"]["colorBox"]["swap"](); else {
          if (_0x462edb == "centerboard") this["centerBoard"](); else {
            if (_0x462edb == "fittoscreen") this["fitToScreen"](); else {
              if (_0x462edb == "resetzoom") room["board"]["changeScale"](1), self["centerBoard"](); else {
                if (_0x462edb == "rotatereset") room.board["changeRotation"](0); else {
                  if (_0x462edb == "rotate45right") room.board["changeRotation"](room.board["rotation"] + 45); else {
                    if (_0x462edb == "toggleareaaverage") !room["myself"]["surface"]["isBrushOptionReadOnly"]("areaaverage") && room["myself"]["surface"]["setBrushOption"]("areaaverage", !room["myself"]["surface"]["getBrushOption"]("areaaverage")); else {
                      if (_0x462edb == "togglemultilayer") !room.myself["surface"]["isBrushOptionReadOnly"]("multilayer") && room["myself"]["surface"].setBrushOption("multilayer", !room.myself["surface"]["getBrushOption"]("multilayer")); else {
                        if (_0x462edb == "togglepressureopacity") !room.myself["surface"]["isBrushOptionReadOnly"]("togglepressureopacity") && room["myself"]["surface"].setBrushOption("togglepressureopacity", !room.myself["surface"]["getBrushOption"]("togglepressureopacity")); else {
                          if (_0x462edb == "locktransparency") !room.myself["surface"]["isBrushOptionReadOnly"]("locktransparency") && room["myself"]["surface"].setBrushOption("locktransparency", !room.myself["surface"]["getBrushOption"]("locktransparency")); else {
                            if (_0x462edb == "togglewholepixels") !room["myself"]["surface"]["isBrushOptionReadOnly"]("togglewholepixels") && room["myself"]["surface"]["setBrushOption"]("togglewholepixels", !room["myself"]["surface"]["getBrushOption"]("togglewholepixels")); else {
                              if (_0x462edb == "polygonalselection") !room["myself"]["surface"]["isBrushOptionReadOnly"]("polygonalselection") && room["myself"]["surface"]["setBrushOption"]("polygonalselection", !room["myself"]["surface"]["getBrushOption"]("polygonalselection")); else {
                                if (_0x462edb == "toggleselectiontype") !room["myself"]["surface"]["isBrushOptionReadOnly"]("selectiontype") && room.myself.surface["setBrushOption"]("selectiontype", !room.myself["surface"]["getBrushOption"]("selectiontype")); else {
                                  if (_0x462edb == "togglesnap") !room["myself"]["surface"]["isBrushOptionReadOnly"]("snap") && room["myself"]["surface"]["setBrushOption"]("snap", !room["myself"]["surface"]["getBrushOption"]("snap")); else {
                                    if (_0x462edb == "toggleaspectratio") !room["myself"]["surface"]["isBrushOptionReadOnly"]("aspectratio") && room["myself"]["surface"].setBrushOption("aspectratio", !room["myself"].surface["getBrushOption"]("aspectratio")); else {
                                      if (_0x462edb == "toggleerasermode") !room["myself"]["surface"]["isBrushOptionReadOnly"]("erasermode") && room["myself"].surface["setBrushOption"]("erasermode", !room["myself"]["surface"]["getBrushOption"]("erasermode")); else {
                                        if (_0x462edb == "toggledrawgrid") !room["myself"]["surface"].isBrushOptionReadOnly("drawgrid") && room.myself["surface"].setBrushOption("drawgrid", !room["myself"].surface["getBrushOption"]("drawgrid")); else {
                                          if (_0x462edb == "cleartext") room.myself["surface"]["getCurrentBrush"]() == "text" && room["myself"]["surface"].penCancel(); else {
                                            if (_0x462edb == "switchprevtool") this["sidebar"]["toolbar"].selectPreviouslyUsed(); else {
                                              if (_0x462edb == "selecteraser") this.sidebar["toolbar"].select("eraser"); else {
                                                if (_0x462edb == "nextfont") {
                                                  var _0x580287 = "font",
                                                    _0x2d6ff1 = "+";
                                                  if (room["myself"]["surface"]["hasBrushOption"](_0x580287)) {
                                                    if (!room["myself"]["surface"].isBrushOptionReadOnly(_0x580287)) {
                                                      var _0x2faa50 = Object["keys"](room["myself"]["surface"]["brushHandler"]["brush"]["options"][_0x580287].list),
                                                        _0x175a54 = room["myself"]["surface"]["getBrushOption"](_0x580287),
                                                        _0x3d8f10 = _0x2faa50["indexOf"](_0x175a54),
                                                        _0x498dd0;
                                                      _0x2d6ff1 == "+" ? _0x3d8f10 + 1 > _0x2faa50["length"] - 1 ? _0x498dd0 = 0 : _0x498dd0 = _0x3d8f10 + 1 : _0x3d8f10 - 1 < 0 ? _0x498dd0 = _0x2faa50.length - 1 : _0x498dd0 = _0x3d8f10 - 1, room["myself"].surface["setBrushOption"](_0x580287, _0x2faa50[_0x498dd0]);
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ["bindEvents"]() {
    var _0x340150 = this;
    this["bindEventsRoom"](), this.bindEventsBoard(), $(".appMain").on("contextmenu", function (_0x49d72f) {
      _0x49d72f.preventDefault();
    }), this["boardContainer"].on("contextmenu", function (_0x2714bf) {
      _0x2714bf["preventDefault"]();
    }), $(this["colorBox"]).on("colorChanged", function (_0x30c564) {
      _0x340150["colorChange"](_0x30c564.color);
    });
  }
  ["setupTools"](_0x80d00) {
    var _0x336a84 = this;
    $["each"](_0x80d00, function (_0x16f70a, _0x2fe424) {
      _0x2fe424 ? _0x336a84["sidebar"].toolbar["showTool"](_0x16f70a) : _0x336a84["sidebar"]["toolbar"]["hideTool"](_0x16f70a);
    });
  }
  ["isToolAvailable"](_0x36e0e9) {
    if (this["sidebar"] && this.sidebar.toolbar) return this["sidebar"].toolbar["container"].find("[name=\"" + _0x36e0e9 + '"]').is(":visible");
    return false;
  }
  ["setupPrivileges"](_0x4d3150) {
    var _0x1e5e75 = this;
    room.myself["rank"] == "UU" ? _0x1e5e75["bottombar"].hideButton("messengerButton") : _0x1e5e75["bottombar"].showButton("messengerButton"), room.myself["rank"] == "GM" ? _0x1e5e75["bottombar"]["showButton"]("adminConsoleButton") : _0x1e5e75["bottombar"]["hideButton"]("adminConsoleButton"), $["each"](_0x4d3150, function (_0x54c26b, _0x45fa21) {
      if (_0x54c26b == "pundo") _0x45fa21 ? (_0x1e5e75["bottombar"]["showButton"]("undoButton"), _0x1e5e75["undoDialog"]["enable"](room.name)) : (_0x1e5e75["bottombar"].hideButton("undoButton"), _0x1e5e75.undoDialog.disable()); else {
        if (_0x54c26b == "pload") _0x45fa21 ? _0x1e5e75.bottombar["showButton"]("uploadButton") : _0x1e5e75.bottombar["hideButton"]("uploadButton"); else {
          if (_0x54c26b == "roommanager") _0x45fa21 ? _0x1e5e75["bottombar"].showButton("roomManagerButton") : _0x1e5e75.bottombar.hideButton("roomManagerButton"); else {
            if (_0x54c26b == "clearlayer") _0x45fa21 ? _0x1e5e75["sidebar"]["layerPreview"]["enableButton"]("clear") : _0x1e5e75.sidebar["layerPreview"]["disableButton"]("clear"); else {
              if (_0x54c26b == "locklayers") _0x45fa21 ? _0x1e5e75.sidebar["layerPreview"]["enableButton"]("locktoggle") : _0x1e5e75["sidebar"].layerPreview["disableButton"]("locktoggle"); else {
                if (_0x54c26b == "fliplayer") _0x45fa21 ? (_0x1e5e75.sidebar["layerPreview"]["enableButton"]("flipv"), _0x1e5e75["sidebar"]["layerPreview"]["enableButton"]("fliph")) : (_0x1e5e75["sidebar"]["layerPreview"]["disableButton"]("flipv"), _0x1e5e75["sidebar"]["layerPreview"]["disableButton"]("fliph")); else {
                  if (_0x54c26b == "mergelayer") _0x45fa21 ? _0x1e5e75["sidebar"]["layerPreview"]["enableButton"]("mergeLayer") : _0x1e5e75.sidebar["layerPreview"]["disableButton"]("mergeLayer"); else _0x54c26b == "manageframes" && (_0x45fa21 ? _0x1e5e75.sidebar["animationOptions"]["enableButton"]("frameOptions") : _0x1e5e75.sidebar["animationOptions"].disableButton("frameOptions"));
                }
              }
            }
          }
        }
      }
    }), this["setupLayerPrivileges"]();
  }
  ["setupLayerPrivileges"]() {
    var _0xddb694 = new Array();
    for (var _0x37dafd = 0; _0x37dafd < room["board"]["nLayers"]; _0x37dafd++) {
      (!this["layerIsLocked"](_0x37dafd) || room["can"]("drawlockedlayers")) && _0xddb694["push"](_0x37dafd);
    }
    var _0x407add = {},
      _0x4fdd6b = this;
    $.each(room["myself"]["surface"]["brushHandler"]["brushes"], function (_0x278446, _0x21bc69) {
      _0x21bc69.hasOption("allowedlayers") && (_0x407add[_0x278446] = {}, _0x407add[_0x278446]["allowedlayers"] = _0xddb694);
    }), room["myself"]["surface"]["setBrushesOptions"](_0x407add);
  }
  ["updateViewLimits"]() {
    var _0x568077 = this["boardContainer"][0].getBoundingClientRect();
    this["viewLeft"] = _0x568077["left"], this["viewTop"] = _0x568077["top"], this.viewWidth = _0x568077.width, this["viewHeight"] = _0x568077["height"];
  }
  ["calculateFlipX"](_0x2002f9) {
    return UI["flipX"] ? room["board"]["canvasWidth"] - _0x2002f9 : _0x2002f9;
  }
  ["calculateRotation"](_0x58fa83, _0xab2482, _0x51bc45) {
    var _0x3743b8 = this["viewWidth"] / 2 / room["board"]["scale"],
      _0x1378eb = this["viewHeight"] / 2 / room["board"]["scale"],
      _0x10f2d8 = -_0x51bc45 * Math.PI / 180,
      _0x13523c = (_0x58fa83 - _0x3743b8) * Math["cos"](_0x10f2d8) - (_0xab2482 - _0x1378eb) * Math.sin(_0x10f2d8) + this["boardContainer"]["width"]() / 2,
      _0x158c80 = (_0xab2482 - _0x1378eb) * Math.cos(_0x10f2d8) + (_0x58fa83 - _0x3743b8) * Math["sin"](_0x10f2d8) + this["boardContainer"].height() / 2;
    return new Point(_0x13523c, _0x158c80);
  }
  ["calculateReverseRotation"](_0x3a4bf9, _0x4dca0f, _0x437761) {
    var _0x55c006 = this["boardContainer"]["width"]() / 2,
      _0x4d89e3 = this["boardContainer"]["height"]() / 2,
      _0xaab1cd = _0x437761 * Math.PI / 180,
      _0x21491e = (_0x3a4bf9 - _0x55c006) * Math["cos"](_0xaab1cd) - (_0x4dca0f - _0x4d89e3) * Math["sin"](_0xaab1cd) + this.viewWidth / room["board"]["scale"] / 2,
      _0x3e9184 = (_0x4dca0f - _0x4d89e3) * Math["cos"](_0xaab1cd) + (_0x3a4bf9 - _0x55c006) * Math["sin"](_0xaab1cd) + this.viewHeight / room["board"]["scale"] / 2;
    return new Point(_0x21491e, _0x3e9184);
  }
  ["updateTransform"]() {
    var _0x3ba85d = this["flipX"] ? -1 : 1;
    room["board"]["cursorContainer"].css("transform", "translateZ(0) scaleX(" + _0x3ba85d + ") translate(" + this["viewOffset"].x + "px, " + this.viewOffset.y + "px)"), room["board"]["canvasContainer"]["css"]("transform", "translateZ(0) scaleX(" + _0x3ba85d + ") translate(" + this["viewOffset"].x + "px, " + this["viewOffset"].y + "px)");
  }
  ["flipViewEnabled"](_0x5aee26) {
    let x_converted = UI.viewWidth - (((UI.drawingArea.offset().left - UI.viewLeft)) + UI.drawingArea.width())
    let y = ((UI.drawingArea.offset().top - UI.viewTop))
    room.board.changeRotation(360 - room.board.rotation),
    UI.moveBoard(-1 * (x_converted), -1 * y), 
    this["flipLabels"](), _0x5aee26 ? this.bottombar["selectButton"]("flipXButton") : this["bottombar"]["unselectButton"]("flipXButton"), this["flipX"] = _0x5aee26, 
    this["updateTransform"](), $(this)["triggerHandler"](new viewFlippedEvent(_0x5aee26).getEvent());
  }
  ["flipViewDisabled"](_0x5aee26) { 
    this["flipLabels"](), _0x5aee26 ? this.bottombar["selectButton"]("flipXButton") : this["bottombar"]["unselectButton"]("flipXButton"), this["flipX"] = _0x5aee26, 
    this["updateTransform"](), $(this)["triggerHandler"](new viewFlippedEvent(_0x5aee26).getEvent());
  }
  ["optionToObject"](_0x277b18, _0x370311 = null) {
    if (_0x277b18 == "size") return new SizeOption(_0x370311); else {
      if (_0x277b18 == "alpha") return new AlphaOption(_0x370311); else {
        if (_0x277b18 == "blur") return new BlurOption(_0x370311); else {
          if (_0x277b18 == "smooth") return new SmoothOption(_0x370311); else {
            if (_0x277b18 == "blendmode") return new BlendModeOption(_0x370311); else {
              if (_0x277b18 == "pressure") return new PressureOption(_0x370311); else {
                if (_0x277b18 == "spacing") return new SpacingOption(_0x370311); else {
                  if (_0x277b18 == "customize") return new CustomizeOption(_0x370311); else {
                    if (_0x277b18 == "gallery") return new GalleryOption(_0x370311); else {
                      if (_0x277b18 == "multilayer") return new MultilayerOption(_0x370311); else {
                        if (_0x277b18 == "togglepressureopacity") return new PressureOpacityOption(_0x370311); else {
                          if (_0x277b18 == "locktransparency") return new LockTransparencyOption(_0x370311); else {
                            if (_0x277b18 == "togglewholepixels") return new WholePixelOption(_0x370311); else {
                              if (_0x277b18 == "polygonalselection") return new PolygonalSelectionOption(_0x370311); else {
                                if (_0x277b18 == "togglezoom") return new ZoomOption(_0x370311); else {
                                  if (_0x277b18 == "selectiontype") return new SelectionTypeOption(_0x370311); else {
                                    if (_0x277b18 == "rightclick") return new RightClickOption(null, _0x370311); else {
                                      if (_0x277b18 == "cursor") return new CursorOption(null, _0x370311); else {
                                        if (_0x277b18 == "erasermode") return new EraserModeOption(_0x370311); else {
                                          if (_0x277b18 == "areaaverage") return new AreaAverageOption(_0x370311); else {
                                            if (_0x277b18 == "aspectratio") return new AspectRatioOption(_0x370311); else {
                                              if (_0x277b18 == "snap") return new SnapOption(_0x370311); else {
                                                if (_0x277b18 == "drawgrid") return new DrawGridOption(_0x370311); else {
                                                  if (_0x277b18 == "font") return new FontOption(_0x370311); else {
                                                    if (_0x277b18 == "fill") return new FillOption(_0x370311); else {
                                                      if (_0x277b18 == "allowedlayers") return new AllowedLayersOption(_0x370311); else {
                                                        if (_0x277b18 == "image") return new ImageOption(_0x370311); else {
                                                          if (_0x277b18 == "tint") return new TintOption(_0x370311); else {
                                                            if (_0x277b18 == "randomrotation") return new RandomRotationOption(_0x370311); else log("Missing option: " + _0x277b18);
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return "";
  }
  ["optionToName"](_0x3f51af) {
    return textManager.getString("tooloption." + _0x3f51af);
  }
  ["rankToStyle"](_0x1a0c30) {
    if (_0x1a0c30 == "GM") return "rankGM"; else {
      if (_0x1a0c30 == "RO" || _0x1a0c30 == "CO") return "rankRO"; else {
        if (_0x1a0c30 == "LM") return "rankLM"; else {
          if (_0x1a0c30 == "FM") return "rankFM"; else {
            if (_0x1a0c30 == "RM") return "rankRM"; else {
              if (_0x1a0c30 == "TU") return "rankTU"; else {
                if (_0x1a0c30 == "WU") return "rankWU"; else {
                  if (_0x1a0c30 == "RU") return "rankRU"; else {
                    if (_0x1a0c30 == "UU") return "rankUU";
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ["brushToName"](_0x16a42f) {
    return textManager.getString("tool." + _0x16a42f);
  }
  ["brushToIcon"](_0x4309cb) {
    if (_0x4309cb == "drag") return new Icon("fa-hand-paper"); else {
      if (_0x4309cb == "rotate") return new Icon("fa-sync-alt"); else {
        if (_0x4309cb == "picker") return new Icon("fa-eye-dropper"); else {
          if (_0x4309cb == "selection") return new Icon("fa-mouse-pointer"); else {
            if (_0x4309cb == "pen") return new Icon("fa-paint-brush"); else {
              if (_0x4309cb == "eraser") return new Icon("fa-eraser"); else {
                if (_0x4309cb == "text") return new Icon("fa-font"); else {
                  if (_0x4309cb == "line") return new Icon("fa-arrows-alt-v"); else {
                    if (_0x4309cb == "rect") return new Icon("fa-square", "far"); else {
                      if (_0x4309cb == "ellipse") return new Icon("fa-circle", "far"); else {
                        if (_0x4309cb == "fill") return new Icon("fa-fill-drip"); else {
                          if (_0x4309cb == "blend") return new Icon("fa-spinner"); else {
                            if (_0x4309cb == "custom") return new Icon("fa-paint-roller"); else {
                              if (_0x4309cb == "blur") return new Icon("fa-tint"); else {
                                if (_0x4309cb == "pixel") return new Icon("fa-pencil-alt");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ["getImageLayer"](_0x22dffb) {
    return new Promise(function (_0x1d8111, _0x2208fa) {
      var _0x2c071f = new Image();
      _0x2c071f["alt"] = _0x22dffb, _0x2c071f["onload"] = function () {
        _0x1d8111(_0x2c071f);
      }, _0x2c071f.src = room.board["layers"][_0x22dffb].getData();
    });
  }
  ["colorChange"](_0x110727) {
    room.myself["surface"]["setColor"](_0x110727);
  }
  ["getThumbnail"]() {
    var _0x3cb00e = new Array();
    for (var _0x37acf2 = 0; _0x37acf2 < room["board"]["nLayers"]; _0x37acf2++) {
      _0x3cb00e.push(this.sidebar["layerPreview"]["previews"][_0x37acf2].getData());
    }
    return _0x3cb00e;
  }
  ["getScreenSize"]() {
    var _0x316b67 = this["drawingArea"]["css"]("width").replace("px", "");
    return sizeToName(_0x316b67);
  }
  ["setupScreenSize"](_0x43c8da) {
    _0x43c8da == "lg" || _0x43c8da == "md" ? this["sidebar"]["set"](true, false) : this["sidebar"]["set"](false, true);
  }
  ["setupControls"]() {
    this.uploader = new Uploader($("#uploadFile")), this.sidebar = new Sidebar($("#sidebar"));
    var _0x3b3e1b = this;
    $(this["sidebar"]).on("sidebarCollapsed sidebarUncollapsed", function (_0x381e77) {
      _0x381e77["type"] == "sidebarCollapsed" ? $(_0x3b3e1b)["triggerHandler"](new sidebarCollapsedEvent()["getEvent"]()) : $(_0x3b3e1b)["triggerHandler"](new sidebarUncollapsedEvent()["getEvent"]());
    }), room.myself["surface"]["setColor"](this["sidebar"]["colorBox"]["primaryColor"]);
  }
  ["drawingAllowed"]() {
    if (!this.sidebar["layerPreview"] || !room || !room["myself"]) return false;
    return this["layerIsVisible"](room["myself"]["surface"]["currentLayer"]) && (!this["layerIsLocked"](room["myself"]["surface"].currentLayer) || this["layerIsLocked"](room.myself["surface"].currentLayer) && room["can"]("drawlockedlayers")) && room.connected && !room["loading"] && !room["myself"]["muted"];
  }
  ["onWheelMoveFaster"](_0x8b2d19) {
    _0x8b2d19["preventDefault"]();
    if (!UI["dialogHandler"].activeDialog) {
        if (UI["sidebar"]["toolbar"]) {
            if (!(UI["sidebar"]["toolbar"]["getHighlighted"]() == "drag" || UI["sidebar"]["toolbar"]["getHighlighted"]() == "rotate")) {
                if (!room.myself["surface"]["isBrushOptionReadOnly"]("size")) {
                    var _0x5cdba4 = room["myself"]["surface"]["getBrushOptionObject"]("size"),
                        _0x12f629 = _0x5cdba4["value"];

                    // Scroll adjustment logic
                    if (!UI["holdingSHIFT"]) {
                        if (!this.scrollData) {
                            this.scrollData = { tickCount: 0, lastTime: Date.now() };
                        }

                        const now = Date.now();
                        const elapsed = (now - this.scrollData.lastTime) / 1000; // in seconds
                        this.scrollData.lastTime = now;
                        this.scrollData.tickCount++;
                        // Apply natural decay to tick count
                        const decayRate = 10; // Controls how fast tickCount decreases naturally (higher = faster)
                        const decayFactor = Math.exp(-decayRate * elapsed) * 1.5;
                        this.scrollData.tickCount *= decayFactor;

                        // Increment tick count for new scrolls
                        

                        // Calculate scrolls per second, capped at 6
                        const scrollsPerSecond = Math.min(this.scrollData.tickCount / elapsed, 6);

                        // Determine brush size adjustment
                        const _0x39e527 = Math.max(2, scrollsPerSecond); // Minimum change is 2, max is up to 6

                        _0x8b2d19["originalEvent"]["deltaY"] < 0
                            ? room["myself"].surface["setBrushOption"](
                                  "size",
                                  Math["max"](
                                      Math["min"](_0x12f629 + _0x39e527, _0x5cdba4["max"]),
                                      _0x5cdba4["min"]
                                  )
                              )
                            : room["myself"].surface.setBrushOption(
                                  "size",
                                  Math["max"](
                                      Math["min"](_0x12f629 - _0x39e527, _0x5cdba4["max"]),
                                      _0x5cdba4["min"]
                                  )
                              );
                    } else {
                        const _0x39e527 = 1; // Holding SHIFT
                        _0x8b2d19["originalEvent"]["deltaY"] < 0
                            ? room["myself"].surface["setBrushOption"](
                                  "size",
                                  Math["max"](
                                      Math["min"](_0x12f629 + _0x39e527, _0x5cdba4["max"]),
                                      _0x5cdba4["min"]
                                  )
                              )
                            : room["myself"].surface.setBrushOption(
                                  "size",
                                  Math["max"](
                                      Math["min"](_0x12f629 - _0x39e527, _0x5cdba4["max"]),
                                      _0x5cdba4["min"]
                                  )
                              );
                    }
                }
            } else
                _0x8b2d19["originalEvent"]["deltaY"] < 0
                    ? UI["zoomToScreenPoint"](
                          UI["mousePointer"]["position"].x,
                          UI["mousePointer"]["position"].y,
                          "zoomIn"
                      )
                    : UI.zoomToScreenPoint(
                          UI["mousePointer"]["position"].x,
                          UI["mousePointer"].position.y,
                          "zoomOut"
                      );
        }
    }
  }
  onWheelMoveCap(_0x8b2d19) {
    _0x8b2d19.preventDefault();
    
    if (!UI.dialogHandler.activeDialog) {
        if (UI.sidebar.toolbar) {
            const highlightedTool = UI.sidebar.toolbar.getHighlighted();

            if (highlightedTool !== "drag" && highlightedTool !== "rotate") {
                if (!room.myself.surface.isBrushOptionReadOnly("size")) {
                    const brushSizeObj = room.myself.surface.getBrushOptionObject("size");
                    let brushSize = brushSizeObj.value;
                    
                    let step;
                    if (brushSize <= 15) {
                        step = 1;  // If brush size is 15 or below, step is 1
                    } else {
                        step = 2;  // If brush size is 16 or above, step is 2
                    }

                    if (_0x8b2d19.originalEvent.deltaY < 0) {
                        // Scroll up: Increase brush size
                        brushSize = Math.min(brushSize + step, brushSizeObj.max);
                    } else {
                        // Scroll down: Decrease brush size
                        brushSize = Math.max(brushSize - step, brushSizeObj.min);
                    }

                    room.myself.surface.setBrushOption("size", brushSize);
                }
            } else {
                // Handle zooming if the selected tool is "drag" or "rotate"
                const zoomAction = _0x8b2d19.originalEvent.deltaY < 0 ? "zoomIn" : "zoomOut";
                UI.zoomToScreenPoint(UI.mousePointer.position.x, UI.mousePointer.position.y, zoomAction);
            }
        }
    }
}


  ["onWheelMoveDefault"](_0x8b2d19) {
    _0x8b2d19["preventDefault"]();
    if (!UI["dialogHandler"].activeDialog) {
      if (UI["sidebar"]["toolbar"]) {
        if (!(UI["sidebar"]["toolbar"]["getHighlighted"]() == "drag" || UI["sidebar"]["toolbar"]["getHighlighted"]() == "rotate")) {
          if (!room.myself["surface"]["isBrushOptionReadOnly"]("size")) {
            var _0x5cdba4 = room["myself"]["surface"]["getBrushOptionObject"]("size"),
              _0x39e527 = UI["holdingSHIFT"] ? 1 : 2,
              _0x12f629 = _0x5cdba4["value"];
            _0x8b2d19["originalEvent"]["deltaY"] < 0 ? room["myself"].surface["setBrushOption"]("size", Math["max"](Math["min"](_0x12f629 + _0x39e527, _0x5cdba4["max"]), _0x5cdba4["min"])) : room["myself"].surface.setBrushOption("size", Math["max"](Math["min"](_0x12f629 - _0x39e527, _0x5cdba4["max"]), _0x5cdba4["min"]));
          }
        } else _0x8b2d19["originalEvent"]["deltaY"] < 0 ? UI["zoomToScreenPoint"](UI["mousePointer"]["position"].x, UI["mousePointer"]["position"].y, "zoomIn") : UI.zoomToScreenPoint(UI["mousePointer"]["position"].x, UI["mousePointer"].position.y, "zoomOut");
      }
    }
  }
  ["toggleUndoHistory"]() {
    // Toggle state
    this.undoHistoryEnabled = !this.undoHistoryEnabled;
    
    // Still save preference in localStorage for future tabs/sessions
    localStorage.setItem("undoHistoryEnabled", this.undoHistoryEnabled.toString());
    
    // Dispatch a custom event ONLY for this tab instance
    const customEvent = new CustomEvent("undoHistoryStateChanged", {
      detail: { enabled: this.undoHistoryEnabled }
    });
    document.dispatchEvent(customEvent);
    
    // Update UI based on new state
    if (this.undoHistoryEnabled) {
      this.boardContainer.removeClass("undoHistoryDisabled");
      this.bottombar.selectButton("toggleUndoHistoryButton");
      
      if (room) {
        // Any room updates if needed
      }
    } else {
      this.boardContainer.addClass("undoHistoryDisabled");
      this.bottombar.unselectButton("toggleUndoHistoryButton");
      
      if (room) {
        // Any room updates if needed
      }
    }
  }
  ["togglePixelSmoothing"]() {
    this.pixelSmoothing = !this["pixelSmoothing"], this.pixelSmoothing ? (this.boardContainer["removeClass"]("noPixelSmoothing"), this["bottombar"]["unselectButton"]("toggleSmoothingButton")) : (this.boardContainer["addClass"]("noPixelSmoothing"), this["bottombar"]["selectButton"]("toggleSmoothingButton"));
  }
  ["fitToScreenModified"]() {    
    if (!isStableConnection) {
    return } 
    // if (room?.loading === "true") {
      else {
      var _0x24dcdd = this.drawingArea["width"](),
        _0x4862fc = this["drawingArea"]["height"](),
        _0x3341c1 = this["boardContainer"]["width"](),
        _0x17c647 = this["boardContainer"]["height"](),
        _0x408a90 = 0.01,
        _0x58c3e0 = _0x4862fc / _0x17c647,
        _0x6e67ff = _0x24dcdd / _0x3341c1,
        _0x2f6216 = Math["min"](_0x58c3e0, _0x6e67ff),
        _0x49110f = parseInt(_0x2f6216 / _0x408a90);
      room.board["changeScale"](_0x49110f * _0x408a90, true);
    }
}

["centerBoardModified"]() {
  if (!isStableConnection) return;
  else {   
    var _0x2bc242 = this["drawingArea"]["width"](),
      _0x41a2b3 = this["drawingArea"]["height"]();
    this["moveBoard"]((_0x2bc242 - this["viewWidth"]) / 2, (_0x41a2b3 - this["viewHeight"]) / 2);
    }
    
}
["fitToScreen"]() {
  if (room) {
    var _0x24dcdd = this.drawingArea["width"](),
      _0x4862fc = this["drawingArea"]["height"](),
      _0x3341c1 = this["boardContainer"]["width"](),
      _0x17c647 = this["boardContainer"]["height"](),
      _0x408a90 = 0.01,
      _0x58c3e0 = _0x4862fc / _0x17c647,
      _0x6e67ff = _0x24dcdd / _0x3341c1,
      _0x2f6216 = Math["min"](_0x58c3e0, _0x6e67ff),
      _0x49110f = parseInt(_0x2f6216 / _0x408a90);
    room.board["changeScale"](_0x49110f * _0x408a90, true);
  }
}
["centerBoard"]() {
  var _0x2bc242 = this["drawingArea"]["width"](),
    _0x41a2b3 = this["drawingArea"]["height"]();
  this["moveBoard"]((_0x2bc242 - this["viewWidth"]) / 2, (_0x41a2b3 - this["viewHeight"]) / 2);
}

  ["moveBoard"](_0x427c7e, _0x97d75a) {
    room && this["boardContainer"]["css"]({
      left: _0x427c7e + (this.viewWidth - this["boardContainer"]["width"]()) / 2 + "px",
      top: _0x97d75a + (this.viewHeight - this["boardContainer"].height()) / 2 + "px"
    });
    this["updateViewLimits"]();
    var _0x2ccaab = this["drawingArea"]["offset"](),
      _0x5e8204 = this["screenToBoard"](_0x2ccaab["left"], _0x2ccaab.top);
    this["pip"]["setView"](_0x5e8204.x, _0x5e8204.y, UI["drawingArea"]["width"](), UI["drawingArea"]["height"](), room["board"]["scale"], room["board"]["rotation"]), room && room["myself"] && room["myself"]["surface"]["getCurrentBrush"]() == "selection" && self["selectionToolbar"] && self["selectionToolbar"]["visible"]() && this["showSelectionToolbar"]();
  }
  ["boardToScreen"](_0x224af3, _0x594578) {
    if (room) {
      var _0x5d0317 = new Point(this["calculateFlipX"](_0x224af3), _0x594578);
      return _0x5d0317 = this["calculateReverseRotation"](_0x5d0317.x, _0x5d0317.y, room["board"].rotation), _0x5d0317.x = _0x5d0317.x * room["board"]["scale"] + this["viewLeft"], _0x5d0317.y = _0x5d0317.y * room.board["scale"] + this["viewTop"], _0x5d0317;
    }
    return null;
  }
  ["screenToBoard"](_0x2cf122, _0x37e1c1) {
    if (room) {
      var _0x193c5f = this["calculateRotation"]((_0x2cf122 - this["viewLeft"]) / room["board"]["scale"], (_0x37e1c1 - this.viewTop) / room.board.scale, room["board"]["rotation"]);
      return new Point(this.calculateFlipX(_0x193c5f.x) - this["viewOffset"].x, _0x193c5f.y - this["viewOffset"].y);
    }
    return null;
  }
  ["zoomToScreenPoint"](_0x556d94, _0x393bd2, _0x472a85) {
    if (room) {
      var _0x1c11a4 = this.drawingArea["offset"](),
        _0xc9b547 = _0x556d94 - _0x1c11a4["left"],
        _0x3ee383 = _0x393bd2 - _0x1c11a4["top"],
        _0x2ed82f = (_0x556d94 - this["viewLeft"]) / room["board"].scale,
        _0x251a9b = (_0x393bd2 - this["viewTop"]) / room["board"]["scale"];
      
      if (typeof _0x472a85 === "number") {
        room["board"].setZoom(room["board"].scale * _0x472a85);
      } else {
        _0x472a85 == "zoomIn" ? room["board"]["increaseZoom"](this["holdingSHIFT"] ? 0.1 : null) : room["board"]["decreaseZoom"](this["holdingSHIFT"] ? 0.1 : null);
      }
      
      this.moveBoard(_0xc9b547 - _0x2ed82f * room.board["scale"], _0x3ee383 - _0x251a9b * room["board"]["scale"]);
    }
  }
  ["onKeyPressed"](_0x2c550b) {
    room && room["connected"] && room["myself"] && UI["dialogHandler"].openedDialogs == 0 && (room["myself"]["surface"]["getCurrentBrush"]() == "text" && _0x2c550b["preventDefault"](), _0x2c550b["which"] != 13 && room["myself"]["surface"]["keyPress"](_0x2c550b.which));
  }
["onKeyDown"](_0xe76660) {
  var _0x368e6d = UI;
  
  // Add the fix for dialog dragging issue with Escape key
  if (_0xe76660["which"] == 27) { // Escape key (27)
    // Force reset dialog dragging state when Escape is pressed
    if (_0x368e6d.dialogHandler && 
        (_0x368e6d.dialogHandler.draggingDialog() || _0x368e6d.dialogHandler.resizingDialog())) {
      // Get current mouse position
      const currentPosition = _0x368e6d.mousePointer ? 
                            { x: _0x368e6d.mousePointer.position.x, y: _0x368e6d.mousePointer.position.y } : 
                            { x: 0, y: 0 };
      
      // Force the mouseUp event to clean up dragging state
      _0x368e6d.dialogHandler.mouseUp(currentPosition.x, currentPosition.y);
      
      // Reset any additional dragging-related flags
      _0x368e6d.dialogHandler.draggedDialog = null;
      _0x368e6d.dialogHandler.resizedDialog = null;
      _0x368e6d.dialogHandler.dragOffset = null;
      
      // Ensure dragging mode is reset
      _0x368e6d.drag(false);
    }
  }
  
  // Original code continues below
  if (_0x368e6d["shortcutManager"]["setupMode"]) {
    _0xe76660["preventDefault"]();
    var _0x38b8f2 = _0x368e6d.shortcutManager["getShortcutString"](_0xe76660["ctrlKey"], _0xe76660["altKey"], _0xe76660["shiftKey"], _0xe76660["which"], _0xe76660["key"], _0xe76660.location || _0xe76660["originalEvent"]["location"]);
    _0x368e6d.configDialog["shortcutPressed"](_0x38b8f2);
    return;
  }
  if (_0x368e6d.dialogHandler["openedDialogs"] == 0) {
    var _0x561148 = [8];
    _0x561148["indexOf"](_0xe76660["which"]) > -1 && _0xe76660["preventDefault"]();
  }
  // Rest of the method remains unchanged
  if (room && room["myself"]) {
      var _0x38b8f2 = _0x368e6d.shortcutManager.getShortcutString(_0xe76660["ctrlKey"], _0xe76660.altKey, _0xe76660["shiftKey"], _0xe76660["which"], _0xe76660["key"], _0xe76660["location"] || _0xe76660["originalEvent"]["location"]),
        _0x4480e2 = _0x368e6d["shortcutManager"]["getShortcutInfo"](_0x38b8f2),
        _0x55966f = room.myself["surface"]["getCurrentBrush"]() == "text" && room.myself["surface"]["brushHandler"]["brush"].enabled,
        _0x12a0f0 = (_0x4480e2.printablechars || _0x4480e2["numbers"]) && !_0x4480e2.ctrl && !_0x4480e2["alt"] && !_0x4480e2["specialchars"];
      (!_0x55966f || _0x55966f && !_0x12a0f0) && _0x368e6d["shortcutManager"]["process"](_0xe76660, "keydown", _0x368e6d.dialogHandler["openedDialogs"] > 0) && (_0xe76660["preventDefault"](), _0x368e6d["setCurrentPointer"](null), _0x368e6d["updateCursor"]());
      if (_0xe76660["which"] == 16) {
        if (_0x368e6d.holdingSHIFT) return;
        _0x368e6d["holdingSHIFT"] = true;
      }
      if (_0xe76660["which"] == 17) {
        if (_0x368e6d["holdingCTRL"]) return;
        _0x368e6d["holdingCTRL"] = true;
      }
      if (_0xe76660["which"] == 18) {
        if (_0x368e6d["holdingALT"]) return;
        _0x368e6d["holdingALT"] = true;
      }
      if (_0x368e6d["dialogHandler"]["openedDialogs"] > 0) {
        _0x368e6d.focusedElementKeyEvent(_0xe76660.which);
        return;
      }
      room["myself"]["surface"]["getCurrentBrush"]() == "text" && (_0xe76660["which"] == 13 || _0xe76660["which"] == 32) && (_0x368e6d["boardContainer"].focus(), _0xe76660.preventDefault());
      _0xe76660["which"] == 8 && _0x368e6d.dialogHandler["openedDialogs"] > 0 && _0xe76660["preventDefault"]();
      if (!_0x368e6d["dialogHandler"]["active"]) {
        if (room && room["myself"]) {
          if (_0xe76660.which == 16 || _0xe76660["which"] == 13 || _0xe76660["which"] == 32) !(_0xe76660["which"] == 16 && _0x55966f) && room["myself"]["surface"].modifierDown(_0xe76660["which"]); else _0xe76660["which"] == 8 && room["myself"].surface["keyPress"](_0xe76660["which"]);
          if (_0xe76660.which == 16) {
            if (room["myself"].surface.getCurrentBrush() == "line") !room.myself["surface"]["isBrushOptionReadOnly"]("snap") && room.myself["surface"].setBrushOption("snap", !room["myself"]["surface"].getBrushOption("snap")); else {
              if (room["myself"]["surface"]["getCurrentBrush"]() == "rect") !room.myself["surface"]["isBrushOptionReadOnly"]("aspectratio") && room["myself"].surface["setBrushOption"]("aspectratio", !room.myself["surface"].getBrushOption("aspectratio")); else room["myself"]["surface"].getCurrentBrush() == "ellipse" && !room["myself"]["surface"]["isBrushOptionReadOnly"]("aspectratio") && room.myself["surface"]["setBrushOption"]("aspectratio", !room["myself"]["surface"]["getBrushOption"]("aspectratio"));
            }
          }
        }
      }
      _0x368e6d["uploadMode"] ? _0xe76660.which == 16 ? _0x368e6d["uploader"]["modifierDown"](_0xe76660["which"]) : _0x368e6d["uploader"]["keyPress"](_0xe76660.which) : _0x368e6d["focusedElementKeyEvent"](_0xe76660.which);
    }
  }
  ["focusedElementKeyEvent"](_0x365afb) {
    this["focusedElement"] && this["focusedElement"].keyPress && this["focusedElement"]["container"] && this["focusedElement"]["container"].is(":visible") && this["focusedElement"]["keyPress"](_0x365afb);
  }
  ["onKeyUp"](_0x471a5e) {
    var _0x93423d = UI;
    if (room && room.myself) {
      var _0x48e8f1 = _0x93423d["shortcutManager"]["getShortcutString"](_0x471a5e["ctrlKey"], _0x471a5e["altKey"], _0x471a5e.shiftKey, _0x471a5e["which"], _0x471a5e["key"], _0x471a5e["location"] || _0x471a5e["originalEvent"]["location"]),
        _0x1e11c2 = _0x93423d.shortcutManager.getShortcutInfo(_0x48e8f1),
        _0x4ef998 = room["myself"]["surface"]["getCurrentBrush"]() == "text" && room.myself["surface"]["brushHandler"]["brush"]["enabled"],
        _0x2f6b1e = (_0x1e11c2["printablechars"] || _0x1e11c2["numbers"]) && !_0x1e11c2.ctrl && !_0x1e11c2.alt && !_0x1e11c2["specialchars"];
      ;
      (!_0x4ef998 || _0x4ef998 && !_0x2f6b1e) && _0x93423d["shortcutManager"]["process"](_0x471a5e, "keyup", _0x93423d["dialogHandler"]["openedDialogs"] > 0) && _0x93423d["updateCursor"]();
      if (_0x471a5e["which"] == 16) {
        if (!_0x93423d["holdingSHIFT"]) return;
        _0x93423d.holdingSHIFT = false;
      }
      if (_0x471a5e["which"] == 17) {
        if (!_0x93423d["holdingCTRL"]) return;
        _0x93423d["holdingCTRL"] = false;
      }
      if (_0x471a5e["which"] == 18) {
        if (!_0x93423d["holdingALT"]) return;
        _0x93423d["holdingALT"] = false;
      }
      if (_0x93423d.dialogHandler["openedDialogs"] > 0) return;
      _0x471a5e["which"] == 8 && _0x93423d["dialogHandler"]["openedDialogs"] > 0 && _0x471a5e["preventDefault"]();
      if (_0x471a5e["which"] == 16 || _0x471a5e.which == 13 || _0x471a5e["which"] == 32) {
        room.myself["surface"].modifierUp(_0x471a5e["which"]);
        if (_0x471a5e["which"] == 16) {
          if (room["myself"]["surface"]["getCurrentBrush"]() == "line") !room.myself["surface"]["isBrushOptionReadOnly"]("snap") && room["myself"]["surface"]["setBrushOption"]("snap", !room["myself"]["surface"]["getBrushOption"]("snap")); else {
            if (room.myself["surface"].getCurrentBrush() == "rect") !room["myself"]["surface"]["isBrushOptionReadOnly"]("aspectratio") && room["myself"].surface.setBrushOption("aspectratio", !room["myself"].surface["getBrushOption"]("aspectratio")); else room["myself"]["surface"].getCurrentBrush() == "ellipse" && !room["myself"].surface["isBrushOptionReadOnly"]("aspectratio") && room["myself"]["surface"]["setBrushOption"]("aspectratio", !room["myself"]["surface"]["getBrushOption"]("aspectratio"));
          }
        }
        _0x93423d["uploadMode"] && _0x93423d.uploader["modifierUp"](_0x471a5e["which"]);
      }
    }
  }
  ["mouseOverBoard"]() {
    return this.hovering || this["boardContainer"].is(":hover");
  }
  ["flipLabels"]() {
    room["board"]["cursorContainer"]["find"](".pointerLabel").css("transform", "translateZ(0) scaleX(" + (this.flipX ? 1 : -1) + ")");
  }
  ["syncBrushes"](_0x19c45c = null) {
    room && room["myself"] && $["each"](room["users"], function (_0x418a4f, _0x482399) {
      if (_0x19c45c == null || _0x482399["username"] == _0x19c45c) {
        var _0xc44490 = {};
        _0xc44490["command"] = "DIRECT", _0xc44490["target"] = _0x482399.username, _0xc44490["action"] = "SYNC", _0xc44490["status"] = room.myself["status"], _0xc44490["inactive"] = room["myself"].inactive, _0xc44490.x = room.myself["surface"]["cursor"].x, _0xc44490.y = room.myself["surface"]["cursor"].y, _0xc44490.visible = room["myself"]["surface"]["cursor"].isVisible(), _0xc44490["brush"] = room.myself["surface"]["getCurrentBrush"](), _0xc44490.color = room["myself"]["surface"]["drawColor"], _0xc44490.options = room["myself"]["surface"].getBrushesOptions(), _0xc44490["layer"] = room["myself"]["surface"]["currentLayer"], _0xc44490["penPressed"] = room["myself"]["surface"]["penPressed"];
        var _0x56cf7c = room["myself"]["surface"]["getCurrentBrush"]();
        (room["myself"]["surface"].penPressed || _0x56cf7c == "text" || _0x56cf7c == "selection") && (_0xc44490["brushSync"] = room.myself.surface["getBrushSync"]()), socket.send(_0xc44490, true);
      }
    });
  }
  ["clearMuteTime"]() {
    this.muteInterval && clearInterval(this["muteInterval"]), this["muteInterval"] = null, this["muteSeconds"] = 0;
  }
  ["muteTime"](_0x5d5d9e) {
    if (_0x5d5d9e <= 0) this["clearMuteTime"](); else {
      this["muteSeconds"] = _0x5d5d9e;
      if (!this["muteInterval"]) {
        var _0x3b6ad7 = this;
        this["muteInterval"] = setInterval(function () {
          if (_0x3b6ad7["muteSeconds"] > 1e5) _0x3b6ad7["bottombar"].setText(textManager["getString"]("alerts.txtYouAreMuted")); else _0x3b6ad7["muteSeconds"] - 1 > 0 ? _0x3b6ad7["bottombar"]["setText"](textManager["getString"]("alerts.txtYouWillBeUnmutedIn", formatSeconds(--_0x3b6ad7["muteSeconds"]), false)) : _0x3b6ad7.bottombar["setText"](textManager["getString"]("alerts.txtYouWillBeUnmuted"));
        }, 1e3);
      }
    }
  }
  ["layerIsVisible"](_0x2381a4) {
    return room["board"]["layers"][_0x2381a4]["isVisible"]();
  }
  ["layerIsLocked"](_0x2e21c9) {
    return room["board"]["layers"][_0x2e21c9]["locked"];
  }
  ["showAllLayers"]() {
    for (var _0x1e1e9d = 0; _0x1e1e9d < room["board"]["nLayers"]; _0x1e1e9d++) {
      room["board"].layers[_0x1e1e9d]["show"]();
    }
  }
  ["hideAllLayers"]() {
    for (var _0x412e1b = 0; _0x412e1b < room.board["nLayers"]; _0x412e1b++) {
      room.board.layers[_0x412e1b]["hide"]();
    }
  }
  ["syncBoard"](_0x4302d5, _0x4dadee = false) {
    if (room["userExists"](_0x4302d5)) {
      if (_0x4dadee) $(this)["triggerHandler"](new firstSyncStartedEvent(_0x4302d5, room["session"])["getEvent"]()); else {
        this.manualSync = _0x4302d5;
        var _0x2f626b = this;
        setTimeout(function () {
          _0x2f626b["manualSync"] = null;
        }, 6e4);
      }
      var _0x486d29 = {};
      _0x486d29["command"] = "DIRECT", _0x486d29["target"] = _0x4302d5, _0x486d29.action = "GETBOARD", socket["send"](_0x486d29, true);
    }
  }
  ["getFocusElement"](_0x55ae4a) {
    return this["focusedElement"];
  }
  ["setFocusElement"](_0x34a3f6) {
    this["focusedElement"] = _0x34a3f6;
  }
  ["reloadStorage"]() {
    this.userPreferences["loadFromStorage"](), this.shortcutManager["loadFromStorage"](), this["sidebar"]["colorBox"]["loadFromStorage"](), this["sidebar"]["colorBox"].redraw(), this["bottombar"]["colorBubbles"]["loadFromStorage"](), this.bottombar.colorBubbles.redraw(), this["colorDialog"].colorBubbles.loadFromStorage(), this["colorDialog"]["colorBubbles"]["redraw"](), this["sidebar"]["presets"]["loadFromStorage"](), this["sidebar"]["presets"].redraw();
  }
  ["preDrag"](_0x150ec5) {
    this["preDraggingMode"] = _0x150ec5, this["hammer"]["get"]("pinch")["set"]({
      enable: !_0x150ec5
    });
  }
  ["drag"](_0x1e3619) {
    this["draggingMode"] = _0x1e3619, this["hammer"]["get"]("pinch")["set"]({
      enable: !_0x1e3619
    });
  }
  ["setCustomBrush"](_0x265f17) {
    this["hasSetCustomBrush"] = true;
    var _0xeb46ca = {};
    _0xeb46ca["custom"] = {}, _0xeb46ca["custom"]["image"] = _0x265f17, room["myself"]["surface"]["setBrushesOptions"](_0xeb46ca);
  }
  ["recommendedSyncModified"](_0x181fdd) {
    if (!Array.isArray(_0x181fdd) || _0x181fdd.length === 0) {
        // console.warn("Invalid or empty sync order:", _0x181fdd);
        return;
    }

    this.firstSyncOrder = _0x181fdd;

    // First-time sync always happens
    if (!firstSyncDone) {
        this.trySync();
        firstSyncDone = true;
        return;
    }

    if (shouldSync()) {
        this.trySync();
    } else {
    }
}

  ["recommendedSyncDefault"](_0x181fdd) {
    this["firstSyncOrder"] = _0x181fdd, this["trySync"]();
  }
  ["trySync"]() {
    var _0x863a00 = this["firstSyncOrder"][0];
    _0x863a00 in room["users"] && this["syncBoard"](_0x863a00, true);
  }
  ["acceptingSync"](_0x150957) {
    if (this.firstSyncEnabled && this["firstSyncUser"] == _0x150957) return true; else {
      if (this["manualSync"] == _0x150957) return true;
    }
    return false;
  }
}
class Device {
  constructor(_0x3ab0ca = null) {
    this.ip = {};
    var _0x5ab4ab = "other";
    this["navigator"] = {}, this["screen"] = {}, this["webgl"] = this["getWebGLInfo"](), this["time"] = this["getTimeInfo"](), this["bot"] = this["getBotInfo"](), _0x3ab0ca != null && (this["import"](_0x3ab0ca), this["detectBrowser"]());
    this.undoHistoryEnabled = localStorage.getItem("undoHistoryEnabled") !== "false"
  }
  ["import"](_0x210ff0) {
    var _0x50e51d = this,
      _0x296669 = new Array("appCodeName", "appName", "appVersion", "cookieEnabled", "buildID", "deviceMemory", "doNotTrack", "hardwareConcurrency", "language", "languages", "maxTouchPoints", "mimeTypes", "onLine", "oscpu", "platform", "plugins", "product", "productSub", "userAgent", "vendor", "vendorSub");
    $["each"](_0x296669, function (_0x5abd49, _0x376193) {
      _0x376193 in _0x210ff0.navigator && (_0x50e51d["navigator"][_0x376193] = _0x210ff0.navigator[_0x376193]);
    });
    var _0x2ae0dd = new Array("availHeight", "availLeft", "availTop", "availWidth", "height", "left", "top", "width", "colorDepth", "pixelDepth", "orientation");
    $["each"](_0x2ae0dd, function (_0x49480c, _0x118e34) {
      _0x118e34 in _0x210ff0.screen && (_0x50e51d.screen[_0x118e34] = _0x210ff0["screen"][_0x118e34]);
    });
  }
  ["detectBrowser"]() {
    let _0x1e2699 = this.navigator["userAgent"];
    if (_0x1e2699.match(/edg/i)) this.browser = "edge"; else {
      if (_0x1e2699.match(/firefox|fxios/i)) this["browser"] = "firefox"; else {
        if (_0x1e2699["match"](/opr\//i)) this.browser = "opera"; else {
          if (_0x1e2699["match"](/safari/i)) this["browser"] = "safari"; else _0x1e2699.match(/chrome|chromium|crios/i) ? this["browser"] = "chrome" : this["browser"] = "other";
        }
      }
    }
  }
  ["getWebGLInfo"]() {
    var _0x30f9c8 = this["getWebGL"]("webgl");
    return !_0x30f9c8["unmaskedRenderer"] && (_0x30f9c8 = this["getWebGL"]("experimental-webgl")), _0x30f9c8;
  }
  ["getWebGL"](_0x4d8d72) {
    var _0x88631f = $("<canvas />"),
      _0x3c163f = _0x88631f[0]["getContext"](_0x4d8d72),
      _0x43dd66 = {};
    _0x43dd66["renderer"] = _0x3c163f.getParameter(_0x3c163f["RENDERER"]), _0x43dd66["vendor"] = _0x3c163f["getParameter"](_0x3c163f["VENDOR"]);
    var _0xdb4c77 = _0x3c163f["getExtension"]("WEBGL_debug_renderer_info");
    return _0xdb4c77 != null && (_0x43dd66["unmaskedRenderer"] = _0x3c163f.getParameter(_0xdb4c77.UNMASKED_RENDERER_WEBGL), _0x43dd66.unmaskedVendor = _0x3c163f["getParameter"](_0xdb4c77.UNMASKED_VENDOR_WEBGL)), _0x88631f["remove"](), _0x43dd66;
  }
  ["getIPAddressInfo"](_0x4a3a18) {
    var _0x22efdc = "";
    return $["ajax"]({
      type: "POST",
      cache: false,
      async: false,
      url: "/api/conn.php?ip=" + _0x4a3a18,
      contentType: "application/json",
      dataType: "json"
    })["done"](function (_0x228a16) {
      _0x22efdc = _0x228a16;
    }), _0x22efdc;
  }
  ["getBotInfo"]() {
    var _0x2fde35 = {};
    _0x2fde35["webdriver"] = false, _0x2fde35["headless"] = false, _0x2fde35["notifications"] = false, _0x2fde35["plugins"] = false, _0x2fde35["languages"] = false;
    try {
      (navigator.webdriver || window["document"].documentElement["getAttribute"]("webdriver")) && (_0x2fde35.webdriver = true);
    } catch (_0x355fcf) { }
    try {
      /Headless/.test(window["navigator"]["userAgent"]) && (_0x2fde35.headless = true);
    } catch (_0x6f56ee) { }
    try {
      navigator["permissions"]["query"]({
        name: "notifications"
      })["then"](function (_0x40da2e) {
        Notification["permission"] === "denied" && _0x40da2e["state"] === "prompt" && (_0x2fde35.notifications = true);
      });
    } catch (_0x553131) { }
    try {
      navigator["plugins"]["length"] === 0 && (_0x2fde35["plugins"] = true);
    } catch (_0x414dc7) { }
    try {
      navigator["languages"] === "" && (_0x2fde35["languages"] = true);
    } catch (_0x2b70b2) { }
    return _0x2fde35;
  }
  ["isBot"]() {
    return this["bot"]["headless"] || this["bot"].webdriver;
  }
  ["getString"]() {
    var _0xe51413 = this.getPluginString(),
      _0x38fd66 = this.getMimeString(),
      _0x179805 = this.getWebGLString();
    return this.navigator.appCodeName + ";" + this["navigator"]["appName"] + ";" + this["navigator"]["appVersion"] + ";" + this.navigator["buildID"] + this["navigator"]["maxTouchPoints"] + ";" + this["navigator"]["cookieEnabled"] + ";" + this["navigator"]["oscpu"] + ";" + this.navigator["language"] + ";" + this["navigator"]["onLine"] + ";" + this["navigator"]["platform"] + ";" + this.navigator["product"] + ";" + this["navigator"]["productSub"] + ";" + this["navigator"]["deviceMemory"] + ";" + this["navigator"]["maxTouchPoints"] + ";" + this.screen["width"] + " x " + this.screen["height"] + ";$;" + _0x179805 + ";@;" + _0x38fd66 + ";" + _0xe51413;
  }
  ["getTimeInfo"]() {
    var _0x313763;
    try {
      _0x313763 = new Date()["getTimezoneOffset"]();
    } catch (_0xa4dd20) { }
    var _0x4aac5d;
    try {
      _0x4aac5d = Intl.DateTimeFormat()["resolvedOptions"]()["timeZone"];
    } catch (_0x1eed3c) { }
    var _0x3479cc = {};
    return _0x3479cc["offset"] = _0x313763, _0x3479cc["zone"] = _0x4aac5d, _0x3479cc;
  }
  ["getTimeString"]() {
    return "t$: " + this["time"].offset + ";" + this["time"].zone;
  }
  ["getBotString"]() {
    return "b$: " + (this["isBot"]() ? 1 : 0) + ";" + (this["bot"]["webdriver"] ? 1 : 0) + ";" + (this["bot"].headless ? 1 : 0) + ";" + (this["bot"]["notifications"] ? 1 : 0) + ";" + (this["bot"]["plugins"] ? 1 : 0) + ";" + (this["bot"]["languages"] ? 1 : 0);
  }
  ["getPluginString"]() {
    var _0x3d07c9 = "";
    return $["each"](this["plugins"], function (_0x2fda92, _0x5ee2e8) {
      _0x3d07c9 += separator + _0x5ee2e8["name"] + "," + _0x5ee2e8["filename"], separator = ",";
    }), _0x3d07c9;
  }
  ["getMimeString"]() {
    var _0x31567c = "",
      _0x29ac52 = "";
    return $["each"](this["mime"], function (_0x18852f, _0x27f513) {
      _0x31567c += _0x29ac52 + _0x27f513["description"] + "," + _0x27f513["suffixes"] + "," + _0x27f513["type"], _0x29ac52 = ",";
    }), _0x31567c;
  }
  ["getWebGLString"]() {
    var _0x1f5816 = this["webgl"]["renderer"] + ";" + this["webgl"]["vendor"];
    return this["webgl"]["unmaskedRenderer"] && (_0x1f5816 += ";" + this.webgl["unmaskedRenderer"]), this.webgl["unmaskedVendor"] && (_0x1f5816 += ";" + this.webgl.unmaskedVendor), _0x1f5816;
  }
  ["getUniqueID"]() {
    return hash(this["getString"]());
  }
  ["getCanvasId"]() {
    var _0x3c3939 = $("<canvas />");
    _0x3c3939["attr"]("width", 280), _0x3c3939.attr("height", 30);
    var _0x50be21 = _0x3c3939[0]["getContext"]("2d"),
      _0x202947 = "flockMOD, 1.0 <$@&%>";
    return _0x50be21["textBaseline"] = "top", _0x50be21["font"] = "14px Arial", _0x50be21.textBaseline = "alphabetic", _0x50be21["fillStyle"] = "#f60", _0x50be21["fillRect"](125, 1, 62, 20), _0x50be21.fillStyle = "#069", _0x50be21["fillText"](_0x202947, 2, 15), _0x50be21["fillStyle"] = "rgba(102, 204, 0, 0.7)", _0x50be21["fillText"](_0x202947, 4, 17), hash(_0x3c3939[0].toDataURL());
  }
}
class SoundSystem {
  constructor() {
    this["sounds"] = {}, 
    this["addSound"]("chat", UI["baseDir"] + "sounds/chat.mp3"), 
    this["addSound"]("pm", UI["baseDir"] + "sounds/pm.mp3"), 
    this["addSound"]("inbox", UI["baseDir"] + "sounds/inbox.mp3"), 
    this["addSound"]("staff", UI["baseDir"] + "sounds/staff.mp3"),
    this["addSound"]("custom", customSoundBase64); // New sound
  }
  ["addSound"](_0xb506b6, _0x5b0a11) {
    this["sounds"][_0xb506b6] = new Audio(_0x5b0a11);
  }
  ["play"](_0x3ed8aa) {
    if (_0x3ed8aa in this["sounds"]) {
      var _0x4dfb96 = UI["userPreferences"].getProperty("soundvolume", 1);
      if (UI["userPreferences"]["getGroupOption"]("sounds", _0x3ed8aa, true) && _0x4dfb96 > 0) {
        var _0x216d10 = this["sounds"][_0x3ed8aa];
        _0x216d10["volume"] = _0x4dfb96, _0x216d10["play"]();
      }
    }
  }
}
class ImagePreview {
  constructor() {
    this["imageServices"] = [], this["createPreviewServices"]();
  }
  ["createPreviewServices"]() {
    var _0x5df47e;
    this["imageServices"] = [], _0x5df47e = {}, _0x5df47e["name"] = "fmgalleryuser", _0x5df47e["regexp"] = /(https\:\/\/(www\.)?flockmod\.com\/gallery\/index\.php\?q\=\/post\/list\/user_id=([0-9]*)?[^\s]*)/i, _0x5df47e["match"] = 3, this["imageServices"]["push"](_0x5df47e), _0x5df47e = {}, _0x5df47e["name"] = "fmgallery", _0x5df47e.regexp = /(https\:\/\/(www\.)?flockmod\.com\/gallery\/index\.php\?q\=\/post\/view\/([0-9]*)?[^\s]*)/i, _0x5df47e.match = 3, this.imageServices.push(_0x5df47e), _0x5df47e = {}, _0x5df47e.name = "fmgallery", _0x5df47e.regexp = /(https\:\/\/(www\.)?flockmod\.com\/img\/\?([0-9]*)?[^\s]*)/i, _0x5df47e["match"] = 3, this["imageServices"]["push"](_0x5df47e), _0x5df47e = {}, _0x5df47e["name"] = "youtube", _0x5df47e["regexp"] = /(https\:\/\/(www\.)?youtube\.com\/watch\?v\=([^\#\&\? ]*)?[^\s]*)/i, _0x5df47e["match"] = 3, this["imageServices"]["push"](_0x5df47e), _0x5df47e = {}, _0x5df47e.name = "youtube", _0x5df47e.regexp = /(https\:\/\/(www\.)?youtu\.be\/([^\#\&\? ]*)?[^\s]*)/i, _0x5df47e["match"] = 3, this["imageServices"]["push"](_0x5df47e), _0x5df47e = {}, _0x5df47e["name"] = "imgur", _0x5df47e.regexp = /(https\:\/\/(www\.)?(i\.)?imgur\.com\/(a\/)?([^\.\#\&\? ]*)?[^\s]*)/i, _0x5df47e["match"] = 5, this["imageServices"]["push"](_0x5df47e);
  }
  ["containsImage"](_0x53a0ea) {
    var _0x2af0ca = null;
    $["each"](this["imageServices"], function (_0x460742, _0x733f11) {
      if (_0x2af0ca == null) {
        let _0xd6931b = _0x733f11["regexp"]["exec"](_0x53a0ea);
        _0xd6931b = _0x733f11.regexp["exec"](_0x53a0ea), _0xd6931b && (_0x2af0ca = {}, _0x2af0ca.service = _0x733f11["name"], _0x2af0ca["regexp"] = _0x733f11.regexp, _0x2af0ca["value"] = _0xd6931b[_0x733f11["match"]], _0x2af0ca["url"] = _0xd6931b[0]);
      }
    });
    if (_0x2af0ca != null) return _0x2af0ca;
    return null;
  }
  ["getThumb"](_0x288117) {
    return new Promise(function (_0x59b3ae, _0x7d6264) {
      var _0x4acc4e = {};
      _0x4acc4e["service"] = _0x288117["service"], _0x4acc4e.url = _0x288117["url"], _0x4acc4e.id = _0x288117["value"];
      var _0x424ce5 = this;
      if (_0x288117["service"] == "fmgallery") $["ajax"]({
        type: "POST",
        cache: true,
        async: true,
        url: "/api/img.php?id=" + _0x288117["value"],
        contentType: "application/json",
        dataType: "json"
      })["done"](function (_0x2db451) {
        _0x4acc4e.url = _0x2db451["picture"], _0x4acc4e["image"] = _0x2db451["thumb"], _0x59b3ae(_0x4acc4e);
      }); else {
        if (_0x288117["service"] == "fmgalleryuser") _0x4acc4e["image"] = UI.baseDir + "images/fmgalleryuser.png"; else {
          if (_0x288117["service"] == "youtube") _0x4acc4e["image"] = "https://img.youtube.com/vi/" + _0x288117["value"] + "/mqdefault.jpg"; else _0x288117["service"] == "imgur" && (_0x4acc4e["image"] = "https://i.imgur.com/" + _0x288117.value + "m.png");
        }
        _0x59b3ae(_0x4acc4e);
      }
    });
  }
}
class Icon {
  constructor(_0x1ed354, _0x217d22 = "fas", _0x3e041e = "", _0x1282f6 = "inherit") {
    this["name"] = _0x1ed354, this.category = _0x217d22, this["properties"] = _0x3e041e, this["color"] = _0x1282f6;
  }
  ["html"]() {
    return this["name"] == "" ? "" : "<i style=\"color: " + this.color + '" class="' + this["category"] + " " + this["name"] + " " + this["properties"] + "\"></i>";
  }
}
class Account {
  constructor(_0x19b371, _0x5405e2, _0x448682 = "UU") {
    this.change(_0x19b371, _0x5405e2, _0x448682);
  }
  ["change"](_0x5dba10, _0x1f3ba8, _0x4d12cf = "UU") {
    var _0x4ca535 = this.username;
    _0x5dba10 == "" && (_0x5dba10 = "Anonymous"), this["username"] = _0x5dba10, this["password"] = _0x1f3ba8, this["rank"] = _0x4d12cf, this.username != _0x4ca535 && $(this)["triggerHandler"](new usernameChangedEvent(this["username"], _0x4ca535)["getEvent"]());
  }
}
class LoadingScreen {
  constructor(_0x59c0a6) {
    this["container"] = _0x59c0a6, this["container"]["attr"]("id", "loadingContainer"), this["container"].addClass("loadingSpinner"), this["half"], this["container"]["contextmenu"](function (_0x306113) {
      _0x306113.preventDefault();
    });
  }
  ["show"](_0x491808 = "", _0x256172 = false, _0x561d5f = 1, _0x523611 = "fa-cog") {
    this["half"] = false, _0x256172 ? this["container"]["html"]("<div class=\"circularProgress sync\"><span class=\"progress-left\"><span class=\"progress-bar\"></span></span><span class=\"progress-right\"><span class=\"progress-bar\"></span></span><div class=\"progress-value\">0%</div></div><p class=\"progressText bottomProgressText\"><span class=\"text\"></span></p>") : this["container"]["html"]('<p class="progressText"><span class="icon">' + new Icon(_0x523611, "fas", "fa-spin")["html"]() + "</span><span class=\"text\"></span></p>"), this["setText"](_0x491808), this["container"]["css"]("opacity", _0x561d5f), this["container"]["show"]();
  }
  ["hide"]() {
    var _0xd2647f = this;
    this.container["fadeOut"](750, function () {
      _0xd2647f["container"].empty();
    });
  }
  ["showProgress"](_0x45827b) {
    var _0x544d6a = Math.min(Math["max"](_0x45827b, 1), 100) * 180 / 100 * 2;
    this["container"]["find"](".progress-value")["html"](parseInt(_0x45827b) + "%"), parseInt(_0x45827b) <= 50 ? this["container"].find(".progress-right .progress-bar")["css"]("transform", "rotate(" + _0x544d6a + "deg)") : (!this.half && (this["container"]["find"](".progress-right .progress-bar").css("transform", "rotate(180deg)"), this["half"] = true), this.container["find"](".progress-left .progress-bar").css("transform", "rotate(" + (_0x544d6a - 180) + "deg)"));
  }
  ["setText"](_0x13ae35, _0x3c3090 = null) {
    this.container["find"](".progressText span.text")["html"](_0x13ae35), _0x3c3090 != null && this["setIcon"](_0x3c3090);
  }
  ["setIcon"](_0x34fd70) {
    this["container"]["find"](".progressText span.icon")["html"](_0x34fd70);
  }
}
class TextManager {
  constructor() {
    this["availableLanguages"] = {
      en: "English",
      es: "Espaol",
      de: "Deutsch",
      pt: "Portugu\xEAs",
      ru: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439"
    };
  }
  ["loadFiles"](_0x1f11ba) {
    var _0x3643de = this;
    $.i18n()["load"](_0x1f11ba)["done"](function () {
      $(_0x3643de).triggerHandler(new fileLoadedEvent()["getEvent"]());
    });
  }
  ["getString"](_0x23e2c9, _0x25aee5 = null, _0x27f0e7 = true) {
    if (_0x25aee5 != null) {
      if (Array.isArray(_0x25aee5)) return _0x25aee5.unshift(_0x23e2c9), (_0x27f0e7 ? "<span data-i18n=\"" + _0x23e2c9 + '"' + (_0x25aee5 ? " data-i18n-args=\"" + _0x25aee5["toString"]() + '"' : "") + ">" : "") + $["i18n"].apply(null, _0x25aee5) + (_0x27f0e7 ? "</span>" : "");
    }
    return (_0x27f0e7 ? '<span data-i18n="' + _0x23e2c9 + '"' + (_0x25aee5 ? " data-i18n-args=\"" + _0x25aee5 + '"' : "") + ">" : "") + $["i18n"](_0x23e2c9, _0x25aee5) + (_0x27f0e7 ? "</span>" : "");
  }
  ["getLocale"]() {
    return $["i18n"]()["locale"];
  }
  ["changeLocale"](_0x449edc) {
    if (Object.keys(this.availableLanguages).indexOf(_0x449edc) > -1) {
      if ($["i18n"]()["locale"] != _0x449edc) {
        let _0x24ad4c = $["i18n"]()["locale"];
        $.i18n().locale = _0x449edc, $(this)["triggerHandler"](new localeChangedEvent(_0x449edc, _0x24ad4c)["getEvent"]());
      }
    }
  }
  ["getSupportedLanguages"]() {
    return this.availableLanguages;
  }
  ["isSupportedLanguage"](_0x226584) {
    return Object["keys"](this["availableLanguages"]).indexOf(_0x226584) >= 0;
  }
  ["updateElement"](_0x2ba9a5) {
    _0x2ba9a5["i18n"]();
  }
}
var room,
  socket,
  cm,
  UI,
  storage,
  device,
  domain = "flockmod.com",
  textManager;
function run() {
  storage = new LocalStorage("fmod"), device = new Device(window), socket = new Socket("wss://" + domain + "/server/"), cm = new ConnectionManager(socket), UI.setup($("#content")), textManager["changeLocale"](UI.userPreferences["getProperty"]("language", "en")), room = new Room(UI["boardContainer"], "Lobby Browser", "L", 1, "1P");
  var _0x5726a6 = 30,
    _0x362ae3 = window["setInterval"](function () {
      socket["execFrame"](), room && room["connected"] && (room["myself"].frameBuffer["execFrame"](), $["each"](room["users"], function (_0x131297) {
        room["users"][_0x131297]["frameBuffer"]["execFrame"]();
      }));
    }, parseInt(1e3 / _0x5726a6));
}
function loadTexts() {
  textManager = new TextManager(), $(textManager).on("fileLoaded", function (_0x243bb2) {
    this["changeLocale"]("en"), run(), this.updateElement($("body")), $(".splashScreen")["stop"]()["animate"]({
      height: "0%"
    }, {
      duration: 2e3,
      easing: "swing"
    });
  }), textManager["loadFiles"]({
    en: "/draw/locale/en.json?" + UI["version"],
    es: "/draw/locale/es.json?" + UI["version"],
    de: "/draw/locale/de.json?" + UI.version,
    pt: "/draw/locale/pt.json?" + UI.version,
    ru: "/draw/locale/ru.json?" + UI["version"]
  });
}
$(document)["ready"](function () {
  UI = new UserInterface();
  var _0x3752a1 = localStorage.getItem("quickLaunch") === "true" ? 0 : 4,
    _0x481822 = this;
  $(".splashScreen").contextmenu(function (_0x37d86a) {
    _0x37d86a.preventDefault();
  });
  var _0x38662c = setInterval(function () {
    if (_0x3752a1 == 0) clearInterval(_0x38662c), changeCaption("LOADING..."), $("#startButton:not(.disabled)")["trigger"]("click"); else _0x3752a1 > 0 && changeCaption("START DRAWING (" + _0x3752a1-- + ")");
  }, 1e3);
  $("#startButton").on("touchstart click", function (_0x243cd9) {
    _0x243cd9["preventDefault"](), $(this)["addClass"]("disabled"), hideButton(), $["ajax"]({
      type: "POST",
      cache: true,
      async: false,
      url: UI["baseDir"] + "forms/app.main.html?v=" + UI.version
    })["done"](function (_0x41e367) {
      $(".contentScreen")["html"](_0x41e367), loadTexts();
    });
  });
});
function changeCaption(_0xcee181) {
  $("#startButton").length > 0 && $("#startButton")["html"](_0xcee181);
}
function hideButton() {
  $("#startButton")["length"] > 0 && $("#startButton")["fadeOut"]("slow");
}
//Added manually
function zeroToOnePercentage(_0x15f254) {
  return parseInt(_0x15f254 * 0x64);
}

let lastX = null;
let lastY = null;
let lastTime = null;

const speedThreshold = 1; // Adjust this value to control how fast the cursor needs to move to reach 0 opacity 
const minOpacity = 0.02; // Minimum opacity value
let previousPressure = 0;

// window.addEventListener("pointermove", (event) => {
//     const mouseModeEnabled = localStorage.getItem('mouseModeEnabled') === 'true';

//     // Brush handler and feature check
//     const brushHandler = room?.myself?.surface?.brushHandler;
//     const toggleFeature = room?.myself?.surface?.getBrushOptions()?.togglepressureopacity;
//     const currentTool = room?.myself?.surface?.getCurrentBrush();

//     if (mouseModeEnabled && currentTool === 'pen' && toggleFeature && room?.myself?.surface?.penPressed) {
//         const currentTime = performance.now();
//         const x = event.clientX;
//         const y = event.clientY;

//         if (lastX !== null && lastY !== null && lastTime !== null) {
//             const dx = x - lastX;
//             const dy = y - lastY;
//             const dt = currentTime - lastTime;

//             const distance = Math.sqrt(dx * dx + dy * dy);
//             const speed = distance / dt;

//             let normalizedSpeed = 1 - Math.min(speed / speedThreshold, 1); // Scale to 0-1, where 1 is slow, 0 is fast
//             normalizedSpeed = Math.max(normalizedSpeed, minOpacity); // Ensure opacity does not go below minOpacity

//             room?.myself?.surface?.setBrushOptions({ alpha: normalizedSpeed.toFixed(2) });
//         }

//         lastX = x;
//         lastY = y;
//         lastTime = currentTime;
//     } else {
//       window.maxOpacitySize = parseFloat(localStorage.getItem('maxOpacitySize')) || 1; 
//       window.opacityChangeThreshold = parseFloat(localStorage.getItem('opacityChangeThreshold')) || 0; 

//       if (brushHandler && currentTool === 'pen' && room?.myself?.inputDevice !== 'mouse') {
//           const baseSize = room?.myself?.surface?.getBrushOptions()?.size;
//           const pressure = event.pressure;
          
//           let quantizedPressure;
//           if (window.opacityChangeThreshold <= 0) {
//             // When threshold is 0, use raw pressure value
//             quantizedPressure = pressure;
//           } else {
//             // Quantize pressure to nearest threshold step
//             quantizedPressure = Math.floor(pressure / window.opacityChangeThreshold) * window.opacityChangeThreshold;
//           }
          
//           // Only update if quantized pressure changed or threshold is 0
//           if (toggleFeature && baseSize != null && (quantizedPressure !== previousPressure || window.opacityChangeThreshold <= 0)) {
//             let size = baseSize * quantizedPressure;
//             window.smartOpacityCapEnabled = localStorage.getItem('smartOpacityCap') === "true";
//             window.blurControlEnabled = localStorage.getItem('blurControl') === "true";
//             let alpha;

//             if (window.smartOpacityCapEnabled) {
//                 alpha = baseSize > window.maxOpacitySize ? (size >= window.maxOpacitySize ? 1 : size / window.maxOpacitySize) : (size >= baseSize ? 1 : size / baseSize);
//             } else {
//                 alpha = size >= baseSize ? 1 : size / window.maxOpacitySize;
//             }

//             if (window.blurControlEnabled) {
//               const maxBlur = 0.4;
//               const minBlur = 0.1;
//               const startThreshold = 0.3;
//               const calculatedSize = baseSize * event.pressure;
//               let blurValue;
            
//               if (calculatedSize < startThreshold) {
//                 blurValue = 0;
//               } else {
//                 blurValue = minBlur + ((calculatedSize - startThreshold) / (baseSize - startThreshold)) * (maxBlur - minBlur);
//                 if (blurValue > maxBlur) {
//                   blurValue = maxBlur;
//                 }
//               }
//               room?.myself?.surface?.setBrushOptions({ alpha, blur: blurValue });
//             } else {
//               room?.myself?.surface?.setBrushOptions({ alpha });
//             }
            
//             previousPressure = quantizedPressure;
//           }
//       }
//   }
// });



// fix vanilla fm pressure not resetting after pointer is released bug

const resetPressureRelease = localStorage.getItem('resetPressureRelease') === 'true';
function checkPenAndSetPressure() {
  setInterval(() => {
      // Ensure that the objects exist before accessing their properties
      if (room?.myself?.surface) {
          const currentTool = room.myself.surface.getCurrentBrush();

          // Check the input device type and penPressed state
          if (room.myself.inputDevice === 'mouse') {
            if (room.myself.surface.penPressed) {
                // If input device is mouse and penPressed is true, set pressure to 1
                const brushOptions = room.myself.surface.getBrushOptions?.();
                if (brushOptions?.pressure) {
                    room.myself.surface.setBrushOptions({
                        pressure: [brushOptions.pressure[0], 1]
                    });
                }
            } else {
                // If input device is mouse and penPressed is false, set pressure to 0
                const brushOptions = room.myself.surface.getBrushOptions?.();
                if (brushOptions?.pressure) {
                    room.myself.surface.setBrushOptions({
                        pressure: [brushOptions.pressure[0], 0]
                    });
                }
            }
        }
         else if ((room.myself.surface.hasBrushOption('pressure')) && !room.myself.surface.penPressed) {
              // analogically to pressure reset to 0, made this so it resets opacity to 0 if dynamic opacity is on and 
              // you are not using mouse(for mouse we don't want to reset to 0 as we are may use mouse mode)
              if (room?.myself?.surface?.getBrushOptions()?.togglepressureopacity && !room.myself.muted) {
                room.myself.surface.setBrushOptions({
                  alpha: 0
              });
            }
            // If input device is not mouse and penPressed is false, set pressure to 0
              room.myself.surface.setBrushOptions({
                  pressure: [room.myself.surface.getBrushOptions().pressure[0], 0]
              });
          }
      }
  }, 30); // Run this check every 30ms
}

if (resetPressureRelease === true) {
  checkPenAndSetPressure();
}



// fix vanilla fm bug for RMB unexpected behavior for stylus

function monitorInputDevice() {
  // Function to update input device
  const updateInputDevice = (event) => {
      let inputDevice = "mouse"; // Default to mouse
      if (event.type === "pointerdown") {
          inputDevice = event.pointerType; // e.g., "mouse", "touch", or "pen"
      } else if (event.type === "touchstart") {
          inputDevice = "touch";
      }
      room?.myself?.changeInputDevice(inputDevice);
  };

  // Add mousedown listener for RMB detection
  document.addEventListener("mousedown", (event) => {
      if (event.button === 2) { // Right Mouse Button (RMB)
          room.myself.changeInputDevice("mouse");
      }
  });

  // Add pointerdown and touchstart listeners to detect other input types
  document.addEventListener("pointerdown", updateInputDevice);
  document.addEventListener("touchstart", updateInputDevice);
}

if (rmbActionFix === true) {
  monitorInputDevice();
}


function getColorUnderCursor(UI) {
  let lastColor = null;
  let lastRequest = null;
  let lastUpdateTime = 0;
  const updateThrottle = 50; // Throttle updates every 50ms

  function onMouseMove(event) {
    const holdToPickColor = localStorage.getItem('holdToPickColor') === 'true';
    if (!holdToPickColor) return; // Disable functionality dynamically

    if (!UI || !room?.myself?.surface) {
      // console.warn("UI or room.myself.surface is not defined.");
      return;
    }

    if (room.myself.surface.getCurrentBrush() !== 'picker' || !event.buttons) return;

    const now = Date.now();
    if (now - lastUpdateTime < updateThrottle) return; // Throttle check
    lastUpdateTime = now;

    const position = UI.mousePointer?.position || { x: event.clientX, y: event.clientY };
    if (UI.mouseOverBoard && UI.mouseOverBoard()) {
      const brushOptions = room.myself.surface.getBrushOptions();
      const areaAverage = brushOptions?.areaaverage || false;
      const boardPosition = UI.screenToBoard(position.x, position.y);
      
      if (areaAverage) {
        if (lastRequest) lastRequest.abort?.(); // Cancel previous request
        
        const sampleSize = brushOptions.size || 10; // Default sample size
        lastRequest = room.board.getAllLayers(
          boardPosition.x - sampleSize / 2,
          boardPosition.y - sampleSize / 2,
          sampleSize,
          sampleSize
        );

        lastRequest.then((layerData) => {
          if (!layerData) return;
          const canvas = new AdvancedCanvas(sampleSize, sampleSize);
          const images = Object.keys(layerData).length;
          let loadedImages = 0;
          let imageElements = {};

          Object.entries(layerData).forEach(([layerIndex, data]) => {
            const img = new Image();
            imageElements[layerIndex] = img;
            img.onload = function () {
              if (++loadedImages === images) {
                for (let i = 0; i < room.board.nLayers; i++) {
                  if (imageElements[i]) canvas.drawImage(imageElements[i], 0, 0);
                }
                
                const avgColor = getRadialAvg(
                  canvas.getImageData(),
                  sampleSize / 2,
                  sampleSize / 2,
                  sampleSize / 2,
                  room.board.backgroundColor
                );
                
                const rgbColor = `rgb(${avgColor[0]}, ${avgColor[1]}, ${avgColor[2]})`;
                if (rgbColor !== lastColor) {
                  lastColor = rgbColor;
                  UI.colorChange(rgbColor);
                }
                canvas.remove();
              }
            };
            img.src = data;
          });
        });
      } else {
        const pixelData = room.board.getPixelAllLayers(boardPosition.x, boardPosition.y);
        if (pixelData) {
          const rgbColor = `rgb(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;
          if (rgbColor !== lastColor) {
            lastColor = rgbColor;
            UI.colorChange(rgbColor);
          }
        } else {
        }
      }
    }
  }

  function onMouseUp() {
    lastRequest = null; // Reset request on mouse release
  }

  document.addEventListener("pointermove", onMouseMove);
  document.addEventListener("pointerup", onMouseUp);
}

// Wait until the page is fully loaded before executing
window.addEventListener("DOMContentLoaded", () => {
  if (typeof UI !== "undefined" && UI) {
    getColorUnderCursor(UI);
  } else {
    //  console.warn("UI is not defined at DOMContentLoaded, delaying execution.");
    const interval = setInterval(() => {
      if (typeof UI !== "undefined" && UI) {
        clearInterval(interval);
        getColorUnderCursor(UI);
      }
    }, 100);
  }
});


function initializeZoomControls() {
  if (!window.UI?.shortcutManager || !room?.myself?.surface) {
    setTimeout(initializeZoomControls, 100);
    return;
  }

  let isZooming = false;
  let startX = 0;
  let zoomPoint = { x: 0, y: 0 };
  // Adjust sensitivity based on precision setting
  const isPreciseZoom = localStorage.getItem("preciseZoomDisplay") === "true";
  const zoomSensitivity = isPreciseZoom ? 0.002 : 0.01; // Higher sensitivity for non-precise mode
  let animationFrame = null;
  let mouseDown = false;

  function isActuallyMuted() {
    return UI.muteSeconds > 0;
  }

  // Check if processing mute is active
  function isProcessingMuted() {
    return room?.board?.needToUnmuteWhenComplete || room?.board?.commitProgress?.active;
  }

  // Main zoom handling functions
  function startZoom() {
    if (!isZooming) {
      isZooming = true;
      if (!isActuallyMuted() && !isProcessingMuted()) {
        room.myself.zoomMuted = true;
        room.myself.muted = true;
        UI.updateCursor(); // Ensure cursor updates when muted
      }
    }
  }

  function endZoom() {
    if (isZooming) {
      isZooming = false;
      if (room.myself.zoomMuted) {
        // Only unmute if not processing-muted and not moderator-muted
        if (!isProcessingMuted()) {
          room.myself.muted = isActuallyMuted();
          room.myself.zoomMuted = false;
          UI.updateCursor(); // Ensure cursor updates when unmuted
        } else {
          // Just clear the zoom mute flag without changing mute status
          room.myself.zoomMuted = false;
        }
      }
    }
  }

  // Hook into ShortcutManager to detect zoom shortcut
  const originalProcessMethod = UI.shortcutManager.process;
  
  UI.shortcutManager.process = function(event, eventType, dialogOpen) {
    // Call the original process method
    const result = originalProcessMethod.call(this, event, eventType, dialogOpen);
    
    // Get the shortcut string from this event
    let shortcutStr;
    if (typeof event === "string") {
      shortcutStr = event;
    } else {
      shortcutStr = this.getShortcutString(
        event.ctrlKey,
        event.altKey,
        event.shiftKey,
        event.which,
        event.key,
        event.location || event.originalEvent?.location
      );
    }
    
    // Process zoom shortcut
    const zoomShortcut = this.shortcuts.find(s => s.id === '+togglezoom');
    if (zoomShortcut && 
        ((zoomShortcut.shortcut && shortcutStr === zoomShortcut.shortcut) || 
         (zoomShortcut.shortcut2 && shortcutStr === zoomShortcut.shortcut2))) {
      
      if (eventType === "keydown") {
        startZoom();
      } else if (eventType === "keyup") {
        endZoom();
      }
    }
    
    // Process undo/redo shortcuts if they don't already have handlers
    if (eventType === "keydown") {
      // Undo
      const undoShortcut = this.shortcuts.find(s => s.id === 'undomodded');
      if (undoShortcut && 
          ((undoShortcut.shortcut && shortcutStr === undoShortcut.shortcut) || 
           (undoShortcut.shortcut2 && shortcutStr === undoShortcut.shortcut2))) {
            if (room && room.board && !UI.dialogHandler.activeDialog) {
          room.board.undo();
        }
      }
      
      // Redo
      const redoShortcut = this.shortcuts.find(s => s.id === 'redomodded');
      if (redoShortcut && 
          ((redoShortcut.shortcut && shortcutStr === redoShortcut.shortcut) || 
           (redoShortcut.shortcut2 && shortcutStr === redoShortcut.shortcut2))) {
            if (room && room.board && !UI.dialogHandler.activeDialog) {
          room.board.redo();
        }
      }
    }
    
    return result;
  };

  // Listen for shortcut changes
  if (!UI.shortcutManager._hasChangeShortcutHook) {
    const originalChangeShortcut = UI.shortcutManager.changeShortcut;
    UI.shortcutManager.changeShortcut = function(id, shortcut, isPrimary = true) {
      const result = originalChangeShortcut.call(this, id, shortcut, isPrimary);
      if (result) {
        if (id === '+togglezoom') {

        } else if (id === 'undomodded' || id === 'redomodded') {

        }
      }
      return result;
    };
    UI.shortcutManager._hasChangeShortcutHook = true;
  }

  // Add mouse event handlers
  window.addEventListener("pointerdown", (e) => {
    if (isZooming && e.button === 0) { // Left mouse button
      mouseDown = true;
      startX = UI.mousePointer.position.x;
      zoomPoint = {
        x: UI.mousePointer.position.x,
        y: UI.mousePointer.position.y
      };
    }
  });

  window.addEventListener("pointermove", (e) => {
    if (isZooming && mouseDown && !animationFrame) {
      animationFrame = requestAnimationFrame(() => {
        let currentX = UI.mousePointer.position.x;
        let delta = currentX - startX;

        if (Math.abs(delta) > 1) {
          let zoomFactor = 1 + delta * zoomSensitivity;
          
          // Round zoom factor for non-precise mode
          if (!isPreciseZoom) {
            // Get current scale after applying factor
            let newScale = room.board.scale * zoomFactor;
            // Round to nearest integer percentage
            newScale = Math.round(newScale * 100) / 100;
            // Calculate adjusted factor to achieve rounded scale
            zoomFactor = newScale / room.board.scale;
          }
          
          UI.zoomToScreenPoint(zoomPoint.x, zoomPoint.y, zoomFactor);
          startX = currentX;
        }
        animationFrame = null;
      });
    }
  });

  window.addEventListener("pointerup", (e) => {
    if (e.button === 0) { // Left mouse button
      mouseDown = false;
    }
  });

  // Ensure cursor is updated after entering the room
  UI.updateCursor();
  

}

// Initialize the controls
initializeZoomControls();

// instant reconnect feature

var instantReconnect = localStorage.getItem('instantReconnect');

function ensureConnection() {
  let reconnecting = false; // Prevent multiple reconnect attempts
  let lastReconnectTime = 0; // Track the timestamp of the last reconnect attempt

  const interval = setInterval(() => {
      // Check if room and socket are defined before proceeding
      if (typeof room === "undefined" || typeof socket === "undefined") {
          return; // Wait until they are defined
      }

      // Ensure room has a valid 'connected' property
      if (typeof room.connected !== "boolean") {
          return;
      }
      if (room.name !== "Lobby Browser") {
        const currentTime = Date.now();
        const timeSinceLastAttempt = currentTime - lastReconnectTime;
        const cooldownPeriod = 10000; // 10 seconds in milliseconds
        
        // If disconnected and cooldown period has elapsed
        if (!room.connected && !reconnecting && typeof socket.connect === "function" && 
            (timeSinceLastAttempt >= cooldownPeriod || lastReconnectTime === 0)) {
            
            reconnecting = true; // Mark as attempting to reconnect
            lastReconnectTime = currentTime; // Update the timestamp
            socket.connect();
        }
      }

      // If connection is restored, reset reconnect flag
      if (room.connected) {
          reconnecting = false;
      }
  }, 50);
}

// Start monitoring connection
if (instantReconnect === "true") {
  ensureConnection();
}

function keepTabAlive() {
  const playInaudibleTone = () => {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    // Function to start and stop the oscillator
    const startTone = () => {
      // Create a high-frequency oscillator
      const oscillator = audioContext.createOscillator();
      oscillator.type = 'sine';
      oscillator.frequency.value = 20050; // 20 kHz, near upper human hearing

      // Create a minimal gain so it's technically audible
      const gainNode = audioContext.createGain();
      // Try a tiny volume above zero
      gainNode.gain.value = 0.00087;

      // Connect oscillator -> gain -> destination
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      oscillator.start();
      //console.log("Playing inaudible tone...");
      setTimeout(() => {
        oscillator.stop();
        //console.log("Stopped inaudible tone...");
        oscillator.disconnect();
      }, 125); // Play for 500 ms
    };

    // Play the tone every 10 seconds
    setInterval(() => {
      if (room?.name !== "Lobby Browser") {
        startTone();
      }
    }, 10000); // Every 10 seconds
  };

  document.addEventListener('click', playInaudibleTone, { once: true });
}

// Call the function to start keeping the tab alive
if (localStorage.getItem('keepTabAlive') === "true") {
  keepTabAlive();
}

let previousRoomName = "Lobby Browser";
let roomChangeTime = null;

function monitorRoomChange() {
  setInterval(() => {
    const currentRoomName = room?.name;

    if (currentRoomName && currentRoomName !== previousRoomName) {
      if (currentRoomName !== "Lobby Browser") {
        roomChangeTime = Date.now();
      } else {
        roomChangeTime = null;
      }
      previousRoomName = currentRoomName;
    }

    if (roomChangeTime && Date.now() - roomChangeTime >= 1250) {
      UI?.fitToScreen();
      UI?.centerBoard();
      roomChangeTime = null; // Reset to avoid repeated execution
    }
  }, 100);
}

monitorRoomChange();

function setupCombinedTransferSystem() {
  // console.group(" Transfer Recording & Replay System");
  // console.log("Setting up combined transfer recording and replay system...");
  
  if (!room.board.transferHistory) {
    room.board.transferHistory = [];
  }
  
  // Add configuration flag for forced flip - DEFAULT TO DISABLED
  room.board._forceFlipX = false;  // Changed from true to false
  room.board._replayInProgress = false;
  room.board._transferSystemFlag = "transfer_system_" + Math.random().toString(36).substring(2, 10);
  
  // Add toggle function for forced flip
  room.board.toggleForceFlipX = function(forceValue = null) {
    if (forceValue !== null) {
      this._forceFlipX = forceValue;
    } else {
      this._forceFlipX = !this._forceFlipX;
    }
    // console.log(`SERVER SIDED FLIP: ${this._forceFlipX ? "ENABLED" : "DISABLED"}`);
    return this._forceFlipX;
  };
  
  const originalAddTransfer = room.addTransfer;
  const originalTransferSend = Transfer.prototype.send;
  
  Transfer.prototype.send = function() {
    try {
      if (this._replaySource || room.board._replayInProgress) {
        if (this.data && this.data.length > 0) {
          this.data.forEach(chunk => {
            if (typeof chunk === 'object') {
              chunk._transferSystemFlag = room.board._transferSystemFlag;
              // Use config flag for flip
              if (room.board._forceFlipX) {
                chunk.flipped = true;
              }
            }
          });
        }
      }
      if (!this._replaySource && !room.board._replayInProgress &&
          !this._alreadyRecorded && this.data && this.data.length > 0) {
        this._alreadyRecorded = true;
        const transferRecord = {
          timestamp: Date.now(),
          type: this.action,
          chunks: this.data.length,
          data: JSON.parse(JSON.stringify(this.data)),
          sender: room.myself?.username || "Anonymous",
          // Use config flag for flip
          flipped: room.board._forceFlipX,
          roomInfo: {
            boardDimensions: {
              width: room.board.canvasWidth,
              height: room.board.canvasHeight
            },
            currentLayer: room.myself?.surface?.currentLayer,
            username: room.myself?.username
          }
        };
      // console.log(` Recording transfer: ${this.action} with ${this.data.length} chunks ${room.board._forceFlipX ? "(FLIP ENABLED)" : ""}`);
      
      // Change from unshift to push to add to end of array
      room.board.transferHistory.push(transferRecord);
      }
    } catch (err) {
      // console.error("Error recording transfer:", err);
    }
    return originalTransferSend.apply(this, arguments);
  };

  room.addTransfer = function(transfer) {
    if (transfer && !transfer.roomInfo) {
      transfer.roomInfo = {
        boardDimensions: {
          width: room.board.canvasWidth,
          height: room.board.canvasHeight
        },
        currentLayer: room.myself?.surface?.currentLayer,
        username: room.myself?.username
      };
    }
    // Use config flag for flip
    if (transfer && room.board._forceFlipX) {
      transfer.flipped = true;
    }
    return originalAddTransfer.apply(this, arguments);
  };

  room.board.getTransferHistory = function() {
    return this.transferHistory;
  };
  
  room.board.getLastTransfer = function() {
    // Change to return the last element instead of the first
    return this.transferHistory.length > 0 ? 
      this.transferHistory[this.transferHistory.length - 1] : null;
  };
  
  room.board.listTransfers = function() {
    // console.group(" Available Transfers");
    if (this.transferHistory.length === 0) {
      // console.log("No transfers recorded yet.");
    } else {
      // console.log(`${this.transferHistory.length} transfers available:`);
      this.transferHistory.forEach((transfer, index) => {
        const time = new Date(transfer.timestamp).toLocaleTimeString();
        if (transfer.imageData) {
          // Show whether flipped or not based on actual state
          // console.log(`${index}: [${time}]  ${transfer.sender} - Image (${transfer.dimensions.width}x${transfer.dimensions.height}) | ${transfer.flipped ? ' FLIPPED' : ' NOT FLIPPED'} | Rotation: ${transfer.rotation || 0}`);
        } else if (transfer.data) {
          // console.log(`${index}: [${time}]  ${transfer.sender} - ${transfer.type} with ${transfer.chunks} chunks`);
        } else {
          // console.log(`${index}: [${time}]  ${transfer.sender} - Unknown transfer`);
        }
      });
    }
    // console.groupEnd();
    return "Use room.board.getDetailedTransferInfo(index) for more details.";
  };
  
  room.board.getDetailedTransferInfo = function(index) {
    if (index < 0 || index >= this.transferHistory.length) {
      // console.error(` Invalid index: ${index}. Valid: 0-${this.transferHistory.length-1}`);
      return false;
    }
    const transfer = this.transferHistory[index];
    // console.group(` Transfer #${index} details`);
    // console.log("Timestamp:", new Date(transfer.timestamp).toLocaleString());
    // console.log("Type:", transfer.type);
    // console.log("Sender:", transfer.sender);
    if (transfer.imageData) {
      // console.log("- Position:", transfer.position);
      // console.log("- Dimensions:", transfer.dimensions);
      // console.log("- Rotation:", `${transfer.rotation}`);
      // console.log("- Flipped:", transfer.flipped ? "Yes" : "No");
      // console.log("- Layer:", transfer.layer);
      // console.log("- Image Count:", transfer.imageCount);
    } else if (transfer.data) {
      // console.log("- Chunks:", transfer.chunks);
      // console.log("- First chunk sample:", transfer.data[0]);
    }
    // console.log("Room Info:", transfer.roomInfo);
    // console.groupEnd();
    return transfer;
  };
  
  room.board.replayTransfer = function(index, useCurrentLayer = true) {
    // console.group(` Client-side Replay #${index}`);
    if (index < 0 || index >= this.transferHistory.length) {
      // console.error(` Invalid index: ${index}`);
      // console.groupEnd();
      return false;
    }
    
    // Create a deep copy to avoid modifying the original
    const originalTransfer = this.transferHistory[index];
    const transfer = JSON.parse(JSON.stringify(originalTransfer));
    
    // Store original flip state
    const originalFlipState = originalTransfer.flipped;
    
    // Determine final flip state based on force setting and original state
    let shouldApplyFlip;
    if (room.board._forceFlipX) {
      shouldApplyFlip = !originalFlipState;
      transfer.flipped = true;
    } else {
      shouldApplyFlip = originalFlipState;
      transfer.flipped = originalFlipState;
    }
    
    // Get the current layer if useCurrentLayer is true
    const currentLayer = useCurrentLayer ? room.myself?.surface?.currentLayer : null;
    // console.log(`Replaying to ${useCurrentLayer ? 'current layer ' + currentLayer : 'original layers'}`);
    
    try {
      room.board._replayInProgress = true;
      
      if (transfer.imageData) {
        // console.log(`Local replay: image (${transfer.dimensions.width}x${transfer.dimensions.height})`);
        
        // Apply position adjustment if enabled
        const fixResizingShift = localStorage.getItem('fixResizingShift') === 'true';
        let adjustedX = transfer.position.x;
        let adjustedY = transfer.position.y;
        
        if (fixResizingShift) {
          adjustedX -= 0;  // Can be adjusted if needed
          adjustedY -= 0;
          // console.log(` Applying position adjustment: (${transfer.position.x}, ${transfer.position.y})  (${adjustedX}, ${adjustedY})`);
        }
        
        let loadedImages = 0;
        const totalImages = transfer.imageData.length;
        const undoActions = [];
        
        transfer.imageData.forEach(imgData => {
          imgData._transferSystemFlag = room.board._transferSystemFlag;
          // Use current layer if specified, otherwise use the original layer from the transfer
          const layerIndex = useCurrentLayer ? currentLayer : (imgData.layerIndex || 0);
          const ctx = room.board.getContext(layerIndex);
          
          // First, capture the area for undo
          const undoData = ctx.getImageData(
            adjustedX, adjustedY, 
            transfer.dimensions.width, 
            transfer.dimensions.height
          );
          
          const img = new Image();
          img.onload = function() {
            // Use AdvancedCanvas for consistent rendering with smoothing
            const tempCanvas = new AdvancedCanvas(
              transfer.dimensions.width, 
              transfer.dimensions.height
            );
            const tCtx = tempCanvas.getContext();
            tempCanvas.smoothing = smoothingSetting;
            
            // Draw to temp canvas first (unrotated, unflipped)
            tCtx.drawImage(img, 0, 0, 
              transfer.dimensions.width, 
              transfer.dimensions.height
            );
            
            // Draw to actual context with rotation and flip
            ctx.save();
            
            // Enable image smoothing explicitly
            ctx.imageSmoothingEnabled = smoothingSetting;
            ctx.imageSmoothingQuality = "high";
            
            // Set up transformation
            ctx.translate(
              adjustedX + transfer.dimensions.width/2, 
              adjustedY + transfer.dimensions.height/2
            );
            
            if (transfer.rotation) {
              ctx.rotate(transfer.rotation * Math.PI / 180);
            }
            
            if (shouldApplyFlip) {
              // console.log(" APPLYING FLIP");
              ctx.scale(-1, 1);
            }
            
            // Draw the properly transformed image
            ctx.drawImage(
              tempCanvas.canvas[0], 
              -transfer.dimensions.width/2, 
              -transfer.dimensions.height/2, 
              transfer.dimensions.width, 
              transfer.dimensions.height
            );
            
            ctx.restore();
            tempCanvas.remove();
            
            // Add to undo stack
            const redoData = ctx.getImageData(
              adjustedX, adjustedY, 
              transfer.dimensions.width, 
              transfer.dimensions.height
            );
            
            undoActions.push({
              layer: layerIndex,
              bbox: [adjustedX, adjustedY, transfer.dimensions.width, transfer.dimensions.height],
              oldData: undoData,
              newData: redoData
            });
            
            room.board.layerChanged(layerIndex);
            
            loadedImages++;
            if (loadedImages === totalImages) {
              // Add to group undo
              if (undoActions.length > 0) {
                room.board.pushGroupUndo(undoActions);
              }
              
              setTimeout(() => {
                room.board._replayInProgress = false;
                // console.log(` Local replay complete ${shouldApplyFlip ? '(with FLIP)' : ''} on layer ${layerIndex}`);
                // console.groupEnd();
              }, 100);
            }
          };
          img.src = imgData.base64;
        });
        
        return true;
      } else if (transfer.data && transfer.type === "selection") {
        // console.log(`Local replay: selection with ${transfer.data.length} chunks`);
        
        const undoActions = [];
        let loadedChunks = 0;
        
        transfer.data.forEach(chunk => {
          // Determine if this chunk should be flipped
          const chunkShouldFlip = room.board._forceFlipX ? true : (chunk.flipped || false);
          
          // Use current layer if specified, otherwise use the layer from the chunk
          const layerIndex = useCurrentLayer ? currentLayer : (chunk.layer || 0);
          const ctx = room.board.getContext(layerIndex);
          
          // Capture undo data
          const undoData = ctx.getImageData(
            chunk.x, chunk.y,
            chunk.width, chunk.height
          );
          
          const img = new Image();
          img.onload = function() {
            // Use AdvancedCanvas for consistent rendering
            const tempCanvas = new AdvancedCanvas(chunk.width, chunk.height);
            const tCtx = tempCanvas.getContext();
            tempCanvas.smoothing = smoothingSetting;
            
            // Draw to temp canvas first
            tCtx.drawImage(img, 0, 0, chunk.width, chunk.height);
            
            // Draw to actual context
            ctx.save();
            ctx.imageSmoothingEnabled = smoothingSetting;
            ctx.imageSmoothingQuality = "high";
            
            ctx.translate(chunk.x + chunk.width/2, chunk.y + chunk.height/2);
            
            if (chunk.rotation) {
              ctx.rotate(chunk.rotation * Math.PI / 180);
            }
            
            if (chunkShouldFlip) {
              // console.log(" APPLYING FLIP to selection chunk");
              ctx.scale(-1, 1);
            }
            
            ctx.drawImage(
              tempCanvas.canvas[0],
              -chunk.width/2, 
              -chunk.height/2,
              chunk.width, 
              chunk.height
            );
            
            ctx.restore();
            tempCanvas.remove();
            
            // Add to undo stack
            const redoData = ctx.getImageData(
              chunk.x, chunk.y,
              chunk.width, chunk.height
            );
            
            undoActions.push({
              layer: layerIndex,
              bbox: [chunk.x, chunk.y, chunk.width, chunk.height],
              oldData: undoData,
              newData: redoData
            });
            
            room.board.layerChanged(layerIndex);
            
            loadedChunks++;
            if (loadedChunks === transfer.data.length) {
              // Add to group undo
              if (undoActions.length > 0) {
                room.board.pushGroupUndo(undoActions);
              }
              
              setTimeout(() => {
                room.board._replayInProgress = false;
                // console.log(` Local selection replay done ${room.board._forceFlipX ? '(with FLIP)' : ''} on layer ${layerIndex}`);
                // console.groupEnd();
              }, 100);
            }
          };
          
          let base64Data = chunk.data;
          if (!base64Data.startsWith('data:image')) {
            base64Data = 'data:image/png;base64,' + base64Data;
          }
          img.src = base64Data;
        });
        
        return true;
      } else {
        // console.log(" Unsupported transfer type");
        room.board._replayInProgress = false;
        // console.groupEnd();
        return false;
      }
    } catch (err) {
      // console.error("Error replaying transfer:", err);
      room.board._replayInProgress = false;
      // console.groupEnd();
      return false;
    }
  };
  
  room.board.broadcastTransfer = function(index) {
    // console.group(` Broadcast Transfer #${index}`);
    if (index < 0 || index >= this.transferHistory.length) {
      // console.error(` Invalid index: ${index}`);
      // console.groupEnd();
      return false;
    }
    
    // Create a deep copy of the transfer to avoid modifying the original
    const originalTransfer = this.transferHistory[index];
    const transfer = JSON.parse(JSON.stringify(originalTransfer));
  
    const transferFlipState = originalTransfer.flipped;
    this._forceFlipX = transferFlipState;
    // console.log(`Setting force flip to ${transferFlipState ? "ENABLED" : "DISABLED"} to match transfer's original state`);
    
    
    // Store the original flip state from the transfer
    const originalFlipState = originalTransfer.flipped;
    
    // Determine the final flip state based on force setting and original state
    let shouldApplyFlip;
    
    if (room.board._forceFlipX) {
      shouldApplyFlip = !originalFlipState;
      transfer.flipped = true;
    } else {
      shouldApplyFlip = originalFlipState;
      transfer.flipped = originalFlipState;
    }
    
    // console.log(`Type=${transfer.type}, rotation=${transfer.rotation}, flip=${transfer.flipped ? 'YES' : 'NO'}`);
    // console.log(`Original state: ${originalFlipState ? 'FLIPPED' : 'NOT FLIPPED'}`);
    // console.log(`Force Flip setting: ${room.board._forceFlipX ? 'ENABLED' : 'DISABLED'}`);
    // console.log(`Should apply new flip: ${shouldApplyFlip ? 'YES' : 'NO'}`);
  
    try {
      if (transfer.imageData) {
        // console.log(`Broadcast image (${transfer.dimensions.width}x${transfer.dimensions.height}) with rotation=${transfer.rotation}, flip=${transfer.flipped ? 'YES' : 'NO'}`);
        const tempUploader = new Uploader($("#uploadFile"));
        
        // Apply the adjustment if setting is enabled
        const fixResizingShift = localStorage.getItem('fixResizingShift') === 'true';
        let adjustedX = transfer.position.x;
        let adjustedY = transfer.position.y;
        
        if (fixResizingShift) {
          adjustedX -= 0;
          adjustedY -= 0;
          // console.log(` Applying position adjustment: (${transfer.position.x}, ${transfer.position.y})  (${adjustedX}, ${adjustedY})`);
        }
        
        // Position uploader at the adjusted place
        tempUploader.position = new Point(adjustedX, adjustedY);
        tempUploader.width = transfer.dimensions.width;
        tempUploader.height = transfer.dimensions.height;
        tempUploader.uploadType = transfer.type;
        tempUploader.originalPosition = new Rect(
          adjustedX,
          adjustedY,
          transfer.dimensions.width,
          transfer.dimensions.height
        );
        
        // Store the current user layer BEFORE changing anything
        const userCurrentLayer = room.myself.surface.currentLayer;
        
        let loadedImages = 0;
        const totalImages = transfer.imageData.length;
        
        transfer.imageData.forEach(imgData => {
          const img = new Image();
          img.onload = function() {
            // Add the layer with the original image (not flipped/rotated yet)
            tempUploader.addLayer(
              imgData.layerIndex || transfer.layer || userCurrentLayer,
              img,
              adjustedX,
              adjustedY
            );
            
            loadedImages++;
            if (loadedImages === totalImages) {
              // Save special flag to indicate this is a broadcast
              tempUploader._isBroadcastTransfer = true;
              
              // Set the broadcast layer on the transfer object but NOT on the local surface
              tempUploader._broadcastLayer = transfer.layer || userCurrentLayer;
              tempUploader._replaySource = true;
              
              // Apply flip only if we determined it should be flipped
              if (shouldApplyFlip) {
                // console.log(" APPLYING FLIP TO UPLOADER");
                tempUploader.flipImage(true);
              }
              tempUploader.rotateImage(transfer.rotation || 0);
              
              // Send a layer change command for other clients WITHOUT changing our own
              if (tempUploader._broadcastLayer !== undefined) {
                const layerData = {
                  command: "BROADCAST", 
                  action: "La", 
                  layer: tempUploader._broadcastLayer
                };
                socket.send(JSON.stringify(layerData));
              }
              
              // console.log(` Pre-broadcast: rotation=${tempUploader.rotation}, flipped=${tempUploader.flipped}`);
              tempUploader.draw(); // This will handle broadcasting with the configured flip state
            }
          };
          img.src = imgData.base64;
        });
        
        // console.log(` Image broadcast initiated${transfer.flipped ? ' with FLIP' : ''}!`);
        // console.groupEnd();
        return true;
      } else if (transfer.data && transfer.type === "selection") {
        // Selection code handling would go here with similar logic
      }
    } catch (err) {
      // console.error("Error broadcasting:", err);
      // console.groupEnd();
      return false;
    }
  };
  
  // console.log(` Combined transfer recording and replay system ready! (Force Flip X: ${room.board._forceFlipX ? "ENABLED" : "DISABLED"})`);
  // console.groupEnd();
  
  return `Transfer system enabled with ${room.board.transferHistory.length} transfers.
  - Force Flip X is currently ${room.board._forceFlipX ? "ENABLED" : "DISABLED"}
  - Toggle Force Flip: room.board.toggleForceFlipX()
  - Set Force Flip: room.board.toggleForceFlipX(true/false)
  - View all: room.board.getTransferHistory()
  - List transfers: room.board.listTransfers()
  - Get details: room.board.getDetailedTransferInfo(index)
  - Replay locally: room.board.replayTransfer(index)
  - Broadcast to others: room.board.broadcastTransfer(index)`;
}

function setupSelectionToolbarRecording() {
  // Override toggleFlip method (flip button)
  if (UI.uploader.toggleFlip) {
    const originalToggleFlip = UI.uploader.toggleFlip;
    UI.uploader.toggleFlip = function() {
      // Record the flip action
      const surface = room?.myself?.surface;
      if (surface?.currentStrokeData?.isSelectionStroke) {
        // console.log("%cCaptured FLIP button via toggleFlip()", "color: blue; font-weight: bold");
        surface.currentStrokeData.selectionActions.push({
          type: 'toolbarAction',
          buttonName: 'flip',
          method: 'toggleFlip',
          time: new Date().getTime()
        });
        surface.currentStrokeData.hasActions = true;
      }
      
      // Log current state BEFORE the toggle (since we're about to toggle it)
      const currentState = this.flipped;
      const nextState = !currentState;
      
      // SYNC: Set the force flip value to match the UI flip state AFTER the toggle
      if (room && room.board && typeof room.board.toggleForceFlipX === 'function') {
        // We need to set it to what the state WILL BE after the toggle
        setTimeout(() => {
          room.board._forceFlipX = nextState;
          // console.log(`Sync: Force flip setting now ${nextState ? "ENABLED" : "DISABLED"} to match UI flip state`);
        }, 0);
      }
      
      // Call original method
      return originalToggleFlip.apply(this, arguments);
    };
  }
  
  // Add this after the uploader instance is created
  $(UI.uploader.selectionToolbar).on("optionSelected", function(event) {

    const surface = room?.myself?.surface;
    if (!surface) return;
    
    // Get reference to the brush if it exists
    const brush = surface?.brushHandler?.brush;
    const isBrushSelection = brush instanceof BrushSelectionModded;
    
    // CRITICAL FIX: Ignore flip button for pending undo actions
    // Only handle confirm/delete/cancel buttons for pending actions
    if (event.option === "flip") {

      return; // Skip any further processing for the flip button
    }
    
    // Helper function to check for clone actions in pending strokes
    function hasClonePendingStrokes(surface) {
      if (!surface || !surface._pendingSelectionStrokes) return false;
      
      return surface._pendingSelectionStrokes.some(stroke => stroke.finalAction === 'clone');
    }
    
    // Get the stroke number from the most relevant source
    let surfaceStrokeNumber = null;
    
    // First try: Check current stroke if it's a selection stroke
    if (surface.currentStroke?.isSelectionStroke && surface.currentStroke?.strokeNumber) {
      surfaceStrokeNumber = surface.currentStroke.strokeNumber;

    } 
    // Second try: Check pending selection strokes
    else if (surface._pendingSelectionStrokes && surface._pendingSelectionStrokes.length > 0) {
      // Use the most recent (last) pending stroke
      const pendingStroke = surface._pendingSelectionStrokes[surface._pendingSelectionStrokes.length - 1];
      if (pendingStroke?.strokeNumber) {
        surfaceStrokeNumber = pendingStroke.strokeNumber;

      }
    } 
    // Third try: Check current stroke data
    else if (surface.currentStrokeData?.isSelectionStroke && surface.currentStrokeData?.strokeNumber) {
      surfaceStrokeNumber = surface.currentStrokeData.strokeNumber;

    }
    // Final try: Look at the stroke counter
    else if (surface.strokeCounter) {
      surfaceStrokeNumber = surface.strokeCounter;

    }
    
    // Determine if we should commit undo actions
    // CRITICAL FIX: For move actions, commit on both confirm and delete 
    // For clone actions, only commit on confirm (discard on delete)
    const actionType = brush?.currentActionType;
    const isMove = actionType === "move";
    const isClone = actionType === "clone";
    
    let shouldCommit = false;
    if (event.option === "confirm") {
      // Always commit on confirm button
      shouldCommit = true;
    } else if (event.option === "delete" && isMove) {
      // For move operations, also commit on delete (clear the area)
      shouldCommit = true;
    }
    // Note: Clone operations with delete button should not commit (implicit false)
    
    // FIRST: Handle pending undo actions if this is a selection brush and it's a relevant button
    if (isBrushSelection && brush.pendingUndoActions?.length > 0 && 
        (event.option === "confirm" || event.option === "delete" || event.option === "cancel")) {

      
      // Pass the surface stroke number to establish mapping
      if (surfaceStrokeNumber) {

        brush.commitPendingUndoActions(shouldCommit, surfaceStrokeNumber);
      } else {
        brush.commitPendingUndoActions(shouldCommit);
      }
    }
    
    // CRITICAL FIX: Only save strokes on confirm, and for clone ONLY save on confirm (not delete)
    if (event.option === "confirm" || (event.option === "delete" && !hasClonePendingStrokes(surface))) {
      // Check for pending strokes
      if (surface._pendingSelectionStrokes && surface._pendingSelectionStrokes.length > 0) {
        // Filter out clones if this is a delete action
        let strokesToSave = [...surface._pendingSelectionStrokes];
        if (event.option === "delete") {
          strokesToSave = strokesToSave.filter(stroke => stroke.finalAction !== 'clone');
          if (strokesToSave.length < surface._pendingSelectionStrokes.length) {

          }
        }
        
        // Move filtered pending strokes to permanent storage
        // Process each stroke to save
        // CRITICAL FIX: Filter out strokes that have already been saved
        strokesToSave = strokesToSave.filter(stroke => !stroke.alreadySaved);
        if (strokesToSave.length < surface._pendingSelectionStrokes.length) {
          }

        strokesToSave.forEach(stroke => {
          // Set a flag to indicate this was confirmed by user
          stroke.userConfirmed = true;
          stroke.confirmMethod = event.option;
          
          // Add to strokes array
          if (!surface.strokes) surface.strokes = [];
          surface.strokes.push(stroke);
          });
        
        // Handle discarded clone strokes
        const discardedStrokes = surface._pendingSelectionStrokes.filter(
          stroke => !strokesToSave.includes(stroke)
        );
        
        if (discardedStrokes.length > 0) {
          // Free up the stroke numbers of discarded strokes
          discardedStrokes.forEach(stroke => {
            if (surface.strokeCount >= stroke.strokeNumber) {
              surface.strokeCount = Math.max(0, surface.strokeCount - 1);

            }
          });
        }
        
        // Clear the pending strokes array
        surface._pendingSelectionStrokes = [];
      } 
      // Handle active stroke if present
      else if (surface.currentStrokeData?.isSelectionStroke) {
        // For active stroke, only save if it's not a clone with delete action
        const shouldSaveActive = (event.option === "confirm") || 
                                (event.option === "delete" && surface.currentStrokeData.finalAction !== 'clone');
                                
        if (shouldSaveActive) {

          
          // Set flags
          surface.currentStrokeData.userConfirmed = true;
          surface.currentStrokeData.confirmMethod = event.option;
          surface.currentStrokeData.end = {
            x: surface.cursor?.x || 0,
            y: surface.cursor?.y || 0,
            time: new Date().getTime(),
            brushOptions: surface.getBrushOptions ? surface.getBrushOptions() : {}
          };
          
          // Save to strokes array
          if (!surface.strokes) surface.strokes = [];
          surface.strokes.push(surface.currentStrokeData);
          } else {

          
          // Free up the stroke number
          if (surface.strokeCount >= surface.currentStrokeData.strokeNumber) {
            surface.strokeCount = Math.max(0, surface.strokeCount - 1);

          }
        }
        
        // Always clear the current stroke
        surface.currentStrokeData = null;
      }
    }
    // Handle cancel action
    else if (event.option === "cancel") {

      
      // Track whether we've handled the cancel
      let cancelHandled = false;
      
      // APPROACH 1: First check for active selection stroke
      if (surface.currentStrokeData?.isSelectionStroke) {

        const currentId = surface.currentStrokeData.strokeNumber;
        
        // Mark as canceled
        surface.currentStrokeData._canceled = true;
        
        // Remove from strokes array if already saved
        if (surface.strokes && surface.strokes.length) {
          const activeIdx = surface.strokes.findIndex(s => s && s.strokeNumber === currentId);
          if (activeIdx >= 0) {

            surface.strokes.splice(activeIdx, 1);
          }
        }
        
        // Remove from pending strokes
        if (surface._pendingSelectionStrokes) {
          const pendingIdx = surface._pendingSelectionStrokes.findIndex(s => s && s.strokeNumber === currentId);
          if (pendingIdx >= 0) {

            surface._pendingSelectionStrokes.splice(pendingIdx, 1);
          }
        }
        
        // Free up the stroke number
        if (surface.strokeCount >= currentId) {
          surface.strokeCount = Math.max(0, surface.strokeCount - 1);

        }
        
        // Clear current stroke
        surface.currentStrokeData = null;
        cancelHandled = true;
      }
      
      // APPROACH 2: Check pending strokes array
      if (!cancelHandled && surface._pendingSelectionStrokes && surface._pendingSelectionStrokes.length > 0) {
        // Since we're canceling, simply discard all pending strokes
        // Clean up stroke numbers
        surface._pendingSelectionStrokes.forEach(stroke => {
          if (surface.strokeCount >= stroke.strokeNumber) {
            surface.strokeCount = Math.max(0, surface.strokeCount - 1);
          }
        });
        
        // Clear the array
        surface._pendingSelectionStrokes = [];
        cancelHandled = true;
      }
      
      // Always call cancel on the brush handler to ensure visual cleanup
      if (surface.brushHandler?.brush?.cancel) {

        surface.brushHandler.brush.cancel();
      }
    }
    
    // Resume drawing (or other post-selection behavior as needed)
    // SAFELY switch back to previous tool if available
    if (event.option === "confirm" || event.option === "delete" || event.option === "cancel") {
      if (event.option === "confirm") {
        const undoHistoryEnabled = UI?.undoHistoryEnabled;
        if (!undoHistoryEnabled) {
        // Only add placeholder stroke for load operations, not selection
        const isLoadUpload = UI?.uploader?.uploadType === 'load';
        if (isLoadUpload) {
          addPlaceholderStroke();
          console.log("Added placeholder for load upload");
        } else {
          console.log("Skipping placeholder for selection operation");
        }
        console.log(event);
      }
    }
      if (room && room.myself && room.myself.surface) {

        room.myself.surface.penHide();
        room.myself.surface.penShow();
      }
      try {
        // Try different approaches to restore the previous tool
        
        // Approach 1: Check for changeTool function (most common)
        if (typeof surface.changeTool === 'function') {
          const previousTool = surface.previousTool || "brush";

          surface.changeTool(previousTool);
        }
        // Approach 2: Check for setTool function
        else if (typeof surface.setTool === 'function') {
          const previousTool = surface.previousTool || "brush";

          surface.setTool(previousTool);
        }
        // Approach 3: Try using the toolbar directly
        else if (UI && UI.toolbar && typeof UI.toolbar.selectTool === 'function') {
          const previousTool = surface.previousTool || "brush";

          UI.toolbar.selectTool(previousTool);
        }
        // Approach 4: Just clean up the selection visually
        else {

          if (surface.brushHandler && surface.brushHandler.brush) {
            surface.brushHandler.brush.cancel();
          }
        }
      } catch (err) {

        // Just make sure the selection is cleaned up
        if (surface.brushHandler && surface.brushHandler.brush) {
          surface.brushHandler.brush.cancel();
        }
      }
    }
  });
}

$(document).ready(function() {
  // Global event listener to verify transferComplete events
  $(document).on("transferComplete", function() {

 // This will show the call stack to help debug where the event came from
  });
});

window.clearUndoHistory = function() {
  if (socket) {
    socket.isTransferInProgress = false
  }
  // Check if required objects exist
  if (!UI.bottombar || !room || !room.board) {

    return false;
  }

  room.board.isProcessingCommit = false;
  room.board.commitProgress = { processed: 0, total: 0, active: false };
  room.board._inProgressBoardStrokes = new Set();
  room.board._inProgressSurfaceStrokes = new Set();
  room.board._unmuteSafetyRetries = 0;
  room.board._lastTransferCompleteTime = 0;
  room.board.needToUnblockMessagesWhenComplete = false;

  // Clear Board undo/redo history and stroke data

  room.board.undoStack = [];
  room.board.redoStack = [];
  room.board.strokeCommitQueue = [];
  room.board.undoneStrokes = new Set();
  room.board.currentStrokeId = 1;
  room.board.strokeIdMap = new Map();
  room.board.surfaceStrokeMap = new Map();
  room.board.needToUnmuteWhenComplete = false;
  room.board._imageStrokeTransferMap = {};
  room.board._strokeToTransferMap = {};
  room.board.strokeToTransferMap = new Map();
  room.board.transferToStrokeMap = new Map();

  // If user was muted during commit process, ensure they're unmuted
  if (room.myself && room.myself.muted && !UI.muteSeconds) {
    room.myself.unmute();
  }
  
  // Clear PenSurface stroke data
  if (room.myself && room.myself.surface) {

    room.myself.surface.strokes = [];
    room.myself.surface.currentStrokeData = null;
    room.myself.surface.strokeCount = 0;
    room.myself.surface._pendingStrokes = [];
    room.myself.surface.completedStrokes = [];
    room.myself.surface.textModeKeyEvents = [];
    room.myself.surface.textModeStartTime = null;
    room.myself.surface.textModeStartPoint = null;
    room.myself.surface.pendingTextCaptures = [];
    room.myself.surface.textStrokeNumbers = new Set();
    
    // Send current brush, brush options, color, and layer to network

    
    const currentBrush = room.myself.surface.brushHandler.currentBrush;
    const brushOptions = room.myself.surface.getBrushOptions();
    const currentColor = room.myself.surface.drawColor;
    const currentLayer = room.myself.surface.currentLayer;
    
    if (room.myself.frameBuffer) {
      const frameBuffer = room.myself.frameBuffer;
      const sourceId = `clearHistory-${Date.now()}`;
      
      frameBuffer.authorizeSource(sourceId);
      
      const cmdBrush = frameBuffer.netcode.brushChanged({brush: currentBrush});
      frameBuffer.outBuffer(cmdBrush, sourceId);
      
      if (brushOptions) {
        for (const option in brushOptions) {
          const cmdOption = frameBuffer.netcode.brushOptionChanged({
            option: option,
            value: brushOptions[option]
          });
          frameBuffer.outBuffer(cmdOption, sourceId);
        }
      }
      
      const cmdColor = frameBuffer.netcode.colorChanged({color: currentColor});
      frameBuffer.outBuffer(cmdColor, sourceId);
      
      // Add current layer broadcast
      const cmdLayer = frameBuffer.netcode.layerSelected({layer: currentLayer});
      frameBuffer.outBuffer(cmdLayer, sourceId);
      
      frameBuffer.execFrame();
      frameBuffer.revokeSource(sourceId);
      

    }
  }
  
  // Clear transfer history if it exists
  if (room.board.transferHistory) {

    room.board.transferHistory = [];
  }
  
  // Show confirmation message
  // UI.dialogHandler.showAlert("Step back history has been cleared");
  
  return true;
};

function addPlaceholderStroke() {
  // Get reference to strokes array and board
  const surface = room?.myself?.surface;
  const board = room?.board;
  
  if (surface && Array.isArray(surface.strokes) && board) {
    // Increment surface stroke count
    
    
    // Increment board stroke ID counter and get new ID
    const boardStrokeId = board.currentStrokeId++;
    
    // Create minimal placeholder stroke with stroke number
    const placeholderStroke = {
      type: "placeholder",
      time: Date.now(),
      color: "#000000",
      brush: "placeholder",
      isPlaceholder: true,
      strokeNumber: surface.strokeCount // Add stroke number for reference
    };
    
    // Register the mapping between board stroke ID and surface stroke number
    if (board.registerStrokeMapping) {
      board.registerStrokeMapping(boardStrokeId, surface.strokeCount);
    }
    
    // Add to strokes array
    surface.strokes.push(placeholderStroke);
    
    console.log(`Placeholder stroke added - Board ID: ${boardStrokeId}, Surface ID: ${surface.strokeCount}`);
    return true;
  }
  
  console.warn("Could not add placeholder: surface or strokes array or board not found");
  return false;
}
// Can be called from anywhere like:
// addPlaceholderStroke();

function movePointToTopLeft(boardX, boardY) {
  const pointOnScreen = UI.boardToScreen(boardX, boardY);
  UI.moveBoard(UI.viewLeft - pointOnScreen.x, UI.viewTop - pointOnScreen.y);
}


// Function to check if quick opacity hotkeys are enabled
function isQuickOpacityHotkeysEnabled() {
  return localStorage.getItem('quickOpacityHotkeys') === 'true';
}

// Track keypress history for two-digit opacity (outside function so they persist)
let lastKeyTime = 0;
let lastKeyValue = null;
const KEY_TIMEOUT = 500; // ms to wait for second digit

// Event handler function for keydown events
function handleQuickOpacityHotkeys(event) {
  // Skip if dialog is open or feature disabled
  if (UI.dialogHandler.activeDialog || !isQuickOpacityHotkeysEnabled()) {
    return;
  }
  
  // Skip if current brush is text
  if (room?.myself?.surface?.getCurrentBrush() === 'text') {
    return;
  }
  
  // Check for number keys 0-9
  if (event.key >= '0' && event.key <= '9') {
    const currentTime = Date.now();
    const digit = parseInt(event.key);
    
    // Handle quick sequential keypresses (within timeout)
    if (lastKeyValue !== null && (currentTime - lastKeyTime) < KEY_TIMEOUT) {
      let opacity;
      
      // Special case: if first digit was 0, treat second digit as exact percentage (1-9%)
      if (lastKeyValue === 0) {
        opacity = digit; // 01 -> 1%, 02 -> 2%, etc.
      } else {
        // Regular case: combine digits (e.g., 45 -> 45%)
        opacity = Math.min(lastKeyValue * 10 + digit, 100);
      }
      
      const alpha = opacity / 100;
      console.log(`Setting opacity: ${opacity}%, alpha: ${alpha}`);
      
      if (room?.myself?.surface) {
        room.myself.surface.setBrushOptions({alpha: alpha});
      }
      
      // Reset tracking after using both digits
      lastKeyValue = null;
    } else {
      // Single digit - convert to opacity percentage
      const opacity = digit === 0 ? 100 : digit * 10;
      const alpha = opacity / 100;
      
      console.log(`Setting opacity: ${opacity}%, alpha: ${alpha}`);
      
      if (room?.myself?.surface) {
        room.myself.surface.setBrushOptions({alpha: alpha});
      }
      
      // Track this keypress for potential second digit
      lastKeyValue = digit;
    }
    
    lastKeyTime = currentTime;
    event.preventDefault();
  }
}

function initQuickOpacityHotkeys() {
  // Only attach event listener if enabled
  if (isQuickOpacityHotkeysEnabled()) {
    console.log("Quick Opacity Hotkeys system initialized");
    $(document).on('keydown', handleQuickOpacityHotkeys);
  }
}

// Global toggle function
window.toggleQuickOpacityHotkeys = function(enabled) {
  if (enabled === undefined) {
    enabled = localStorage.getItem('quickOpacityHotkeys') !== 'true';
  }
  
  // Update localStorage
  localStorage.setItem('quickOpacityHotkeys', enabled.toString());
  console.log("Quick opacity hotkeys toggled to:", enabled);
  
  // Remove existing handler if any
  $(document).off('keydown', handleQuickOpacityHotkeys);
  
  // Add handler if enabled
  if (enabled) {
    console.log("Quick Opacity Hotkeys system initialized");
    $(document).on('keydown', handleQuickOpacityHotkeys);
  }
  
  return enabled;
};

// Initialize the system only if enabled
initQuickOpacityHotkeys();

function formatNumberMod(number) {
  // Check if the whole pixels option is enabled
  const useWholePixels = room?.myself?.surface?.getBrushOption("togglewholepixels");
  
  // If whole pixels option is enabled, round up to whole numbers
  if (useWholePixels) {
    return Math.ceil(number);
  }
  
  // Otherwise return the number as-is
  return number;
}

function arePointsClose(point1, point2, threshold = 2) {
  // Adjust threshold based on zoom level
  const zoomLevel = room?.board?.scale || 1;
  const adjustedThreshold = threshold / zoomLevel;
  
  const dx = point1.x - point2.x;
  const dy = point1.y - point2.y;
  return Math.sqrt(dx * dx + dy * dy) < adjustedThreshold;
}

function setupPolygonalSelectionShortcut() {
  // Set up shortcut handler for finalizing polygonal selection
  $(UI.shortcutManager).on("shortcutPressed", function(event) {
    // Check for the finalize polygonal selection shortcut with + prefix
    if (event.id === "+finalizepolygonalselection") {
      // Only proceed if we're in selection tool with polygonal mode active
      const surface = room.myself.surface;
      if (!surface) return;
      
      const isSelectionTool = surface.getCurrentBrush() === "selection";
      const isPolygonalMode = isSelectionTool && 
                             surface.getBrushOption("polygonalselection") && 
                             surface.getBrushOption("selectiontype");
      
      // Only complete the polygon if we have at least 3 points
      if (isPolygonalMode && surface.polygonPoints && surface.polygonPoints.length >= 3) {
        console.log("Finalizing polygonal selection via hotkey");
        
        // Complete the polygon by adding a final penMove to the start point
        const startPoint = surface.polygonPoints[0];
        surface.isAddingPolygonPoint = true;
        surface.penMove(startPoint.x, startPoint.y);
        surface.isAddingPolygonPoint = false;
        
        // Then execute penUp at the original start point
        surface.isClosingPolygon = true;
        surface.penUp(startPoint.x, startPoint.y);
        surface.isClosingPolygon = false;
        
        // Reset polygon points
        surface.polygonPoints = [];
      }
    }
  });
  
  console.log("Polygonal selection shortcut handler initialized");
}

// Complete persistent selection system
(function initPersistentSelectionSystem() {
  if (localStorage.getItem("paintWithinSelection") === "true") {
  // Create global object to store selection state
  window.persistentSelection = {
    active: false,
    bounds: null,
    type: null,
    points: [],
    start: null,
    end: null,
    originalBrush: null,
    renderInterval: null,
    offset: 0,
    selectionCanvas: null,
    selectionCtx: null,
    initialized: false,
    initAttempts: 0
  };
  
  // Attempt initialization periodically until successful
  function attemptInitialization() {
    if (window.persistentSelection.initialized) return true;
    
    // Check if the required objects exist
    if (!room || !room.board || !room.myself || !room.myself.surface) {
      console.log("FlockMod not fully loaded yet, will retry initialization...");
      window.persistentSelection.initAttempts++;
      
      if (window.persistentSelection.initAttempts > 30000) {
        console.error("Failed to initialize after multiple attempts");
        return false;
      }
      
      // Try again in a second
      setTimeout(attemptInitialization, 1000);
      return false;
    }
    
    console.log("Initializing persistent selection system...");
    
    try {
      // Create an AdvancedCanvas for the selection overlay
      const selectionAdvCanvas = new AdvancedCanvas(room.board.canvasWidth, room.board.canvasHeight);
      const selectionCanvas = selectionAdvCanvas.canvas;
      
      // Style the canvas
      selectionCanvas.addClass("selection-overlay");
      selectionCanvas.css({
        position: 'absolute',
        top: '0',
        left: '0',
        pointerEvents: 'none',
        zIndex: '9999'
      });
      
      // Add to the canvas container
      room.board.canvasContainer.append(selectionCanvas);
      
      // Store references
      window.persistentSelection.selectionCanvas = selectionAdvCanvas;
      window.persistentSelection.selectionCtx = selectionAdvCanvas.canvas[0].getContext('2d');
      window.persistentSelection.initialized = true;
      
      // Now that we have the canvas, override the selection brush
      overrideSelectionBrush();
      
      // Set up the clear selection shortcut (Ctrl + ~)
      setupClearSelectionShortcut();
      
      console.log("Persistent selection system initialized successfully!");
      return true;
    } catch (error) {
      console.error("Error initializing selection system:", error);
      
      // Try again in a second
      setTimeout(attemptInitialization, 1000);
      return false;
    }
  }
  
  // Override selection brush to capture selection when switching tools
  function overrideSelectionBrush() {
    const selectionBrush = room.myself.surface.brushHandler.brushes.selection;
    if (!selectionBrush) {
      console.error("Selection brush not found!");
      return false;
    }
    
    // Store reference to original brush
    window.persistentSelection.originalBrush = selectionBrush;
    
    // Save original brushStop method
    const originalBrushStop = selectionBrush.brushStop;
    
    // Override the brushStop method
    selectionBrush.brushStop = function() {
      // Capture the current selection before it's cleared
      if (this.isUsingSlate()) {
        // Get selection information
        const bounds = this.getBounds();
        const type = this.getOption("selectiontype") ? 'polygon' : 'rectangle';
        
        // Store selection data
        window.persistentSelection.active = true;
        window.persistentSelection.bounds = bounds;
        window.persistentSelection.type = type;
        
        if (type === 'polygon') {
          window.persistentSelection.points = this.getClicks();
        } else {
          window.persistentSelection.start = this.start;
          window.persistentSelection.end = this.end;
        }
        
        // Start rendering the selection
        startSelectionRendering();
        
        // Enable clipping automatically - always clip when selection exists
        applyClippingToBrushes(true);
      }
      
      // Call original method partially
      clearInterval(this.tInt);
      this.updateZIndex(false);
      this.clearSlate();
    };
    
    return true;
  }
  
  // Function to start rendering the selection with marching ants
  function startSelectionRendering() {
    // Clear any existing interval
    if (window.persistentSelection.renderInterval) {
      clearInterval(window.persistentSelection.renderInterval);
    }
    
    // Render immediately once
    renderSelection();
    
    // Start interval for marching ants effect
    window.persistentSelection.renderInterval = setInterval(() => {
      window.persistentSelection.offset = (window.persistentSelection.offset + 1) % 24;
      renderSelection();
    }, 50);
  }
  
  // Function to render the selection
  function renderSelection() {
    if (!window.persistentSelection.active) return;
    
    const advCanvas = window.persistentSelection.selectionCanvas;
    const ctx = window.persistentSelection.selectionCtx;
    
    // Double-check we have valid canvas and context
    if (!advCanvas || !ctx) {
      console.error("Invalid canvas or context for selection rendering");
      return;
    }
    
    try {
      const offset = window.persistentSelection.offset;
      
      // Clear previous rendering
      ctx.clearRect(0, 0, advCanvas.width, advCanvas.height);
      
      // Set up drawing style
      ctx.setLineDash([5, 7]);
      ctx.lineDashOffset = -offset;
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#808080';
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      
      // Draw the selection
      ctx.beginPath();
      
      if (window.persistentSelection.type === 'polygon') {
        const points = window.persistentSelection.points;
        if (points && points.length > 0) {
          ctx.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
          }
          ctx.closePath();
        }
      } else {
        const start = window.persistentSelection.start;
        const end = window.persistentSelection.end;
        if (start && end) {
          ctx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
        }
      }
      
      ctx.stroke();
    } catch (err) {
      console.error("Error rendering selection:", err);
    }
  }
  
  // Apply clipping to all relevant brushes
  function applyClippingToBrushes(enable = true) {
    const brushHandler = room.myself.surface.brushHandler;
    
    // List of brushes to apply clipping to
    const brushesToClip = [
      'pen', 'eraser', 'blur', 'blend', 'custom', 'pixel'
    ];
    
    // Apply to each brush
    brushesToClip.forEach(brushName => {
      const brush = brushHandler.brushes[brushName];
      if (!brush) return;
      
      // Store original methods if not already stored
      if (!brush._originalCompositeRegular && brush.compositeRegular) {
        brush._originalCompositeRegular = brush.compositeRegular;
      }
      
      if (!brush._originalCompositeSpacing && brush.compositeSpacing) {
        brush._originalCompositeSpacing = brush.compositeSpacing;
      }
      
      if (!brush._originalCompositeSmooth && brush.compositeSmooth) {
        brush._originalCompositeSmooth = brush.compositeSmooth;
      }
      
      // Override composite methods
      if (brush._originalCompositeRegular) {
        brush.compositeRegular = function() {
          if (!window.persistentSelection.active) {
            return brush._originalCompositeRegular.call(this);
          }
          
          const ctx = room.board.getContext(this.surface.currentLayer);
          ctx.save();
          
          // Create clip path based on selection type
          ctx.beginPath();
          if (window.persistentSelection.type === 'polygon') {
            const points = window.persistentSelection.points;
            if (points && points.length > 0) {
              ctx.moveTo(points[0].x, points[0].y);
              for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
              }
              ctx.closePath();
            }
          } else {
            const start = window.persistentSelection.start;
            const end = window.persistentSelection.end;
            if (start && end) {
              ctx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
            }
          }
          ctx.clip();
          
          const result = brush._originalCompositeRegular.call(this);
          ctx.restore();
          return result;
        };
      }
      
      if (brush._originalCompositeSpacing) {
        brush.compositeSpacing = function() {
          if (!window.persistentSelection.active) {
            return brush._originalCompositeSpacing.call(this);
          }
          
          const ctx = room.board.getContext(this.surface.currentLayer);
          ctx.save();
          
          // Create clip path
          ctx.beginPath();
          if (window.persistentSelection.type === 'polygon') {
            const points = window.persistentSelection.points;
            if (points && points.length > 0) {
              ctx.moveTo(points[0].x, points[0].y);
              for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
              }
              ctx.closePath();
            }
          } else {
            const start = window.persistentSelection.start;
            const end = window.persistentSelection.end;
            if (start && end) {
              ctx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
            }
          }
          ctx.clip();
          
          const result = brush._originalCompositeSpacing.call(this);
          ctx.restore();
          return result;
        };
      }
      
      if (brush._originalCompositeSmooth) {
        brush.compositeSmooth = function() {
          if (!window.persistentSelection.active) {
            return brush._originalCompositeSmooth.call(this);
          }
          
          const ctx = room.board.getContext(this.surface.currentLayer);
          ctx.save();
          
          // Create clip path
          ctx.beginPath();
          if (window.persistentSelection.type === 'polygon') {
            const points = window.persistentSelection.points;
            if (points && points.length > 0) {
              ctx.moveTo(points[0].x, points[0].y);
              for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
              }
              ctx.closePath();
            }
          } else {
            const start = window.persistentSelection.start;
            const end = window.persistentSelection.end;
            if (start && end) {
              ctx.rect(start.x, start.y, end.x - start.x, end.y - start.y);
            }
          }
          ctx.clip();
          
          const result = brush._originalCompositeSmooth.call(this);
          ctx.restore();
          return result;
        };
      }
    });
  }
  
  // Function to clear the selection
  function clearSelection() {
    window.persistentSelection.active = false;
    window.persistentSelection.bounds = null;
    window.persistentSelection.type = null;
    window.persistentSelection.points = [];
    window.persistentSelection.start = null;
    window.persistentSelection.end = null;
    
    // Clear rendering
    if (window.persistentSelection.renderInterval) {
      clearInterval(window.persistentSelection.renderInterval);
      window.persistentSelection.renderInterval = null;
    }
    
    // Clear canvas if it exists
    if (window.persistentSelection.initialized && 
        window.persistentSelection.selectionCtx) {
      try {
        window.persistentSelection.selectionCtx.clearRect(
          0, 0, 
          room.board.canvasWidth,
          room.board.canvasHeight
        );
      } catch (err) {
        console.error("Error clearing selection canvas:", err);
      }
    }
    
    console.log("Selection cleared");
    return true;
  }
  
  // Make clear selection function globally available
  window.clearPersistentSelection = clearSelection;
  
  // Set up global shortcut for clearing selection (Ctrl + ~)
  function setupClearSelectionShortcut() {
    const tildePressHandler = function(e) {
      // Check for Ctrl + ~ (Tilde key)
      if (e.ctrlKey && (e.key === '`' || e.key === '~' || e.keyCode === 192)) {
        e.preventDefault();
        clearSelection();
        
        // Visual feedback
        if (!document.getElementById('selection-cleared-notice')) {
          const notice = document.createElement('div');
          notice.id = 'selection-cleared-notice';
          notice.style.position = 'fixed';
          notice.style.top = '10px';
          notice.style.left = '50%';
          notice.style.transform = 'translateX(-50%)';
          notice.style.padding = '10px 20px';
          notice.style.background = 'rgba(0,0,0,0.7)';
          notice.style.color = 'white';
          notice.style.borderRadius = '5px';
          notice.style.zIndex = '10000';
          notice.style.fontFamily = 'Arial, sans-serif';
          notice.style.fontSize = '14px';
          notice.textContent = 'Selection cleared';
          document.body.appendChild(notice);
          
          // Remove after 1.5 seconds
          setTimeout(() => {
            if (notice.parentNode) {
              notice.parentNode.removeChild(notice);
            }
          }, 1500);
        }
      }
    };
    
    // Add event listener directly to document
    document.addEventListener('keydown', tildePressHandler);
    
    console.log("Selection clear shortcut (Ctrl+~) registered");
  }
  
  // Create a test rectangle selection - useful for debugging
  window.createTestRectangleSelection = function() {
    // Clear any existing selection
    clearSelection();
    
    // Check initialization
    if (!window.persistentSelection.initialized) {
      console.error("Selection system not initialized yet");
      return "Selection system not initialized yet";
    }
    
    // Create a rectangle selection
    window.persistentSelection.active = true;
    window.persistentSelection.type = 'rectangle';
    window.persistentSelection.start = { x: 100, y: 100 };
    window.persistentSelection.end = { x: 300, y: 300 };
    
    // Start rendering
    startSelectionRendering();
    
    // Apply clipping
    applyClippingToBrushes(true);
    
    return "Test rectangle selection created at (100,100) to (300,300)";
  };
  
  // Start initialization process
  attemptInitialization();
  
  console.log("Persistent selection system started. Press Ctrl+~ to clear selection.");
  }
})();

// ============================================================================
// FLOCKMOD ENHANCEMENTS - EXTERNAL PROTOTYPE OVERRIDES
// Features: Chat repositioning fix, non-blocking chat, compact mode
// ============================================================================

(function() {
  'use strict';
  
  // Enable all features by default
  const FEATURES = {
    FIX_RESIZE_BUG: true,
    ALLOW_NON_BLOCKING_CHAT: true,
    COMPACT_CHAT_MODE: true,
    ALLOW_DRAW_SHORTCUTS_WITH_CHAT: true
  };
  
  // Storage key for dialog positions
  const DIALOG_POSITION_STORAGE_KEY = 'FM_DIALOG_POSITIONS';
  const CHAT_COMPACT_MODE_KEY = 'FM_CHAT_COMPACT_MODE';
  
  // Initialize position storage
  function initializePositionStorage() {
    if (!window.fmDialogPositions) {
      window.fmDialogPositions = {};
      try {
        const stored = localStorage.getItem(DIALOG_POSITION_STORAGE_KEY);
        if (stored) {
          window.fmDialogPositions = JSON.parse(stored);
        }
      } catch (e) {
        console.warn('Failed to load dialog positions from storage:', e);
      }
    }
  }
  
  // Save position to storage
  function saveDialogPosition(dialogName, rect) {
    initializePositionStorage();
    if (dialogName) {
      window.fmDialogPositions[dialogName] = {
        x: rect.x || rect.left,
        y: rect.y || rect.top,
        width: rect.width,
        height: rect.height
      };
      try {
        localStorage.setItem(DIALOG_POSITION_STORAGE_KEY, JSON.stringify(window.fmDialogPositions));
      } catch (e) {
        console.warn('Failed to save dialog position to storage:', e);
      }
    }
  }
  
  // Get saved position from storage
  function getSavedDialogPosition(dialogName) {
    initializePositionStorage();
    return window.fmDialogPositions[dialogName] || null;
  }
  
  // ========================================================================
if (FEATURES.FIX_RESIZE_BUG) {
    const chatDialogTracking = {};

    function isChatDialog(dialog) {
      return dialog instanceof ChatDialog || dialog.name === 'chat';
    }

    const originalDialogShow = Dialog.prototype.show;
    Dialog.prototype.show = function() {
      if (isChatDialog(this)) {
        const wasInitializing = this.initializing;

        if (wasInitializing) {
          const result = originalDialogShow.call(this);
          setTimeout(() => {
            const rect = this.form.offset();
            saveDialogPosition(this.name, {
              x: rect.left,
              y: rect.top,
              width: this.form.width(),
              height: this.form.height()
            });
          }, 50);
          return result;
        } else {
          const savedPos = getSavedDialogPosition(this.name);
          if (savedPos && !chatDialogTracking.isRestoringPosition) {
            chatDialogTracking.isRestoringPosition = true;

            this.active = true;
            this.isModal ? this.formHolder.addClass("dialogModal") : this.formHolder.removeClass("dialogModal");
            this.formHolder.fadeIn(200);
            this.form.removeClass("dialogInvisible").addClass("dialogVisible");
            $(this).triggerHandler(new dialogOpenedEvent(this.name).getEvent());
            this.createTitlebar();
            this.disableModal();
            this.previousFocus = UI.getFocusElement();
            UI.setFocusElement(null);
            this.loading(false);
            this.title.find("select[name=\"languagebutton\"]").val(textManager.getLocale());
            this.title.find("select[name=\"languagebutton\"]").toggle(this.languageSelector);
            this.onShow.apply(this, arguments);

            setTimeout(() => {
              this.setPosition(savedPos.x, savedPos.y);
              this.setSize(savedPos.width, savedPos.height);
              chatDialogTracking.isRestoringPosition = false;
            }, 10);

            return;
          }
        }
      }

      return originalDialogShow.call(this);
    };

    const originalOnWindowResize = Dialog.prototype.onWindowResize;
    Dialog.prototype.onWindowResize = function(isStarting) {
      if (isChatDialog(this)) {
        this.windowWidth = $(window).width();
        this.windowHeight = $(window).height();
        return;
      }

      originalOnWindowResize.call(this, isStarting);
    };

    const originalCenter = Dialog.prototype.center;
    Dialog.prototype.center = function() {
      if (isChatDialog(this)) {
        return;
      }
      originalCenter.call(this);
    };

    const originalResizeToFit = Dialog.prototype.resizeToFit;
    Dialog.prototype.resizeToFit = function() {
      if (isChatDialog(this)) {
        return;
      }
      originalResizeToFit.call(this);
    };

    const originalCheckSizeRequirements = Dialog.prototype.checkSizeRequirements;
    Dialog.prototype.checkSizeRequirements = function() {
      if (isChatDialog(this)) {
        return true;
      }
      return originalCheckSizeRequirements.call(this);
    };

    const originalOutOfBounds = Dialog.prototype.outOfBounds;
    Dialog.prototype.outOfBounds = function() {
      if (isChatDialog(this)) {
        return false;
      }
      return originalOutOfBounds.call(this);
    };

    const originalSetPosition = Dialog.prototype.setPosition;
    Dialog.prototype.setPosition = function(x, y) {
      originalSetPosition.call(this, x, y);
      if (isChatDialog(this) && !chatDialogTracking.isRestoringPosition) {
        const rect = this.form.offset();
        saveDialogPosition(this.name, {
          x: rect.left,
          y: rect.top,
          width: this.form.width(),
          height: this.form.height()
        });
      }
    };

    const originalSetSize = Dialog.prototype.setSize;
    Dialog.prototype.setSize = function(width, height) {
      originalSetSize.call(this, width, height);
      if (isChatDialog(this) && !chatDialogTracking.isRestoringPosition) {
        const rect = this.form.offset();
        saveDialogPosition(this.name, {
          x: rect.left,
          y: rect.top,
          width: width,
          height: height
        });
      }
    };
  }

  if (FEATURES.ALLOW_NON_BLOCKING_CHAT) {
    const originalChatShow = Dialog.prototype.show;
    ChatDialog.prototype.show = function() {
      this.isModal = false;
      this.blockBackground = false;

      originalChatShow.call(this);

      this.formHolder.removeClass('dialogModal');

      this.formHolder.css({
        'position': 'fixed',
        'background': 'transparent',
        'pointer-events': 'none',
        'z-index': '10000'
      });

      this.form.css({
        'pointer-events': 'auto'
      });

      this.content.css({
        'pointer-events': 'auto'
      });

      this.form.find('.dialogTitlebar, .dialogSize, input, button, .chatBox, .chatBar, .sidebarElements').css({
        'pointer-events': 'auto'
      });
    };
  }

  if (FEATURES.ALLOW_DRAW_SHORTCUTS_WITH_CHAT) {
    const originalOnKeyDown = UserInterface.prototype.onKeyDown;
    const originalOnKeyPressed = UserInterface.prototype.onKeyPressed;
    const originalWheelDefault = UserInterface.prototype.onWheelMoveDefault;
    const originalWheelFaster = UserInterface.prototype.onWheelMoveFaster;
    const originalWheelCap = UserInterface.prototype.onWheelMoveCap;

    const isChatDialogInstance = (dialog) => dialog && (dialog instanceof ChatDialog || dialog.name === 'chat');
    const isChatInputFocused = (chatDialog) => {
      const active = document.activeElement;
      if (!active || !chatDialog || !chatDialog.form) return false;
      return chatDialog.form.find('input, textarea, [contenteditable="true"]').filter((_, el) => el === active).length > 0;
    };

    const withChatBypass = (fn) => function() {
      const dh = UI && UI.dialogHandler;
      const activeDialog = dh && dh.activeDialog;
      const chatOpen = isChatDialogInstance(activeDialog);
      const chatInputFocused = chatOpen && isChatInputFocused(activeDialog);

      if (chatOpen && !chatInputFocused && dh && dh.openedDialogs > 0) {
        const prevOpened = dh.openedDialogs;
        const prevActive = dh.activeDialog;
        const prevActiveFlag = dh.active;
        dh.openedDialogs = 0;
        dh.activeDialog = null;
        dh.active = false;
        try {
          return fn.apply(this, arguments);
        } finally {
          dh.openedDialogs = prevOpened;
          dh.activeDialog = prevActive;
          dh.active = prevActiveFlag;
        }
      }

      return fn.apply(this, arguments);
    };

    UserInterface.prototype.onKeyDown = withChatBypass(originalOnKeyDown);
    UserInterface.prototype.onKeyPressed = withChatBypass(originalOnKeyPressed);
    if (originalWheelDefault) UserInterface.prototype.onWheelMoveDefault = withChatBypass(originalWheelDefault);
    if (originalWheelFaster) UserInterface.prototype.onWheelMoveFaster = withChatBypass(originalWheelFaster);
    if (originalWheelCap) UserInterface.prototype.onWheelMoveCap = withChatBypass(originalWheelCap);
  }
  
})();


let customSoundBase64 = `data:audio/mpeg;base64,SUQzAwAAAABHS1RZRVIAAAAGAAAAMjAyNQBUREFUAAAABgAAADA0MDIAVElNRQAAAAYAAAAwOTEz
AFBSSVYAABuRAABYTVAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6
TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0i
QWRvYmUgWE1QIENvcmUgNi4wLWMwMDIgNzkuMTY0MzYwLCAyMDIwLzAyLzEzLTAxOjA3OjIyICAg
ICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIy
LXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1s
bnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICB4bWxuczpzdEV2
dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAg
eG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJl
ZiMiCiAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICB4bWxu
czp4bXBETT0iaHR0cDovL25zLmFkb2JlLmNvbS94bXAvMS4wL0R5bmFtaWNNZWRpYS8iCiAgICB4
bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOmNyZWF0
b3JBdG9tPSJodHRwOi8vbnMuYWRvYmUuY29tL2NyZWF0b3JBdG9tLzEuMC8iCiAgICB4bWxuczpk
Yz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtcE1NOkluc3RhbmNlSUQ9
InhtcC5paWQ6NGM4YWQ1YzQtYTk1ZC04NTQ1LTgxYzItNTJjNGQ2ZTI3YmZiIgogICB4bXBNTTpE
b2N1bWVudElEPSI0YTNkZTg1Yi1mODEwLThkNTMtM2IyYy00ZGMyMDAwMDAwNTUiCiAgIHhtcE1N
Ok9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo5NmZjYmQ2MC0zMDc4LWM5NDgtODIyNi1hMzZk
NzAzNjBiY2QiCiAgIHhtcDpNZXRhZGF0YURhdGU9IjIwMjUtMDItMDRUMDk6MTQ6MDMtMDU6MDAi
CiAgIHhtcDpNb2RpZnlEYXRlPSIyMDI1LTAyLTA0VDA5OjE0OjAzLTA1OjAwIgogICB4bXA6Q3Jl
YXRvclRvb2w9IkFkb2JlIFByZW1pZXJlIFBybyAyMDIwLjAgKFdpbmRvd3MpIgogICB4bXA6Q3Jl
YXRlRGF0ZT0iMjAyNS0wMi0wNFQwOToxMzozMi0wNTowMCIKICAgeG1wRE06YXVkaW9TYW1wbGVS
YXRlPSItMSIKICAgeG1wRE06YXVkaW9TYW1wbGVUeXBlPSIxNkludCIKICAgeG1wRE06YXVkaW9D
aGFubmVsVHlwZT0iU3RlcmVvIgogICB4bXBETTpzdGFydFRpbWVTY2FsZT0iMzAwMDAiCiAgIHht
cERNOnN0YXJ0VGltZVNhbXBsZVNpemU9IjEwMDEiCiAgIGRjOmZvcm1hdD0iTVAzIj4KICAgPHht
cE1NOkhpc3Rvcnk+CiAgICA8cmRmOlNlcT4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlv
bj0ic2F2ZWQiCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9IjZiMDBiZTVhLTkxM2MtNWE1NC01ZWMw
LTFkMWQwMDAwMDA4MiIKICAgICAgc3RFdnQ6d2hlbj0iMjAyNS0wMi0wNFQwOToxNDowMy0wNTow
MCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUHJlbWllcmUgUHJvIDIwMjAuMCAo
V2luZG93cykiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4KICAgICA8cmRmOmxpCiAgICAgIHN0
RXZ0OmFjdGlvbj0iY3JlYXRlZCIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDphNGVm
MDc3Ny0wZDZhLWYzNDEtOGMwOS1jNTEyODYwY2NmMTkiCiAgICAgIHN0RXZ0OndoZW49IjIwMjUt
MDItMDRUMDk6MTQ6MDItMDU6MDAiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBy
ZW1pZXJlIFBybyAyMDIwLjAgKFdpbmRvd3MpIi8+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDph
Y3Rpb249InNhdmVkIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjYwMDRhNGFiLTM0
ZTktODE0Ni05M2UyLWYyNjkxNDljMTRhYyIKICAgICAgc3RFdnQ6d2hlbj0iMjAyNS0wMi0wNFQw
OToxNDowMy0wNTowMCIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUHJlbWllcmUg
UHJvIDIwMjAuMCAoV2luZG93cykiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4KICAgICA8cmRm
OmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9Inht
cC5paWQ6NGM4YWQ1YzQtYTk1ZC04NTQ1LTgxYzItNTJjNGQ2ZTI3YmZiIgogICAgICBzdEV2dDp3
aGVuPSIyMDI1LTAyLTA0VDA5OjE0OjAzLTA1OjAwIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50
PSJBZG9iZSBQcmVtaWVyZSBQcm8gMjAyMC4wIChXaW5kb3dzKSIKICAgICAgc3RFdnQ6Y2hhbmdl
ZD0iL21ldGFkYXRhIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICAgPHht
cE1NOkluZ3JlZGllbnRzPgogICAgPHJkZjpCYWc+CiAgICAgPHJkZjpsaQogICAgICBzdFJlZjpp
bnN0YW5jZUlEPSJkOWEzODg5Yy0yNDdkLTM1ODEtODJjMy0zMjJkMDAwMDAwOTQiCiAgICAgIHN0
UmVmOmRvY3VtZW50SUQ9ImFlNDk1YmFkLTQ2NDEtNjg0Mi1iM2VmLTJlMmYwMDAwMDA2NyIKICAg
ICAgc3RSZWY6ZnJvbVBhcnQ9InRpbWU6Mjc4MTQ0NzM4NTI0OGYyNTQwMTYwMDAwMDBkMzAwNTgy
NTk0MTQ0ZjI1NDAxNjAwMDAwMCIKICAgICAgc3RSZWY6dG9QYXJ0PSJ0aW1lOjBkMzAwNTgyNTk0
MTQ0ZjI1NDAxNjAwMDAwMCIKICAgICAgc3RSZWY6ZmlsZVBhdGg9InVua25vd25fMjAyNS4wMi4w
NC0wOS4wOF8xLm1wNCIKICAgICAgc3RSZWY6bWFza01hcmtlcnM9Ik5vbmUiLz4KICAgICA8cmRm
OmxpCiAgICAgIHN0UmVmOmluc3RhbmNlSUQ9ImQ5YTM4ODljLTI0N2QtMzU4MS04MmMzLTMyMmQw
MDAwMDA5NCIKICAgICAgc3RSZWY6ZG9jdW1lbnRJRD0iYWU0OTViYWQtNDY0MS02ODQyLWIzZWYt
MmUyZjAwMDAwMDY3IgogICAgICBzdFJlZjpmcm9tUGFydD0idGltZToyNzgxNDQ3Mzg1MjQ4ZjI1
NDAxNjAwMDAwMGQzMDA1ODI1OTQxNDRmMjU0MDE2MDAwMDAwIgogICAgICBzdFJlZjp0b1BhcnQ9
InRpbWU6MGQzMDA1ODI1OTQxNDRmMjU0MDE2MDAwMDAwIgogICAgICBzdFJlZjpmaWxlUGF0aD0i
dW5rbm93bl8yMDI1LjAyLjA0LTA5LjA4XzEubXA0IgogICAgICBzdFJlZjptYXNrTWFya2Vycz0i
Tm9uZSIvPgogICAgPC9yZGY6QmFnPgogICA8L3htcE1NOkluZ3JlZGllbnRzPgogICA8eG1wTU06
UGFudHJ5PgogICAgPHJkZjpCYWc+CiAgICAgPHJkZjpsaT4KICAgICAgPHJkZjpEZXNjcmlwdGlv
bgogICAgICAgeG1wOkNyZWF0ZURhdGU9IjE5MDQtMDEtMDFUMDA6MDBaIgogICAgICAgeG1wOk1v
ZGlmeURhdGU9IjIwMjUtMDItMDRUMDk6MTE6MjgtMDU6MDAiCiAgICAgICB4bXA6TWV0YWRhdGFE
YXRlPSIyMDI1LTAyLTA0VDA5OjExOjI4LTA1OjAwIgogICAgICAgdGlmZjpPcmllbnRhdGlvbj0i
MSIKICAgICAgIHhtcE1NOkluc3RhbmNlSUQ9ImQ5YTM4ODljLTI0N2QtMzU4MS04MmMzLTMyMmQw
MDAwMDA5NCIKICAgICAgIHhtcE1NOkRvY3VtZW50SUQ9ImFlNDk1YmFkLTQ2NDEtNjg0Mi1iM2Vm
LTJlMmYwMDAwMDA2NyIKICAgICAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpj
M2FiY2JkNC03NGRlLTlkNDItOTQzOC01YzdhYTg3YmFjMWYiPgogICAgICA8eG1wRE06ZHVyYXRp
b24KICAgICAgIHhtcERNOnZhbHVlPSIxNDU0NSIKICAgICAgIHhtcERNOnNjYWxlPSIxLzEwMDAi
Lz4KICAgICAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICA8cmRmOlNlcT4KICAgICAgICA8cmRmOmxp
CiAgICAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9
ImQ5YTM4ODljLTI0N2QtMzU4MS04MmMzLTMyMmQwMDAwMDA5NCIKICAgICAgICAgc3RFdnQ6d2hl
bj0iMjAyNS0wMi0wNFQwOToxMToyOC0wNTowMCIKICAgICAgICAgc3RFdnQ6c29mdHdhcmVBZ2Vu
dD0iQWRvYmUgUHJlbWllcmUgUHJvIDIwMjAuMCAoV2luZG93cykiCiAgICAgICAgIHN0RXZ0OmNo
YW5nZWQ9Ii8iLz4KICAgICAgIDwvcmRmOlNlcT4KICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAg
ICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgICA8L3JkZjpsaT4KICAgIDwvcmRmOkJhZz4KICAgPC94
bXBNTTpQYW50cnk+CiAgIDx4bXBNTTpEZXJpdmVkRnJvbQogICAgc3RSZWY6aW5zdGFuY2VJRD0i
eG1wLmlpZDphNGVmMDc3Ny0wZDZhLWYzNDEtOGMwOS1jNTEyODYwY2NmMTkiCiAgICBzdFJlZjpk
b2N1bWVudElEPSJ4bXAuZGlkOmE0ZWYwNzc3LTBkNmEtZjM0MS04YzA5LWM1MTI4NjBjY2YxOSIK
ICAgIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphNGVmMDc3Ny0wZDZhLWYzNDEt
OGMwOS1jNTEyODYwY2NmMTkiLz4KICAgPGNyZWF0b3JBdG9tOndpbmRvd3NBdG9tCiAgICBjcmVh
dG9yQXRvbTpleHRlbnNpb249Ii5wcnByb2oiCiAgICBjcmVhdG9yQXRvbTppbnZvY2F0aW9uRmxh
Z3M9Ii9MIgogICAgY3JlYXRvckF0b206dW5jUHJvamVjdFBhdGg9IlxcP1xDOlxVc2Vyc1xSb21h
XERvY3VtZW50c1xBZG9iZVxQcmVtaWVyZSBQcm9cMTQuMFxTcG90dGVkIFNGWCBXb3JsZCBPZiBU
YW5rcy5wcnByb2oiLz4KICAgPGNyZWF0b3JBdG9tOm1hY0F0b20KICAgIGNyZWF0b3JBdG9tOmFw
cGxpY2F0aW9uQ29kZT0iMTM0NzQ0OTQ1NSIKICAgIGNyZWF0b3JBdG9tOmludm9jYXRpb25BcHBs
ZUV2ZW50PSIxMTI5NDY4MDE4Ii8+CiAgIDx4bXBETTpwcm9qZWN0UmVmCiAgICB4bXBETTp0eXBl
PSJtb3ZpZSIvPgogICA8eG1wRE06ZHVyYXRpb24KICAgIHhtcERNOnZhbHVlPSIzNSIKICAgIHht
cERNOnNjYWxlPSIxMDAxLzMwMDAwIi8+CiAgIDx4bXBETTpzdGFydFRpbWVjb2RlCiAgICB4bXBE
TTp0aW1lRm9ybWF0PSIyOTk3RHJvcFRpbWVjb2RlIgogICAgeG1wRE06dGltZVZhbHVlPSIwMDsw
MDswMDswMCIvPgogICA8eG1wRE06YWx0VGltZWNvZGUKICAgIHhtcERNOnRpbWVWYWx1ZT0iMDA7
MDA7MDA7MDAiCiAgICB4bXBETTp0aW1lRm9ybWF0PSIyOTk3RHJvcFRpbWVjb2RlIi8+CiAgPC9y
ZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAog
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4A
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/++RA
AAAP/ABLgAAACZyACXAAAAEAAAEuAAAAIAAAJcAAAAT/////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////++RAAAAP/ABLgAAA
CY0ACXAAAAEBLAEagAAAIBcAY1AAAAT/////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////////////////////////RJQBQCTNIA6TQIBABA/0j/++RAAAAK+EFF47p64LZoKLx3L1wY
ZYM7TXGN8wyuZ3WeMbZuWNJJ/1KBi+CRj0JhiCQ4GKMwlJczpOkxTZQ7myw3CLYRBoYLimYlhmZk
WgnMiJfAEhV5JuOSKiTYwxaenCv5Xqr1xJcNDSIaXDbfLFMaJSVeYvuq9LdTlTtX58iAFUEEKgAM
Harx61IpEWulKplKplCokshCIOBzQhXpxjXbYp10wqZYRCyyu3FVzKOIr2Bsb4C7XnsKLGjRZ5n9
I+rw8S4riW1ZratWPS9KXgZFQZBoyZcK6q13oMwGtSqaEZf/////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////////////////////////////9uWNJJ/1KBiOAxiwGBhiNJiOCJhWPJmOa5iyuh1hdBs0VA
XCYwREsxHC80xy65lh0BcNoywEMio529j4atLQl+qfY8rxv1iOG+7rLCmWKna8yN6/002LtHXue4
6DMDkKAAeIlDy5qRcKduXLc2qZWqpaUCkOCdUM6sb2OAp2p63OCkWWV3Fc5meIr2CRjkb16LCi2n
izzR6R9Xh4viuM2rq2t1j6vSl4GQqKg0ZMmQH22dzq+6QRylf8aSRJWbMGZMifZU4FaHBjqcQMBk
6A58H6cZdTDmXMtTlZ6ZAGCw09cqVZx/4ugUYWCgsDTGS+CMibzrJyheESdU5eV0JDEIOuQ/asdm
l6y+5Ywr28udzz/QPGNTxDxxYO8d0EqCAXKiQI65RDccyevLfSYAg6ZhwMH7CQo5tUOBYSX+Thlf
sFCWJZmv8kGDjC+Bxw4r8581JZPeJANBEEc/w4clt/73Yif279Pu+vmWFjk4sc3+ys39hzV95278
/oiJCUbcaaRJUWWAZ86T/InmHUffaoIUaoJfqCIs8wkAkfkDmgqAt1MdC5fVvVS7OQ3PocDCQOJg
KYsVQCtJuGcnDFUTIhvnVrUtSd1L7XOzS/beSyU5+05i87SFsHigoLDLCxxXBUtDgJCEysXxna+h
XP6RywsOL+BQPKRrIfcQhAJhw2vfSRHb5weGZLMzNWVBALGH9toshX5SW9Xr2CQJAiCOfvwLJbuv
cpSEzv80lt/DxxhYs/FlTM/n9vfGOLn7/0D/++RAAAAMZWBS+zljaKnsCl9nLG0XRYFJ7GHtgq0w
KTT8MbKYMCRVVFJm2tuxYFKFfQa1yCxstX9PYkkzZilW/OVqKcSalt/n9vS21rPF92AncUlrTXsu
b7zLD6fe3/tXzwzO1zUOLGufZBoDQ0GJkTQrdKw0iMdjMiBGvEAvKDAzJiR+pEIBYeLKwZBykOvR
FeFW+VS28XWsNbISyq15WfnytDXr2IInNi8/OGlHHK54+Wew+fPXrqctp2IGcx1+7jFMtSzbeXR6
29NOnrMc5P2923//////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
///9OgkiqqKTdtbdAaw0BMGeFqDdxvNt6f49Mzsmxr2LWM4kFFc+fuzZy1ni6bIToGUNpr3f/vKb
Dcv3m1+1cOH200ENlEEb/joJBYIheJpP06IJOXn5oFasSOWpF54hfCalJF6hwoklYm1Qd7R9DfO2
2mj1kpOQqGF686elmhxaq5ln5PLOrjk+yNi7T7yuM9jWr4bQOy1Fe8U0tfpbX0uj3Xpp05bbsV+3
xWliEjRERQJtt/4BajDzGYiz4ZOaSQXNslfKNYV6TGW0koroJeTlu3Zj9Pzf/Zf0/qVi5/85j/aS
h38/EO1WJPNz5vrAVarW2VRqJftd4xqpMr2nBrhVROXJSSsjIoTjbneYjE4oicfKmVLx1KxMqewi
YDau0lHZYCThKyqEoSy4WXlo0F43OWnqkZG5fgsDCzp97ir2M1xKOL+VxtKx6huUa9qala7sL1hv
nbzNbP4tauvGiz6lvFnaP12oFJJIBNtuR+PF4IuYYwgQ4AuTvGaVsLcOtuTVJRstznLM88bf7/fz
MVPaFYse//Mf3SVc+S+Iaqnx8mPl8VCWvP0SMtIcZ+7cfk5e44SsQifsnF0Cq0P2H/YTLSkjAqZK
ViiNM6XqCnEMrkKFTg9wHlTVlzOQnJ5xi+3QljCe6xbkLrSI5VM9HEdvlh66+rNjNuOkltt9DWnN
9uYay0fqFtUDY++YbuvFD9b/++RAAAAL0mBTezl7aK+sCl9nL2wVyYFL7OGNow4wKb2MvbSJUSNV
VFButlukrKo4phOuOtEJMkFiHKXl7+Xe4Y6SW19b6feXM9fQMbMKtVk7lrLHe7NBKtU81AdDdgV7
bHrFTMWrlB3VuhNzk2N7E05cILBRxtHaWO2tPtNjm3yMDOPieSLHzR85WjOU0rHas0KNZW6c6Xi1
ap7M9HGCs5n9swISne6ixK1lYZo165xCw24g3kzCvnOLwsvaYvnVomoMlPjGfjPsx/q/////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////eFAjRFNSbtt/3paU3Z8IFYm7omI9tR9K9
ikz5Qz9JO1k3st1vp6G/Lc9fEF9mJ6oRe7rLHe7Nya5L7kB26tIuZX81UnBvDb53rdCanJWN8Jaf
sj1kYGViZ0uxvsvW6ki3DkYGcfHo6c3UD73HUTjFY4V9RmaitkZ1mO6lUltw6MsdZzH1Ha2zt8GM
9dSxZ4NNx4ntJpSyPdwNtz/cuKwsvaT/OLUrBkp8YvLCz7P/1VaiRqzIwN11t65mbMoU3dBpZVGO
ANmkQc6RzWUrrU8SynplN/trdNTZybL/+NrpMeFc6x/n49hnOrLbEFuNf0eD/EkbgZSqEMlKVqgt
lp+6AlW3P1LpmYP3Mk1jmFXZxPAfDikOgFARPLsoLY9XhHr7IR86tcOeJzKRKpeuiXK2XmFyqqvn
72OoSqp9u1nMOTVYq/oIoOTLn7OWXM9ZbEd8qddv9f+2R930x2u8P02ombMysXdtduw5py3Xbep4
ywY3Bhykc6T4ZzOqeaqW9ioPZ7KmlXZBb/uEXU1BvSXs1Z+r2ltRHdWK4QHD1/2RC3sCG8VqliLt
XOKlVCFmU15K1fe1Q9WKk42BbhQnkJ7DdtzYuWpVHKpG5Di2qCM2pt+d0d+SpycoEbD1kL6oTqqi
Hqy5NqhZltWuTUxKu6Xq50qilKYKpjP3yueUP1AsiWly3OLZRehM9nTctPaRoOmOrkrWV/W/3PZy
pEc8Wi+HpVD/++RAAAALRV7S+xhjaq2L2l9jDG1ZNYFLrWXtsvCvKXWsPbfKYRNWZWTn2u3XMy1f
TBW6SYqyCP9+B5FDtu3PZffpLRbR7pRlct0FffN4uym4bCyHdq9r+/dwu/vBqGF9uq3z5UWZaouF
B5A9AulOvNThOgwHTr7p4lQYlfp4SwNZucHjLKE4hOUMz08fPzhvTx9lpQ8U2YhOsXUjadgyhUmj
RYMmqLIbYsOKQUfe1W3H/XvayHZDbjjXuRPuWfrLnMxzRu/bBSGrFdjTf///////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
///////+64kjMysXdtbuxJkK+IYYc/g6gXvA11+4tKbde/ljf+XA4EDRi1NV8r93m8YBZ4S3XVLb
WP7rdr4ynmOLFKkuXwmNTJ9TkHF4UHC5U09hVMyaVCufWEpE+6ULDPveK61wH47EgzbSQnUCQSz1
w/fPEtDV2tkBeVTFYdIRi1VOaH01UQKV1rQM88YMQLq88+2lenn+yM5/W/Pi65WNQ89eJAcZerVm
7uwMVZSVmOFYynJHCnG03IPbItOAV9IEF1j65ccGrFZlW7FcKCSS75aEDPL+Ea+tPzuX1oCcAfCD
AIt/abn7qbs8ll0v3ayfTI07U1HdMizZgMM4DyP1o0c6gjpZILbLFcy9F+WXCsRX4Vqcexla1vns
A+EIZ4ezmQpUtlmddRmV6qkSpYBCkOkTz5OI4oTlmjIktpebvIKbQ92yHazp1WHAwRFy8WnNjVat
cDwjvFY1OM867ZXtFaqVQrnbkzXfHVHeo1XXgwVvEW718zYgNk7u1lOSOEuNptxdniDbOWlJSICw
8Up+Op0vpI7MR7clV+tSA5z5ZYZX927H87KHYViSwtd/L/+znjlqujnfuKphTSnVD955sMBzoQlk
S6uu2SG5KRbcPYridKmLuLDeRUUvsz27NH7YqJ7xjSVSpYrK9MOlbVXNqdgC3KI0U8ujeJ0d7DaM
iTpiM8FyZ1G+VClV6G0WGWTLg5wbqpWsCgc9skjUxM0dDU6xQ2WI+cp42NRvXUbeYN9anzaNuy7/
++RAAAAKhV1RaxnDbrxLah1jGG3X9YFFrOHtsz0wKLWcPbaxhKSNpKNpJ5s8Q0NhHbZmK3GVIot0
KAKgjbZS4cblTgM7WsyAyH3Lv2OYV8tdrV1US6VcDkvJfxt8yvaxy1qOqUc1ampBLZbOzU/UvTIw
V/YZfWfll/GC4i5VPOzObJpXDUNT81yK9tUVLK7GUPZUNL2ct18p75ulh2pYjMO0s9S0tFcjtmxa
prF2RVLOMtxrTtNhU1R16DLLLK1TT0Sp8JjG/z7NrVL3lfWG8ss7vN47u6synH86uPO1um3Sf///
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////9bBMkTJUbSTmVsOIXQgFOcZ+CFKwvAp5zH/U7
Llv3DzcF3r+YAAGyvvOWbvcfy+nSGUqEm0GP57/mt97cjqlH6l0xJpbSw5JHngCg4MJisdjr5yC1
XeuIvtKbEttLWob8FW5VMPLK7UJnI3Zlkixtztqcl+6k9GJmzS2bktltLalMpxjURs2L8PVaGfqW
Zyd5NSbL7HZPXmsPzrW8u1p/Cpy3Y1Q37NXOp3VjGtlnjzu+Y95S49zxqsrgk7VbJTjdSccaTag0
pymsmACZBIETOZESBcJoa7VctrYUGT6XtQM6QTJ1K6pp6RuvZmrWreRCMFiC/BacZitnHKarb1Wl
1uBQ4tztGSrAuTzUzpy62wq0+mRndubDmPdOt8yaUYxFQ4G70KU7RU6znLBDJYrjaKN42w46vblS
un57luNtCmY4IaiVN2KJVUM8Ojxl8O1tvoEj+fN94+9R5qyVhY3ExaRk876BPaTT28OJJD3D3qDv
V8WtPrHzvFMalmrZKcbhTjjabQGZNKZCWhMo0EDnUuLAu0t9nLBXVsKmV8v6acpHoKgYlWnpqjxr
Yc7k8a1jXAas/M7Z/tNW3MXJ6/AoYGm0rTIgNSdJufx4Qsl7cV2WBOJZyZ1DRzQ9FmWwlsS4mj1E
COsy6LufijQs3xNFGXxsGIG2LA35il3XR2rynN8fRJktHOg3TWJapU8XxWGQStTvDQQlLrtiYkmX
JSK1VptTwo8bLn7uoNokmNzb8KB7PmSeNTsse9ZIe8u4tbavJazt5q/3AiY03xD/++RAAAAJ4lhR
6zhLbseMCi1jD22YWYE5jGXts1SwJ/WcPbbNEqSSlONpJsqhEgV6w5eIhRAZ6u9s3gFrzWlqOTL3
qgllCq4gVSyynnYpLMssO6lqmBiiyyX4485+57WOvuJZX7yEERE0dQMLmAciXEwNkAPS0WgMIz6x
Es0gRNClYeMNybYTYIlUK4NNDCR9QlULylRpk2SSSUGYPRL0Y6aKViSa02VFNVkxbkkbEyCUcTaZ
3bis/nZXJ3T1iUqYnvTGBLxIOFHjP///////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
8kEpG4C42kmrc0ylaaxJSlAsXug+7zU4JWGdZoLTaVu0Mww3dNCW2dzsUhzVN/dVY4bmvbnvH8e7
frGcvYaSikfC+jhJ8rizVkBTrBVPbliNdJEyhNI8ZiiZVpqLk+VjCm25Kq5HMKnkV6oPl5HVKtPU
1jmPQ/lU8ULgf6mZ7tLiY6MkbjkLq5zxkXCcMMaqXSfMSK+aZmSBhhfMkGqmT7I3n45PaSvnHcsO
Vun6Rbo8J5aW7JC3CcH94bexRcaxd5mt7Wj2hOqSCU0o30rWlbI+oZIlNBWoBIzRaKJLUVLX0c50
10rodmQJOl9WC2b0a+zN26lXBQIw0jH4KEUrozNTNaOzcJntV4ow8v5A0Ts3Viq5WJpLGayNAZiF
SwUNL4W1nu+ZkNnWD+T8zGZZ4OZ5mg0x2+EoWg9WxHl8lYKMK8zsM00dwWGaSROucCVmyqG+rEjM
s0ZxWorxlc6R5ZoMOzVGjqaLl3RenhRIvmbr4ev9xnuJPDnivHu55L4mr9wa41msLes30/rRJccg
TjaSfWsXUjHUQwIZTPcU4vLhg6BHIb9d8mWJQy1ZYJ+ra/9Wg7HJTH9bwgKqc6F6GnWbmNaO5yGV
5VrD7pgUe3xflYrCuViANcYKEJoFAQpzSKdIIENZoK4SxknMeBfj3RKLH+REIZ5KC5UMO5ol4MFs
QQti7XUZcrx5nrVoYz6OlPHM8LrOsOkc1mKp3BPF4jHM5q08mR4hK7yr3s14M7UtsZ7KllR8RcWU
yw6zFbtuChnnVzjEfPGNpVsRO4YrR7Oqtz9le6i5iN26Zu6Y/1D/++RAAAAJr19P6zh7bsCsCg1j
L22ZUYE/rGHts2qwJ7WMPbatAuSSlSNpJwlW55Eg4fUk8oDke1mjDKjMn0gaGmgS9pLYXdNilrWp
mJxaPu5T5aqrTSrOewg0I+ks1Pv0dPPtigWVJK1ZGf5bVIdqyh6JQK7ViuD+IhXKJWMmC3qxFTGe
tVJfDgJI/Y9iDrURMOJsOk5MtQC3uUyEocqEG2bcj2kbGQ82FRwWZqT+1BS79TzOd4Ccdbbsx60i
QrqKDCq9cFeu4kOqqrSHqHjU/7+2YT1ggU92rFo1YGV6W+Z8UrJmd7op////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////mwpJJUpG0k3VR6cliaP6
z2gi+EDVwK7WI05fkjYE9jvxFpaxTMIUutzdmNRmHovnqUorlszM7Hh3k5YxuZdv4y2ALsELZtwt
nQ1WKVOrllQnKcciREkZnJlVGznVh3SLlbYy/wJoTC5zl/Z1QulQmKKzCbqm2SRYfMp1sUaOf2as
E+GeZ91fAdUVbHWLGnkbnHFmaG9qyMFVdBiSxXjO/ma6OVLw4rbS0LeY/tGiYpArt9jMasDcbefG
pjwM7g076NBOSSpyNpJ11oQ4tmVjkSpQ2PEiM8cpNdtUFUI2VR962dqGz5leq+WxmHG0g6WwJldo
CZBjKF9FkUAMXkFemp5mIu/1326RESlbgNCUuzISvHizKqO2MIUNDHOVWM5yHqnbnzM3G5DJKxIc
jT0SCc7EoEUiaTrpoaBSW5LO21+kzeYKquG4tK29ZIa0zp1XMUBsjNkaqtZIqmgx5pTt2wvIrhiN
dyi3Zom+9it81UrFz6s27stbXkzt9Iy73pjzAgao2V3PE1nwtq2MgtyShONpJwWyCClV5WrOVYCJ
8XpFXJ1va5rbuvHYi77g1AUOLOp61GsMViTyd/ByVMzbQWGymL2OZS+hjr7yKH4IhlOqVwW0DHdj
pP4mqFJtVYRYONMHW2IY+JYVJw2M1gRByKw1TYLkRBGCYF0VK0jGo3XysOg8ECB9RBlTn+iTPH0i
G0sZ1l8L2c7o4GEin5owHG7EqjAc3FCVY6RSGw3ilO9XvTQWVRqIwrUWGhzI30b4qreQVhZf1Vqu
eP1a1wo7zFfCVO2KZja8Nm4C4ixnNwg+zdtCf1j/++RAAAAKWlhRYxp7brosCh9jD20Z9YFJ7WXt
oxqwKT2svbTMgpxt1dSzB2YCpRkTR3uBFC+aB6w661ro3J0p1qYF02GNKXypsYwQjRP85uku37sv
lAVIGkZHGZmwAMtl9etNUnamqft2V0lntZFROn4CrV+md0Pc07Qbw4fmkUDQr3NTquWkS9okRsrC
jv3Nrfra2LmoyEI2O5Nj+YnighRToUKfbFTBkjxnsO1oGdvMbb6QPH07jYtEea3mmrv84xA06p48
OJa16Y+MarbV81j0jzh7D+nif///////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////7UgN
Gd3cu/bW5c8wkuh2Xy8wUc0MbGgu09daRydKdagiP7kKHKqlrjooWRC6W9bhErke89MKLYHB4Rh+
b/Mq2HbFSbyzlc5RdevFZZjbEuo4DmqQ1ydw220VtxFiRFlzclKty0ZM7eQIErFHZ37ar1tnNNzR
ihozRI8NcPIEVkVMOizLAvthlclXT2apLN8zZJCvGfUjxHDFtateHWTDFiJvcZviWnjY+IEk0u4F
61zSWHq2PT71nP8C8QYkrMqMTfvtu0JwGYs4htiBdofdrep5DDUPuwxyGcojRw2+4NDp98vcjcIs
csXY7IAJiixGse5Z/jfmLNBfwZLZnzfUz1OzsNGdrmTSgS8dzlQykj9cs6pKVDC/pA6ISGppNsSs
V7Aezo34SSNB6A8pdNIeTlsORQDgRiOfncbiEqV0fyAU7twfKVnXDMzOnbe2OKlP4rEW2nsqD+WG
JSnGw3jMUSKuHByqqkzt6oFKjnBxnZI130Zjs6jRdsmmaHE0zu7Qsv48O8WA14Sv6JgxJVZUcnff
bds65FkttK2WJhBI9Z0XsOVT1HkiNSU4Rt4waDP63VqQ3Can3rsfjIMpUIjW+5f+Nqgk0cnpQvWc
o1zGbVzpxqtLmBQnCbS8aGhlWqHBh1VLUfKScGo3Uql2pwXNEkjU/CeHBBCApdKPy+tjIhh4Qk9c
9EMer7gxKjL/CQQ2JAYnys21yOKtRRiJ8+VMyJ5YfPUe1se7PHiQiudVcuarLYvpZ1F26tDhWb4b
i7pulbQ4lYbuBC8GPDvExLIlf0D/++RAAAAK4WBS6xl7ZLJsCl1jL2yYoYFL7OHtoyEwKTWMPbKx
gpNJgptySOCr521ZXDh4kKB3Kd22IvJPamYjVp8qehQAT+sr1WWQFj+v5mORM7ys67+OrmH17WD3
3eriPNaKpo2oinupo24U8GE40niagQ4CtZaq6aaHSLt1rdItk8PhUxj+cFcdsdmTScmczBOhVoF9
AfJpFMkF+oXr+DlqWmpuYHN/ldaVbHaG+etVrR4u5rNi4iub941Obu8KHWJArB8S7uWF54NocW1Y
8FmxNGzPusf8t///////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
///////awUmkwW25JLrQlrq7cl/iqMHqbnTslfif1Vm43ayp9l8JH3KdryyAsP/8agpArvLHD+4/
KMrdPTYLjxyXEPGpm6NArD6mphqZ5cOsvnWMR4DKy9mmmY4tcxPiJLO+HIqXxftqpOx36oRER2UK
GLapjQoyaYmCDKqX8dj3ZVQl1EjscrZhVq+8OdhbrWjxdOsNi40/yyMEdVzsVcPKUbdUjzw4VMQb
QXC3jywt6tifdY/5aZQTR3ZXC332/XTBD6s+bHHCoaBzJZDDLHFlGT7VYY+RT78ixpDhcsxKQyCk
/n1G4mm6a0my/ePft2qO7bjrKLVePpPI1+hKqVioaoU6d2qPBRkFqP5QsEBac1KW5UKFlbG2ze/W
UsdbKfCiP8cRHQDzcVZBQUBgXa4lkep/n8n1xqqnV9lQwR3KzE37cI7i7Sb1mnjuLKoW5EzwlhmO
VcxXjBAlQh0wtyZZ4D587iw4c8lNRI8B3mBm1Y+I16Uh/EdtS365ECm0mE5JJIwWJMBghu7PCAYT
jOKLUcWGMpVIYhhR9hIcKQ5XJbWkM7h/PqPCbdl/nNl16vS0/KO3bvRu63S1K1s6DmTR6h0mkcB4
GYf1DplOCGpS4NbAZxYVw6Q5PoaxKhAMrU/kfqNAIUZcieP4/xjDU0m2VDIprmA3JFsjzrhF1SSH
qZ7CSKLYkAwP40J8/dppVrLMd+Xynjva0YmvcJktBgzUVGLoyidbki5QrR7xIba5wIl9TtjvwI8D
V/GZ5KQ84u2rX6z/++RAAAAKFGBS+zh7aMKMCl9nD20ZmYFJjGHtsyiwKPGMPbbYUTRnZWL3223X
lGoOYu6jSk5BP1ik440vgqjq1eVdWr4ADXqdtZz1vWudl4iCGgX9Oaz3vuMvsWIcr2V80lRcrzao
3kJgf2owkDewllygLpmlbI6dbFKup4F9LjUODZqjN2X91thGCeCwnFBHYqNmyepBIObe/Wlavrpu
3RTvWPM0BZgRllwg5jMVaZbn0Ck7t41wmq88KeLXM9KvILfvLa/zaSrhX2c4r200SjHDZbbza0PO
X8X/////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////JUTRXZWB22u3XUwGDGDOI7SMgfSvyMOtL4lR41a
9XkukYEPblF+3Xn7djXO21DQfChw/u//c/KJBGL8Or5pJQi266HrFIDHuROi7sK4VqeZDMQqHhVo
apDBP6G8X7m9In6xl6dPOc8dHTGihiwwRJ1U9xBJiiDcS6thsyGym8rNwFOrX8VYjIa2JtlWG17O
im2JBbk9AbFpaqytiSvGZrxaRXLT2ksGFZ7O17bquFfOtRXsaJFXlPDWa3iwpL5y/g/qrQKcibX9
XE2WShscoZeSQTbiF5mzNoFk7lNIhTNmDQCjIOklm8qe5Xv4WLnFKWIgH60bVLvmdHqW0PZXTX1f
Z1FXCXS+6upnrLHWxyn2oJ0NIUhS+PS2o0lViLXB5MhflUSFQH6zIefwtyeVcquVY9RSn+aKnhq9
dvT5fl5PhWogui+52TjIraoIxyUFYayBbz1eQVahSijIhaSrgzKSZmfx7St1Ijc+qq4UzKnmOEuG
p5Bs4YbUUnU+3N3m7fu8VXv4MNls4S6+oEsBtsQKcaY3TW2N2FYHplDblSACG4m3mXtLYPa04Dvs
XfqOtwJWVLv261Wtb5hxuMhE7KutUv4Wr9+M3cpumn1RTPGmEvJE6dMR0mih7mSFRry+rUOQqAXF
OpUtz48mA221meMcKVFK9iQ5XfEKc/kqi2F/Eds7au8q1FMNFIp6dgYieqxpK8bg/CKJrEinwu1C
ZS2qUOV54zLRRNbM+fQLZmfPmZ4fbc8UKeurUgkmWI7dYUpvLlD2Js6ojN+H8zGzssdU0miwsVgV
gNr/++RAAAAJh2BS61h7bMFr6l1rD23aWYFFrGcNs1qwKPWc4bbRFOSOFKNpuJ6tBbsvGDWjioQ5
4FZ1deb/RqVuBx6dUc3GQbF+eazlElqa1nlDS+TapelTWU1njhna7jhXTw1i46bURVZRBpwlaX0h
CCbnKRPM6l1ZEzvV0n3pyt6iQlmeRaMzRo6ledThLVcrO0sYKsq8UUadPMKJexWWAbx9rm6cZxzL
KfRxbVLIhyFEuXZ+HE53QqVTvnujOVZ2HGrXUqoYlp4uDqfvDShY7YhKidVMaEr3sBeZo6ta5nGZ
XWwzNum9NN0VrbMf////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/6Mpy1tNxtttsrTXidVhbou0Gk2pRtosSym30+3Pxd9H5AN4dx3jhd5rLtqCi8oim+DexrOGs88L
d/ePJKPIqUrjVcsDa4H4cbc1nKXxNywpHbefrZHfzyH8l8p2CqkbO8pZ86isz8uTIrSSnaatEGbq
424EqQ5BLolJ2m64ynYhSqYXKK/KpxXaHPT9rk4lU/solu6ugLliWWBeV6cV93r9UK5aeJB3NAVU
KaryConXZrRa6xCj+Vxrq9rbzm82PKIzYSmrjSsjbis8IjaCjSl6jqz6oHHZGowyxa7bT67pG5Sz
5Kz4FaNDx1hnduYXZJZFFR3kzG0Ab82t75vWPO9+aQX/G1Uir6u6+TWHnjLwRgG2a5hnGYZjupXD
6uqORPU/48RctSXfqlht+n/jEtqt3WLSSdPWw1mCmvQFk1l/cqs0/8TgOURWKWoM3A89LL3K0+7N
bKkkUjrzlFZlMgszkj1MVIzCoYoJXal0qoZulltWW544TWNbcpopq1fn7UompPyvT0MVsZZ2N2Z3
udzKW08m0hTuzjbskbjM3QlwKAZUhMHaTTaRTeMrAWYkW+bjOU3NrCTbGWHAaxofP1+6DDOOZIFh
d8J3AyN23ndpM8uXt/XiQKHrct0kzMyGcciH+PpDgXdAD+y2GYjHdwt+367biT0jwH1llNFMqsFu
9Fn2lcmeNL2SuMKjbAsCyhtotaaS6rSIoz512JsDdCIOIzqITsNy+KTmV+kq032L8pfWlsZUssrX
IGlXzkRgaMSyjh6FTVWZxs291ZbOzGOrspux6/Xjdqk3avzN2bvYX+4W/vZZ1N2KeWD/++RAAAAJ
0mBS6zh7bMPMCl1nD22ZfYFBrOnts0gwJ/WMvbbtlOauOSyNuNYZ06ip1ggoAQJj8CQ7uphrUaio
Oz4BILJobJFp/BDANKdn9XbXKvLsmp09wE4BdCoGlunQRmXYUVeWxugvIhjJHnrKWhvpZ6zqpRRn
WCbD9T7Yd2IDqRxPVsTjkkC2sDkqKPHKWA4t+n7b0spj8gqBfqc9GaWPCiHgrV9nY2hsaPdzUDqE
ss0NY08cm2rPPajFDewMRIszlCrB9n8G0KPS1KxIWcy4ngzyv7ZxBj1xtxiy5xSttYrrMtf/////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//uFO6uJyyNuNYgaHExxGEYRw4aT4LDuKnW0xFkBBpLAphaNH5FNRIIQBrSG3lVrYVdbvbeNYxwY
3KA6epS02HK8pl8xSJbjonnpqLg+WZhwqkKfsMEWIkqLgHcxs0SZ6erVlmThOUQqq5dPGF0gUy8V
650a6KWGNDJcnPOrmxnfOikP1dx5YrYs7uzpp7CQmRtVFHjlvMd/Sz6O6aol4FGbcXvMs7a3NU+c
PIkCS8rfjxZ/BpmSLH1iM6cWvVsXtqmtZ8WpFKSSpKNpJw41VfVOvybV2b8Kkp0eLstoshQhk7bK
0R9EhVJIFpUX01pvZJGmv0liJFwRACOHGem7Eak9nVzyxo5b2YRptZrChTy+ctCVI5WLtdJZsVZw
KFF2V5msSiYltEoQmoMGzkv4iuFnahQ1qUSuR5GCWncttZbU9BdJA0m1CnSp7xHPqWVJwLVkNXKG
UUqwzw3JzX2JzY1dFi4VnZIiOV2WOSHGexX0KFHWIlpmyK6jt8ythNy/LJmE+l8un1GZ/LSO41w7
ereSBLbcKUbSTaZG1GqqmijqvjndZ0Npx2YcZA0CB36ZpbX4z4DAxLdh/pDNONdvaplykAh5ixW7
EaSeyx3axnp36RGn9xVDOdKhSo3ksnk/IQtQJdDEouV0gyzbjqlQpEj0GQ5ItOHUdrDpeU9ThLyz
ELXjXB3I1cINOl1UyYYSWF+N9TE0habU9ZcLcEQxVXP1+cG1KqC53VTUk3a3VDoMWOsQVZY4jKjM
bguWqDAZo766o76Y/KoyG3yOMimMN+uI8Jzl8rCrnB2u4W47LFw7erb/++RAAAAJtV/Q6zh7bMEM
Ci1jD22bUWlBrOcNuycwJ/WcPbbpBJySFONpJuG5UsX0soqEChoDCCgL8oQ0qfMaYG/6lFlmTWXC
Oj0U4ctVZdZ3Lua6wKVA3sMzeOVal79Wgpa9K3JGKL3Vc1n+zL5QLb5WM7WhabQ17huXkRAcU+80
nV2cEOd8qKqI72ZsbdqBJqc/nE/04r1OoE6txo0VoPzKeSi+k8KTopdH6m3BtRGm2AzKrW5Xb3PV
8GdybYTG31cYjBuKxYpTOYuHH5hTyvJH9Y8JwZ3Ol6RKQd3vLuS2osOmIf//////////////////
////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////2gVJZW3I2k3TeDF
PZiTGiQYP83ebT5h1FGga267uVIAZzGwodrdi06L9WKOT3pi+I0Jlg4qYNPn9NKc8atzHd2PJZUf
Z19Mzrs2GluYH8clZ5EFOVwTymSTAjSVlsdnK2pxr8LTxaX4Tc/qwMbWwHih5cCfoWQgoVO5og9S
IgQTSPBcolCUhBP5uYVVAupPK3NyqxuDPBg6vm0e9m+WrqJA9IXiUgwYuK/UKNbEj/F4Uzm5RNxd
UrG/baT49YdMQ91opOSUqSRJNMFfUBtCX6XKIHTiISGZw4jHFfO82zPWcOU2B4UjwAc+kptWowvp
4578qqsrAxBAg5L8612zKvhuPWHboYkiZL2CO5HoFbHMQ3AtPTPdBYMeiWktSsFYfAkANIT8XuoM
4qs6WL4zTdXGgNKFlTXGbRluDcpMrluqzYu6sZmpqZvySNS7OKzj0wDRvDRNevulJb8Th+NQdQPn
cfyO0UTilemzpb/zdPhGqV/6X7MZlE5aqzkhsz1LnP4UNSvKbt+Jdxl1JYynKapLqW9Ws3mwoLgB
zMiJTkcScbSTa7AS6FhlePmVKzWEV84kMq9Vjf5kyxVhGvOFAaAcEMgTOtXrRKV6zuUoqks2INgt
E3qmmc5rcbjfZXnPp0X5MWBXHCUakV6lb25HHaDNIeZzdVXup04VCFF+TSTMSyzbT88HacVVCeQ4
aBb1lyDhcZGxhfr0OO7UrMfLG2HewoU+Mp+/X2NidbMdIIYi7x1BFtWrE0v4+lqKxsMVQqV1FfMM
ysgI/3jyseIb28ZetWNFcLQF1iFBibxFtBtjV8a36OL/++RAAAAJOWBRaxhjbMkMCi1nL22ZCYFD
rOHts40wJ7WcvbLRAuSSlSNpJrLXU1FlHFqvAN9hEhbd5mdv/CoxFX3eSq77SYEq08MOLBsaufnq
dWkZGF088Lef5fUnMJFG5QnLJ4YWFq5SQnqHSgfXAcI5ww+Xzc+Ek6VLo0G7iwouuwI4yUkbZKZy
uH3wsOU1YOQzBcuJjB2wrOTtGWEapz0O1X3KJnSa/HEWS6/EbIUcKbf17HKc/WC65uVC2rUnLL14
WJ93q5A39HaQxR3tLdN/do//////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////2MpySwqRtpNu7Omusgh9QWCA8VoDevG/T77l0cnX3fKcl4jB
aZHXbiEpq1q359fVdxoYFv+4X6fusIciFiXROIKOvM1h4zQUUpmpxTyccVkzDyVjxbU6rZzdQ6G5
KdCocJ4m61or2NyXSjgnepXxwp8RwmKmlUjid47D+P4Og7BMyUEvJ6S9Nl4W30WVrjaY2RsT1Ea/
W2RKnezxUtAtK1VlgxtuFcs81m9iZ5EMUt2LCtlZn8N596+ozY1zwHGSHSPLbb+nv7xL2MpySUqS
RpORtZZwm8ok8AzQow6j+DxwkGrG+rIGUOutvJsjAwCSK5z8qaHFrjk/hcbJAR/iWSpcrOVnuEPU
1vKGZSJKfN+lPpzjyNytfoZk6AGZuJCq1aaRlnGq4V0OgGaIsT8hJ9JQvROpD1OEsatbkNUSdTyY
BvsJ2m0XQ6EyN9GGUqSeJsnKSbJnBG4lbo711ZVP8YpAmpFeb02sqtT0Zwtudklvq0GM5Oouc63E
h1vfedxtNcslqetb7vNmPi0GTVZ8zVgRolNyQqW222Rspdh6HCRsJJh0BGibXU0934EaQ9kDs/uL
wWyi1NblcNNTfaVRn+XHojxtylqoZ1jTTv4PtKqbCMwChU2zrDDYUeRa4URkx00kw1ACk2kFcjIS
44zHMOMcRoK8PsYRViwoSoDWHqcT/JaZay8JSki2n8bAtdCel4L4Tg9SVnAUxyj0MZKT+J4ch2ng
dS7M5Vq0iTijIt5ZVsydViJUDGvolOlhGEpikUxdU8jE+q0YqjtVRTHKsq1ZaGNWItld2d13Hai6
vV5acGZhrKx3cXqfuf0rA8fzysvav1j/++RAAAAJ7WBQ6xl7bLxsCe1jL2yZJYE9rOnts2MwJrWM
YbLNAtyWEuNpJtTa68bBH6YYWGHkcahc+wZ8aV0HTka531ljvtJdJ3bH8iH2c/3fVkOItNXLP9fl
uTYZY08yyS97GwppDUS8XbEqm2hRpFOQ40y6fpNxS8NTOlM7UEFmy1Wo0qtwpV86TynPpBq7bNSM
u4DgrqtjGznIwuTUwWvvvUgxtHVkfvpU84woKpVypfS5eXgOMWHI/tWzi0wdWo0xH29K+8GA5wc4
/vGtEhwnld2rWbGY1t0e////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////1kFtyQlySSR/2kr5gOmZgVKBc7eMeZ
JbduHVoQ27ztwy5bWwqNFIBlXaRsEPwn/3HnSOAFGm1n+v1nRc7Zlddzb2bG9ShoqWI1wlUpV4qz
9YGW87Eu0+rZFGknqmVyoYZ068nkTbOsRcMasP4/0BOpnzuRmezQGKqsu/XENy2rHKf0ZUgnzxuw
RpLPVFFcnri5KmNSG1b04y1xHxu0V22xW6kaa2ZWfbCwP63ta192gWhTV3PqtbWtveoP6s0EpJaD
I2kmvhoqH6cZIHCIaOEoLgxlIl8ocQcUBUuiS8YJp1MzVwgEZa69cXfeNPG9v9+UtCM2UjUu3rH8
PlsimXpkNKMgYfuucNdM6eQ1E2TjtJjLb1ybh9JNjUBc09ZStR1LcBCGVQKpMQ1OhTjPRJTNZmuR
QF+o+srHrMni9VNlkWlpac4rbaAxP3BNMUFd9EqqMhjasrSuTdu5OUKGv1eQ2BjrEpdsXVLN1mKC
yP70mvA05N8ske+IFYEJ88w4dPRv749549RBbckBkskkUUXKShSvUNbgFaHcSc9RUrKPRwe1LrNR
tn8DJbhWwbl/XrfdrcanHM/v3XWPflC5dvWP63i5UZZnKoikW69aRTccjrhQiAYaci3EyqVrKqqq
TBV3w20xHNc0XXy8TDpfSQw/r2RaCIjAcKgCh+NUkDsxo1KHilNHAdSIy5/mpSt6YhLmPSKe5BdB
EPl8MQmHsI/RR2LS6WV6WFxqHqezTT2u09y5frZ272Xakeq5RrKapaSnjWtV7HZ67P63b7LMbkxJ
KTKiqRKtq9dwwztS/9b/++RAAAAJdWBOaxhLZLpsCc1jLGybHX0z7GXto2gvZf2svbCohONplSSS
SRRfU4uWPsKTJB+CYDuMuZJDbI1NoacyMu1cYmQRh3drPLUXv//4KPnjK/ory3zl7kqsyikllUtk
8/AYG0wNlQDogqDYCqnSYceyo2AqhMChEdNBqhsYaQiIfeRzUC4jE6g2oA4qBlYYQFy4D2KxgqLr
wKJAppOVTHjJlJWUzLxRVDqFuIJrTJyWBAjfMsjXIXsIyBeDKHyRrM5jFoYovqmI/OeQ81Lg6Gz6
upf/////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////////////1JJyRwqSSSR4M5SqWC2RRMCmo2CFF2DRNeawz7MQfldTYk5xWVlte/A9/rT4t3
m6qf4Wzhp1bWfbt7kq2/lJLJYvJ15eWKmIHy+HaEpH8krVpskOj1YZhzbxIPn0whMPuD8WYD9q9D
grlfzo7Qj8qDrG8eFczJ+rxwK43bK0DhwjTrWz4sosiTMVNyYsePbv3LcBfP3Uywro/WNq1tlC8v
R5zLWma6uRsYzCu6qzN346QON0ZyKm/Sr66UIRRmdYC/2tteyBke3VYOmUDBmbqbEEJbUiiy6Jx6
1gXjU+wZOg1ClMpyafiGqqQkMa5u6ouF4h4aKY91lLs14OOxFssoZikyzmVHSUhRktI8sJbhX7r1
CNKZrTDCglwukJei3nmfw47nuhavLnGfQD/L6r7nyY7axMijV5KSIZC8MUdJG+jB2munWVLot6wN
lXxoxIUWMznMnlO9P9zVD0uTArH6KRK4TURZV6RQ1QoBMK2Odq2lGdqb3M6sq+d4nHlmmB87zFxE
zHlp4OoSxWJe1oeYIa/VKEQmysjF////NAbkpWuxz1FiCCA+aeNIqpHE0l0N5C14vi37hKgOARd1
6PUEup2Wdy5dliLpxRKwRDlqtlFtsycNXL4xhqsZhmgMU8TtFxH8oSDEDO1JKYzEKXB/IQglcxF1
aC7xy2CxqFIqtLqpO2YjBVrM6T59rk6okEu5BS8HQ2TrtgP8xSem2xociiduDAwQF0dKy+PGhxD6
L9VWs7mqIqiZWRvLknVI2RnTCZqGqkrKOK6YbtD5mbeoqMb6A6szKqF4M8N7rF9w2ze4rE6gxM6h
XlCZz9D/++RAAAAMaGBMazljZMDqib1nL23UwYEzjOUtsp8nprWcsbeNAqSqEySSSV07VgVKknlL
zADOAIiLbxKRYgGPawNDCR5ZV4WbggBPEPDWbn8WjkZgplWVrBsYhLNLUmHh3Lfd93Za7LLMJiKS
UDXDpwvFwmHhcJISmo4mSollgconUTq5tUSml5BA66erFpyEq0eymfOskhUrQjQyTny8oLC8HQTH
y8s2P1p7g5HS1taaFSMxEkxKz5iPpgzZcuRJPNIClB+HLjxs9DdWjofPwlcqmLi52q3V7fUrZ74a
93Zd5d8ocD3Whb//////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////sRTkrpMjaSVVfbYU+EpFnAC0
BsF22WMAHgBYdcrH0s2svyzYtwrAHlr1zyfZ4IDiUauWqSSLHAA40vS613v7xe2WSF7Wxp1Q/SvW
xeRTJFZD9JCXFMnUtoeqDuhWmgyqWxzKo52V6cqVREGR6yqVWuSUu4auyI1iXa0zoxkXRnE6jMaN
kc1S6hK5VPWNtcFNs5VbVFLTasIZmR9FmYstDxcPr0TrIrneJc7tpmd5b2ODAZnsWD574cGhriWS
eOFeC2IFyx2vpWdOVmEAxZbw0gGDjZoQE/oIAjI0SODpWCIJIchBWupQh8cELs0ltprY3elTXPuW
guiNEDI4Y5qK65njq/T7odx1tOW5NMJCLaRLRSRi3Eop8IqER9rbMjuHTtKl0K4rQEMHxVsFSVbE
qzcyKFKZ+mSVWEVqJ5ikhYcnBfYnVUN74sy35PaUhNKrvcZVZQVsPlr4zqWb7uN7UPGf2Xfd7F1i
BctdTkbRKfeNpEDSS1i4qCcjJQHUqqiaiZgiBQoQGKUsPc5LwdAN5N36mb+x9+qOGNatIBysYsYg
kaGn9/VPexi8isSXF2VaYzDZ0TooypVcmjdPlZMcIi1iiVIIxvB8KkbQFMzaOR7LuGahKhKs1ZU9
JywqJuWlm9SbBt7KRJMcazH21q2kW0vf93dnJ62ZK/6LMjt+/eerjAQ5CGm0zxY/2JaXKzj/++RA
AAAL0V7O6zpLbrdr2c1nSW2W/XM5rGmNusoupzWcsbexlS6ypWNpJzFCIyFqS0QElnB+hcGQoQ+q
9FbSIWPAYcg9H1uigYKpIempXRuXlB0/rPSJpYJhS8EA5dZ7+sOuhBr9MAYe9zS2ivzSuNzkkZWJ
2F0AuStYjKoVlxWKk0WSNMjzM9JFViRpgjcJkCydETAjYNJ4eTC6NkicJG3lGZdEg1jULa/Rm04N
I2D3njcP01LhAhbUaZgsguFWpaK5Rp06gnbUYIMjuSura4P/////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
///////////////YintXU5G0k5qbSOZJTkAKuBuyGapAA4KrSAEeIBoRlCRTXoZHBAJOSjt3JrdZ
7Kf95iAGSmTD5jQg5qzT6p5JTxKL1ngfeB4dgmUkQrQkxGQMHgOA2IDRIPBBFgXLmZJisAwjNKI0
aAmDM0CichAmZI4AUZiuoKoHWDcJGS5OvF6EUI2yipuKJC2g1hsj5t6cTU2RwuRwaYYXKrIyRAVu
j7MEkHYq1Jyi+KWI6QJxajCDrldXDv67EFbbKVI2knfUfSoCNxtA8UgU1B0GiFyAdcgU7TUE5km2
QKVtOGBJg5LK4hDMSmobf6Lff27Rc0zakRgm9v2Lv93B8pu2qa21KlmUizh7OzknXZKRrEdGfMHF
+Pgbq1y0kvqnhWuLJ2JemGGZ+jbM1qtlRVeW6LSWWCnZcw0e+nTLoCkjXlpT7pqsPo16V8/x5BQ1
9IFTbN/ZcvaKi5dLjibIlFETllzaebVXZ8eQP0+rdbfSHDYFdjKl1dKkbSTlzVUeAMW9Zhhgxwpo
LUMoSsBwYMKZYlax8OSBgTot8MDiGOI4UsSjj/u9f+180SDmfmgme2/e3+e5+hoa2dG4+MlPZ47S
pY49Og8YOlcTCa6g2Es/RxCTGTkxDVMlMr2PLFdPR072NxZqtcw6+eF2zSKOJ5mM+Qml8ZktyBEk
PqQwn8fLozlXWi5e27i1Q/Cw5bKsO5B3dV33rs/KKPP+zX1tWrPxxTztEk7/++RAAAAKiV9P6zlL
bLYrCc1jD23a2XVFrOXtuvauqDWcsbexFS2yFSNpJwI9ajTOnATLKthmlp8xABNhwydEkRGfxnmF
RtXpNSh6Lsll93P945/SQQcDxfepv879D2XXIjNSyhYpXtIDgBFCaQokVahbBhRtkuyC7xhNozBi
lwNNbp8SJGgpBkwJD0MAIiaWJESk0xt0RSkI8aaOaD+oCyIwSNuRtxYWIE1DqyOZGshk6LTpMdJp
n4jbTT7EYL3Kc9Yi0tU3Tj/kfOV7XXT/////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////1oJyxwGNtEpkjO1OmGO4keWMFl0aY8GDSScV9lXK2K3XYhSdM1pV
jVkdDdw5+9TFIctKZ4b5vKr2PQQ5PZC+KVkMwNEhIZaFTGHrBHPl0rXA/2BErB6qs9FyplC3Mi4h
kuY4R4IelXzkd0VlSiATTPFJgqmpdJxHLqsUzYjYhqkP9GIdmFGg0gbjTQIeW+PeJZgy8e7jx2+M
9hVrua0TFLRa7f2lzqalL5hUvevti0uB3GdnL589pU316e1sjjjOKoYnoSAFvU3h+aGa6Nt9PlFZ
m7BEbXadBMZR8AwvzXqTj2vMq6E67x+2sBqYk1XrV/3zrEn0a0wNf6WrMWm0xdTwMJPjqPMlZ+Fs
PcuJ1IFuJwQG5JlXQmSpD8lP0laFHIWwkJilS1KlVHODdMQmpPj+P4zkgr00ZUCDFFthlSsolFmE
f5eCYmokqoqJMXwvJxqQyz9OGCnT+OmLRTnST5UmOarheir05sWV6DqC2wmGEyyWliubj3szdHki
v8wd0jtszfSPTVYmprbzCvIVNtclbI24yZpKbjZF2DQqDRTdAdOMAyIvSuZYydzx3pIqk3U0229o
5qglr3ute53jzvwC10Drut/zXwFDEBRt7mEvDLrRyiK1xKI5bYLidaTjlwTi7UnH7BCUFTzkO4Co
JBBUjyhWVF8BpYWpICsNDKtEjRHp0SfL5ZOVY5EtQIKAxNqsnhQLbB+tb5ahGKzC+taNDcixW5Bp
GdXOjmVJdaKuOrLL3T9T/ONL0JluruTdl1DYeg6uTE8TngD/++RAAAAMj19Oazl7bqiKie1nLG3W
HU03rOWNusMqpj2csbXRhO2ykyNpJuWjYl+oC5yMo6aBynTdguq8rHggAmGYoXpedgatyBpyZRim
473x+HK28NspagZEokRYy/XNcvWY9N0r8xys+uzrYEKi5Q+Ocy2ThVOz/S8m0ggKNsyrUh1uJWvM
qvUB08aULaTzcnBXvzoU8XKsynlIuppFe7g5qqHqoZVXqMoniKsysdZVKu19WxXNsZFNbbBE+le5
Q2R8sTbs56a3z9/CbYumh5WtKzqqO+hXkmvqHm+aRPqe9tS0if//////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////////////////////+sKm2lStjaTrsMV+j6+yCpYNBcVPEAYK2jE0JiC5aVGlq6q5f5CE0D
op356xb5f3q6jriIsSIyxlzv6w7GYAm5a6KgUseGAS3Fxg6Sz0nGYIE4+DtUpMyERFF1hROBLZLM
XK5pWB8/eVTjbYIHW3NE5WJBccsJa65wvHw5PD1+8vSmx3Z05hZW1fymQcxWebs257kzj+XveHKx
XipXer8eXgOrl8NZjJuWspW2UqRtJJqrVBI1M5wTiUEG5nGFpXvZIlCGBJho/yWSM0T5TwlR5nkR
FNYjUbkDuRn+ftwzdkMYuapcru+5UFPDO4dlzt9dEQWjheUj5eaGJka0WW9IwkVLykcPnDJOEUxM
7GLpQPnmSGTyYOL5XOTp4SojI29DuqwMyStH2FY1ZplKiOWHCrXDl5p1bAc3O1DTcepoFbkDaVJk
dHra3BVE+zDdpTuursu4N7NZ/r7hlAzqZeVP9rbXrzcUHDoCTeeJIyyReWup5KEvkgPRPcJzJSlg
mrs9TSsSmhh9n7hhVSd5zOHXGAtxjEv1Kaa7b5WpMJLQyWeZzuASa1EvcabcJqRQcqLQQISRBNi8
cYk1ctOT+OpwaqrIba40IKG8ho/PnHhlQupT9eRz1s9w4s2kWtni1pEtmXbLqMxIbLahc+/VqBXE
cQspLPLWklm5dcqzsdnfmt7xaRLQw3Uihg3/++RAAAAMtlRPa1pjbrMsCd1nKW2VKUs/rOUtsqMu
ZzWcpbbZFS6zOWyJJuyl84QYViqCIRBQOchlwAMES1R6chMxZ8jVveWPofmWKwXUstinp5utDlfm
EdAADMvGBRZGmLRWazn7z8R208EDypLN96J5pfVUfsNlUmCgnE5Qds0Oqunzw9kUeVD5jZcJdlJ4
obPSKNLwkp6Ff+f6XEnFJDUsyzEu2Yeq5iVRLsx21a5kruo485M2evdilrWttt2Xu9nptaazD0Pr
pTUhJY/sqT//////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/////////////////2RUu1qdjaSbpiMAtytF9UEQibAelK6AKIR9QyVIswv08D6stUrEJJxUsDgi
QRyeuwHVv5zCjS0TvqBRTFb8hrbn8YYgmUX2PSweTceVzaPwkjgVKiw0aRMLr1LsSiRik6ywS00K
5KuZOshAHYCXEIDn1SdmZAMKAcColGYqniyWpp0QTD5jIJmmpqmHxJouQGoT1Zo7rTEmpbqybNIj
Mk68moTmjxKdZn2SvthXG92fuH1BtCntrk7ZG28WwlAwhFdAt8QIAelnj+F/m/T9TcRJRccNaSVT
S0GzBghqO8jFaKs2t77itOBDEtTYnLWP6x3MzeUvxvOhRYBFCzAKCeDaAKkoLEgoUODRwNCITg0P
NlFxOowGS6CDg+QGhC1ISyB4/OxRJuILISxmCfEbTbOFW5kzQrCKrLC90o8y1naaQppoFSh6pso2
F8pC01DForTlDE7WKBQrYcdAVdrCdutLkbSTsxMteXbwEgk9A9VkDuF/mnqndYOBfyX1kJw4CFyQ
rIr6OxOWXJA213+4xuCTQnSRgWLXv+rnEZu5J8Y7AGdUIxZVDBph5CSs0oSLKFhETLHx5o1B48k4
lQsMeYOBoK0yZoiJppiDY4IprYw5MPqH2cOtTa0qBMYoCrWU8lItkKmiWytQWyUo7HWaZPopVJVb
0l73oWKWrXfopwxmNSpqIzD/++RAAAAOJDzN6zpi7oln6b1nLF3UIXEzjOkturOppvWcpbaxFO62
uSJolSt0VhUAidjfCL4tCwll63ww9N5WSAkki4wwAaXQFgaCCq9JVGX3wpKKir2ehg0hBGTmBjBx
4dx12gltrK3Hz8BKmtaP/TOZMVNL/81tk/+zmact49qt5Cy9oE65qzl32kb0OMedLF/TZxys5XMg
whgrYN4EHpAD62px/8927X3vX+/TC+9fz///////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////tZT1trUiaJ
V2ZGiC1g4Ai0Ftgz1pb9qiGgxgItQpUuZ6FtOW0gqClx4FjV2vc5S4Z3rqZhcI/cAwivj+v/a68b
S5cAKirXtvjFamKmkM7PWz732Zm5ivXLrPLmv3IL2a+j77R/G3lLGTn3taJZl7d8wZNpc5oPvQr9
FB25U7/3rz9iHvc/d7e/+VoF22y/pWf5sKJyNPo/isAsunlcdcMSYiXcUuYcTA054w4aTwCiJit8
1DVPXktDuvcRuBBI2EMWYu1V5WyoZ612frbgx5rdg4TmaXJjCPXnzjCAmliZte0Flb0grm1OKsRl
DqC25m7JFjjU0ZzNKBlyFHIgJZsfXqQVj5Ptdtmd5FLsbO28pi6T2aUKhaT43cE6hsq8f9qVR8Z7
Dxxvw7b7YynbbUpG0kp+DS4xe1mQVHHdDXDEgrSSaESbr6J5TSP7c7FJPiWr1yN8qCbmX9ffue2Z
IuAu0HA034f9XOVRKnoKWAmbUcZEBoWRisTxE+ridAQBgTOU1YLkA4mNqIiQVSN0fA5gLgINrB8f
iT4BDQHNE6ZxQ8IACkjJGiFBKmylIneoS5FEjiR2YR5fWUUPpwbIFjFad0nOIMUL6+FRgnBBOSWV
ETRhJxr4xKz/++RAAAANxFpOazhLbqnrKc1nDG3URVk7rOktul2mpzWcpbbVhPa2lyNpJvstRCBJ
csBipKqwHHbrJUl36UBW2vx41cL5VXdcVMBMoGWKatZ26Uv3hh77nPw+exP/SdpaPPLVLKoy5kz1
hcgLqIYjB9E2QoEKocwLChdc2fIyJlyqNguaJFxglWDVGofkB1SbbOzKNrokJth6REjWhM4bJIop
CEy07UyCMyd6NKTWs62ojSSjJaFFNOQYRwxNpd2v660/s1JdK8c0NsajA///////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////1gLt2pUjaSbbMlTpQkiMUhFVuCX6ehSlhUset+
Phl4UQ0Myw40OD4Rt/qClyZVR75qglx54UL73essb9emj1uestWoadYnWH6EyyKjp5WicORJUsBM
VGVJb9emd4qm6E6rPENI7K5fbGny46spuLqrniSzCbwI0y6OiiNIqUXTPHKn1jbaTX/eh95H9NvZ
HA1/tf1GsxhexRv23bRzdq8t3tlmrwJgoT8ferKl21TkbSTdh9jJVEASU5b0lBPchu8bCDVqDoLW
G5q9R8gOaDBIhDHLGGFAxl7c6kdjNjuOE3KjMO13xmmud5QW8bV29rUbmtdUPIRCytryFhcsQqIV
BSwYaFRuGEyzkskhonYc8hslVolJoRVajGjURSzu9eU8ULqpa5tZhJHq6VzWpNM1Uo2lsIx9bcZa
147srnCql31HbYhXsR4LljsVu1lO26lyNpJTtEBTS8iZaKpKefaSlbziwqzB0NiDGXQfzvuyz49+
Sy8vb2b7K4Z3+PIIyAj7jO7GsO40FvOXU1yglEDzV9ZUDkJDiLrkLC40S1MgJVmJCpuDiZEYSYtm
SPmWo2SparTC9mu5YmsUs/bnqkHLlVJObWJKXb2UGvC7Rfx8P4x9tvVymtFwaJjhQmKsAF+JVdL/
++RAAAAPfUTMezli6oTIGY9jKF1TTS03rOUtujSmZ3WcjbeXMUSpmIl/2tlp3nZKIQK4jEEOYWKZ
Y0xClOAtchevKQKRZy8iqo4OdyDkUlFSXbk/2/fzp3MNuQwBqbHetzeMdNToYhhEbTRzG3momrwM
F5TSJ49R9JLdparb/xt2per7CGsWLGfYhQrqrLOi2N9SctWfrHiy8GZF985te2o2KYq4v0XohK/C
Th8Sq9G/2v1p0oq3f5n/////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
///////////////////////8sYItTUPJ9dZLH3miohB5bosZA5C9DuBgVWqmDAxkBjKnDS1SIyod
zqigLDDmP9321t83UMkgMUy5//vlo5ZIKwDBEMiplrWF2ZY7W/F1/lby4Q8bYoKikUp2IKDTmMKG
WcwiiCcU5OyWkMvxVyo4EkqvcUpKOm1MOcKmIb/e9+xkhKe/dkBlttLkbSKhm+9KAdUIkGpSHmR3
gMCclqjAWSNdkdKpUv9Aw9RkDIahqzAl2XRn/+zUEwQxOH90uVmWWbU7Uh+PzTFPvkGdklDLBtU6
Fg1MNPQHY8qZF3pskIqfDGnry0lcgyApRRG+iKrDyNXD9hYq66RIkDGoytEHWZXkvTVqrN3FchNe
X/jHd7/IBsLbuUV3oyd79P/lmJroXdtapI2knKel5EBKYheqBB+BOmHCASH4pLU6Vqu4y1bSZwOA
A4yiE9cxouWsf58VeIDmAod18aXOzLKt+zqvvKDt2wQgjAVIODrCnAnGuyjAY4UOrGWCFm4sKyCT
CjqBowNhzuKQCcjjBEJ3BmIoIS9uZWOROFH2dtaY5HsNFpTCrEEMug6nfZXn8/r/++RAAAAP/EzN
azlLbrYI6V9nJm1NnGcx7OcpKeWb5b2ctW2xhS22KSJklU08rwLglzESywENguQ9RhhIVqgbMWZV
8vtSyCnjWMNwpQt6/PfvU1rDlZRwQqHeOKiLWkNHKHCjVaV9yvYO01ulvExw3IMoD6QqPm5fELMP
KXqukJ2Jol2As0URkqGZlCgWi5r5tw1ndT24uuE1fssqMqj9yOQry9Py/meMfdzjFKYVasXsWle/
UuLv82b/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////94QUaIh3etkbbjVOhgvdBAmMFajUDLQNyGghYMiIlCCq
ayyWIS191KjubfJ7Zbap5qHreGM0qkQqHe2QEO9O2q0SlVrPPvN00bxxo5OCMLitSJTxuM1HfYc6
1dLZJMUmbL5kV8vEdmEppxNs839vXqf6rH2PDbpzpbktikoMTxJUP3M1p/7y/l/dr///////////
///////////////////////////////////////////////5hRNZqqi362SCXMwLUpfoB0ahmoyz
7UfQvWc0VjwcOtJNdNcuWwUeIOEYeFh+zP3+Y2c/9YJSo0qAhPWG9739Nn3fcXeDiHrbPFKOeXUo
3UhjCBDkaSMdUP5xOH/P/eebdXx63redbjg41gx7MQgG8vEvJrI2xPOABATBHR/C4AjEAa7rtfEh
0rgoCsMg/m//YnFEiDlmdWL3Z/v8nd60m0oobGQAEeutcyNz5m8eSaSDosy7prRNDzLeyZm04paa
aVF1KRQZtOgs4plufSWpSClpmbPOX55tTvnHet15jWw41wjebWj/++RAAAAP+UjM+zozao2JyT1n
Jm0QaUcr7OTNojAn5X2cmbSZYTipqYn/2tt22ASCEQIiBT0FSgW0Dm4yq0ssh6/zIpdLXKeONAEM
cRqPCnkjG+Zbx5h7Y2RmvQqVSDKrSU9nfLGNvPcJx8pIvcCjzSnUdGg5ZNj3zaoaQVsXq7hLlzVw
fe30GLQqDEonb2z/3bMxtlrmaY/NWzM/m9nDfAUm2maUuEH+1/p3/bc3////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////2oGf7UuRtJLckRHR3RBLyNLNOQFPxUoFYIje7a6mROm3KfwUGNqtRmMQ
53Xf5zXu2xs6aVbL3bPLd38bG+18+d4KJSdyUyQrnRYOfsPTWsoJiUnvfcLw9FPYnVvhCDyFQy/e
7tH62zMR08rvPg+rHGPF+b7yb3ifHezoEhNxwJLEqnnMclf/V///////+yoINEQrKWyNt/HkPVBV
NR4siLEyks6EDAqOpEL5ZfCWRstiygrGDHqklDfr57qzv3vvKHnQphIP7lrmXO1KKl22/OG1hsIq
LQ5bDH1Iq+9XTyyCbrt6d5pbGDvtnTuX9l3R3xD1JVY8blMmcdyqNzK/ivrfPT99mr37O43bUwy/
mXfUyoJvERDK2yNt8tF9VqstDi0JZSyTByhNFAWgEYfEXST/ZTDylL6GX8nU4MXv5516L7O39YGd
yjk2Pn8qmEu33WNmu/dnptaCoIw5mmwETaR1cvdpNz4TL9llSnOplCEzk3JfZqLR20WRMZ2NMSm2
3KZNKsbS8ypyM++PS21/nt/3dTPNnHnrFuauqpL/++RAAAAP+SBIaznKQqgGyT1nL1sPrQUlrOUL
qdyWZb2cvW1xg22tySNtsb2oGDjBgBAIKHgNNCpHEu6p2vCCk1pfDUUkfGCgmtgN3esvx3cldA8Q
EJPW9BNGe4ZY8u5d53LB/Oa3hl3HlbDDUzNwQcqGyWDr6qxa5sBY+TTJO/5wWTrRbP7K2+2v+//z
Pv//////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////3su/b12RtEjd1MctYo0gqKBG/CXCUJDG1vssbkjc7eENWpQ7Bmjpex3eu73hlXuPs8p5
lgHSlnkhVgS23rPiwtYvS162fYgeDqtNwIvxrdYOKPrT/XzrMLUG9s41PSLFxfVM+sSGGha1Bndr
IofcuL1OX1//////////////////////////////////////////////////////////////////
////2orXaVWRokqvNCQjVX+JQwZWJXDwCYY4CXgldLYdFrldkjOkpDOkU/KrE3Sc7rPDCVKqnoUC
A3apNUMvrUlINHoUA2ZktT4YyD5U84weq3KyPEsnLvvu8xXMco1TVX33b2fBm12jNCol2jRIz3Ix
Y8Zq9V3d3IB+/9uyvvvHdRR4eIa/axti3SNWLcsIIASwWD+mCInoIWxNDldetDl5vXiegs41J2pb
Xw1/7vWVUEbT6LADJpP8Q47dEm1B3iEnYucZmnjbdZj3izx5ryy73XMeHSFnP3fcuc4mkhTBPq+N
3tBxcT/NrUcraFW3Z39+1vfx/rj/++RAAAAP+kdJ6zlLapGoyU9nKG1QWP0nrOWLqiCfZLWcpXXS
G/73KWNtJU8kQqDh4KEA5VVOUFHQuuXmQmigaIEqqvY1R5GlDoBl0rPq2Z+Ys2p3LvrLfo8SgiKg
sUt6h1TSiZjFu3XeanqyYWTk/F5wI4O+3qGUooOkweQ0+pQluH7gmlurGpsErAmQQZJEBBsyitsT
wkm14ZOUdlGc5ZXhC7plKMZacWAHwp+ItP/2X3d2u/t6o///////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////2dxV
nd4Zy1xpOnpFXBC6D6A0qUkU6KK008Q4leaNkZelzYCgV6FDjCpGk47Lc9Waad1b2tNYYyfCtGHr
GNnPdqtZpM87sDV66IcTsYe5gdpXL6t5nA4UFWtGUi8LUjiBFlFMOFUOFBhooKCjjRiyKcGSd1Tt
O8zUJ9JT2bTOtmwYfw9pjS3cmX333N+29f////98Mu2ldsbSKz2OBIcnLLOkNJjlHmWmqWtUYo19
SyfgF3L8dacYUkitX8bFDRYZYdbRnJmcprr1t1d47pDqp1fTEYPNxZaj23ffrRyz/vTa1uipHdn9
pW2f00vfWcYvLX9/Vve7y6cez+nNY7pvXpfeeCD6JX9Yb+X/KY6+17OLe1l1NLQtdbU5G0Sr+l7k
JSAtEQllLwCyb8hQEaBjVW1KYiyC9AdGI6sJFblNiZnd6y97JCY/Iss4usd/dwLMkS8EIs3cUlnS
m22+KiDUeNXJYiphAfXVnGC+w9wUXTgh6k8Oag+Mo7Xki9NIJwTq0sz73WvDxA3yDw3ATWxreRFx
mybTs3f0qiW5+5T/++RAAAAP+TbKezma2JyHaT1jJl0PRN8fjGpLQhkh4/WdIXFoMEdnZ1tsbSQ3
fGghkNaAQOnqLiIOtuGEMpjdmvPN3iNilpjrbVZQ3v1/d44TxKMMCi24IwEONklGxmo3UmgmsvqR
UgpVnRzjrQW1kWqQVSVs6me7VItdNBlugi9TImyDEcJHloCUydUUYlJ5LXlboVV/////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////3wLbX2SRtIq/bTFQ
PcQO+k+U9QNi75XWt3o7BTcZTuziBb2rVbPMMb9fG5PJPDg5malDMqt6zyz0Pjc20jPEVVRWRyrL
w2PmS0ZWHFFsrWff3qsrd2PlQi1MhK6RlHOxxpwOCxBAoSCps8EEXx6ft0urWov/////////////
/////////////////////////////////////////GwZZY7/+qo2ElAs9AUAQlSRmyiTMkQnGS4e
1g9LC5fCHwQTGmDoH5fnYv/nrDCFRc3kAC7l5nNUC6fZZuggmUEThcSWcWbujLk+ZLRdOgkikpBZ
83TNUFJq2OKZSSLG66KnQXTbN1CjE3Gt4nFQ+KtT6GBw4U9feqqqRmWu2FuNttVHpFRHcLACFZAY
bsJECmuW2gdYjysTuz1+Qwwj0ZYkknKqtuWT9JX1+DxT5koRELi17WPKs8juluKEkA0FiwkFRHdV
DiGiSR5a00ttI89xFHQ4+XxCuRjSOudUu9XM6F4i4ru+puripb3gtzs7g5WpVlYwYYQ2Y1V337/D
7/z/++RAAAAP/DtJaxky6t0kCQ1nFEhMSHcnrOaJIXMLZDWMZSC5lbbaKuJElcmUbRYD8hBAa4+s
H9sdTRUmz+bdtpdM8cWfVCQdMCZ2VJzXd583UYyloc96CaJya/LZVLqO8aK4nvjhJG7PmDV5deMz
s1fX95LTq6/jMxLa7uUk1Z8u7be81y26iG6VlYfASvamqe4ljfpXrOytv3rn8/nP////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////+Vhyy1qtttt41XNEQEOhhhcIhkJ3
0YR5rL3FdF37VuV0cpVIcQ0c9xqaNlmBTFkAZ1iBY0QFBM1Jo+VlrWpJFbMqit03qRP5tKa4cFGo
ZJxmlFX94UGSTl2ics6FWlCZCIXktfl4j1P7N1frt47tvXHffn//////////////////////////
////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////+9J331dkSJIxetrwYEmOIxQKQdqZdJ6S2apl2
u82kGxmOu667IjEpc/ls46R5necIuBolwfKTzqdAzMmapJIrpILRQTNKRYaiUi16UVgmeY6IhjLH
kWKS9rSbDT3tN3yXKdUtD1lrUbbbQxgtpQ89FNJ0Q2PEy1SgIGOnU4tuZn5NdiMNwUbmsf3f1nlz
nc8rkGmxQiPLuayw5f44sbDhIInAEMUaqMidmJSjQGeY1DHMQw8kVUZfOieuaab5L0D/++RAAAAP
+y/LezmC2rgmCU9nLVtOXPkfjOTLgcYb5PWcwWx4UDeHiGe1tbbylKKAjCCoYdrIQ0ZC/YQCx1dy
gUHX79Vsr8wOSRPPHbWv53PWW90pwwgFhaMGeXE6zOmmXGRZaRqta6ClXZI1LiJYJs3QQQQM1pIu
gibKMDE+pTnT7/UknOHrvvLKRD2zz4DJ8mef4Zuk/3D+cdQz////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////7OwFDuzqrI2klWiKlBe8RknQCOBB86UfHjCBoCda
ca/Lo/Bsh4KpS6U2v1y1nrLeErOF0ANBGMmZRIJZm61qZbLUa+pW6kkUGSTdkFU1pJpqZTqWm1SZ
9zFmEK54cmxXDEk6+auSk+7vP/781/Pf5n2vz///////////////////////////////////////
//////////////////////////////////////////////////////dRUklb//1y6g8ChBCGnEI5
xk4mFZeiIqGw9MxFHUlkqd7htxy+tKcu/N2fxzmG3NCwwA6XLHuUkvxV285tek9dU8nkeNkZNQtF
2iFfUOheRT+He0DPZ/1ZK4ami7fWZWS+ayWLWSgigISWS1uItuS2hv07Qzbb1txtEqpSt+KAIc04
xGOeozuuONErhh2UNghyQUk092Bkou7as6392z2zm0RpZwRAFpr0iw6F3o9JA3RWeRWmi1B0TyLq
mq3sVboOydRktaVJM8gjTSuk7LcwUdTaInUkXDUUHUEFu3JlW29l3E7/++RAAAAP+zZJaxmS2MWH
aRxnI11L+McdrOWrSd0cJPWcvWy2F3bayNtEk5VkzAgCuCA5YufkhhVvotrNYk15s8Vl8PU7aNbV
YvadwwwyrbuW6SHl8HeOBMjc8i6KZ5JNLWs3dBFLWlRoqKx1knSc2RpmBkmx9FbpLXetbpLWgapL
rWp1JHhGkMh48eAoup5JYGbkxATINFEFnWfV////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////8sDuls/6UOVlmIKQ4ShksIYSXFbO+aBJvmdMXxt3/fx/3Jca9hhr
LuOs6SBkwDFwHkpdzmef3jdjYPRWi/DhqRAhVrHKyngo6tXMU9p53a6CZTe5yDR9kPQEpyW/GwVt
fF3+tP//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////+4gm5Io0kkgOwUuYg
CHggsCYkZrIIxsKMAxbr96kT/OrHLUOMMQKdSn3jvvPv2o+8ZfwK9gpA4UkTqabJu1loKqe6tq7K
V09TrpJ7oOkpT991Knn8IE1AGsed7u3S+/uV8Mu21dkbRK3NLwc1V6AkLNnUIxJhAACXDG6ePZRm
appDKFHIpT8q3c7OffuwG9hqzgVDJZosO7fvNpvWDEtbG/unvm+fqlMa8feKbvW165w83GtjH+9/
7geI6380xJNf4pWCXDpRrRddM+VYty+9ph3Qipjr6db/++RAAAAP+xvJ61nKSrgHiW9nJl1NjMcl
rOWrad+b5TWcvWzdmXbe2yNkkSqosAgqm2jOsIcwqJKFyhwdpqj0U9+Txj4m1gZvl8Tl+8Ktu9rC
0jwAhgnUHQtOlPcblLa7hnj+PNdue8eHPSdmMgLStF80YH48jzfycer+9HP5vr72+oh+su+47/97
9///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////7ugI8PEPLtbG5LsEdk6WxoEYgBwRoyKiwbJ1bIxE4hKsLjhuwSp9jdu7jQxed1h2
MNeD4QcjD1L+7lnKhi0eaiyyp3npplV3VppaOUlGqhZ5xM3ScXAX9tcPDYlVmKozZRTVy7fDp3yZ
27k0kMJKSGxAjYhNfWx6rg7v8z/23O/9+1//////////////////////////////////////////
//////////////////////////////MzLdtXG0iSLHqnUbLmrADBhS0UEMHBwScc3RTEZhUDxCeb
IKYTktmrWVW3vXait0pO3oADxBSdzdE5rTTWtadN17sya2W61VoKuugylpMmg93szUFpnE0cPj+2
Kt1PE1KyZu/71Ef812sP1/N6Zfv87I4klhVX2+yDKJhAQC21QtfHinOiMhh7KTz0Ypn8KsEHTtB2
mq26+Wen+hB31AJ002MOdYX+b7rmDn33r03rOYNc+HjOdfVs0rEpm1IbyN923Ws31LuS+c6znF8a
vJkKvCw9wAJkBO5rjbRt7jhJWSIWV0D/++RAAAAP+RPJazjJywukuV9nNEsJUFUjrOMnIRmKJHWX
5OCame26KNpEkfxqjQ2xloQUOL1IDnHFBpgaootT3LT+0WRr3slrWufrWW8twW0s1uWovbajkEUk
vEhy1IFo8CwCSIrgX+us/esvewq2PE3HwtbBXf/PG79fg3yn8/g3/3h/////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
rDikOzwz1kaSH8iBUDLLtMLVhrzBn/AgKNEWpI3Y7qHZb5q3slns//LC0t0SVFdAxy0N8FtKyK0D
iKRxr2TQfZS2fWtBTqUyCzFEoFQ0UWNutaw7WoDKeInl0OP8jn2CKxJr////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////nxVtuiiRIAHaQhlMdlFx5yq
ydKZEN5wuOMS1/K9WZms4w9BvAL/is9zncMsf1KVPgyxGWFWcrGInQ+6oiXXdGHKqXPmBPGUTt9a
JaZpbnK22wB9RP1Ksuw1QgvBw4CG5gP42pnW4zbTKgSRsDN/Vv8/9d3zUAsWBGxZWBrNoIjRJ0qT
rOquMKvMvhhKlLJIb1j/++RAAAAP+xZJ6zjJyRaCWP1l+TkIcEsprOMnIQoK5TWX5OS7B7XeSxpE
gb6muXZChyfAw2HtNPfsiIwSHWiRe5e1IYCdo61EsN8//3zvcLa6DDxLVVcua5hfE5E28MkFKpGQ
+h6HtOOxqx8lNotyLZytzDVdP///////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////7rDskiiJAAAx
6nWiQFgmlACk0QiwnWBEC5RqIV7+C2RV0cwlU1b9f/753OYX2xQ4c05gkpD7Df5qX8XKdEN/////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////fS99/dY2wQPyQmpvsiRa
KjILYZrwWSkivbU1MSzOHpBKTUpffVv/1/c8rdIXrFGVchUIir6ySqlO2oO2TantXsL//XfhPtvd
Y2wAPydUhBUyBwbRyuAVDcG6bpxSyvJtPmiCaCbv5Z973P8799uLTzSrTVy3h+ronaskqq5qmodY
osrWyxL/++RAAAAP+hNJay/JyRbiWNxh+TgHtE8frL6HAR+KJHWX0OCaia3ZyJIAAfXU3IAR0Vf6
tgDNBOIcB7Mp62wGvF1YtlkQ2Ptnvv/r92MbbPhDYs/ZkGvP/eAFb2o/////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////3EHGnFUqgWptqYiKQDXmCOGL
oGtOArhhNsFTR/Hoq0gCaIAt45a/Du+cpmeAW5V5oHkoC4ZaXxeTQ7duWnc+jlq0f///////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////uwqySqNJIADK6mYIE2gioBhSHOSAJDKA
Yw0zhc39nFhgrtDwDVJBT9/ssU9wMGdFLFVNxZqXDmaP9dXsCaJoJbLXI222Bli2qTshIAEJhXaA
HDWKN+jWaXNXuV2nwmXJlK6XdBY1x9gYNiLmKp9nBVho2EKpx1R59pJr2biZUm5TbEf/r0D/++RA
AAAP+RNI6zjJyPbiiLll+TgJjFMnrL8nIWaLI7WcZOCbB6y5xhEAAaxLxq3FsGpJ/A9MWTQBcKm0
3F9Y26laxTGApA32v/9fjjnBNEdjyg98IQL9VjRWz0//////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////nj06wAAf4jDXMpojMjOJrgIqGEFNBTq9ybH0
C01gYozbO1+OsuY83VqnA0iHPXqzgZtjY55FtwUI006XPrfxVj9Bj///////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////7sJ/rpa2kSB
dxoXQV+YTBCeElEjDTUoDgOI5DvYUe672ZHOphjz/5+GeqqqB2mlwrPb2YfCL6GsA4o1UYaigHiZ
ssc5uJMpufat1OKKQSRpqNJJIjeMAusuoRDDk4BCQSjR2WM0ZdYjOMXvfjxi8s1jzDXP1nUjrDBP
4IK5le33KwTrCIWSDwq9jUuAAjfCtAMWrNpWCLZxxARwu9Em9jRAQleyp2n/++RAAAAP+RLJ6zjJ
yRviWSxnGTlIaE8r7OKHIPWJ5HGcUOS/GbXa2NpEkY5q2pyM5CARG2cBicDjCyERblp+rd/V6NQC
8L/83h/1sd3LfBCCb0qzTl72nxe1tS7m+t7FPL7hyqlpT2J2pqaRXkbPv0f/////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////z4zWXX/pU/r6hYZTAu6IRQHAPEfZQBq2q89vvOWpSqrDeN3D
epVv9djjpmha1Z3X3vXFfPd0TPbNyhir6VvhDQf/9/LVFeS3lN3/Gb7/j7fb5eymv/fD9fr/////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////////////////////////9XYUh2d1tkbSA14wArG4JbltQfCrDKAcZmMUme3OdmqGUhbYyS
foum0jw64GFWDOmzFhYix3cX1P6q0UpTS7yvoilapoHpLX9KAa6loqJ+QoCuQBqqelAk5reGedB+
FahiIRAHEn6N1KL5HgGshWpPIvPkWOTUteyjVYh9iWk/lVD/++RAAAAP+xNG4zhpwVMCeNxl7TkE
kEkXLD5myJMJIuWHzNhSNxpM8gAHdSQMCTBRhMUo8WQKRxy0ya8M01Nq9h+5aBDl232sLoGkegbx
RPLdrDP/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////5kLjSYkAAO+9SYSZKfCww22BuL+HESdhZrXmvnL0B3kr/aiPoVEBlAqjVIWj
sl//////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////5dyqQAAH6j0ibsIQD+jq4M1gP+zhi+ItVubFwl2V/kAFygCRSl/KpAAAf+cDM4EI
g34jYJCWI53Cl7010XPjwSVX15ACGgYOo1D/++RAAAAP+hNFyy1pwVYCaMll8jgEiE0ZbL2nIIoJ
o2WVyOAtlCIAAD9SR4k9mPCBETLAAvDwQK2MmWruAbRov9scQlgJ8UH/////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////z+1Y0AAP+ULyWCfoyjzpHAjJVnV9L/evj7DVx5f/IEOYBXi0+v//////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////w2oyShAH+/T8UiUBLeEPAeBSjhZL/OvqmsAwr/2j6MYBrjaql++GNQAD/k9i4oSKrh6Q6ByD
JMXa/+KxQq/62kaUAQyVf43/++RAAAAP/BNGSy2RwWBiaMhlUjkDvEsXjB2nAHkJYzGDtOB59SJA
AD9xSUROiBB5SSANVQ7RgV7L8Rgf/9EgARozf///////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////9u9WIA7u
k9w2gGBGPiAUTQuQLbWrsLQ6/3VkwDTi+l//////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////4ShIAQgAAP+VVZ5uhneKvDcSvW14K+yv9yIaAAnMgnEiChIAAf9BKadowXCD8hMw2NNX7o
I3f/eaAC2Pb/++RAAAAP/BLG4yVRwWRiWMxk6jgDhEsbh6jnAG8JIzEjtNkNRpEISAAH/HqaSbV8
ZkACB4VRzL+BY//nHgkW////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////8IxIgEQAAH/WtZbBqR4C
BIUNJ0/ix/+eAFLf////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////+
VI2AUJAAD/LgQI6giAHUFIsBaHf3w23/ZhwRjQXEgCRAAAa2GOHOARAHciQWDxd/VN2/9ZcBwCz/
++RAAAAP+RLG4yc5wWwiWMhkpzgDGEsdiRznAF6JY7EhHOApxogoSAAH7rZR6NMfK5wWs6J/cHL/
+iiUd///////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////rcgpgH77qammbB6wAlp/nI6/6wLkv///
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////8KV
tAISAAGek+M6J/AMgJi5pFf8Lf/RANYJ1sAISAAGeYvlEMvgeMKHGG/49/+4ArD/++RAAAAP+RJF
wgdRsXwCSLhMpzYB3EkYgoTm4EcJI2zQnNwXkBIA01lk6IzAbQdCw7/xVb/8JX//////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////i8gBAGms6mgAfEDCg8//N/+sBX//////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////+CUSCCMrRUgAKXr5T/+C0IxIAEQBoo2A3BxjGJ/9P/4CT/++RAAAAP+hJGIQIpuXsCSMQ0
JTcCSEkbZ4Sm4D0JI1DQiNwFJAAEfNlUDrhX/+f/6wG/////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////wUyAABu5kkM4A3Df///6BL//////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////8JREAEQ
B/Wu5BHwPY1X/b/9ABBURABHacAa4Sww1/1//hT/++RAAAAP/ARFoAN4EX9giMQAOAMB0BUWgOBC
QDkCo1AMGEwAskAAXocP0BwPhj1flv//////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////8FQIAAGYRqqhLIY9X///////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////+AmgAAO6tPDJO
gQIZ6f0AKNAAjdduA3UIgO+X/KD/++RAAAAP+wRGWAF4EYNiSNtAIjYBmBUYgLzCQDCCo1AMCEwA
woAAQBmYfQKkwHf/g3//////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////4ChQ
AIgD1ohDB++J/9v/4f//////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////BLQAAGSpkjRNh2//oBU
RAAGsVghYw//6ED/++RAAAAP+QRFoAF4EYrgiOgADwIBNBMWgCQCYCECYxAEhE0AMAAAXqYHW/6P
y3//////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////gaABAFy1//lv////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////8AoAAAVAQgGR9ABRIAA8Do
0aj/++RAAAAP+QBGIAAACZygCMQAAAEAAAEuAAAAIAAAJcAAAAQAEAAAdf//////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////gAgAADo/////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////z/++RAAAAP
/ABLgAAACZyACXAAAAEAAAEuAAAAIAAAJcAAAAT/////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////9UQUcAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAyMDI1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==
`;